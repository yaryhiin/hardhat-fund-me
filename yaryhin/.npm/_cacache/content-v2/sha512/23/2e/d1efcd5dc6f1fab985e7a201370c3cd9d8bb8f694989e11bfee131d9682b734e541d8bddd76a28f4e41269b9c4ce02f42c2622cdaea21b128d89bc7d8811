{"_id":"hardhat-deploy","_rev":"173-b4e84bc8783da808a8d72d0774d3ebb5","name":"hardhat-deploy","dist-tags":{"next":"0.11.0-next.5","latest":"0.11.34","experimental":"0.11.3-experimental.2","zksync":"0.11.5-zksync.1"},"versions":{"0.7.0-beta.0":{"name":"hardhat-deploy","version":"0.7.0-beta.0","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-plugin"],"devDependencies":{"@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","chai":"^4.2.0","dotenv":"^6.2.0","hardhat":"^2.0.0-rc.0","mocha":"^5.2.0","prettier":"^1.19.1","prettier-plugin-solidity":"^1.0.0-alpha.56","source-map-support":"^0.5.12","ts-node":"^8.1.0","tslint":"^5.16.0","tslint-config-prettier":"^1.18.0","tslint-plugin-prettier":"^2.0.1","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0-rc.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.0.0","chokidar":"^3.4.0","debug":"^4.1.1","fs-extra":"^9.0.0","match-all":"^1.2.6","qs":"^6.9.4"},"scripts":{"compile":"hardhat compile","lint:fix":"prettier --write src/**/*.{js,ts} test/**/*.{js,ts} && tslint --fix --config tslint.json --project tsconfig.json","lint":"tslint --config tslint.json --project tsconfig.json","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","prepublishOnly":"npm run build"},"gitHead":"ca37e3df1c11b766fa6815ccbc0a777673169183","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.0","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-OvKXsb+wFp4rCNc0XRT9MJ0nZQDx9qsBCkHnzR7MAcW0LpOA1ZtiiTfw7mjXrF4raesT9NYbjpL9cRF5sEgSaA==","shasum":"3ff3124185d5e628a880a0c693d643a9656fd77b","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.0.tgz","fileCount":68,"unpackedSize":796239,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfj29MCRA9TVsSAnZWagAAqEMQAIKCOSFoXfCfRpIG4tL5\nDCDUsOWkj/XQ3ro+IT94fiWKc4aD+0CmIvrCYLFX2NCwn1XpuF8C4wnhwWUC\ny4QqMZ1nSuIDQFcA+E1Ma1xNncpJtSjeXxoVBrvufWvjN7a7VrJdAn0mH9p+\nRm3SnyG+Yvo64+F4IitRmMOaytNvc/l+B4rsBxctzlB0evu3ywOKV4MdeQU5\n8mwpd8D1BX8QNCCWHu2LdSGPLvrsXQk/CERm4VhKxdyhMbypL/avQR7u7NkX\nr6jfFyTdwhxLUo0tu4N8wpa2dnBIR4SkPvSWhSWPj2QKreXv81Rq5dzHNYgk\nQMq7gqrXGg2tXaIAzSPpgkvwG7qA9jI8XY+pC8j5gKNBchplL94YynKB4RjT\nPQRFTwRzMVtqnobwvYs1H7SBtVX83FhzivfYluUp+0W6Edr14X3iZIENCsHd\nRk2j9Rb9oxsRr6psjAJ9FJipI9Zg5NPVtwxvLJdN00GC3S5YBzYMcX7Y50Z4\nylCQgDKRSzr57kuJXzygDy0Y9F8s6R1L5SL7qKFcwFW9xnwND5r+1Tm8PK1S\nBCYC8plm87aBImhp/QFDI43qre+t8PknwLJmkReMWbf9aQHz2YduVh3GvgwR\n6h0NtVxB6+VNqOy9ZdKcs7iMMwrt8joVdteqn6no+jwYGngBz7tV8MllFOra\nsGIo\r\n=6Abr\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIG/b6f9OGgh70GdPHrO9R75KUZkd63VZ0T43GDI6C6DTAiEA3TDcs3V/wdkdRjsiNjNbNIX1dgwm2MMOX08LWm4pNNU="}]},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.0_1603235659863_0.3576221749712072"},"_hasShrinkwrap":false},"0.7.0-beta.1":{"name":"hardhat-deploy","version":"0.7.0-beta.1","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-plugin"],"devDependencies":{"@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","chai":"^4.2.0","dotenv":"^6.2.0","hardhat":"^2.0.0-rc.0","mocha":"^5.2.0","prettier":"^1.19.1","prettier-plugin-solidity":"^1.0.0-alpha.56","source-map-support":"^0.5.12","ts-node":"^8.1.0","tslint":"^5.16.0","tslint-config-prettier":"^1.18.0","tslint-plugin-prettier":"^2.0.1","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0-rc.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.0.0","chokidar":"^3.4.0","debug":"^4.1.1","fs-extra":"^9.0.0","match-all":"^1.2.6","qs":"^6.9.4"},"scripts":{"compile":"hardhat compile","lint:fix":"prettier --write src/**/*.{js,ts} test/**/*.{js,ts} && tslint --fix --config tslint.json --project tsconfig.json","lint":"tslint --config tslint.json --project tsconfig.json","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","prepublishOnly":"npm run build"},"readme":"[![hardhat](https://hardhat.org/hardhat-plugin-badge.svg?1)](https://hardhat.org)\n\n<h1> hardhat-deploy</h1>\n\n_A Hardhat Plugin For Replicable Deployments And Tests_\n\n[Hardhat](https://hardhat.org) Deployment And Test Plugin.\n\n- [What is it for ?](#what-is-it-for-)\n- [Installation](#installation)\n  - [npm install hardhat-deploy](#npm-install-hardhat-deploy)\n  - [TypeScript support](#typescript-support)\n  - [Migrating existing deployment to hardhat-deploy](#migrating-existing-deployment-to-hardhat-deploy)\n- [Hardhat Tasks Availabled/Updated](#hardhat-tasks-availabledupdated)\n  - [hardhat deploy](#hardhat-deploy)\n    - [Options](#options)\n    - [Flags](#flags)\n  - [hardhat node](#hardhat-node)\n  - [hardhat test](#hardhat-test)\n  - [hardhat etherscan-verify](#hardhat-etherscan-verify)\n    - [Options](#options-1)\n    - [Flags](#flags-1)\n  - [hardhat export](#hardhat-export)\n    - [Options](#options-2)\n- [Hardhat Environment Extensions](#hardhat-environment-extensions)\n- [Configuration](#configuration)\n  - [namedAccounts (ability to name addresses)](#namedaccounts-ability-to-name-addresses)\n  - [extra network's config](#extra-networks-config)\n  - [extra paths config](#extra-paths-config)\n  - [Importing deployment from other projects (truffle support too)](#importing-deployment-from-other-projects-truffle-support-too)\n  - [Access to Artifacts (non-deployed contract code and abi)](#access-to-artifacts-non-deployed-contract-code-and-abi)\n- [How to Deploy Contracts](#how-to-deploy-contracts)\n  - [The `deploy` Task](#the-deploy-task)\n  - [Deploy Scripts](#deploy-scripts)\n  - [The `deployments` field](#the-deployments-field)\n    - [`deployments.deploy`](#deploymentsdeploy)\n- [Handling contract using libraries](#handling-contract-using-libraries)\n- [Exporting Deployments](#exporting-deployments)\n- [Deploying and Upgrading Proxies](#deploying-and-upgrading-proxies)\n- [Builtin-In Support For Diamonds (EIP2535)](#builtin-in-support-for-diamonds-eip2535)\n- [Testing Deployed Contracts](#testing-deployed-contracts)\n- [More Information On Hardhat Tasks](#more-information-on-hardhat-tasks)\n  - [node task](#node-task)\n  - [test task](#test-task)\n  - [run task](#run-task)\n  - [console task](#console-task)\n- [Deploy Scripts: Tags And Dependencies](#deploy-scripts-tags-and-dependencies)\n\n## What is it for ?\n\nThis [hardhat](https://hardhat.dev) plugin adds a mechanism to deploy contracts to any network, keeping track of them and replicating the same environment for testing.\n\nIt also adds a mechanism to associate names to addresses so test and deployment scripts can be reconfigured by simply changing the address a name points to, allowing different configurations per network. This also results in much clearer tests and deployment scripts (no more `accounts[2]` in your code).\n\nThis plugin contains a lot more features too, all geared toward a better developer experience :\n\n- chain configuration export, listing deployed contract, their abi and address, usefull for webapps.\n- library linking at time of deployment\n- deterministic deployment across networks\n- ability to submit contract source to etherscan for verification. Because hardhat-deploy will save all necessary info, it can be executed at any time.\n- deployment dependency system (allowing you to only deploy what is needed).\n- deployment as migration so once a deployment is done, it can be set to never be executed again.\n- deployment retrying (by saving pending tx): so you can feel confident when making a deployment that you can always recover.\n- deployments as test fixture using `evm_snapshot` to speed up testing.\n- ability to create your own test fixture that automatically benefit from `evm_snapshot` to speed up tests using it.\n- TODO: update : combined with `buidler-ethers-v5` it has the ability to get ethers contract instance by name (like `await ethers.getContract(\"ContractName\")`).\n- importing previously compiled contract (possibly in different solidity compiler version).\n- importing artifact from external sources (like npm packages), including truffle support\n- importing deployments from external sources (like npm packages), including truffle support\n- ability to log information in `deploy` mode only (while in test the console remains clean).\n- contains helpers to read and execute transaction on deployed contract referring to them by name.\n- These helpers contains options to auto mine on dev environment like ganache (to speed up deployments).\n- save metadata of deployed contract so they can always be fully verified, via [sourcify](https://github.com/ethereum/sourcify) or [etherscan](https://etherscan.io).\n- proxy deployment with ability to upgrade them transparently, only if code changes.\n- diamond deployment with facets, allowing you to focus on what the new version will be. It will generate the diamondCut necessary to reach the new state.\n- watch and deploy: hardhat-deploy can watch both your deploy script and contract code and redeploy on changes.\n- HCR (Hot Contract Replacement): the watch feature combined with proxy or diamond, gives you an experience akin to frontend Hot Module Replacement: Once your contract change, the deployment is executed and your contract retain the same address and same state.\n\n## Installation\n\n### npm install hardhat-deploy\n\n```bash\nnpm install -D hardhat-deploy\n```\n\nAnd add the following statement to your `hardhat.config.js`:\n\n```js\nimport \"hardhat-deploy\";\n```\n\n### TypeScript support\n\nWith hardhad the tsconfig.json is optional.\n\nBut if you add folders to the `include` field in `tsconfig.json` you ll also need to include `hardhat.config.ts` like :\n\n`include\": [\"./hardhat.config.ts\", \"./scripts\", \"./deploy\", \"./test\"]`\n\nfor deploy script (see below) you can write them this way to benefit from typing :\n\n```\nimport {\n  HardhatRuntimeEnvironment,\n  DeployFunction,\n} from \"hardhat/types\";\n\nconst func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {\n  // code here\n};\nexport default func;\n```\n\nTODO update: See a full example of typescript usage here : https://github.com/wighawag/hardhat-deploy-ts-test\n\n### Migrating existing deployment to hardhat-deploy\n\nYou might want to switch your current deployment process to use hardhat-deploy. In that case you probably have some deployments saved elsewhere.\n\nIn order to port them to hardhat-deploy, you'll need to create one `.json` file per contract in the `deployments/<network>` folder (configurable via [paths config](#extra-paths-config)).\n\nThe network folder is simply the hardhat network name (as configured in hardhat.config.js) (accessible at runtime via `hre.network.name`).\nSuch folder need to have a file named `.chainId` containing the chainId as decimal.\n\nFor example for network named \"rinkeby\" (for the corresponding network) the file `deployments/rinkeby/.chainId` would be\n\n```\n4\n```\n\nNote, prior to hardhat 0.6 the chainId was appended to the folder name (expect for some known network name). This has changed and upgrading to 0.6 will require you to change the folder name and add the '.chainId' file.\n\nEach contract file must follow this type (as defined in [src/type-extensions.d.ts](src/type-extensions.d.ts)) :\n\n```ts\nexport interface Deployment {\n  abi: any[];\n  address: string;\n  receipt?: Receipt;\n  transactionHash?: string;\n  contractFilepath?: string;\n  contractName?: string;\n  history?: Deployment[];\n  args?: any[];\n  linkedData?: any;\n  metadata?: string;\n  bytecode?: string;\n  deployedBytecode?: string;\n  userdoc?: any;\n  devdoc?: any;\n  methodIdentifiers?: any;\n  diamondCut?: { address: string; sigs: string[] }[];\n  facets?: { address: string; sigs: string[] }[];\n  storageLayout?: any;\n}\n```\n\nAs you can see, only abi and address are mandatory. But having the other fields allow more feature. For example, metadata and args allow you to benefit from contract code verification.\n\nFor Receipt, the following type is expected:\n\n```ts\nexport type Receipt = {\n  from: string;\n  transactionHash: string;\n  blockHash: string;\n  blockNumber: number;\n  transactionIndex: number;\n  cumulativeGasUsed: string | number;\n  gasUsed: string | number;\n  contractAddress?: string;\n  to?: string;\n  logs?: Log[];\n  events?: any[];\n  logsBloom?: string;\n  byzantium?: boolean;\n  status?: number;\n  confirmations?: number;\n};\n```\n\nHere is an example:\n\nLet sey you have:\n\n- 2 Contract named Greeter and Registry deployed on rinkeby\n- 1 contract named Greeter on mainnet\n- 2 Contract named Greeter and Registry deployed on a network named rinkeby2\n\nYou would get the following folder structure:\n\n```\ndeployments/\n  mainnet/\n    .chainId\n    Greeter.json\n  rinkeby/\n    .chainId\n    Greeter.json\n    Registry.json\n  rinkeby2/\n    .chainId\n    Greeter.json\n    Registry.json\n```\n\nThe reason why hardhat-deploy save chainId in the `.chainId` file is both for\n\n- safety: so that if you were to change the network to point to a different chain, it would not attempt to read the wrong folder and assume that a contract has been deployed while it has not.\n- ability to know the chainId without requring to be connected to a node (and so not dependent on hardhat.config.js settings). Useful for `export` task.\n\n## Hardhat Tasks Availabled/Updated\n\n### hardhat deploy\n\nThis plugin adds the _deploy_ task to Hardhat.\n\nThis task will execute the scripts in the `deploy` folder and save the contract deployments to disk. These deployments are supposed to be saved for example in a git repository. This way they can be accessed later.\n\nWith the deployment saved, it allows you to deploy a contract only if changed were made.\n\nDeploy scripts (also called Deploy functions) can also perform aribtrary logic.\n\nFor further details on how to use it and write deploy script, see [section](#deploy-scripts) below.\n\n#### Options\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice to use by default for transactions executed via hardhat-deploy helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### Flags\n\n`--reset`: This flag reset the deployments from scratch. Previously deployed contract are not considered and deleted from disk.\n\n`--silent`: This flag remove hardhat-deploy log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n### hardhat node\n\nThis plugin modify the _node_ task so that it also execute the deployment script before exposing the server http RPC interface\n\nIt also add the same options as the _deploy_ task with the same functionality. It adds an extra flag:\n\n`--no-deploy` that discard all other options to revert to normal `hardhat node` behavior without any deployment being performed.\n\nNote that the deployments are saved as if the network name is `localhost`. This is because `hardhat node` is expected to be used as localhost: You can for example execute `hardhat --network localhost console` after `node` is running. Doing `builder --network hardhat console` would indeed not do anythong useful. It still take the configuration from `hardhat` in the hardhat.config.js file though.\n\n### hardhat test\n\nThis plugin add to the _test_ task a flag argument `--deploy-fixture` that run the global deployments fixture before the tests and snapshot it.\n\n### hardhat etherscan-verify\n\nThis plugin adds the _etherscan-verify_ task to Hardhat.\n\nThis task will submit the contract source and other info of all deployed contracts to allow etherscan to verify and record the sources.\n\nInstead of using the full solc input, this task will first attempt to send the minimal sources from the metadata.\nBut Etherscan sometime fails due to a bug in solidity compiler (https://github.com/ethereum/solidity/issues/9573). As such this task can fallback on full solc input (see option --solc-input). Note that if your contract was deployed with a previous version of hardhat-deploy, it might not contains the full information.\n\nThis task will also attempt to automatically find the SPDX license in the source.\n\nTo execute that task, you need to specifiy the network to run against :\n\n```\nhardhat --network mainnet etherscan-verify --api-key <apikey>\n```\n\n#### Options\n\n`--api-key <API_KEY>`: Etherscan API key. Optional as such api key can also be set by setting the environment variable : ETHERSCAN_API_KEY\n\n`--license <SPDX>`: specifiy the license to use (using SPDX id) or can be \"UNLICENSED\". Note that etherscan have limited support for licenses, see : https://etherscan.io/contract-license-types\n\n#### Flags\n\n`--solcInput`: allow the use of full solc-input as fallback. Note that the whole source folder will be included in the result of the verification on etherscan.\n\n`--force-license`: This flag force the use of the license specified by --license (useful if your inline SPDX are not compatible with etherscan list)\n\n### hardhat export\n\nThis plugin adds the _export_ task to Hardhat.\n\nThis task will export the contract deployed (saved in `deployments` folder) to a simple format containing only contract addresses and abi, useful for web apps.\n\nOne of the following options need to be set for this task to have any effects :\n\n#### Options\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\nThis last option has some limitations, when combined with the use of external deployments (see [Configuration](#configuration)). If such external deployments were using older version of hardhat-deploy or truffle, the chainId might be missing. In order for these to be exported, the hardhat network config need to explicity state the chainId in the `networks` config of `hardhat.config.js`.\n\n## Hardhat Environment Extensions\n\nThis plugin extends the Hardhat Runtime Environment by adding 4 fields:\n\n- `getNamedAccounts: () => Promise<{ [name: string]: string }>`: a function returning an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [Configuration](#configuration)).\n\n- `getUnamedAccounts: () => Promise<string[]}>`: accounts which has no names, useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`: contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId(): Promise<string>`: offer an easy way to fetch the current chainId.\n\n## Configuration\n\n### namedAccounts (ability to name addresses)\n\nThis plugin extends the `HardhatConfig`'s object with an optional `namedAccounts` field.\n\n`namedAccounts` allows you to associate names to addresses and have them configured per chain.\nThis allows you to have meaningful names in your tests while the addresses match to multi sig in real network for example.\n\n```js\n{\n    namedAccounts: {\n        deployer: {\n            default: 0, // here this will by default take the first account as deployer\n            1: 0, // similarly on mainnet it will take the first account as deployer. Note though that depending on how hardhat network are configured, the account 0 on one network can be different than on another\n            4: '0xA296a3d5F026953e17F472B497eC29a5631FB51B', // but for rinkeby it will be a specific address\n            \"goerli\": '0x84b9514E013710b9dD0811c9Fe46b837a4A0d8E0', //it can also specify a specific netwotk name (specified in hardhat.config.js)\n        },\n        feeCollector:{\n            default: 1, // here this will by default take the second account as feeCollector (so in the test this will be a different account than the deployer)\n            1: '0xa5610E1f289DbDe94F3428A9df22E8B518f65751', // on the mainnet the feeCollector could be a multi sig\n            4: '0xa250ac77360d4e837a13628bC828a2aDf7BabfB3', // on rinkeby it could be another account\n        }\n    }\n}\n```\n\n### extra network's config\n\nhardhat-deploy add 2 new fields to `networks` configuration\n\n`live` : this is not used internally but is useful to perform action on a network whether it is a live network (rinkeby, mainnet, etc) or a temporary one (localhost, hardhat). The default is true (except for localhost and hardhat where the default is false).\n\n`saveDeployments`: this tell whether hardhat-deploy should save the deployments to disk or not. Default to true.\n\n`tags`: network can have tags to represent them. The config is an array and at runtime the hre.network.tags is an object whose fields (the tags) are set to true.\n\nThis is useful to conidtionaly operate on network based on their use case.\n\nExample:\n\n```js\n{\n  networks: {\n    localhost: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"local\"]\n    },\n    hardhat: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"test\", \"local\"]\n    },\n    rinkeby: {\n      live: true,\n      saveDeployments: true,\n      tags: [\"staging\"]\n    }\n  }\n}\n```\n\n### extra paths config\n\nIt also adds fields to `HardhatConfig`'s `ProjectPaths` object.\n\nHere is an example showing the default values :\n\n```js\n{\n    paths: {\n        deploy: 'deploy',\n        deployments: 'deployments',\n        imports: `imports`\n    }\n}\n```\n\nThe deploy folder is expected to contains the deploy script that are executed upon invocation of `hardhat deploy` or `hardhat node`\n\nThe deployment folder will contains the resulting deployments (contract addresses along their abi, bytecode, metadata...). One folder per network and one file per contract.\n\nThe imports folder is expected to contains artifacts that were pre-compiled. Useful if you want to upgrade to a new solidity version but want to keep using previously compiled contracts. The artifact is the same format as normal hardhat artifact, so you can easily copy them over, before switching to a new compiler version.\n\n### Importing deployment from other projects (truffle support too)\n\nIt also add the `external` field to `HardhatConfig`\n\nSuch fiels allows to specify paths for external artifacts or deployments. The use of the `paths` field is not possible because hardhat expects all paths field to be string. It does not accept arrays or objects, see https://github.com/nomiclabs/hardhat/issues/776.\n\nThe external object has 2 fields:\n\n```js\n{\n    external: {\n        artifacts: [\"node_modules/@cartesi/arbitration/build/contracts\"],\n        deployments: {\n          rinkeby: [\"node_modules/@cartesi/arbitration/build/contracts\"],\n        }\n    }\n}\n```\n\nThe artifacts fields specify an array of path to look for artifact. it support both hardhat and truffle artifacts.\n\nThe deployments fields specify an object whose field name are the hardhat network and the value is an array of path to look for deployments. It supports both hardhat-deploy and truffle formats.\n\n### Access to Artifacts (non-deployed contract code and abi)\n\nyou can access contract artifact via `getArtifact` function :\n\n```js\nconst { deployments } = require(\"hardhat\");\nconst artifact = await deployments.getArtifact(artifactName);\n```\n\nWith the `buidler-ethers-v5` plugin you can get your ethers contract via :\n\n```js\nconst { deployments, ethers } = require(\"hardhat\");\nconst factory = await ethers.getContractFactory(artifactName);\n```\n\nNote that the artifact file need to be either in `artifacts` folder that hardhat generate on compilation or in the `imports` folder where you can store contracts compiled elsewhere. They can also be present in the folder specified in `external.artifacts` see [Importing deployment from other projects](#importing-deployment-from-other-projects-truffle-support-too)\n\n## How to Deploy Contracts\n\n### The `deploy` Task\n\n`hardhat --network <networkName> deploy [options and flags]`\n\nThis is a new task that the plugin adds. As the name suggests it deploys contracts.\nTo be exact it will look for files in the folder `deploy` or whatever was configured in `paths.deploy`, see [paths config](#extra-paths-config)\n\nIt will scan for files in alphabetical order and execute them in turn.\n\n- it will `require` each of these files and execute the exported function with the HRE as argument\n\nNote that running `hardhat deploy` without specifying a network will use the default network. If the default network is an internal ganache or hardhat then nothing will happen as a result but this can be used to ensure the deployment is without issues.\n\nTo specified the network, you can use the builtin hardhat argument `--network <network name>` or set the env variable `HARDHAT_NETWORK`\n\n### Deploy Scripts\n\nThe deploy scripts need to be of the following type :\n\n```js\nexport interface DeployFunction {\n  (env: HardhatRuntimeEnvironment): Promise<void | boolean>;\n  skip?: (env: HardhatRuntimeEnvironment) => Promise<boolean>;\n  tags?: string[];\n  dependencies?: string[];\n  runAtTheEnd?: boolean;\n  id?: string;\n}\n```\n\nThe skip function can be used to skip executing the script under whatever condition. It simply need to resolve a promise to true.\n\nThe tags is a list of string that when the _deploy_ task is executed with, the script will be executed (unless it skips). In other word if the deploy task is executed with a tag that does not belong to that script, that script will not be executed unless it is a dependency of a script that does get executed.\n\nThe dependencies is a list of tag that will be executed if that script is executed. So if the script is executed, every script whose tag match any of the dependency will be executed first.\n\nThe `runAtTheEnd` is a boolean that if set to true, will queue that script to be executed after all other scripts are executed.\n\nThese set of fields allow more flexibility to organize the script. You are not limited to alphabetical order.\n\nFinally the function can return true if it wishes to never be executed again. This can be usfeul to emulate migration scripts that are meant to be executed only once. Once such script return true (async), the `id` field is used so to track execution and if that field is not present when the script return true, it will fails.\n\nIn any case, as a general advice every deploy function should be idempotent. This is so they can always recover from failure or pending transaction.\n\nThis is why the `hre.deployments.deploy` function will by default only deploy if the contract code has changed, making it easier to write idempotent script.\n\nAn example of a deploy script :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnamedAccounts\n}) => {\n  const { deploy } = deployments;\n  const { deployer } = await getNamedAccounts();\n\n  // the following will only deploy \"GenericMetaTxProcessor\" if the contract was never deployed or if the code changed since last deployment\n  await deploy(\"GenericMetaTxProcessor\", {\n    from: deployer,\n    gas: 4000000,\n    args: []\n  });\n};\n```\n\nAs you can see the HRE passed in has 4 new fields :\n\n- `getNamedAccounts` is a function that returns a promise to an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [`namedAccounts`](#namedaccounts)).\n\n- `getUnamedAccounts`: function that return a promise to an array of accounts (which were not used in `getNamedAccounts`), useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`, which contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId` which return a promise for the chainId\n\nThe deploynments field contains the `deploy` function taht allow you to deploy contract and save them. It contains a lot more functions though :\n\n### The `deployments` field\n\nThe deployments field contains several helpers function to deploy contract but also execute transaction.\n\n```js\ndeploy(name: string, options: DeployOptions): Promise<DeployResult>; // deploy a contract\ndiamond: { // deploy diamond based contract (see section below)\n  deploy(name: string, options: DiamondOptions): Promise<DeployResult>;\n};\ndeterministic( // return the determinsitic address as well as a function to deploy the contract, can pass the `salt` field in the option to use different salt\n      name: string,\n      options: Create2DeployOptions\n    ): Promise<{\n      address: Address;\n      deploy(): Promise<DeployResult>;\n    }>;\nfetchIfDifferent(name: string, options: DeployOptions): Promise<boolean>; // return true if new compiled code is different than deployed contract\nsave(name: string, deployment: DeploymentSubmission): Promise<void>; // low level save of deployment\nget(name: string): Promise<Deployment>; // fetch a deployment by name, throw if not existing\ngetOrNull(name: string): Promise<Deployment | null>; // fetch deployment by name, return null if not existing\nall(): Promise<{ [name: string]: Deployment }>; // return all deployments\ngetArtifact(name: string): Promise<Artifact>; // return a hardhat artifact (compiled contract without deployment)\nrun( // execute deployment scripts\n  tags?: string | string[],\n  options?: {\n    resetMemory?: boolean;\n    deletePreviousDeployments?: boolean;\n    writeDeploymentsToFiles?: boolean;\n    export?: string;\n    exportAll?: string;\n  }\n): Promise<{ [name: string]: Deployment }>;\nfixture(tags?: string | string[]): Promise<{ [name: string]: Deployment }>; // execute deployment as fixture for test // use evm_snapshot to revert back\ncreateFixture(func: FixtureFunc, id?: string): () => Promise<any>; // execute a function as fixture using evm_snaphost to revert back each time\nlog(...args: any[]): void; // log data only ig log enabled (disabled in test fixture)\nexecute( // execute function call on contract\n  name: string,\n  options: TxOptions,\n  methodName: string,\n  ...args: any[]\n): Promise<Receipt>;\nrawTx(tx: SimpleTx): Promise<Receipt>; // execute a simple transaction\nread( // make a read-only call to a contract\n  name: string,\n  options: CallOptions,\n  methodName: string,\n  ...args: any[]\n): Promise<any>;\nread(name: string, methodName: string, ...args: any[]): Promise<any>;\n```\n\n#### `deployments.deploy`\n\nThe deploy function as mentioned allow you to deploy a contract and save it under a specific name.\n\nThe deploy function expect 2 parameters: one for the name and one for the options\n\nSee below the full list of fields that the option parameter allows and requires:\n\n```js\nfrom: string; // address (or private key) that will perform the transaction. you can use `getNamedAccounts` to retrived the address you want by name.\ncontract?: // this is an optional field. If not specified it defaults to the contract with the same name as the first parameter\n  | string // this field can be either a string for the name of the contract\n  | { // or abi and bytecode\n      abi: ABI;\n      bytecode: string;\n      deployedBytecode?: string;\n    };\nargs?: any[]; // the list of argument for the constructor (or the upgrade function in case of proxy)\nskipIfAlreadyDeployed?: boolean; // if set it to true, will not attempt to deploy even if the contract deployed under the same name is different\nlog?: boolean; // if true, it will log the result of the deployment (address and gas used)\nlinkedData?: any; // This allow to associate any JSON data to the deployment. Useful for merkle tree data for example\nlibraries?: { [libraryName: string]: Address }; // This let you associate libraries to the deployed contract\nproxy?: boolean | string | ProxyOptions; // This options allow to consider yoru contract as a proxy (see below for more details)\n\n// here some common tx options :\ngasLimit?: string | number | BigNumber;\ngasPrice?: string | BigNumber;\nvalue?: string | BigNumber;\nnonce?: string | number | BigNumber;\n\nestimatedGasLimit?: string | number | BigNumber; // to speed up the estimation, it is possible to provide an upper gasLimit\nestimateGasExtra?: string | number | BigNumber; // this option allow you to add a gas buffer on top of the estimation\n\ndev_forceMine?: boolean; // this force a evm_mine to be executed. this is useful to speed deployment on test network that allow to specify a block delay (ganache for example). This option basically skip the delay by force mining.\ndeterministicDeployment? boolean | string; // if true, it will deploy the contract at a deterministic address based on bytecode and constuctor arguments. The address will be the same across all network. It use create2 opcode for that, if it is a string, the string will be used as the salt.\n```\n\n## Handling contract using libraries\n\nIn the deploy function, one of the `DeployOptions` that can be passed into the function is the `libraries` field.\n\nFirst, deploy the library using the `deploy` function, then when we deploy a contract that needs the the linked library, we can pass the deployed library name and address in as an argument to the `libraries` object.\n\n```js\nconst exampleLibrary = await deploy(\"ExampleLibary\", {\n    from: <deployer>\n});\n\n```\n\nExampleLibrary is now deployed to whatever network is in the context of the environment.\n\nFor example, if we are deploying on Rinkeby, this library will get deployed on rinkeby, and the `exampleLibrary` variable will be an deployment object that contains the abi as well as the deployed address for the contract.\n\nNow that the library is deployed, we can link it in our next deployed contract.\n\n```js\nconst example = await deploy(\"Example\", {\n    from: <deployer>\n    args: [\"This is an example string argument in the constructor for the 'Example' contract\"],\n    libraries: {\n        ExampleLibrary: exampleLibrary.address\n    }\n});\n\n```\n\nThis `libraries` object takes the name of the library, and its deployed address on the network. Multiple libraries can be passed into the `libraries` object.\n\n## Exporting Deployments\n\nApart from deployments saved in the `deployments` folder which contains all information available about the contract (compile time data + deployment data), `hardhat-deploy` allows you to export lightweight file.\n\nThese can be used for example to power your frontend with contract's address and abi.\n\nThis come into 2 flavors.\n\nThe first one is exported via the `--export <file>` option and follow the following format :\n\n```js\nexport interface Export {\n  chainId: string;\n  name: string;\n  contracts: { [name: string]: ContractExport };\n}\n```\n\nwhere name is the name of the network configuration chosen (see hardhat option `--network`)\n\nThe second one is exported via the `--export-all <file>` option and follow the following format :\n\n```js\nexport type MultiExport = {\n  [chainId: string]: { [name: string]: Export }\n};\n```\n\nAs you see the second format include the previous. While in most case you'll need the single export where your application will support only one network, there are case where your app would want to support multiple network at nonce. This second format allow for that.\n\nFurthermore as hardhat support multiple network configuration for the same network (rinkeby, mainnet...), the export-all format will contains each of them grouped by their chainId.\n\n## Deploying and Upgrading Proxies\n\nAs mentioned above, the deploy function can also deploy a contract through a proxy. It can be done without modification of the contract as long as it does not have a constructor (or constructor with zero arguments).\n\nThe Proxy is both ERC-1967 and ERC-173 Compliant\n\nCode can be found [here](solc_0.7/proxy/EIP173Proxy.sol)\n\nTo perform such proxy deployment, you just need to invoke the deploy function with the following options : `{..., proxy: true}`\n\nSee example :\n\n```js\nmodule.exports = async ({ getNamedAccounts, deployments, getChainId }) => {\n  const { deploy } = deployments;\n  const { deployer } = await getNamedAccounts();\n  await deploy(\"Greeter\", {\n    from: deployer,\n    proxy: true\n  });\n};\n```\n\nYou can also set it to `proxy: \"<upgradeMethodName>\"` in which case the function `<upgradeMethodName>` will be executed upon upgrade.\nthe `args` field will be then used for that function instead of the contructor. It is also possible to then have a constructor with the same arguments and have the proxy be disabled. It can be useful if you want to have your contract as upgradeable in a test network but be non-upgradeable on the mainnet. Further documentation need to written for that.\n\nSee example :\n\n```js\nmodule.exports = async ({ getNamedAccounts, deployments, getChainId }) => {\n  const { deploy } = deployments;\n  const { deployer } = await getNamedAccounts();\n  await deploy(\"Greeter\", {\n    from: deployer,\n    proxy: \"postUpgrade\",\n    args: [\"arg1\", 2, 3]\n  });\n};\n```\n\nThe proxy option can also be an object which can set the specific owner that the proxy is going to be managed by.\n\nSee example:\n\n```js\nmodule.exports = async ({ getNamedAccounts, deployments, getChainId }) => {\n  const { deploy } = deployments;\n  const { deployer, greeterOwner } = await getNamedAccounts();\n  await deploy(\"Greeter\", {\n    from: deployer,\n    proxy: {\n      owner: greeterOwner,\n      methodName: \"postUpgrade\"\n    },\n    args: [\"arg1\", 2, 3]\n  });\n};\n```\n\nNote that for the second invokation, this deployment will fails to upgrade the proxy as the `from` which is `deployer` is not the same as the proxy's owner : `greeterOwner`\n\nTo make it work, you have to create a new script that have for `from` field: `greeterOwner`. If such value is a a multi sig or an address not registered as part of hardhat signers, the tx will not be executed but instead an error will be throw, mentionning the tx data necessary to perform the upgrade.\n\n## Builtin-In Support For Diamonds (EIP2535)\n\nThe deployments field also expose the diamond field: `hre.deployments.diamond` that let you deploy [Diamonds](https://eips.ethereum.org/EIPS/eip-2535) in an easy way.\n\nInstead of specifying the facets to cut out or cut in, which the diamond contract expects, you specify the facets you want to end up having on the deployed contract.\n\n`diamond.deploy` expect the facet as names. The name represent the compiled contract name that going to be deployed as facet. In future version you ll be able to specify deployed contract or artifact object as facet.\n\nTo deploy a contract with 3 facet you can do as follow :\n\n```js\nmodule.exports = async ({ getNamedAccounts, deployments, getChainId }) => {\n  const { diamond } = deployments;\n  const { deployer, diamondAdmin } = await getNamedAccounts();\n  await diamond.deploy(\"ADiamondContract\", {\n    from: deployer,\n    owner: diamondAdmin,\n    facets: [\"Facet1\", \"Facet2\", \"Facet3\"]\n  });\n};\n```\n\nif you then later execute the following script:\n\n```js\nmodule.exports = async ({ getNamedAccounts, deployments, getChainId }) => {\n  const { diamond } = deployments;\n  const { deployer, diamondAdmin } = await getNamedAccounts();\n  await diamond.deploy(\"ADiamondContract\", {\n    from: diamondAdmin, // this need to be the diamondAdmin for upgrade\n    owner: diamondAdmin,\n    facets: [\"NewFacet\", \"Facet2\", \"Facet3\"]\n  });\n};\n```\n\nThen the NewFacet will be deployed automatically if needed and then the diamondCut will cut Facet1 out and add NewFacet.\n\nNote that if the code for Facet2 and Facet3 changes, they will also be redeployed automatically and the diamondCuts will replace the existing facets with these new ones.\n\nNote that The Diamond contract's code is part of hardhat-deploy and contains 3 built-in facet that can be removed manually if desired.\nThese facets are used for ownership, diamondCut and diamond loupe.\n\nThe implementation is the [reference implementation by Nick Mudge](https://github.com/mudgen/Diamond)\n\nLike normal proxies you can also execute a function at the time of an upgrade.\n\nThis is done by specifying the execute field in the diamond deploy options :\n\n```js\ndiamond.deploy(\"ADiamondContract\", {\n  from: deployer,\n  owner: diamondAdmin,\n  facets: [\"NewFacet\", \"Facet2\", \"Facet3\"],\n  execute: {\n    methodName: \"postUpgrade\",\n    args: [\"one\", 2, \"0x3\"]\n  }\n});\n```\n\nSince the diamond standard has no builtin mechanism to make the deployment of Diamond with function execution, the Diamond when deployed is actually deployed through a special contract, the `Diamantaire` (see code [here](solc_0.7/diamond/Diamantaire.sol)) that act as factory to build Diamond. It uses deterministic deployment for that so, it is transparently managed by hardhat-deploy.\n\nThe Diamantaire also support the deterministic deployment of Diamond.\nAn extra field can be passed to the Diamond deployment options : `deterministicSalt`. It has to be a non-zero 32bytes string (in hex format).\nNote that if you want to deploy 2 diamonds with same owner, you'll need 2 different deterministicSalt for them to be 2 separate contracts.\n\n## Testing Deployed Contracts\n\nYou can continue using the usual test task :\n\n`hardhat test`\n\nTests can then use the `hre.deployments.fixture` function to run the deployment for the test and snapshot it so that tests don't need to perform all the deployments transaction every time, they simply reuse the snapshot for every test (this leverages `evm_snapshot` and `evm_revert` provided by both `hardhat` and `ganache`). You can for example set them in a `beaforeEach`.\n\nHere is an example of a test :\n\n```js\nconst { deployments } = require(\"hardhat\");\n\ndescribe(\"Token\", () => {\n  beforeEach(async () => {\n    await deployments.fixture();\n  });\n  it(\"testing 1 2 3\", async function() {\n    const Token = await deployments.get(\"Token\"); // Token is available because the fixture was executed\n    console.log(Token.address);\n    const ERC721BidSale = await deployments.get(\"ERC721BidSale\");\n    console.log({ ERC721BidSale });\n  });\n});\n```\n\nIf the deployment scripts are complex, the first test could take while (as the fixture need to execute the deployment) but then from the second test onward, the deployments are never re-executed, instead the fixture will do `evm_revert` and test will run far faster.\n\nTests can also leverage named accounts for clearer test. Combined with `buidler-ethers-v5` plugin, you can write succint test :\n\n```js\nconst { ethers, getNamedAccounts } = require(\"hardhat\");\n\ndescribe(\"Token\", () => {\n  beforeEach(async () => {\n    await deployments.fixture();\n  });\n  it(\"testing 1 2 3\", async function() {\n    const { tokenOwner } = await getNamedAccounts();\n    const TokenContract = await ethers.getContract(\"Token\", tokenOwner);\n    await TokenContract.mint(2);\n  });\n});\n```\n\nFurthermore, tests can easily create efficient fixture using `deployments.createFixture`\n\nSee example :\n\n```js\nconst setupTest = deployments.createFixture(async ({deployments, getNamedAccounts, ethers}, options) => {\n  await deployments.fixture(); // ensure you start from a fresh deployments\n  const { tokenOwner } = await getNamedAccounts();\n  const TokenContract = await ethers.getContract(\"Token\", tokenOwner);\n  await TokenContract.mint(10); //this mint is executed once and then `createFixture` will ensure it is snapshotted\n  return {\n    tokenOwner: {\n      address: tokenOwner,\n      TokenContract\n    }\n  };\n};\ndescribe(\"Token\", () => {\n  it(\"testing 1 2 3\", async function() {\n    const {tokenOwner} = await setupTest()\n    await tokenOwner.TokenContract.mint(2);\n  });\n});\n```\n\nWhile this example is trivial, some fixture can requires several transaction and the ability to snapshot them automatically speed up the tests greatly.\n\n## More Information On Hardhat Tasks\n\n### node task\n\nas mentioned above, the node task is slighly modified and augmented with various flag and options\n\n`hardhat node`\n\nIn particulat It adds an argument `--export` that allows you to specify a destination file where the info about the contracts deployed is written.\nYour webapp can then access all contracts information.\n\n### test task\n\n`hardhat test`\n\nthe test task is augmented with one flag argument `--deploy-fixture` that allow to run all deployments in a fixture snapshot before executing the tests. This can speed up tests that use specific tags as the global fixture take precedence (unless specified).\n\nIn other word tests can use `deployments.fixture(<specific tag>)` where specific tag only deploy the minimal contracts under tests, while still benefiting from global deployment snapshot if used.\n\nIf a test need the deployments to only include the specific deployment specified by the tag, it can use the following :\n\n```js\ndeployments.fixture(\"<specific tag>\", { fallbackToGlobal: false });\n```\n\nDue to how snapshot/revert works in hardhat, this means that these test will not be able to benefit from the global fixture snapshot and will have to deploy their contract as part of the fixture call. This is automatix but means that these tests will run slower.\n\n### run task\n\n`hardhat --network <networkName> run <script>`\n\nThe run task act as before but thanks to the `hre.deployments` field it can access deployed contract :\n\n```js\nconst hre = require(\"hardhat\");\nconst { deployments, getNamedAccounts } = hre;\n\n(async () => {\n  console.log(await deployments.all());\n  console.log({ namedAccounts: await getNamedAccounts() });\n})();\n```\n\nYou can also run it directly from the command line as usual.\n\n`HARDHAT_NETWORK=rinkeby node <script>` is the equivalent except it does not load the hardhat environment twice (which the run task does)\n\n### console task\n\n`hardhat console`\n\nThe same applies to the `console` task.\n\n## Deploy Scripts: Tags And Dependencies\n\nIt is possible to execute only specific part of the deployments with `hardhat deploy --tags <tags>`\n\nTags represent what the deploy script acts on. In general it will be a single string value, the name of the contract it deploys or modifies.\n\nThen if another deploy script has such tag as a dependency, then when this latter deploy script has a specific tag and that tag is requested, the dependency will be executed first.\n\nHere is an example of two deploy scripts :\n\n```js\nmodule.exports = async ({ getNamedAccounts, deployments }) => {\n  const { deployIfDifferent, log } = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const { deployer } = namedAccounts;\n  const deployResult = await deploy(\"Token\", {\n    from: deployer,\n    args: [\"hello\", 100]\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Token deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = [\"Token\"];\n```\n\n```js\nmodule.exports = async function({ getNamedAccounts, deployments }) {\n  const { deployIfDifferent, log } = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const { deployer } = namedAccounts;\n  const Token = await deployments.get(\"Token\");\n  const deployResult = await deploy(\"Sale\", {\n    from: deployer,\n    contract: \"ERC721BidSale\",\n    args: [Token.address, 1, 3600]\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Sale deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = [\"Sale\"];\nmodule.exports.dependencies = [\"Token\"]; // this ensure the TOken script above is executed first, so `deployments.get('Token') succeeds\n```\n\nAs you can see the second one depends on the first. This is because the second script depends on a tag that the first script registers as using.\n\nWith that when `hardhat deploy --tags Sale` is executed\n\nthen both scripts will be run, ensuring Sale is ready.\n\nYou can also define the script to run after another script is run by setting `runAtTheEnd` to be true. For example:\n\n```js\nmodule.exports = async function({ getNamedAccounts, deployments }) {\n  const { deployIfDifferent, execute, log } = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const { deployer, admin } = namedAccounts;\n  await execute(\"Sale\", { from: deployer }, \"setAdmin\", admin);\n};\nmodule.exports.tags = [\"Sale\"];\nmodule.exports.runAtTheEnd = true;\n```\n\nTags can also be used in test with `deployments.fixture`. This allow you to test a subset of the deploy script.\n","readmeFilename":"README.md","gitHead":"04f7e24c458cee7aa24b3c5c0b3c1a7ac7402a25","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.1","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-hBsILnfdnF1+VvAmZQdyRc6ehl/3QQRevYmXXYoBVZnv6V32aVbcVCDnmw9KLQA6/ujVTMP+oBZsC+7jLgQwOw==","shasum":"a19b1e3064ce27d5be09bc4f042369398368d728","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.1.tgz","fileCount":68,"unpackedSize":790001,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfkALWCRA9TVsSAnZWagAAzX8P/30IrikXsHUWfRZhln6F\ni+7qg09tUZQ3+Roy9TNYMfNEbUC+oe45TNqe3btgbG9T5QWTnMRfhPs0L/SI\nOJ1JzIxljYUvJ04AXiDjqPDET2UawR4fCFZQjkloUBXg8ITAS8RX/u5T9Aru\nw+a4VwJLgpaDGr0buKy82jiFjy0sgIogcIMV3YMrbPxxoWxTPcQfO1qJdXNi\nhqB5//3sia+CHBmeQ2DNhFb6O9028Pl+8YDoYDKAOAoxvgqZB9CuLQgzSEQ/\nJuLfJQdPUSCo4BwTDXnzHfY+Tntc3bzkQBXKiWetD+a2EvW6nuQi6bNFfGLI\nx1sHOoSqjiYm331xzghdRzdNuYIvtPnMIFflW0RHWAXjv35BNUrmZLV84bdd\np0kCQAOgCJgO/NCtGZ6H3cd//ItP2CKRjn0Xtk2uSZSLImgPMlKm7TzRgSgc\nv0CaRZUH0mkSHZsXUa6SwsfWqpWM8vO7crDtcut7yhcuhMImiWC7exJpuzGX\nbwIe1Sp0yV1WFZ59cfb4rWRKoHMg+wALbI+E8vZ7VOT/2qwelYz4jiwqeBYS\n1QDU4Xq5TY63tIV493LTOnPi7DGVQqoAoy5Oe+xr0LoVshU3g5cQW13OB4R2\nREaiM2iRdDU78qcBISPIsDE7nyaSNmZBzXiPvwRexG2KIw6BQRr+NyEQnoRB\nHlTb\r\n=emLK\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQC1ODWON5A++URV7JWDSGKHIvydLoDnj/F4CnNerW1oIQIhAK0ErucLl4QphiQf7t5XyVOirMKRGLgBCkNLL6YV8npE"}]},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.1_1603273430322_0.20644541537769356"},"_hasShrinkwrap":false},"0.7.0-beta.2":{"name":"hardhat-deploy","version":"0.7.0-beta.2","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-plugin"],"devDependencies":{"@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","chai":"^4.2.0","dotenv":"^6.2.0","hardhat":"^2.0.0-rc.0","mocha":"^5.2.0","prettier":"^1.19.1","prettier-plugin-solidity":"^1.0.0-alpha.56","source-map-support":"^0.5.12","ts-node":"^8.1.0","tslint":"^5.16.0","tslint-config-prettier":"^1.18.0","tslint-plugin-prettier":"^2.0.1","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0-rc.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.0.0","chokidar":"^3.4.0","debug":"^4.1.1","fs-extra":"^9.0.0","match-all":"^1.2.6","qs":"^6.9.4"},"scripts":{"compile":"hardhat compile","lint:fix":"prettier --write src/**/*.{js,ts} test/**/*.{js,ts} && tslint --fix --config tslint.json --project tsconfig.json","lint":"tslint --config tslint.json --project tsconfig.json","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","prepublishOnly":"npm run build"},"readme":"[![hardhat](https://hardhat.org/hardhat-plugin-badge.svg?1)](https://hardhat.org)\n\n<h1> hardhat-deploy</h1>\n\n_A Hardhat Plugin For Replicable Deployments And Tests_\n\n[Hardhat](https://hardhat.org) Deployment And Test Plugin.\n\n- [What is it for ?](#what-is-it-for-)\n- [Installation](#installation)\n  - [npm install hardhat-deploy](#npm-install-hardhat-deploy)\n  - [TypeScript support](#typescript-support)\n  - [Migrating existing deployment to hardhat-deploy](#migrating-existing-deployment-to-hardhat-deploy)\n- [Hardhat Tasks Availabled/Updated](#hardhat-tasks-availabledupdated)\n  - [hardhat deploy](#hardhat-deploy)\n    - [Options](#options)\n    - [Flags](#flags)\n  - [hardhat node](#hardhat-node)\n  - [hardhat test](#hardhat-test)\n  - [hardhat etherscan-verify](#hardhat-etherscan-verify)\n    - [Options](#options-1)\n    - [Flags](#flags-1)\n  - [hardhat export](#hardhat-export)\n    - [Options](#options-2)\n- [Hardhat Environment Extensions](#hardhat-environment-extensions)\n- [Configuration](#configuration)\n  - [namedAccounts (ability to name addresses)](#namedaccounts-ability-to-name-addresses)\n  - [extra network's config](#extra-networks-config)\n  - [extra paths config](#extra-paths-config)\n  - [Importing deployment from other projects (truffle support too)](#importing-deployment-from-other-projects-truffle-support-too)\n  - [Access to Artifacts (non-deployed contract code and abi)](#access-to-artifacts-non-deployed-contract-code-and-abi)\n- [How to Deploy Contracts](#how-to-deploy-contracts)\n  - [The `deploy` Task](#the-deploy-task)\n  - [Deploy Scripts](#deploy-scripts)\n  - [The `deployments` field](#the-deployments-field)\n    - [`deployments.deploy`](#deploymentsdeploy)\n- [Handling contract using libraries](#handling-contract-using-libraries)\n- [Exporting Deployments](#exporting-deployments)\n- [Deploying and Upgrading Proxies](#deploying-and-upgrading-proxies)\n- [Builtin-In Support For Diamonds (EIP2535)](#builtin-in-support-for-diamonds-eip2535)\n- [Testing Deployed Contracts](#testing-deployed-contracts)\n- [More Information On Hardhat Tasks](#more-information-on-hardhat-tasks)\n  - [node task](#node-task)\n  - [test task](#test-task)\n  - [run task](#run-task)\n  - [console task](#console-task)\n- [Deploy Scripts: Tags And Dependencies](#deploy-scripts-tags-and-dependencies)\n\n## What is it for ?\n\nThis [hardhat](https://hardhat.dev) plugin adds a mechanism to deploy contracts to any network, keeping track of them and replicating the same environment for testing.\n\nIt also adds a mechanism to associate names to addresses so test and deployment scripts can be reconfigured by simply changing the address a name points to, allowing different configurations per network. This also results in much clearer tests and deployment scripts (no more `accounts[2]` in your code).\n\nThis plugin contains a lot more features too, all geared toward a better developer experience :\n\n- chain configuration export, listing deployed contract, their abi and address, usefull for webapps.\n- library linking at time of deployment\n- deterministic deployment across networks\n- ability to submit contract source to etherscan for verification. Because hardhat-deploy will save all necessary info, it can be executed at any time.\n- deployment dependency system (allowing you to only deploy what is needed).\n- deployment as migration so once a deployment is done, it can be set to never be executed again.\n- deployment retrying (by saving pending tx): so you can feel confident when making a deployment that you can always recover.\n- deployments as test fixture using `evm_snapshot` to speed up testing.\n- ability to create your own test fixture that automatically benefit from `evm_snapshot` to speed up tests using it.\n- TODO: update : combined with `buidler-ethers-v5` it has the ability to get ethers contract instance by name (like `await ethers.getContract(\"ContractName\")`).\n- importing previously compiled contract (possibly in different solidity compiler version).\n- importing artifact from external sources (like npm packages), including truffle support\n- importing deployments from external sources (like npm packages), including truffle support\n- ability to log information in `deploy` mode only (while in test the console remains clean).\n- contains helpers to read and execute transaction on deployed contract referring to them by name.\n- These helpers contains options to auto mine on dev environment like ganache (to speed up deployments).\n- save metadata of deployed contract so they can always be fully verified, via [sourcify](https://github.com/ethereum/sourcify) or [etherscan](https://etherscan.io).\n- proxy deployment with ability to upgrade them transparently, only if code changes.\n- diamond deployment with facets, allowing you to focus on what the new version will be. It will generate the diamondCut necessary to reach the new state.\n- watch and deploy: hardhat-deploy can watch both your deploy script and contract code and redeploy on changes.\n- HCR (Hot Contract Replacement): the watch feature combined with proxy or diamond, gives you an experience akin to frontend Hot Module Replacement: Once your contract change, the deployment is executed and your contract retain the same address and same state.\n\n## Installation\n\n### npm install hardhat-deploy\n\n```bash\nnpm install -D hardhat-deploy\n```\n\nAnd add the following statement to your `hardhat.config.js`:\n\n```js\nimport \"hardhat-deploy\";\n```\n\n### TypeScript support\n\nWith hardhad the tsconfig.json is optional.\n\nBut if you add folders to the `include` field in `tsconfig.json` you ll also need to include `hardhat.config.ts` like :\n\n`include\": [\"./hardhat.config.ts\", \"./scripts\", \"./deploy\", \"./test\"]`\n\nfor deploy script (see below) you can write them this way to benefit from typing :\n\n```\nimport {\n  HardhatRuntimeEnvironment,\n  DeployFunction,\n} from \"hardhat/types\";\n\nconst func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {\n  // code here\n};\nexport default func;\n```\n\nTODO update: See a full example of typescript usage here : https://github.com/wighawag/hardhat-deploy-ts-test\n\n### Migrating existing deployment to hardhat-deploy\n\nYou might want to switch your current deployment process to use hardhat-deploy. In that case you probably have some deployments saved elsewhere.\n\nIn order to port them to hardhat-deploy, you'll need to create one `.json` file per contract in the `deployments/<network>` folder (configurable via [paths config](#extra-paths-config)).\n\nThe network folder is simply the hardhat network name (as configured in hardhat.config.js) (accessible at runtime via `hre.network.name`).\nSuch folder need to have a file named `.chainId` containing the chainId as decimal.\n\nFor example for network named \"rinkeby\" (for the corresponding network) the file `deployments/rinkeby/.chainId` would be\n\n```\n4\n```\n\nNote, prior to hardhat 0.6 the chainId was appended to the folder name (expect for some known network name). This has changed and upgrading to 0.6 will require you to change the folder name and add the '.chainId' file.\n\nEach contract file must follow this type (as defined in [src/type-extensions.d.ts](src/type-extensions.d.ts)) :\n\n```ts\nexport interface Deployment {\n  abi: any[];\n  address: string;\n  receipt?: Receipt;\n  transactionHash?: string;\n  contractFilepath?: string;\n  contractName?: string;\n  history?: Deployment[];\n  args?: any[];\n  linkedData?: any;\n  metadata?: string;\n  bytecode?: string;\n  deployedBytecode?: string;\n  userdoc?: any;\n  devdoc?: any;\n  methodIdentifiers?: any;\n  diamondCut?: { address: string; sigs: string[] }[];\n  facets?: { address: string; sigs: string[] }[];\n  storageLayout?: any;\n}\n```\n\nAs you can see, only abi and address are mandatory. But having the other fields allow more feature. For example, metadata and args allow you to benefit from contract code verification.\n\nFor Receipt, the following type is expected:\n\n```ts\nexport type Receipt = {\n  from: string;\n  transactionHash: string;\n  blockHash: string;\n  blockNumber: number;\n  transactionIndex: number;\n  cumulativeGasUsed: string | number;\n  gasUsed: string | number;\n  contractAddress?: string;\n  to?: string;\n  logs?: Log[];\n  events?: any[];\n  logsBloom?: string;\n  byzantium?: boolean;\n  status?: number;\n  confirmations?: number;\n};\n```\n\nHere is an example:\n\nLet sey you have:\n\n- 2 Contract named Greeter and Registry deployed on rinkeby\n- 1 contract named Greeter on mainnet\n- 2 Contract named Greeter and Registry deployed on a network named rinkeby2\n\nYou would get the following folder structure:\n\n```\ndeployments/\n  mainnet/\n    .chainId\n    Greeter.json\n  rinkeby/\n    .chainId\n    Greeter.json\n    Registry.json\n  rinkeby2/\n    .chainId\n    Greeter.json\n    Registry.json\n```\n\nThe reason why hardhat-deploy save chainId in the `.chainId` file is both for\n\n- safety: so that if you were to change the network to point to a different chain, it would not attempt to read the wrong folder and assume that a contract has been deployed while it has not.\n- ability to know the chainId without requring to be connected to a node (and so not dependent on hardhat.config.js settings). Useful for `export` task.\n\n## Hardhat Tasks Availabled/Updated\n\n### hardhat deploy\n\nThis plugin adds the _deploy_ task to Hardhat.\n\nThis task will execute the scripts in the `deploy` folder and save the contract deployments to disk. These deployments are supposed to be saved for example in a git repository. This way they can be accessed later.\n\nWith the deployment saved, it allows you to deploy a contract only if changed were made.\n\nDeploy scripts (also called Deploy functions) can also perform aribtrary logic.\n\nFor further details on how to use it and write deploy script, see [section](#deploy-scripts) below.\n\n#### Options\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice to use by default for transactions executed via hardhat-deploy helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### Flags\n\n`--reset`: This flag reset the deployments from scratch. Previously deployed contract are not considered and deleted from disk.\n\n`--silent`: This flag remove hardhat-deploy log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n### hardhat node\n\nThis plugin modify the _node_ task so that it also execute the deployment script before exposing the server http RPC interface\n\nIt also add the same options as the _deploy_ task with the same functionality. It adds an extra flag:\n\n`--no-deploy` that discard all other options to revert to normal `hardhat node` behavior without any deployment being performed.\n\nNote that the deployments are saved as if the network name is `localhost`. This is because `hardhat node` is expected to be used as localhost: You can for example execute `hardhat --network localhost console` after `node` is running. Doing `builder --network hardhat console` would indeed not do anythong useful. It still take the configuration from `hardhat` in the hardhat.config.js file though.\n\n### hardhat test\n\nThis plugin add to the _test_ task a flag argument `--deploy-fixture` that run the global deployments fixture before the tests and snapshot it.\n\n### hardhat etherscan-verify\n\nThis plugin adds the _etherscan-verify_ task to Hardhat.\n\nThis task will submit the contract source and other info of all deployed contracts to allow etherscan to verify and record the sources.\n\nInstead of using the full solc input, this task will first attempt to send the minimal sources from the metadata.\nBut Etherscan sometime fails due to a bug in solidity compiler (https://github.com/ethereum/solidity/issues/9573). As such this task can fallback on full solc input (see option --solc-input). Note that if your contract was deployed with a previous version of hardhat-deploy, it might not contains the full information.\n\nThis task will also attempt to automatically find the SPDX license in the source.\n\nTo execute that task, you need to specifiy the network to run against :\n\n```\nhardhat --network mainnet etherscan-verify --api-key <apikey>\n```\n\n#### Options\n\n`--api-key <API_KEY>`: Etherscan API key. Optional as such api key can also be set by setting the environment variable : ETHERSCAN_API_KEY\n\n`--license <SPDX>`: specifiy the license to use (using SPDX id) or can be \"UNLICENSED\". Note that etherscan have limited support for licenses, see : https://etherscan.io/contract-license-types\n\n#### Flags\n\n`--solcInput`: allow the use of full solc-input as fallback. Note that the whole source folder will be included in the result of the verification on etherscan.\n\n`--force-license`: This flag force the use of the license specified by --license (useful if your inline SPDX are not compatible with etherscan list)\n\n### hardhat export\n\nThis plugin adds the _export_ task to Hardhat.\n\nThis task will export the contract deployed (saved in `deployments` folder) to a simple format containing only contract addresses and abi, useful for web apps.\n\nOne of the following options need to be set for this task to have any effects :\n\n#### Options\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\nThis last option has some limitations, when combined with the use of external deployments (see [Configuration](#configuration)). If such external deployments were using older version of hardhat-deploy or truffle, the chainId might be missing. In order for these to be exported, the hardhat network config need to explicity state the chainId in the `networks` config of `hardhat.config.js`.\n\n## Hardhat Environment Extensions\n\nThis plugin extends the Hardhat Runtime Environment by adding 4 fields:\n\n- `getNamedAccounts: () => Promise<{ [name: string]: string }>`: a function returning an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [Configuration](#configuration)).\n\n- `getUnamedAccounts: () => Promise<string[]}>`: accounts which has no names, useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`: contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId(): Promise<string>`: offer an easy way to fetch the current chainId.\n\n## Configuration\n\n### namedAccounts (ability to name addresses)\n\nThis plugin extends the `HardhatConfig`'s object with an optional `namedAccounts` field.\n\n`namedAccounts` allows you to associate names to addresses and have them configured per chain.\nThis allows you to have meaningful names in your tests while the addresses match to multi sig in real network for example.\n\n```js\n{\n    namedAccounts: {\n        deployer: {\n            default: 0, // here this will by default take the first account as deployer\n            1: 0, // similarly on mainnet it will take the first account as deployer. Note though that depending on how hardhat network are configured, the account 0 on one network can be different than on another\n            4: '0xA296a3d5F026953e17F472B497eC29a5631FB51B', // but for rinkeby it will be a specific address\n            \"goerli\": '0x84b9514E013710b9dD0811c9Fe46b837a4A0d8E0', //it can also specify a specific netwotk name (specified in hardhat.config.js)\n        },\n        feeCollector:{\n            default: 1, // here this will by default take the second account as feeCollector (so in the test this will be a different account than the deployer)\n            1: '0xa5610E1f289DbDe94F3428A9df22E8B518f65751', // on the mainnet the feeCollector could be a multi sig\n            4: '0xa250ac77360d4e837a13628bC828a2aDf7BabfB3', // on rinkeby it could be another account\n        }\n    }\n}\n```\n\n### extra network's config\n\nhardhat-deploy add 2 new fields to `networks` configuration\n\n`live` : this is not used internally but is useful to perform action on a network whether it is a live network (rinkeby, mainnet, etc) or a temporary one (localhost, hardhat). The default is true (except for localhost and hardhat where the default is false).\n\n`saveDeployments`: this tell whether hardhat-deploy should save the deployments to disk or not. Default to true.\n\n`tags`: network can have tags to represent them. The config is an array and at runtime the hre.network.tags is an object whose fields (the tags) are set to true.\n\nThis is useful to conidtionaly operate on network based on their use case.\n\nExample:\n\n```js\n{\n  networks: {\n    localhost: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"local\"]\n    },\n    hardhat: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"test\", \"local\"]\n    },\n    rinkeby: {\n      live: true,\n      saveDeployments: true,\n      tags: [\"staging\"]\n    }\n  }\n}\n```\n\n### extra paths config\n\nIt also adds fields to `HardhatConfig`'s `ProjectPaths` object.\n\nHere is an example showing the default values :\n\n```js\n{\n    paths: {\n        deploy: 'deploy',\n        deployments: 'deployments',\n        imports: `imports`\n    }\n}\n```\n\nThe deploy folder is expected to contains the deploy script that are executed upon invocation of `hardhat deploy` or `hardhat node`\n\nThe deployment folder will contains the resulting deployments (contract addresses along their abi, bytecode, metadata...). One folder per network and one file per contract.\n\nThe imports folder is expected to contains artifacts that were pre-compiled. Useful if you want to upgrade to a new solidity version but want to keep using previously compiled contracts. The artifact is the same format as normal hardhat artifact, so you can easily copy them over, before switching to a new compiler version.\n\n### Importing deployment from other projects (truffle support too)\n\nIt also add the `external` field to `HardhatConfig`\n\nSuch fiels allows to specify paths for external artifacts or deployments. The use of the `paths` field is not possible because hardhat expects all paths field to be string. It does not accept arrays or objects, see https://github.com/nomiclabs/hardhat/issues/776.\n\nThe external object has 2 fields:\n\n```js\n{\n    external: {\n        artifacts: [\"node_modules/@cartesi/arbitration/build/contracts\"],\n        deployments: {\n          rinkeby: [\"node_modules/@cartesi/arbitration/build/contracts\"],\n        }\n    }\n}\n```\n\nThe artifacts fields specify an array of path to look for artifact. it support both hardhat and truffle artifacts.\n\nThe deployments fields specify an object whose field name are the hardhat network and the value is an array of path to look for deployments. It supports both hardhat-deploy and truffle formats.\n\n### Access to Artifacts (non-deployed contract code and abi)\n\nyou can access contract artifact via `getArtifact` function :\n\n```js\nconst { deployments } = require(\"hardhat\");\nconst artifact = await deployments.getArtifact(artifactName);\n```\n\nWith the `buidler-ethers-v5` plugin you can get your ethers contract via :\n\n```js\nconst { deployments, ethers } = require(\"hardhat\");\nconst factory = await ethers.getContractFactory(artifactName);\n```\n\nNote that the artifact file need to be either in `artifacts` folder that hardhat generate on compilation or in the `imports` folder where you can store contracts compiled elsewhere. They can also be present in the folder specified in `external.artifacts` see [Importing deployment from other projects](#importing-deployment-from-other-projects-truffle-support-too)\n\n## How to Deploy Contracts\n\n### The `deploy` Task\n\n`hardhat --network <networkName> deploy [options and flags]`\n\nThis is a new task that the plugin adds. As the name suggests it deploys contracts.\nTo be exact it will look for files in the folder `deploy` or whatever was configured in `paths.deploy`, see [paths config](#extra-paths-config)\n\nIt will scan for files in alphabetical order and execute them in turn.\n\n- it will `require` each of these files and execute the exported function with the HRE as argument\n\nNote that running `hardhat deploy` without specifying a network will use the default network. If the default network is an internal ganache or hardhat then nothing will happen as a result but this can be used to ensure the deployment is without issues.\n\nTo specified the network, you can use the builtin hardhat argument `--network <network name>` or set the env variable `HARDHAT_NETWORK`\n\n### Deploy Scripts\n\nThe deploy scripts need to be of the following type :\n\n```js\nexport interface DeployFunction {\n  (env: HardhatRuntimeEnvironment): Promise<void | boolean>;\n  skip?: (env: HardhatRuntimeEnvironment) => Promise<boolean>;\n  tags?: string[];\n  dependencies?: string[];\n  runAtTheEnd?: boolean;\n  id?: string;\n}\n```\n\nThe skip function can be used to skip executing the script under whatever condition. It simply need to resolve a promise to true.\n\nThe tags is a list of string that when the _deploy_ task is executed with, the script will be executed (unless it skips). In other word if the deploy task is executed with a tag that does not belong to that script, that script will not be executed unless it is a dependency of a script that does get executed.\n\nThe dependencies is a list of tag that will be executed if that script is executed. So if the script is executed, every script whose tag match any of the dependency will be executed first.\n\nThe `runAtTheEnd` is a boolean that if set to true, will queue that script to be executed after all other scripts are executed.\n\nThese set of fields allow more flexibility to organize the script. You are not limited to alphabetical order.\n\nFinally the function can return true if it wishes to never be executed again. This can be usfeul to emulate migration scripts that are meant to be executed only once. Once such script return true (async), the `id` field is used so to track execution and if that field is not present when the script return true, it will fails.\n\nIn any case, as a general advice every deploy function should be idempotent. This is so they can always recover from failure or pending transaction.\n\nThis is why the `hre.deployments.deploy` function will by default only deploy if the contract code has changed, making it easier to write idempotent script.\n\nAn example of a deploy script :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnamedAccounts\n}) => {\n  const { deploy } = deployments;\n  const { deployer } = await getNamedAccounts();\n\n  // the following will only deploy \"GenericMetaTxProcessor\" if the contract was never deployed or if the code changed since last deployment\n  await deploy(\"GenericMetaTxProcessor\", {\n    from: deployer,\n    gas: 4000000,\n    args: []\n  });\n};\n```\n\nAs you can see the HRE passed in has 4 new fields :\n\n- `getNamedAccounts` is a function that returns a promise to an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [`namedAccounts`](#namedaccounts)).\n\n- `getUnamedAccounts`: function that return a promise to an array of accounts (which were not used in `getNamedAccounts`), useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`, which contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId` which return a promise for the chainId\n\nThe deploynments field contains the `deploy` function taht allow you to deploy contract and save them. It contains a lot more functions though :\n\n### The `deployments` field\n\nThe deployments field contains several helpers function to deploy contract but also execute transaction.\n\n```js\ndeploy(name: string, options: DeployOptions): Promise<DeployResult>; // deploy a contract\ndiamond: { // deploy diamond based contract (see section below)\n  deploy(name: string, options: DiamondOptions): Promise<DeployResult>;\n};\ndeterministic( // return the determinsitic address as well as a function to deploy the contract, can pass the `salt` field in the option to use different salt\n      name: string,\n      options: Create2DeployOptions\n    ): Promise<{\n      address: Address;\n      deploy(): Promise<DeployResult>;\n    }>;\nfetchIfDifferent(name: string, options: DeployOptions): Promise<boolean>; // return true if new compiled code is different than deployed contract\nsave(name: string, deployment: DeploymentSubmission): Promise<void>; // low level save of deployment\nget(name: string): Promise<Deployment>; // fetch a deployment by name, throw if not existing\ngetOrNull(name: string): Promise<Deployment | null>; // fetch deployment by name, return null if not existing\nall(): Promise<{ [name: string]: Deployment }>; // return all deployments\ngetArtifact(name: string): Promise<Artifact>; // return a hardhat artifact (compiled contract without deployment)\nrun( // execute deployment scripts\n  tags?: string | string[],\n  options?: {\n    resetMemory?: boolean;\n    deletePreviousDeployments?: boolean;\n    writeDeploymentsToFiles?: boolean;\n    export?: string;\n    exportAll?: string;\n  }\n): Promise<{ [name: string]: Deployment }>;\nfixture(tags?: string | string[]): Promise<{ [name: string]: Deployment }>; // execute deployment as fixture for test // use evm_snapshot to revert back\ncreateFixture(func: FixtureFunc, id?: string): () => Promise<any>; // execute a function as fixture using evm_snaphost to revert back each time\nlog(...args: any[]): void; // log data only ig log enabled (disabled in test fixture)\nexecute( // execute function call on contract\n  name: string,\n  options: TxOptions,\n  methodName: string,\n  ...args: any[]\n): Promise<Receipt>;\nrawTx(tx: SimpleTx): Promise<Receipt>; // execute a simple transaction\nread( // make a read-only call to a contract\n  name: string,\n  options: CallOptions,\n  methodName: string,\n  ...args: any[]\n): Promise<any>;\nread(name: string, methodName: string, ...args: any[]): Promise<any>;\n```\n\n#### `deployments.deploy`\n\nThe deploy function as mentioned allow you to deploy a contract and save it under a specific name.\n\nThe deploy function expect 2 parameters: one for the name and one for the options\n\nSee below the full list of fields that the option parameter allows and requires:\n\n```js\nfrom: string; // address (or private key) that will perform the transaction. you can use `getNamedAccounts` to retrived the address you want by name.\ncontract?: // this is an optional field. If not specified it defaults to the contract with the same name as the first parameter\n  | string // this field can be either a string for the name of the contract\n  | { // or abi and bytecode\n      abi: ABI;\n      bytecode: string;\n      deployedBytecode?: string;\n    };\nargs?: any[]; // the list of argument for the constructor (or the upgrade function in case of proxy)\nskipIfAlreadyDeployed?: boolean; // if set it to true, will not attempt to deploy even if the contract deployed under the same name is different\nlog?: boolean; // if true, it will log the result of the deployment (address and gas used)\nlinkedData?: any; // This allow to associate any JSON data to the deployment. Useful for merkle tree data for example\nlibraries?: { [libraryName: string]: Address }; // This let you associate libraries to the deployed contract\nproxy?: boolean | string | ProxyOptions; // This options allow to consider yoru contract as a proxy (see below for more details)\n\n// here some common tx options :\ngasLimit?: string | number | BigNumber;\ngasPrice?: string | BigNumber;\nvalue?: string | BigNumber;\nnonce?: string | number | BigNumber;\n\nestimatedGasLimit?: string | number | BigNumber; // to speed up the estimation, it is possible to provide an upper gasLimit\nestimateGasExtra?: string | number | BigNumber; // this option allow you to add a gas buffer on top of the estimation\n\ndev_forceMine?: boolean; // this force a evm_mine to be executed. this is useful to speed deployment on test network that allow to specify a block delay (ganache for example). This option basically skip the delay by force mining.\ndeterministicDeployment? boolean | string; // if true, it will deploy the contract at a deterministic address based on bytecode and constuctor arguments. The address will be the same across all network. It use create2 opcode for that, if it is a string, the string will be used as the salt.\n```\n\n## Handling contract using libraries\n\nIn the deploy function, one of the `DeployOptions` that can be passed into the function is the `libraries` field.\n\nFirst, deploy the library using the `deploy` function, then when we deploy a contract that needs the the linked library, we can pass the deployed library name and address in as an argument to the `libraries` object.\n\n```js\nconst exampleLibrary = await deploy(\"ExampleLibary\", {\n    from: <deployer>\n});\n\n```\n\nExampleLibrary is now deployed to whatever network is in the context of the environment.\n\nFor example, if we are deploying on Rinkeby, this library will get deployed on rinkeby, and the `exampleLibrary` variable will be an deployment object that contains the abi as well as the deployed address for the contract.\n\nNow that the library is deployed, we can link it in our next deployed contract.\n\n```js\nconst example = await deploy(\"Example\", {\n    from: <deployer>\n    args: [\"This is an example string argument in the constructor for the 'Example' contract\"],\n    libraries: {\n        ExampleLibrary: exampleLibrary.address\n    }\n});\n\n```\n\nThis `libraries` object takes the name of the library, and its deployed address on the network. Multiple libraries can be passed into the `libraries` object.\n\n## Exporting Deployments\n\nApart from deployments saved in the `deployments` folder which contains all information available about the contract (compile time data + deployment data), `hardhat-deploy` allows you to export lightweight file.\n\nThese can be used for example to power your frontend with contract's address and abi.\n\nThis come into 2 flavors.\n\nThe first one is exported via the `--export <file>` option and follow the following format :\n\n```js\nexport interface Export {\n  chainId: string;\n  name: string;\n  contracts: { [name: string]: ContractExport };\n}\n```\n\nwhere name is the name of the network configuration chosen (see hardhat option `--network`)\n\nThe second one is exported via the `--export-all <file>` option and follow the following format :\n\n```js\nexport type MultiExport = {\n  [chainId: string]: { [name: string]: Export }\n};\n```\n\nAs you see the second format include the previous. While in most case you'll need the single export where your application will support only one network, there are case where your app would want to support multiple network at nonce. This second format allow for that.\n\nFurthermore as hardhat support multiple network configuration for the same network (rinkeby, mainnet...), the export-all format will contains each of them grouped by their chainId.\n\n## Deploying and Upgrading Proxies\n\nAs mentioned above, the deploy function can also deploy a contract through a proxy. It can be done without modification of the contract as long as it does not have a constructor (or constructor with zero arguments).\n\nThe Proxy is both ERC-1967 and ERC-173 Compliant\n\nCode can be found [here](solc_0.7/proxy/EIP173Proxy.sol)\n\nTo perform such proxy deployment, you just need to invoke the deploy function with the following options : `{..., proxy: true}`\n\nSee example :\n\n```js\nmodule.exports = async ({ getNamedAccounts, deployments, getChainId }) => {\n  const { deploy } = deployments;\n  const { deployer } = await getNamedAccounts();\n  await deploy(\"Greeter\", {\n    from: deployer,\n    proxy: true\n  });\n};\n```\n\nYou can also set it to `proxy: \"<upgradeMethodName>\"` in which case the function `<upgradeMethodName>` will be executed upon upgrade.\nthe `args` field will be then used for that function instead of the contructor. It is also possible to then have a constructor with the same arguments and have the proxy be disabled. It can be useful if you want to have your contract as upgradeable in a test network but be non-upgradeable on the mainnet. Further documentation need to written for that.\n\nSee example :\n\n```js\nmodule.exports = async ({ getNamedAccounts, deployments, getChainId }) => {\n  const { deploy } = deployments;\n  const { deployer } = await getNamedAccounts();\n  await deploy(\"Greeter\", {\n    from: deployer,\n    proxy: \"postUpgrade\",\n    args: [\"arg1\", 2, 3]\n  });\n};\n```\n\nThe proxy option can also be an object which can set the specific owner that the proxy is going to be managed by.\n\nSee example:\n\n```js\nmodule.exports = async ({ getNamedAccounts, deployments, getChainId }) => {\n  const { deploy } = deployments;\n  const { deployer, greeterOwner } = await getNamedAccounts();\n  await deploy(\"Greeter\", {\n    from: deployer,\n    proxy: {\n      owner: greeterOwner,\n      methodName: \"postUpgrade\"\n    },\n    args: [\"arg1\", 2, 3]\n  });\n};\n```\n\nNote that for the second invokation, this deployment will fails to upgrade the proxy as the `from` which is `deployer` is not the same as the proxy's owner : `greeterOwner`\n\nTo make it work, you have to create a new script that have for `from` field: `greeterOwner`. If such value is a a multi sig or an address not registered as part of hardhat signers, the tx will not be executed but instead an error will be throw, mentionning the tx data necessary to perform the upgrade.\n\n## Builtin-In Support For Diamonds (EIP2535)\n\nThe deployments field also expose the diamond field: `hre.deployments.diamond` that let you deploy [Diamonds](https://eips.ethereum.org/EIPS/eip-2535) in an easy way.\n\nInstead of specifying the facets to cut out or cut in, which the diamond contract expects, you specify the facets you want to end up having on the deployed contract.\n\n`diamond.deploy` expect the facet as names. The name represent the compiled contract name that going to be deployed as facet. In future version you ll be able to specify deployed contract or artifact object as facet.\n\nTo deploy a contract with 3 facet you can do as follow :\n\n```js\nmodule.exports = async ({ getNamedAccounts, deployments, getChainId }) => {\n  const { diamond } = deployments;\n  const { deployer, diamondAdmin } = await getNamedAccounts();\n  await diamond.deploy(\"ADiamondContract\", {\n    from: deployer,\n    owner: diamondAdmin,\n    facets: [\"Facet1\", \"Facet2\", \"Facet3\"]\n  });\n};\n```\n\nif you then later execute the following script:\n\n```js\nmodule.exports = async ({ getNamedAccounts, deployments, getChainId }) => {\n  const { diamond } = deployments;\n  const { deployer, diamondAdmin } = await getNamedAccounts();\n  await diamond.deploy(\"ADiamondContract\", {\n    from: diamondAdmin, // this need to be the diamondAdmin for upgrade\n    owner: diamondAdmin,\n    facets: [\"NewFacet\", \"Facet2\", \"Facet3\"]\n  });\n};\n```\n\nThen the NewFacet will be deployed automatically if needed and then the diamondCut will cut Facet1 out and add NewFacet.\n\nNote that if the code for Facet2 and Facet3 changes, they will also be redeployed automatically and the diamondCuts will replace the existing facets with these new ones.\n\nNote that The Diamond contract's code is part of hardhat-deploy and contains 3 built-in facet that can be removed manually if desired.\nThese facets are used for ownership, diamondCut and diamond loupe.\n\nThe implementation is the [reference implementation by Nick Mudge](https://github.com/mudgen/Diamond)\n\nLike normal proxies you can also execute a function at the time of an upgrade.\n\nThis is done by specifying the execute field in the diamond deploy options :\n\n```js\ndiamond.deploy(\"ADiamondContract\", {\n  from: deployer,\n  owner: diamondAdmin,\n  facets: [\"NewFacet\", \"Facet2\", \"Facet3\"],\n  execute: {\n    methodName: \"postUpgrade\",\n    args: [\"one\", 2, \"0x3\"]\n  }\n});\n```\n\nSince the diamond standard has no builtin mechanism to make the deployment of Diamond with function execution, the Diamond when deployed is actually deployed through a special contract, the `Diamantaire` (see code [here](solc_0.7/diamond/Diamantaire.sol)) that act as factory to build Diamond. It uses deterministic deployment for that so, it is transparently managed by hardhat-deploy.\n\nThe Diamantaire also support the deterministic deployment of Diamond.\nAn extra field can be passed to the Diamond deployment options : `deterministicSalt`. It has to be a non-zero 32bytes string (in hex format).\nNote that if you want to deploy 2 diamonds with same owner, you'll need 2 different deterministicSalt for them to be 2 separate contracts.\n\n## Testing Deployed Contracts\n\nYou can continue using the usual test task :\n\n`hardhat test`\n\nTests can then use the `hre.deployments.fixture` function to run the deployment for the test and snapshot it so that tests don't need to perform all the deployments transaction every time, they simply reuse the snapshot for every test (this leverages `evm_snapshot` and `evm_revert` provided by both `hardhat` and `ganache`). You can for example set them in a `beaforeEach`.\n\nHere is an example of a test :\n\n```js\nconst { deployments } = require(\"hardhat\");\n\ndescribe(\"Token\", () => {\n  beforeEach(async () => {\n    await deployments.fixture();\n  });\n  it(\"testing 1 2 3\", async function() {\n    const Token = await deployments.get(\"Token\"); // Token is available because the fixture was executed\n    console.log(Token.address);\n    const ERC721BidSale = await deployments.get(\"ERC721BidSale\");\n    console.log({ ERC721BidSale });\n  });\n});\n```\n\nIf the deployment scripts are complex, the first test could take while (as the fixture need to execute the deployment) but then from the second test onward, the deployments are never re-executed, instead the fixture will do `evm_revert` and test will run far faster.\n\nTests can also leverage named accounts for clearer test. Combined with `buidler-ethers-v5` plugin, you can write succint test :\n\n```js\nconst { ethers, getNamedAccounts } = require(\"hardhat\");\n\ndescribe(\"Token\", () => {\n  beforeEach(async () => {\n    await deployments.fixture();\n  });\n  it(\"testing 1 2 3\", async function() {\n    const { tokenOwner } = await getNamedAccounts();\n    const TokenContract = await ethers.getContract(\"Token\", tokenOwner);\n    await TokenContract.mint(2);\n  });\n});\n```\n\nFurthermore, tests can easily create efficient fixture using `deployments.createFixture`\n\nSee example :\n\n```js\nconst setupTest = deployments.createFixture(async ({deployments, getNamedAccounts, ethers}, options) => {\n  await deployments.fixture(); // ensure you start from a fresh deployments\n  const { tokenOwner } = await getNamedAccounts();\n  const TokenContract = await ethers.getContract(\"Token\", tokenOwner);\n  await TokenContract.mint(10); //this mint is executed once and then `createFixture` will ensure it is snapshotted\n  return {\n    tokenOwner: {\n      address: tokenOwner,\n      TokenContract\n    }\n  };\n};\ndescribe(\"Token\", () => {\n  it(\"testing 1 2 3\", async function() {\n    const {tokenOwner} = await setupTest()\n    await tokenOwner.TokenContract.mint(2);\n  });\n});\n```\n\nWhile this example is trivial, some fixture can requires several transaction and the ability to snapshot them automatically speed up the tests greatly.\n\n## More Information On Hardhat Tasks\n\n### node task\n\nas mentioned above, the node task is slighly modified and augmented with various flag and options\n\n`hardhat node`\n\nIn particulat It adds an argument `--export` that allows you to specify a destination file where the info about the contracts deployed is written.\nYour webapp can then access all contracts information.\n\n### test task\n\n`hardhat test`\n\nthe test task is augmented with one flag argument `--deploy-fixture` that allow to run all deployments in a fixture snapshot before executing the tests. This can speed up tests that use specific tags as the global fixture take precedence (unless specified).\n\nIn other word tests can use `deployments.fixture(<specific tag>)` where specific tag only deploy the minimal contracts under tests, while still benefiting from global deployment snapshot if used.\n\nIf a test need the deployments to only include the specific deployment specified by the tag, it can use the following :\n\n```js\ndeployments.fixture(\"<specific tag>\", { fallbackToGlobal: false });\n```\n\nDue to how snapshot/revert works in hardhat, this means that these test will not be able to benefit from the global fixture snapshot and will have to deploy their contract as part of the fixture call. This is automatix but means that these tests will run slower.\n\n### run task\n\n`hardhat --network <networkName> run <script>`\n\nThe run task act as before but thanks to the `hre.deployments` field it can access deployed contract :\n\n```js\nconst hre = require(\"hardhat\");\nconst { deployments, getNamedAccounts } = hre;\n\n(async () => {\n  console.log(await deployments.all());\n  console.log({ namedAccounts: await getNamedAccounts() });\n})();\n```\n\nYou can also run it directly from the command line as usual.\n\n`HARDHAT_NETWORK=rinkeby node <script>` is the equivalent except it does not load the hardhat environment twice (which the run task does)\n\n### console task\n\n`hardhat console`\n\nThe same applies to the `console` task.\n\n## Deploy Scripts: Tags And Dependencies\n\nIt is possible to execute only specific part of the deployments with `hardhat deploy --tags <tags>`\n\nTags represent what the deploy script acts on. In general it will be a single string value, the name of the contract it deploys or modifies.\n\nThen if another deploy script has such tag as a dependency, then when this latter deploy script has a specific tag and that tag is requested, the dependency will be executed first.\n\nHere is an example of two deploy scripts :\n\n```js\nmodule.exports = async ({ getNamedAccounts, deployments }) => {\n  const { deployIfDifferent, log } = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const { deployer } = namedAccounts;\n  const deployResult = await deploy(\"Token\", {\n    from: deployer,\n    args: [\"hello\", 100]\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Token deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = [\"Token\"];\n```\n\n```js\nmodule.exports = async function({ getNamedAccounts, deployments }) {\n  const { deployIfDifferent, log } = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const { deployer } = namedAccounts;\n  const Token = await deployments.get(\"Token\");\n  const deployResult = await deploy(\"Sale\", {\n    from: deployer,\n    contract: \"ERC721BidSale\",\n    args: [Token.address, 1, 3600]\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Sale deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = [\"Sale\"];\nmodule.exports.dependencies = [\"Token\"]; // this ensure the TOken script above is executed first, so `deployments.get('Token') succeeds\n```\n\nAs you can see the second one depends on the first. This is because the second script depends on a tag that the first script registers as using.\n\nWith that when `hardhat deploy --tags Sale` is executed\n\nthen both scripts will be run, ensuring Sale is ready.\n\nYou can also define the script to run after another script is run by setting `runAtTheEnd` to be true. For example:\n\n```js\nmodule.exports = async function({ getNamedAccounts, deployments }) {\n  const { deployIfDifferent, execute, log } = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const { deployer, admin } = namedAccounts;\n  await execute(\"Sale\", { from: deployer }, \"setAdmin\", admin);\n};\nmodule.exports.tags = [\"Sale\"];\nmodule.exports.runAtTheEnd = true;\n```\n\nTags can also be used in test with `deployments.fixture`. This allow you to test a subset of the deploy script.\n","readmeFilename":"README.md","gitHead":"3ea0ca10fe16bff2c76b789366be7348b2a8f2d0","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.2","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-VXhDBDLHPGdoKQAA9hHpk/FwougJCHQAztneCkQQZLwmpJlET2XrMhodXFhXJo6R1XrYD1YMQA1V1ljuFw48vw==","shasum":"dfa2555c023a177c2bd318a2993ca8c0f3e702aa","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.2.tgz","fileCount":68,"unpackedSize":785888,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfkJR1CRA9TVsSAnZWagAAh+EP/jXGBMnln8NfConOt4gz\nXPxj0jQEDy1MPAbsS8uDqwqjwLgcVY1whGxXpdb4EISr/zpZfByjWKSjT6Xm\nfdZ+qgJMnpP9LKR8pJidVQZRapwV6wUdrN1bV3KtEnNoPX89zw/jQXVbRZmr\n3rkVYHmhzjAED229LyRof68rJGlJmKRNyGCE6lLEdmFagUzqr8xnsloZB9tE\nDuRTa71TzU2P2225H9BlvArrQuqUYIq7ekm16eEDFoalGq8XTwFYhuNGF9YM\nRSpS7BT18mlrqxwHDdKwiZF9eEY0XlURRx+s2csKtyCoyLpbuU0AiFle/7ra\nDPieFunsuSEwvhbXgm9vsr5X1S3Sh+SNJN0XmGZRMpSe/zYqmdK70ThQezHb\neennQzDXIJ58xGiqKucGGjH8TglZh6fe9CYbWWEIbkBwEOaPt6GflnTRNrsl\njRMAQCvku8eTm4CtKolUyACwHB4cxlJv1IKt0oVZty+BPIDB2V/KewCQqvHj\nOUkV8aaT4/RW7OtuL9+peXPHy76nTMWoaARt43/e1ui8IPlX1CAxxw2cEOdY\ng+YRZs+SVycfb1/MIB5ZNbGh5ucSSZnAn+Pe3e8aGSk7vpIGG9XaOYsueNWR\nKMcUbhmYl1hv45npO3109GBkro18QQuROrWQ8pXZlIYVwB3nLUAvfgXhDEeJ\n3pyI\r\n=QvKh\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDYwd/UU9dl7L+9JmkQo46IYTpRlf4GfAC2xtUr1kTrDAIhAISY8ZII+pmMO3O27MNCUqaXBNX30RjxdfCOoOwMECjY"}]},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.2_1603310709229_0.9580672960039005"},"_hasShrinkwrap":false},"0.7.0-beta.3":{"name":"hardhat-deploy","version":"0.7.0-beta.3","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-plugin"],"devDependencies":{"@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","chai":"^4.2.0","dotenv":"^6.2.0","hardhat":"^2.0.0-rc.0","mocha":"^5.2.0","prettier":"^1.19.1","prettier-plugin-solidity":"^1.0.0-alpha.56","source-map-support":"^0.5.12","ts-node":"^8.1.0","tslint":"^5.16.0","tslint-config-prettier":"^1.18.0","tslint-plugin-prettier":"^2.0.1","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0-rc.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.0.0","chokidar":"^3.4.0","debug":"^4.1.1","fs-extra":"^9.0.0","match-all":"^1.2.6","qs":"^6.9.4"},"scripts":{"compile":"hardhat compile","lint:fix":"prettier --write src/**/*.{js,ts} test/**/*.{js,ts} && tslint --fix --config tslint.json --project tsconfig.json","lint":"tslint --config tslint.json --project tsconfig.json","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","prepublishOnly":"npm run build"},"readme":"[![hardhat](https://hardhat.org/hardhat-plugin-badge.svg?1)](https://hardhat.org)\n\n<h1> hardhat-deploy</h1>\n\n_A Hardhat Plugin For Replicable Deployments And Tests_\n\n[Hardhat](https://hardhat.org) Deployment And Test Plugin.\n\n- [What is it for ?](#what-is-it-for-)\n- [Installation](#installation)\n  - [npm install hardhat-deploy](#npm-install-hardhat-deploy)\n  - [TypeScript support](#typescript-support)\n  - [Migrating existing deployment to hardhat-deploy](#migrating-existing-deployment-to-hardhat-deploy)\n- [Hardhat Tasks Availabled/Updated](#hardhat-tasks-availabledupdated)\n  - [hardhat deploy](#hardhat-deploy)\n    - [Options](#options)\n    - [Flags](#flags)\n  - [hardhat node](#hardhat-node)\n  - [hardhat test](#hardhat-test)\n  - [hardhat etherscan-verify](#hardhat-etherscan-verify)\n    - [Options](#options-1)\n    - [Flags](#flags-1)\n  - [hardhat export](#hardhat-export)\n    - [Options](#options-2)\n- [Hardhat Environment Extensions](#hardhat-environment-extensions)\n- [Configuration](#configuration)\n  - [namedAccounts (ability to name addresses)](#namedaccounts-ability-to-name-addresses)\n  - [extra network's config](#extra-networks-config)\n  - [extra paths config](#extra-paths-config)\n  - [Importing deployment from other projects (truffle support too)](#importing-deployment-from-other-projects-truffle-support-too)\n  - [Access to Artifacts (non-deployed contract code and abi)](#access-to-artifacts-non-deployed-contract-code-and-abi)\n- [How to Deploy Contracts](#how-to-deploy-contracts)\n  - [The `deploy` Task](#the-deploy-task)\n  - [Deploy Scripts](#deploy-scripts)\n  - [The `deployments` field](#the-deployments-field)\n    - [`deployments.deploy`](#deploymentsdeploy)\n- [Handling contract using libraries](#handling-contract-using-libraries)\n- [Exporting Deployments](#exporting-deployments)\n- [Deploying and Upgrading Proxies](#deploying-and-upgrading-proxies)\n- [Builtin-In Support For Diamonds (EIP2535)](#builtin-in-support-for-diamonds-eip2535)\n- [Testing Deployed Contracts](#testing-deployed-contracts)\n- [More Information On Hardhat Tasks](#more-information-on-hardhat-tasks)\n  - [node task](#node-task)\n  - [test task](#test-task)\n  - [run task](#run-task)\n  - [console task](#console-task)\n- [Deploy Scripts: Tags And Dependencies](#deploy-scripts-tags-and-dependencies)\n\n## What is it for ?\n\nThis [hardhat](https://hardhat.dev) plugin adds a mechanism to deploy contracts to any network, keeping track of them and replicating the same environment for testing.\n\nIt also adds a mechanism to associate names to addresses so test and deployment scripts can be reconfigured by simply changing the address a name points to, allowing different configurations per network. This also results in much clearer tests and deployment scripts (no more `accounts[2]` in your code).\n\nThis plugin contains a lot more features too, all geared toward a better developer experience :\n\n- chain configuration export, listing deployed contract, their abi and address, usefull for webapps.\n- library linking at time of deployment\n- deterministic deployment across networks\n- ability to submit contract source to etherscan for verification. Because hardhat-deploy will save all necessary info, it can be executed at any time.\n- deployment dependency system (allowing you to only deploy what is needed).\n- deployment as migration so once a deployment is done, it can be set to never be executed again.\n- deployment retrying (by saving pending tx): so you can feel confident when making a deployment that you can always recover.\n- deployments as test fixture using `evm_snapshot` to speed up testing.\n- ability to create your own test fixture that automatically benefit from `evm_snapshot` to speed up tests using it.\n- TODO: update : combined with `buidler-ethers-v5` it has the ability to get ethers contract instance by name (like `await ethers.getContract(\"ContractName\")`).\n- importing previously compiled contract (possibly in different solidity compiler version).\n- importing artifact from external sources (like npm packages), including truffle support\n- importing deployments from external sources (like npm packages), including truffle support\n- ability to log information in `deploy` mode only (while in test the console remains clean).\n- contains helpers to read and execute transaction on deployed contract referring to them by name.\n- These helpers contains options to auto mine on dev environment like ganache (to speed up deployments).\n- save metadata of deployed contract so they can always be fully verified, via [sourcify](https://github.com/ethereum/sourcify) or [etherscan](https://etherscan.io).\n- proxy deployment with ability to upgrade them transparently, only if code changes.\n- diamond deployment with facets, allowing you to focus on what the new version will be. It will generate the diamondCut necessary to reach the new state.\n- watch and deploy: hardhat-deploy can watch both your deploy script and contract code and redeploy on changes.\n- HCR (Hot Contract Replacement): the watch feature combined with proxy or diamond, gives you an experience akin to frontend Hot Module Replacement: Once your contract change, the deployment is executed and your contract retain the same address and same state.\n\n## Installation\n\n### npm install hardhat-deploy\n\n```bash\nnpm install -D hardhat-deploy\n```\n\nAnd add the following statement to your `hardhat.config.js`:\n\n```js\nimport \"hardhat-deploy\";\n```\n\n### TypeScript support\n\nWith hardhad the tsconfig.json is optional.\n\nBut if you add folders to the `include` field in `tsconfig.json` you ll also need to include `hardhat.config.ts` like :\n\n`include\": [\"./hardhat.config.ts\", \"./scripts\", \"./deploy\", \"./test\"]`\n\nfor deploy script (see below) you can write them this way to benefit from typing :\n\n```\nimport {\n  HardhatRuntimeEnvironment,\n  DeployFunction,\n} from \"hardhat/types\";\n\nconst func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {\n  // code here\n};\nexport default func;\n```\n\nTODO update: See a full example of typescript usage here : https://github.com/wighawag/hardhat-deploy-ts-test\n\n### Migrating existing deployment to hardhat-deploy\n\nYou might want to switch your current deployment process to use hardhat-deploy. In that case you probably have some deployments saved elsewhere.\n\nIn order to port them to hardhat-deploy, you'll need to create one `.json` file per contract in the `deployments/<network>` folder (configurable via [paths config](#extra-paths-config)).\n\nThe network folder is simply the hardhat network name (as configured in hardhat.config.js) (accessible at runtime via `hre.network.name`).\nSuch folder need to have a file named `.chainId` containing the chainId as decimal.\n\nFor example for network named \"rinkeby\" (for the corresponding network) the file `deployments/rinkeby/.chainId` would be\n\n```\n4\n```\n\nNote, prior to hardhat 0.6 the chainId was appended to the folder name (expect for some known network name). This has changed and upgrading to 0.6 will require you to change the folder name and add the '.chainId' file.\n\nEach contract file must follow this type (as defined in [src/type-extensions.d.ts](src/type-extensions.d.ts)) :\n\n```ts\nexport interface Deployment {\n  abi: any[];\n  address: string;\n  receipt?: Receipt;\n  transactionHash?: string;\n  contractFilepath?: string;\n  contractName?: string;\n  history?: Deployment[];\n  args?: any[];\n  linkedData?: any;\n  metadata?: string;\n  bytecode?: string;\n  deployedBytecode?: string;\n  userdoc?: any;\n  devdoc?: any;\n  methodIdentifiers?: any;\n  diamondCut?: { address: string; sigs: string[] }[];\n  facets?: { address: string; sigs: string[] }[];\n  storageLayout?: any;\n}\n```\n\nAs you can see, only abi and address are mandatory. But having the other fields allow more feature. For example, metadata and args allow you to benefit from contract code verification.\n\nFor Receipt, the following type is expected:\n\n```ts\nexport type Receipt = {\n  from: string;\n  transactionHash: string;\n  blockHash: string;\n  blockNumber: number;\n  transactionIndex: number;\n  cumulativeGasUsed: string | number;\n  gasUsed: string | number;\n  contractAddress?: string;\n  to?: string;\n  logs?: Log[];\n  events?: any[];\n  logsBloom?: string;\n  byzantium?: boolean;\n  status?: number;\n  confirmations?: number;\n};\n```\n\nHere is an example:\n\nLet sey you have:\n\n- 2 Contract named Greeter and Registry deployed on rinkeby\n- 1 contract named Greeter on mainnet\n- 2 Contract named Greeter and Registry deployed on a network named rinkeby2\n\nYou would get the following folder structure:\n\n```\ndeployments/\n  mainnet/\n    .chainId\n    Greeter.json\n  rinkeby/\n    .chainId\n    Greeter.json\n    Registry.json\n  rinkeby2/\n    .chainId\n    Greeter.json\n    Registry.json\n```\n\nThe reason why hardhat-deploy save chainId in the `.chainId` file is both for\n\n- safety: so that if you were to change the network to point to a different chain, it would not attempt to read the wrong folder and assume that a contract has been deployed while it has not.\n- ability to know the chainId without requring to be connected to a node (and so not dependent on hardhat.config.js settings). Useful for `export` task.\n\n## Hardhat Tasks Availabled/Updated\n\n### hardhat deploy\n\nThis plugin adds the _deploy_ task to Hardhat.\n\nThis task will execute the scripts in the `deploy` folder and save the contract deployments to disk. These deployments are supposed to be saved for example in a git repository. This way they can be accessed later.\n\nWith the deployment saved, it allows you to deploy a contract only if changed were made.\n\nDeploy scripts (also called Deploy functions) can also perform aribtrary logic.\n\nFor further details on how to use it and write deploy script, see [section](#deploy-scripts) below.\n\n#### Options\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice to use by default for transactions executed via hardhat-deploy helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### Flags\n\n`--reset`: This flag reset the deployments from scratch. Previously deployed contract are not considered and deleted from disk.\n\n`--silent`: This flag remove hardhat-deploy log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n### hardhat node\n\nThis plugin modify the _node_ task so that it also execute the deployment script before exposing the server http RPC interface\n\nIt also add the same options as the _deploy_ task with the same functionality. It adds an extra flag:\n\n`--no-deploy` that discard all other options to revert to normal `hardhat node` behavior without any deployment being performed.\n\nNote that the deployments are saved as if the network name is `localhost`. This is because `hardhat node` is expected to be used as localhost: You can for example execute `hardhat --network localhost console` after `node` is running. Doing `builder --network hardhat console` would indeed not do anythong useful. It still take the configuration from `hardhat` in the hardhat.config.js file though.\n\n### hardhat test\n\nThis plugin add to the _test_ task a flag argument `--deploy-fixture` that run the global deployments fixture before the tests and snapshot it.\n\n### hardhat etherscan-verify\n\nThis plugin adds the _etherscan-verify_ task to Hardhat.\n\nThis task will submit the contract source and other info of all deployed contracts to allow etherscan to verify and record the sources.\n\nInstead of using the full solc input, this task will first attempt to send the minimal sources from the metadata.\nBut Etherscan sometime fails due to a bug in solidity compiler (https://github.com/ethereum/solidity/issues/9573). As such this task can fallback on full solc input (see option --solc-input). Note that if your contract was deployed with a previous version of hardhat-deploy, it might not contains the full information.\n\nThis task will also attempt to automatically find the SPDX license in the source.\n\nTo execute that task, you need to specifiy the network to run against :\n\n```\nhardhat --network mainnet etherscan-verify --api-key <apikey>\n```\n\n#### Options\n\n`--api-key <API_KEY>`: Etherscan API key. Optional as such api key can also be set by setting the environment variable : ETHERSCAN_API_KEY\n\n`--license <SPDX>`: specifiy the license to use (using SPDX id) or can be \"UNLICENSED\". Note that etherscan have limited support for licenses, see : https://etherscan.io/contract-license-types\n\n#### Flags\n\n`--solcInput`: allow the use of full solc-input as fallback. Note that the whole source folder will be included in the result of the verification on etherscan.\n\n`--force-license`: This flag force the use of the license specified by --license (useful if your inline SPDX are not compatible with etherscan list)\n\n### hardhat export\n\nThis plugin adds the _export_ task to Hardhat.\n\nThis task will export the contract deployed (saved in `deployments` folder) to a simple format containing only contract addresses and abi, useful for web apps.\n\nOne of the following options need to be set for this task to have any effects :\n\n#### Options\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\nThis last option has some limitations, when combined with the use of external deployments (see [Configuration](#configuration)). If such external deployments were using older version of hardhat-deploy or truffle, the chainId might be missing. In order for these to be exported, the hardhat network config need to explicity state the chainId in the `networks` config of `hardhat.config.js`.\n\n## Hardhat Environment Extensions\n\nThis plugin extends the Hardhat Runtime Environment by adding 4 fields:\n\n- `getNamedAccounts: () => Promise<{ [name: string]: string }>`: a function returning an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [Configuration](#configuration)).\n\n- `getUnamedAccounts: () => Promise<string[]}>`: accounts which has no names, useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`: contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId(): Promise<string>`: offer an easy way to fetch the current chainId.\n\n## Configuration\n\n### namedAccounts (ability to name addresses)\n\nThis plugin extends the `HardhatConfig`'s object with an optional `namedAccounts` field.\n\n`namedAccounts` allows you to associate names to addresses and have them configured per chain.\nThis allows you to have meaningful names in your tests while the addresses match to multi sig in real network for example.\n\n```js\n{\n    namedAccounts: {\n        deployer: {\n            default: 0, // here this will by default take the first account as deployer\n            1: 0, // similarly on mainnet it will take the first account as deployer. Note though that depending on how hardhat network are configured, the account 0 on one network can be different than on another\n            4: '0xA296a3d5F026953e17F472B497eC29a5631FB51B', // but for rinkeby it will be a specific address\n            \"goerli\": '0x84b9514E013710b9dD0811c9Fe46b837a4A0d8E0', //it can also specify a specific netwotk name (specified in hardhat.config.js)\n        },\n        feeCollector:{\n            default: 1, // here this will by default take the second account as feeCollector (so in the test this will be a different account than the deployer)\n            1: '0xa5610E1f289DbDe94F3428A9df22E8B518f65751', // on the mainnet the feeCollector could be a multi sig\n            4: '0xa250ac77360d4e837a13628bC828a2aDf7BabfB3', // on rinkeby it could be another account\n        }\n    }\n}\n```\n\n### extra network's config\n\nhardhat-deploy add 2 new fields to `networks` configuration\n\n`live` : this is not used internally but is useful to perform action on a network whether it is a live network (rinkeby, mainnet, etc) or a temporary one (localhost, hardhat). The default is true (except for localhost and hardhat where the default is false).\n\n`saveDeployments`: this tell whether hardhat-deploy should save the deployments to disk or not. Default to true.\n\n`tags`: network can have tags to represent them. The config is an array and at runtime the hre.network.tags is an object whose fields (the tags) are set to true.\n\nThis is useful to conidtionaly operate on network based on their use case.\n\nExample:\n\n```js\n{\n  networks: {\n    localhost: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"local\"]\n    },\n    hardhat: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"test\", \"local\"]\n    },\n    rinkeby: {\n      live: true,\n      saveDeployments: true,\n      tags: [\"staging\"]\n    }\n  }\n}\n```\n\n### extra paths config\n\nIt also adds fields to `HardhatConfig`'s `ProjectPaths` object.\n\nHere is an example showing the default values :\n\n```js\n{\n    paths: {\n        deploy: 'deploy',\n        deployments: 'deployments',\n        imports: `imports`\n    }\n}\n```\n\nThe deploy folder is expected to contains the deploy script that are executed upon invocation of `hardhat deploy` or `hardhat node`\n\nThe deployment folder will contains the resulting deployments (contract addresses along their abi, bytecode, metadata...). One folder per network and one file per contract.\n\nThe imports folder is expected to contains artifacts that were pre-compiled. Useful if you want to upgrade to a new solidity version but want to keep using previously compiled contracts. The artifact is the same format as normal hardhat artifact, so you can easily copy them over, before switching to a new compiler version.\n\n### Importing deployment from other projects (truffle support too)\n\nIt also add the `external` field to `HardhatConfig`\n\nSuch fiels allows to specify paths for external artifacts or deployments. The use of the `paths` field is not possible because hardhat expects all paths field to be string. It does not accept arrays or objects, see https://github.com/nomiclabs/hardhat/issues/776.\n\nThe external object has 2 fields:\n\n```js\n{\n    external: {\n        artifacts: [\"node_modules/@cartesi/arbitration/build/contracts\"],\n        deployments: {\n          rinkeby: [\"node_modules/@cartesi/arbitration/build/contracts\"],\n        }\n    }\n}\n```\n\nThe artifacts fields specify an array of path to look for artifact. it support both hardhat and truffle artifacts.\n\nThe deployments fields specify an object whose field name are the hardhat network and the value is an array of path to look for deployments. It supports both hardhat-deploy and truffle formats.\n\n### Access to Artifacts (non-deployed contract code and abi)\n\nyou can access contract artifact via `getArtifact` function :\n\n```js\nconst { deployments } = require(\"hardhat\");\nconst artifact = await deployments.getArtifact(artifactName);\n```\n\nWith the `buidler-ethers-v5` plugin you can get your ethers contract via :\n\n```js\nconst { deployments, ethers } = require(\"hardhat\");\nconst factory = await ethers.getContractFactory(artifactName);\n```\n\nNote that the artifact file need to be either in `artifacts` folder that hardhat generate on compilation or in the `imports` folder where you can store contracts compiled elsewhere. They can also be present in the folder specified in `external.artifacts` see [Importing deployment from other projects](#importing-deployment-from-other-projects-truffle-support-too)\n\n## How to Deploy Contracts\n\n### The `deploy` Task\n\n`hardhat --network <networkName> deploy [options and flags]`\n\nThis is a new task that the plugin adds. As the name suggests it deploys contracts.\nTo be exact it will look for files in the folder `deploy` or whatever was configured in `paths.deploy`, see [paths config](#extra-paths-config)\n\nIt will scan for files in alphabetical order and execute them in turn.\n\n- it will `require` each of these files and execute the exported function with the HRE as argument\n\nNote that running `hardhat deploy` without specifying a network will use the default network. If the default network is an internal ganache or hardhat then nothing will happen as a result but this can be used to ensure the deployment is without issues.\n\nTo specified the network, you can use the builtin hardhat argument `--network <network name>` or set the env variable `HARDHAT_NETWORK`\n\n### Deploy Scripts\n\nThe deploy scripts need to be of the following type :\n\n```js\nexport interface DeployFunction {\n  (env: HardhatRuntimeEnvironment): Promise<void | boolean>;\n  skip?: (env: HardhatRuntimeEnvironment) => Promise<boolean>;\n  tags?: string[];\n  dependencies?: string[];\n  runAtTheEnd?: boolean;\n  id?: string;\n}\n```\n\nThe skip function can be used to skip executing the script under whatever condition. It simply need to resolve a promise to true.\n\nThe tags is a list of string that when the _deploy_ task is executed with, the script will be executed (unless it skips). In other word if the deploy task is executed with a tag that does not belong to that script, that script will not be executed unless it is a dependency of a script that does get executed.\n\nThe dependencies is a list of tag that will be executed if that script is executed. So if the script is executed, every script whose tag match any of the dependency will be executed first.\n\nThe `runAtTheEnd` is a boolean that if set to true, will queue that script to be executed after all other scripts are executed.\n\nThese set of fields allow more flexibility to organize the script. You are not limited to alphabetical order.\n\nFinally the function can return true if it wishes to never be executed again. This can be usfeul to emulate migration scripts that are meant to be executed only once. Once such script return true (async), the `id` field is used so to track execution and if that field is not present when the script return true, it will fails.\n\nIn any case, as a general advice every deploy function should be idempotent. This is so they can always recover from failure or pending transaction.\n\nThis is why the `hre.deployments.deploy` function will by default only deploy if the contract code has changed, making it easier to write idempotent script.\n\nAn example of a deploy script :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnamedAccounts\n}) => {\n  const { deploy } = deployments;\n  const { deployer } = await getNamedAccounts();\n\n  // the following will only deploy \"GenericMetaTxProcessor\" if the contract was never deployed or if the code changed since last deployment\n  await deploy(\"GenericMetaTxProcessor\", {\n    from: deployer,\n    gas: 4000000,\n    args: []\n  });\n};\n```\n\nAs you can see the HRE passed in has 4 new fields :\n\n- `getNamedAccounts` is a function that returns a promise to an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [`namedAccounts`](#namedaccounts)).\n\n- `getUnamedAccounts`: function that return a promise to an array of accounts (which were not used in `getNamedAccounts`), useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`, which contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId` which return a promise for the chainId\n\nThe deploynments field contains the `deploy` function taht allow you to deploy contract and save them. It contains a lot more functions though :\n\n### The `deployments` field\n\nThe deployments field contains several helpers function to deploy contract but also execute transaction.\n\n```js\ndeploy(name: string, options: DeployOptions): Promise<DeployResult>; // deploy a contract\ndiamond: { // deploy diamond based contract (see section below)\n  deploy(name: string, options: DiamondOptions): Promise<DeployResult>;\n};\ndeterministic( // return the determinsitic address as well as a function to deploy the contract, can pass the `salt` field in the option to use different salt\n      name: string,\n      options: Create2DeployOptions\n    ): Promise<{\n      address: Address;\n      deploy(): Promise<DeployResult>;\n    }>;\nfetchIfDifferent(name: string, options: DeployOptions): Promise<boolean>; // return true if new compiled code is different than deployed contract\nsave(name: string, deployment: DeploymentSubmission): Promise<void>; // low level save of deployment\nget(name: string): Promise<Deployment>; // fetch a deployment by name, throw if not existing\ngetOrNull(name: string): Promise<Deployment | null>; // fetch deployment by name, return null if not existing\nall(): Promise<{ [name: string]: Deployment }>; // return all deployments\ngetArtifact(name: string): Promise<Artifact>; // return a hardhat artifact (compiled contract without deployment)\nrun( // execute deployment scripts\n  tags?: string | string[],\n  options?: {\n    resetMemory?: boolean;\n    deletePreviousDeployments?: boolean;\n    writeDeploymentsToFiles?: boolean;\n    export?: string;\n    exportAll?: string;\n  }\n): Promise<{ [name: string]: Deployment }>;\nfixture(tags?: string | string[]): Promise<{ [name: string]: Deployment }>; // execute deployment as fixture for test // use evm_snapshot to revert back\ncreateFixture(func: FixtureFunc, id?: string): () => Promise<any>; // execute a function as fixture using evm_snaphost to revert back each time\nlog(...args: any[]): void; // log data only ig log enabled (disabled in test fixture)\nexecute( // execute function call on contract\n  name: string,\n  options: TxOptions,\n  methodName: string,\n  ...args: any[]\n): Promise<Receipt>;\nrawTx(tx: SimpleTx): Promise<Receipt>; // execute a simple transaction\nread( // make a read-only call to a contract\n  name: string,\n  options: CallOptions,\n  methodName: string,\n  ...args: any[]\n): Promise<any>;\nread(name: string, methodName: string, ...args: any[]): Promise<any>;\n```\n\n#### `deployments.deploy`\n\nThe deploy function as mentioned allow you to deploy a contract and save it under a specific name.\n\nThe deploy function expect 2 parameters: one for the name and one for the options\n\nSee below the full list of fields that the option parameter allows and requires:\n\n```js\nfrom: string; // address (or private key) that will perform the transaction. you can use `getNamedAccounts` to retrived the address you want by name.\ncontract?: // this is an optional field. If not specified it defaults to the contract with the same name as the first parameter\n  | string // this field can be either a string for the name of the contract\n  | { // or abi and bytecode\n      abi: ABI;\n      bytecode: string;\n      deployedBytecode?: string;\n    };\nargs?: any[]; // the list of argument for the constructor (or the upgrade function in case of proxy)\nskipIfAlreadyDeployed?: boolean; // if set it to true, will not attempt to deploy even if the contract deployed under the same name is different\nlog?: boolean; // if true, it will log the result of the deployment (address and gas used)\nlinkedData?: any; // This allow to associate any JSON data to the deployment. Useful for merkle tree data for example\nlibraries?: { [libraryName: string]: Address }; // This let you associate libraries to the deployed contract\nproxy?: boolean | string | ProxyOptions; // This options allow to consider yoru contract as a proxy (see below for more details)\n\n// here some common tx options :\ngasLimit?: string | number | BigNumber;\ngasPrice?: string | BigNumber;\nvalue?: string | BigNumber;\nnonce?: string | number | BigNumber;\n\nestimatedGasLimit?: string | number | BigNumber; // to speed up the estimation, it is possible to provide an upper gasLimit\nestimateGasExtra?: string | number | BigNumber; // this option allow you to add a gas buffer on top of the estimation\n\ndev_forceMine?: boolean; // this force a evm_mine to be executed. this is useful to speed deployment on test network that allow to specify a block delay (ganache for example). This option basically skip the delay by force mining.\ndeterministicDeployment? boolean | string; // if true, it will deploy the contract at a deterministic address based on bytecode and constuctor arguments. The address will be the same across all network. It use create2 opcode for that, if it is a string, the string will be used as the salt.\n```\n\n## Handling contract using libraries\n\nIn the deploy function, one of the `DeployOptions` that can be passed into the function is the `libraries` field.\n\nFirst, deploy the library using the `deploy` function, then when we deploy a contract that needs the the linked library, we can pass the deployed library name and address in as an argument to the `libraries` object.\n\n```js\nconst exampleLibrary = await deploy(\"ExampleLibary\", {\n    from: <deployer>\n});\n\n```\n\nExampleLibrary is now deployed to whatever network is in the context of the environment.\n\nFor example, if we are deploying on Rinkeby, this library will get deployed on rinkeby, and the `exampleLibrary` variable will be an deployment object that contains the abi as well as the deployed address for the contract.\n\nNow that the library is deployed, we can link it in our next deployed contract.\n\n```js\nconst example = await deploy(\"Example\", {\n    from: <deployer>\n    args: [\"This is an example string argument in the constructor for the 'Example' contract\"],\n    libraries: {\n        ExampleLibrary: exampleLibrary.address\n    }\n});\n\n```\n\nThis `libraries` object takes the name of the library, and its deployed address on the network. Multiple libraries can be passed into the `libraries` object.\n\n## Exporting Deployments\n\nApart from deployments saved in the `deployments` folder which contains all information available about the contract (compile time data + deployment data), `hardhat-deploy` allows you to export lightweight file.\n\nThese can be used for example to power your frontend with contract's address and abi.\n\nThis come into 2 flavors.\n\nThe first one is exported via the `--export <file>` option and follow the following format :\n\n```js\nexport interface Export {\n  chainId: string;\n  name: string;\n  contracts: { [name: string]: ContractExport };\n}\n```\n\nwhere name is the name of the network configuration chosen (see hardhat option `--network`)\n\nThe second one is exported via the `--export-all <file>` option and follow the following format :\n\n```js\nexport type MultiExport = {\n  [chainId: string]: { [name: string]: Export }\n};\n```\n\nAs you see the second format include the previous. While in most case you'll need the single export where your application will support only one network, there are case where your app would want to support multiple network at nonce. This second format allow for that.\n\nFurthermore as hardhat support multiple network configuration for the same network (rinkeby, mainnet...), the export-all format will contains each of them grouped by their chainId.\n\n## Deploying and Upgrading Proxies\n\nAs mentioned above, the deploy function can also deploy a contract through a proxy. It can be done without modification of the contract as long as it does not have a constructor (or constructor with zero arguments).\n\nThe Proxy is both ERC-1967 and ERC-173 Compliant\n\nCode can be found [here](solc_0.7/proxy/EIP173Proxy.sol)\n\nTo perform such proxy deployment, you just need to invoke the deploy function with the following options : `{..., proxy: true}`\n\nSee example :\n\n```js\nmodule.exports = async ({ getNamedAccounts, deployments, getChainId }) => {\n  const { deploy } = deployments;\n  const { deployer } = await getNamedAccounts();\n  await deploy(\"Greeter\", {\n    from: deployer,\n    proxy: true\n  });\n};\n```\n\nYou can also set it to `proxy: \"<upgradeMethodName>\"` in which case the function `<upgradeMethodName>` will be executed upon upgrade.\nthe `args` field will be then used for that function instead of the contructor. It is also possible to then have a constructor with the same arguments and have the proxy be disabled. It can be useful if you want to have your contract as upgradeable in a test network but be non-upgradeable on the mainnet. Further documentation need to written for that.\n\nSee example :\n\n```js\nmodule.exports = async ({ getNamedAccounts, deployments, getChainId }) => {\n  const { deploy } = deployments;\n  const { deployer } = await getNamedAccounts();\n  await deploy(\"Greeter\", {\n    from: deployer,\n    proxy: \"postUpgrade\",\n    args: [\"arg1\", 2, 3]\n  });\n};\n```\n\nThe proxy option can also be an object which can set the specific owner that the proxy is going to be managed by.\n\nSee example:\n\n```js\nmodule.exports = async ({ getNamedAccounts, deployments, getChainId }) => {\n  const { deploy } = deployments;\n  const { deployer, greeterOwner } = await getNamedAccounts();\n  await deploy(\"Greeter\", {\n    from: deployer,\n    proxy: {\n      owner: greeterOwner,\n      methodName: \"postUpgrade\"\n    },\n    args: [\"arg1\", 2, 3]\n  });\n};\n```\n\nNote that for the second invokation, this deployment will fails to upgrade the proxy as the `from` which is `deployer` is not the same as the proxy's owner : `greeterOwner`\n\nTo make it work, you have to create a new script that have for `from` field: `greeterOwner`. If such value is a a multi sig or an address not registered as part of hardhat signers, the tx will not be executed but instead an error will be throw, mentionning the tx data necessary to perform the upgrade.\n\n## Builtin-In Support For Diamonds (EIP2535)\n\nThe deployments field also expose the diamond field: `hre.deployments.diamond` that let you deploy [Diamonds](https://eips.ethereum.org/EIPS/eip-2535) in an easy way.\n\nInstead of specifying the facets to cut out or cut in, which the diamond contract expects, you specify the facets you want to end up having on the deployed contract.\n\n`diamond.deploy` expect the facet as names. The name represent the compiled contract name that going to be deployed as facet. In future version you ll be able to specify deployed contract or artifact object as facet.\n\nTo deploy a contract with 3 facet you can do as follow :\n\n```js\nmodule.exports = async ({ getNamedAccounts, deployments, getChainId }) => {\n  const { diamond } = deployments;\n  const { deployer, diamondAdmin } = await getNamedAccounts();\n  await diamond.deploy(\"ADiamondContract\", {\n    from: deployer,\n    owner: diamondAdmin,\n    facets: [\"Facet1\", \"Facet2\", \"Facet3\"]\n  });\n};\n```\n\nif you then later execute the following script:\n\n```js\nmodule.exports = async ({ getNamedAccounts, deployments, getChainId }) => {\n  const { diamond } = deployments;\n  const { deployer, diamondAdmin } = await getNamedAccounts();\n  await diamond.deploy(\"ADiamondContract\", {\n    from: diamondAdmin, // this need to be the diamondAdmin for upgrade\n    owner: diamondAdmin,\n    facets: [\"NewFacet\", \"Facet2\", \"Facet3\"]\n  });\n};\n```\n\nThen the NewFacet will be deployed automatically if needed and then the diamondCut will cut Facet1 out and add NewFacet.\n\nNote that if the code for Facet2 and Facet3 changes, they will also be redeployed automatically and the diamondCuts will replace the existing facets with these new ones.\n\nNote that The Diamond contract's code is part of hardhat-deploy and contains 3 built-in facet that can be removed manually if desired.\nThese facets are used for ownership, diamondCut and diamond loupe.\n\nThe implementation is the [reference implementation by Nick Mudge](https://github.com/mudgen/Diamond)\n\nLike normal proxies you can also execute a function at the time of an upgrade.\n\nThis is done by specifying the execute field in the diamond deploy options :\n\n```js\ndiamond.deploy(\"ADiamondContract\", {\n  from: deployer,\n  owner: diamondAdmin,\n  facets: [\"NewFacet\", \"Facet2\", \"Facet3\"],\n  execute: {\n    methodName: \"postUpgrade\",\n    args: [\"one\", 2, \"0x3\"]\n  }\n});\n```\n\nSince the diamond standard has no builtin mechanism to make the deployment of Diamond with function execution, the Diamond when deployed is actually deployed through a special contract, the `Diamantaire` (see code [here](solc_0.7/diamond/Diamantaire.sol)) that act as factory to build Diamond. It uses deterministic deployment for that so, it is transparently managed by hardhat-deploy.\n\nThe Diamantaire also support the deterministic deployment of Diamond.\nAn extra field can be passed to the Diamond deployment options : `deterministicSalt`. It has to be a non-zero 32bytes string (in hex format).\nNote that if you want to deploy 2 diamonds with same owner, you'll need 2 different deterministicSalt for them to be 2 separate contracts.\n\n## Testing Deployed Contracts\n\nYou can continue using the usual test task :\n\n`hardhat test`\n\nTests can then use the `hre.deployments.fixture` function to run the deployment for the test and snapshot it so that tests don't need to perform all the deployments transaction every time, they simply reuse the snapshot for every test (this leverages `evm_snapshot` and `evm_revert` provided by both `hardhat` and `ganache`). You can for example set them in a `beaforeEach`.\n\nHere is an example of a test :\n\n```js\nconst { deployments } = require(\"hardhat\");\n\ndescribe(\"Token\", () => {\n  beforeEach(async () => {\n    await deployments.fixture();\n  });\n  it(\"testing 1 2 3\", async function() {\n    const Token = await deployments.get(\"Token\"); // Token is available because the fixture was executed\n    console.log(Token.address);\n    const ERC721BidSale = await deployments.get(\"ERC721BidSale\");\n    console.log({ ERC721BidSale });\n  });\n});\n```\n\nIf the deployment scripts are complex, the first test could take while (as the fixture need to execute the deployment) but then from the second test onward, the deployments are never re-executed, instead the fixture will do `evm_revert` and test will run far faster.\n\nTests can also leverage named accounts for clearer test. Combined with `buidler-ethers-v5` plugin, you can write succint test :\n\n```js\nconst { ethers, getNamedAccounts } = require(\"hardhat\");\n\ndescribe(\"Token\", () => {\n  beforeEach(async () => {\n    await deployments.fixture();\n  });\n  it(\"testing 1 2 3\", async function() {\n    const { tokenOwner } = await getNamedAccounts();\n    const TokenContract = await ethers.getContract(\"Token\", tokenOwner);\n    await TokenContract.mint(2);\n  });\n});\n```\n\nFurthermore, tests can easily create efficient fixture using `deployments.createFixture`\n\nSee example :\n\n```js\nconst setupTest = deployments.createFixture(async ({deployments, getNamedAccounts, ethers}, options) => {\n  await deployments.fixture(); // ensure you start from a fresh deployments\n  const { tokenOwner } = await getNamedAccounts();\n  const TokenContract = await ethers.getContract(\"Token\", tokenOwner);\n  await TokenContract.mint(10); //this mint is executed once and then `createFixture` will ensure it is snapshotted\n  return {\n    tokenOwner: {\n      address: tokenOwner,\n      TokenContract\n    }\n  };\n};\ndescribe(\"Token\", () => {\n  it(\"testing 1 2 3\", async function() {\n    const {tokenOwner} = await setupTest()\n    await tokenOwner.TokenContract.mint(2);\n  });\n});\n```\n\nWhile this example is trivial, some fixture can requires several transaction and the ability to snapshot them automatically speed up the tests greatly.\n\n## More Information On Hardhat Tasks\n\n### node task\n\nas mentioned above, the node task is slighly modified and augmented with various flag and options\n\n`hardhat node`\n\nIn particulat It adds an argument `--export` that allows you to specify a destination file where the info about the contracts deployed is written.\nYour webapp can then access all contracts information.\n\n### test task\n\n`hardhat test`\n\nthe test task is augmented with one flag argument `--deploy-fixture` that allow to run all deployments in a fixture snapshot before executing the tests. This can speed up tests that use specific tags as the global fixture take precedence (unless specified).\n\nIn other word tests can use `deployments.fixture(<specific tag>)` where specific tag only deploy the minimal contracts under tests, while still benefiting from global deployment snapshot if used.\n\nIf a test need the deployments to only include the specific deployment specified by the tag, it can use the following :\n\n```js\ndeployments.fixture(\"<specific tag>\", { fallbackToGlobal: false });\n```\n\nDue to how snapshot/revert works in hardhat, this means that these test will not be able to benefit from the global fixture snapshot and will have to deploy their contract as part of the fixture call. This is automatix but means that these tests will run slower.\n\n### run task\n\n`hardhat --network <networkName> run <script>`\n\nThe run task act as before but thanks to the `hre.deployments` field it can access deployed contract :\n\n```js\nconst hre = require(\"hardhat\");\nconst { deployments, getNamedAccounts } = hre;\n\n(async () => {\n  console.log(await deployments.all());\n  console.log({ namedAccounts: await getNamedAccounts() });\n})();\n```\n\nYou can also run it directly from the command line as usual.\n\n`HARDHAT_NETWORK=rinkeby node <script>` is the equivalent except it does not load the hardhat environment twice (which the run task does)\n\n### console task\n\n`hardhat console`\n\nThe same applies to the `console` task.\n\n## Deploy Scripts: Tags And Dependencies\n\nIt is possible to execute only specific part of the deployments with `hardhat deploy --tags <tags>`\n\nTags represent what the deploy script acts on. In general it will be a single string value, the name of the contract it deploys or modifies.\n\nThen if another deploy script has such tag as a dependency, then when this latter deploy script has a specific tag and that tag is requested, the dependency will be executed first.\n\nHere is an example of two deploy scripts :\n\n```js\nmodule.exports = async ({ getNamedAccounts, deployments }) => {\n  const { deployIfDifferent, log } = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const { deployer } = namedAccounts;\n  const deployResult = await deploy(\"Token\", {\n    from: deployer,\n    args: [\"hello\", 100]\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Token deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = [\"Token\"];\n```\n\n```js\nmodule.exports = async function({ getNamedAccounts, deployments }) {\n  const { deployIfDifferent, log } = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const { deployer } = namedAccounts;\n  const Token = await deployments.get(\"Token\");\n  const deployResult = await deploy(\"Sale\", {\n    from: deployer,\n    contract: \"ERC721BidSale\",\n    args: [Token.address, 1, 3600]\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Sale deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = [\"Sale\"];\nmodule.exports.dependencies = [\"Token\"]; // this ensure the TOken script above is executed first, so `deployments.get('Token') succeeds\n```\n\nAs you can see the second one depends on the first. This is because the second script depends on a tag that the first script registers as using.\n\nWith that when `hardhat deploy --tags Sale` is executed\n\nthen both scripts will be run, ensuring Sale is ready.\n\nYou can also define the script to run after another script is run by setting `runAtTheEnd` to be true. For example:\n\n```js\nmodule.exports = async function({ getNamedAccounts, deployments }) {\n  const { deployIfDifferent, execute, log } = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const { deployer, admin } = namedAccounts;\n  await execute(\"Sale\", { from: deployer }, \"setAdmin\", admin);\n};\nmodule.exports.tags = [\"Sale\"];\nmodule.exports.runAtTheEnd = true;\n```\n\nTags can also be used in test with `deployments.fixture`. This allow you to test a subset of the deploy script.\n","readmeFilename":"README.md","gitHead":"d8d13474910c88af9da73076896acd4136da2306","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.3","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-KuTLZRQ0DFxoKauoqtXIF6EYPbJ81mDtBg40rJ9LP+q/n/wh5u2znI02n6HK2QdijmGgtClIT3w7GeHfD/k1UA==","shasum":"86c5b9c85b7cce8c54f89d5b2a7ae1f19fcfeebc","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.3.tgz","fileCount":68,"unpackedSize":787086,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfkbJnCRA9TVsSAnZWagAAUwoP/j+vGvUrx6N4HIj8PJ+a\ngUGvC49hx9I8Kn0MXaxL2RSUypOHxTykhvIXr724cVIA7rfQGiwuhq99rd9y\nUbv7oF9hin8R4JBn0/EMF9dU4bbsdhQPwCOQ/SDEdTVXcvecHmFc6U9Izwxj\nNQ2+XILYNalZh/Rb/mo0ABB0SzbQo+Efd8dMqjjUAIe/KZb0EDBj/XeejbGF\n8uEh9c49D5zrqWUhbwZL9l21o6FjRDMw77Gc0Me1KTcf5Ksmp+tFwuUwlpqo\nwj4Ols9V9rZ/mhOw4vUzVGx0FYlQ4E+f9Ny9u54ww55GY9/CrXdn9uBarCLq\n9JuOKYc4fiWeLaLFzLejQ0Qjfig1YdOuajy7A9LRCATJKCuNBadzOUH/rOw5\nqqytmoTdMdGylfl35JPXNeO5VGVDut5cMTQ0jYvUPnV+W/K22TjEuW+cgLPQ\nzJ7cS0P4dchfb9I5oaHplGAaSeTFStMq3PUE56/ycM56pieJOpkGzYo41r3R\n46UHTO0puFh4vDBTCEOksWlvE5xlqseXvt6Y733QEMMjRKVZApQfS+E1//o2\n/cN1F0uE5yrvU3BmJWpHfYPVaRpm5b5QZxPRaUBk8xRDq78bhDZtAIX7ynDV\nU70iIGNV9pfVjO8MQimuCECXoyUAoLTqK92Ag0A21zC+4TWASLFD7+juhQRL\no+nM\r\n=Agcq\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCzORVZwYmrgJFNGbSLvidWGwblH3/GLIYZg8tLA0LHVgIgPiUBA6wO8zMJTysqgyU5PlxbEC+u/qE8BbuZCPIHfWQ="}]},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.3_1603383910347_0.29480496573884496"},"_hasShrinkwrap":false},"0.7.0-beta.4":{"name":"hardhat-deploy","version":"0.7.0-beta.4","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","chai":"^4.2.0","dotenv":"^6.2.0","hardhat":"^2.0.0-rc.0","mocha":"^5.2.0","prettier":"^1.19.1","prettier-plugin-solidity":"^1.0.0-alpha.56","source-map-support":"^0.5.12","ts-node":"^8.1.0","tslint":"^5.16.0","tslint-config-prettier":"^1.18.0","tslint-plugin-prettier":"^2.0.1","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0-rc.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.0.0","chokidar":"^3.4.0","debug":"^4.1.1","fs-extra":"^9.0.0","match-all":"^1.2.6","qs":"^6.9.4"},"scripts":{"compile":"hardhat compile","lint:fix":"prettier --write src/**/*.{js,ts} test/**/*.{js,ts} && tslint --fix --config tslint.json --project tsconfig.json","lint":"tslint --config tslint.json --project tsconfig.json","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"62111aa58e2981c3ad4ebfb58cac28b326f3a7c9","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.4","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-KCiroRo4wge99aukkSzNpIBg8TGt5INxUHJhQVTNSOo5/wyMGdWkjP33z2rqsIsh3nyC3ZZL+9hk/hwE4LKMNA==","shasum":"135ce26b65d0de9a74e8c872d52b8943514fcc46","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.4.tgz","fileCount":68,"unpackedSize":787158,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfkcmYCRA9TVsSAnZWagAAZi8P/j+LOxXAakC1fqttCjUs\n1evQY45Vk1sjxrYBxq8OM4GY45T/D+leWQgj6ZJcHFtnHg8Sy0EGvv/QlgNc\ntqu2GHdMjZLea02nRGflIbxMij60U0bgnj3XXgvzk5HdtnTCDznZWKHUuFfG\njR/r3oZIxDMKWu5Da7Kb8CkJwrKyhJf6KDiC3+ZOJ5OM5l7YdLje6gxqB8qc\nCGZGXhcy4+/o2CB2B4e1eYtXM2/YzEWK8BOZx4H8u4uJn8zVc0bnzCKzzgfQ\nZ1gl2hp1uW+Z6aWrrd1g4ZyzFcuwrXYgpg/AKNcefnHRpJYTdsjaE5FDR7P4\n/FikK8KcoOFEhVXJALuFMfPSrda+1EJLrxhnh60go9t1GX8QtzR1lNKIrmiT\nVtaUkwQ2bE5m4TY3PQMNWh6K4Hm6Lw6P1VppcgJZbS294+TxqppwlGCET4ep\nRaQB4ZCKaqo9RG24mZlLOTOB/O8tLKUNVbaO0xzKJgoNbsvW2qyirFFQPh/3\noo/uLTa4GBlXPEJNN85qt64vpyz+Ky8fdAFsil+YJB/uUEz5kSbvKUT6oHDf\nJmUTeXofPxv2Zsd2mwF4Af3qzRhF4gwpqc0pkB/ZlQdql3yaXbp4iLyP3/18\nF11OJ/6CRl87Rb3j/ntJ1RxC4j5lKY38LsxYm8EBIECi9MG6whtAwjVqYWvv\nSids\r\n=YUUv\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDNJlz8XCnvdozHYOvv/qTwtCHjzSyoKSCZjqOiCCDGGgIgYKYEFDAVnzl7wbc2uR4udsuRhzQrQtdnJcl+l85X2CE="}]},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.4_1603389847605_0.23140754565208765"},"_hasShrinkwrap":false},"0.7.0-beta.5":{"name":"hardhat-deploy","version":"0.7.0-beta.5","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","chai":"^4.2.0","dotenv":"^6.2.0","hardhat":"^2.0.0-rc.0","mocha":"^5.2.0","prettier":"^1.19.1","prettier-plugin-solidity":"^1.0.0-alpha.56","source-map-support":"^0.5.12","ts-node":"^8.1.0","tslint":"^5.16.0","tslint-config-prettier":"^1.18.0","tslint-plugin-prettier":"^2.0.1","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0-rc.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.0.0","chokidar":"^3.4.0","debug":"^4.1.1","fs-extra":"^9.0.0","match-all":"^1.2.6","qs":"^6.9.4"},"scripts":{"compile":"hardhat compile","lint:fix":"prettier --write src/**/*.{js,ts} test/**/*.{js,ts} && tslint --fix --config tslint.json --project tsconfig.json","lint":"tslint --config tslint.json --project tsconfig.json","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"1612cd0db297bb2b11bd6c51226599449a909911","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.5","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-no7gTaWfN98EsUqW/5qqLzAHirE4WaNmyTGe4LL5Moldsa9KjCBOnlg6/NewUbd7wiqNFr+SMt1tvpEu77SvfQ==","shasum":"1f19f3ed3be55c3692973098f7fde93f5b52c224","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.5.tgz","fileCount":68,"unpackedSize":787194,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfkdkMCRA9TVsSAnZWagAA5lcP/R9TBXZRy+pDoioMKaA5\nGsbzOUqED3gEM6EL0gU/VnlJyuoaUA62VRXMypxi+oo4Plkj54DhRUyjm/1i\nJeDwRLbaEDVMOUGfT0rY0fFkq6jjD0kEWSYml9fo5CVY8Efsn3CTradz4RZH\nsfKDnoBVLhhYB+QbfbPWsc2i89OcLcfws53xDFPLXqwfL4Qtydubhym5ZxkV\nQDcHnTkHHvlS4VhD7pzFULCNbE9Oksygm/qpa96y+HoHawAvt+589FcTaCAl\nzbjeKow6w4MrZL99/uZ2BS17At9sp+aS2qeN8h0d8DchjCnP3YnCZNbnaUA5\nros0FlU+bQUbSutoD8MZXC5DSxqIGU9QdC3L9XnbqsQGCuZxoz5/hHpX2kR9\n4i2IOKIxhBdD2y2R13cCXZ7cqWY3Le5PZx7awNVPCVLQI9AmDZcj5kh18OKL\nzdKASzCCu593lx1hGo7uU8n5p/8h+bnIxhdkNGHPM17WFEJWASjIWfHwZTp9\nn/6RYvRISHt/9fnquOWjO3Jq7vDEyKQepU8S1bAjwPceG0HCyz+kGhadC0wT\nDL7oz6ds4cEam7eQ3alVzZO0sDFv8kS0mLuobHrOmm5jNEOxKfr7Tpxrmq/8\nHoFHALfTwCUQv1SVCqrdu5PHt02sD7SkmlqEHT3fJHKj6h1hb+CMDWrgqY4Z\n5CJ7\r\n=2nXo\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIHYjsirJ1jVHnIp1/GKGvuHRcM7o+1PXi1HGpOoFMZGoAiEAvpItF7itJFMw5NfnThU3xMIKqVuGhCW4MPI7+/PIQXQ="}]},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.5_1603393802999_0.4535261349229054"},"_hasShrinkwrap":false},"0.7.0-beta.6":{"name":"hardhat-deploy","version":"0.7.0-beta.6","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","chai":"^4.2.0","dotenv":"^6.2.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^1.19.1","prettier-plugin-solidity":"^1.0.0-alpha.56","source-map-support":"^0.5.12","ts-node":"^8.1.0","tslint":"^5.16.0","tslint-config-prettier":"^1.18.0","tslint-plugin-prettier":"^2.0.1","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0-rc.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.0.0","chokidar":"^3.4.0","debug":"^4.1.1","fs-extra":"^9.0.0","match-all":"^1.2.6","qs":"^6.9.4"},"scripts":{"compile":"hardhat compile","lint:fix":"prettier --write src/**/*.{js,ts} test/**/*.{js,ts} && tslint --fix --config tslint.json --project tsconfig.json","lint":"tslint --config tslint.json --project tsconfig.json","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"09d4a02dfe0061e0e0ffa7383faae338f42116a2","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.6","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-/2fd3j7IWLeRxGPwzbsUMN5TSvawCALHUOng++hWsmAt8kgevfMl4SMrBZWi48YulmWz/nJbgyLhPGuTUcDEQQ==","shasum":"fd5b39977454089a8e58e0bc569ff782731687eb","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.6.tgz","fileCount":68,"unpackedSize":787189,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfkeB3CRA9TVsSAnZWagAAjIwP/i956Nnk3NsTpOwzN7Hg\n1Ibs50Wg+hE0foMFYs7k2NUFdhrppQzWTY/EiGt8limAHxff7xCUXD1oxepC\nXodIed1wI/4rWp9721smaYwtwnxAvuystx3EvmCg5zN8HDjp1HVFVLVPQ891\nW4zloFetD2+xOEylTr6zHi1A3pLFCZv53W8cs+N4hSaPpuWsLKQGJN2Z6P5J\nO5JGElWUI7+M34RaftdUwUS6klgspvBGaXQncWOk1LoRp6gOtjYAi9c+wFmD\nB91QaTxGfsOpcuMw1aSrkoai3dX4HtXi4TMhq2ibRKL5IGOPI9qbimw2kSHA\nMi/K7roB1dZeNzi1H0LNhqBCN5hqugf8UeuAHkF/nkB0G9XHQ+VMMuyX4mkO\n03ioQ9hsSpw1cvHfD2Q6PbcmEniKFZsWj8CbpTl/C7vjQrxG7WXDXTjHiLTo\nVUIGCOdXEkJ15PXer5pEv1xb613KL3eA6H/5hCLgmOO823qqSeoCcOwLuol0\nErK6uhSq95pVIPk+HiNn1o4X7a5jBFgKkuSCgJr5HAOj4nNWcXI8qdfxVsSH\nEkjRh20NJYsohQ2Z0plBwjJZxzSFu8CfEnUPkKx3D8iT6elixId9QsTsRt8/\nzZewE+CRUH59Yl/k9snBEJhIbCWiZfajemo4FB7b1BnFZ/wj2TKB/mfglliY\n3r9m\r\n=Krnx\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDFtxOM5QEZG+okFuiuUNUuzrHuRn5sgMkUB0cBSJZP3QIhAJ+jZyWcOcBxG7aLhz4qvFNgHUERaqDg5BTeI33M5aP6"}]},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.6_1603395703308_0.1515019242144391"},"_hasShrinkwrap":false},"0.7.0-beta.7":{"name":"hardhat-deploy","version":"0.7.0-beta.7","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","chai":"^4.2.0","dotenv":"^6.2.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^1.19.1","prettier-plugin-solidity":"^1.0.0-alpha.56","source-map-support":"^0.5.12","ts-node":"^8.1.0","tslint":"^5.16.0","tslint-config-prettier":"^1.18.0","tslint-plugin-prettier":"^2.0.1","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0-rc.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.0.0","chokidar":"^3.4.0","debug":"^4.1.1","fs-extra":"^9.0.0","match-all":"^1.2.6","qs":"^6.9.4"},"scripts":{"compile":"hardhat compile","lint:fix":"prettier --write src/**/*.{js,ts} test/**/*.{js,ts} && tslint --fix --config tslint.json --project tsconfig.json","lint":"tslint --config tslint.json --project tsconfig.json","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"3f8c526d552aee58fe31f45a837dab8ce6484851","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.7","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-4z0eykLUARMNMeoVgwb+rXNv0WyjueC7f/XzLMEYE2+ggUYNxC6Rfc2XcEAss2az7K0Guv2Hvh1TIopJr3mGpQ==","shasum":"1c078db9df4fdffe50a2f96fb729069ff15955c9","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.7.tgz","fileCount":68,"unpackedSize":789581,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfkyd2CRA9TVsSAnZWagAAy+MP/2KPVsLVS7jRNXsxVeUg\nxo07fs1JX81rRPu3XbdVQcCufXjaceOYaLslf+6qWKk9i1NvqbkvERTKMFvC\nWWShOFGhJleWWdnZwCCqpv+b9uWTk0KDh6Jd+fLnRUoVtZp/dHNqFnZJoohB\ned6F+oFtShR/X6tV57fe2YXhNmhmaWPpR5yM3Oiz2QUVM5Jmkxeg0GU8dlm5\nTTvzH6BT2hph4LdAu06iW3Ad9sc4hHGANgp1ZTgIzqAt4DhHwqyRw4AH0exf\nBOOIcWg+0Jyxfj7NoUdeLAzhAXAdUZGj73CNzeHU/kmudDs0QOBxo2/4CrNV\nu3VGxLmRPuhJAVnpJzq3jyZbGYsUyrK6DHiez68fqkCwkKT1YRQVdqUR1GRq\nTkdzWzCNkW7MXI3KvZ/0xrZoP7hny1MGiSnwamh9JpxmhRXYcLTFChO03R21\n25fNd9rhoxNd5TKdtrvcEXWEHGny6ComfBLfsykkasqV8qxy6crLGiZfXpRN\nckHKVkDG3tVYJEKd8uOgQQWVFGtGurW6jzxncnzw/bFp3G0Ujctp5CVMC8nK\ncYtpc7Sx8HV5nImW/S5LkDZupxOevV9e/sP9igJSzYL4Y1cN7baRUOYYxv7z\nFBYHVK96Aj/oM1H1HTGKfWtlJufZU2Ofb0qcIpA+30QF/8eJXyR9g3NQWJXe\nZVzn\r\n=9LJP\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCEZz3MysewCruZ5bztTOT82gR7mNH/5S+xf93OAqPCBgIgAW9lk8kYmVX4lqzM8oAr5lE7u03YwQkr6umIeCAL6/c="}]},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.7_1603479413827_0.5840360549670478"},"_hasShrinkwrap":false},"0.7.0-beta.8":{"name":"hardhat-deploy","version":"0.7.0-beta.8","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","chai":"^4.2.0","dotenv":"^6.2.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^1.19.1","prettier-plugin-solidity":"^1.0.0-alpha.56","source-map-support":"^0.5.12","ts-node":"^8.1.0","tslint":"^5.16.0","tslint-config-prettier":"^1.18.0","tslint-plugin-prettier":"^2.0.1","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0-rc.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.0.0","chokidar":"^3.4.0","debug":"^4.1.1","fs-extra":"^9.0.0","match-all":"^1.2.6","qs":"^6.9.4"},"scripts":{"compile":"hardhat compile","lint:fix":"prettier --write src/**/*.{js,ts} test/**/*.{js,ts} && tslint --fix --config tslint.json --project tsconfig.json","lint":"tslint --config tslint.json --project tsconfig.json","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"61b195f0c2862d8275da70eb71910dcda91ee74a","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.8","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-k56RKihniapmc2TxASC4mfsR1Z1nFkb9r8E9kNjIPta5PkX3Ck+EUB7j0lD/KluIv/Jo4X9+uJZ3Juo2XKOX/A==","shasum":"89c42ce79ae7cd82889b31fbf534f2ef5f04b8e6","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.8.tgz","fileCount":68,"unpackedSize":789694,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfkyq0CRA9TVsSAnZWagAA83oP/iS1f1QrKq2dHDjQDqLF\nrc0xQFx6x8Hy/iyrKU+tE/pnSb3eA5bLm95tQX92o5sxfOtvh5iJHmnPc5dZ\nW1W9Y/Bk4ClWqoDR1M6ha9SESz3v0E3hx9nenCPACnwA++4aMaFO03Bal6J6\nN75O6pW9dCxnqiLOgDDVA+XteaWLi3dVQHZwdwZkEURpso7P3GAkEEs62RO5\nZf7YUHjVzu43A90HTVx6L2Tk61Aub+I1dFFDQRc0KqIAiN1lwL3huLS7xSKt\nYdKHrFGzWtaO/BiRr2S0cBWfiM83fEwn+UWXQBw0gbq0g38E3YeTFIiXKhOI\nwlk3siLFtexWSUGTTc/wR5w3IXKvxVOaEIpuGGGa1G9iyw4ePxwEGAxk6SHI\nEMcPZQ2aHF5DsNAL5j78Oj6Nz5rWfA4ENAqwtxk6AudwDwONBmK1PzX2ombK\neWOyH5KMCoIRwN6xxt2Gs9h3K2+qjAvPd73WlzP2IM4TdAt6hGeP/dd8inr+\nTLZM5WEIHyZ9qHyctl5CchvYEZe7eVO/pxUjixg8q6vs11dcT/IdighbpBry\nR0May/AxX/Kn+sS65x/yK79V6VPRcqjormfwRl0rtae4bSAngu5TVpGcFiIh\nCPYvcfcgHfFV5FObNRnt+LvC9ZpQTUvkznR8+MCFh5iHWtIvy2xpgePBglUN\nJMWB\r\n=y4L2\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCmfgsDVmHLqZzOtGoh1IB1M7/uh7B5Si1oKSh2GXwUNAIhAOCSP0juq80xzJ2QPpg5mOE/2bIuUtWq90YqjVq2ta1y"}]},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.8_1603480244114_0.8378570614274445"},"_hasShrinkwrap":false},"0.7.0-beta.9":{"name":"hardhat-deploy","version":"0.7.0-beta.9","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","eslint-plugin-prettier":"^3.1.4","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.0.0","chokidar":"^3.4.0","debug":"^4.1.1","fs-extra":"^9.0.0","match-all":"^1.2.6","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint:fix":"prettier --write solc*/**/*.sol && prettier --write src/**/*.{js,ts} test/**/*.{js,ts} && eslint --fix .","lint":"prettier --check solc*/**/*.sol && prettier --check src/**/*.{js,ts} test/**/*.{js,ts} && eslint .","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"df39fb84f8bed4894ba79ba410b71bc5172f0e9d","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.9","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-ypN3weQZvPF/96iBqHkDQCon+h8T/Zsxa9W+Zu4lvzeC5AptgnuJhhYrecF2bB/fko9jwit3OyS2/gcmE5KfXA==","shasum":"b81182f5ea3d74f3b0c4cba7dd448e899001e3c9","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.9.tgz","fileCount":68,"unpackedSize":788629,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJflGhyCRA9TVsSAnZWagAAXNYP/RcUifaYE3JP0iE0w6pV\nRFtOixfftjlQWIWTUaJavd3PWUvw+hsVPe7Mc4fT+yH+n/VR72Fo3DjHr2Uq\nh/AERDTcPsyOi5sFRWeioADJ5yBz4BVxNrl07c2yrdAoHk6tWmrVZlFfe/MS\nQhZFEPK8Ue8E+/vYrUpLRvGCxCdr1tgGHkLnvJY8mXpoKIV0PzYh/Eok0YZo\nSx0kIQVvGG9ro9rSV+sXoy/dBKJGVJ3y8uQN5gsA7avXRHTiUiu00F3AGn4B\nT+7n6wPv+JsSel3BZNs8SynCCHZdEcrmtuXD1N4XxW+2atjZ3pz9fgH4GvmC\n4WZvemY/XMuyTB3oAIdxp2xlH1buFwY6u59A4DmlQ8tZnBz3A8fJfmT5vdJZ\npADCYGESEIkUYHMtE5BT346ul9j1gdyGNg6uV69kAQF/2ywC41xHHcbA7eMI\nlekpF8AsY2zhmhGroEcPz885l73MXnFpl6o3IYGpRnOFHs8xipKVsAFSIReK\nnosaGnc3gV8i8djIkTam9uC6GuvSmlJHk36S1fQ3crAJiEz2h3PIbwCA3t+j\nUIdED5hLsdg5UOf0ywnMbouutBleTSXH2Su++lJNGrOPFiqF+x2vzaE8MuUG\nM0TaF+NsjEche9+WRbqeHnLCZPh5PhQGEb7KXBNEbGksTGvsDL8p4cTC9S49\ntpce\r\n=a+8G\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIEiFIZN+3aliJKI+kuMt34S3OLQ7phjjq6fHwcrk168sAiAIlnBOmjdWtQPjAicHyuiBN5hIbSYevGbwI1eT+uHjaA=="}]},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.9_1603561585848_0.24061002937289322"},"_hasShrinkwrap":false},"0.7.0-beta.10":{"name":"hardhat-deploy","version":"0.7.0-beta.10","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","eslint-plugin-prettier":"^3.1.4","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.0.0","chokidar":"^3.4.0","debug":"^4.1.1","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint:fix":"prettier --write solc*/**/*.sol && prettier --write src/**/*.{js,ts} test/**/*.{js,ts} && eslint --fix .","lint":"prettier --check solc*/**/*.sol && prettier --check src/**/*.{js,ts} test/**/*.{js,ts} && eslint .","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"readme":"[![hardhat](https://hardhat.org/hardhat-plugin-badge.svg?1)](https://hardhat.org)\n\n<h1> hardhat-deploy</h1>\n\n_A Hardhat Plugin For Replicable Deployments And Tests_\n\n[Hardhat](https://hardhat.org) Deployment And Test Plugin.\n\n- [What is it for ?](#what-is-it-for-)\n- [Installation](#installation)\n  - [npm install hardhat-deploy](#npm-install-hardhat-deploy)\n  - [TypeScript support](#typescript-support)\n  - [Migrating existing deployment to hardhat-deploy](#migrating-existing-deployment-to-hardhat-deploy)\n- [Hardhat Tasks Availabled/Updated](#hardhat-tasks-availabledupdated)\n  - [hardhat deploy](#hardhat-deploy)\n    - [Options](#options)\n    - [Flags](#flags)\n  - [hardhat node](#hardhat-node)\n  - [hardhat test](#hardhat-test)\n  - [hardhat etherscan-verify](#hardhat-etherscan-verify)\n    - [Options](#options-1)\n    - [Flags](#flags-1)\n  - [hardhat export](#hardhat-export)\n    - [Options](#options-2)\n- [Hardhat Environment Extensions](#hardhat-environment-extensions)\n- [Configuration](#configuration)\n  - [namedAccounts (ability to name addresses)](#namedaccounts-ability-to-name-addresses)\n  - [extra network's config](#extra-networks-config)\n  - [extra paths config](#extra-paths-config)\n  - [Importing deployment from other projects (truffle support too)](#importing-deployment-from-other-projects-truffle-support-too)\n  - [Access to Artifacts (non-deployed contract code and abi)](#access-to-artifacts-non-deployed-contract-code-and-abi)\n- [How to Deploy Contracts](#how-to-deploy-contracts)\n  - [The `deploy` Task](#the-deploy-task)\n  - [Deploy Scripts](#deploy-scripts)\n  - [The `deployments` field](#the-deployments-field)\n    - [`deployments.deploy`](#deploymentsdeploy)\n- [Handling contract using libraries](#handling-contract-using-libraries)\n- [Exporting Deployments](#exporting-deployments)\n- [Deploying and Upgrading Proxies](#deploying-and-upgrading-proxies)\n- [Builtin-In Support For Diamonds (EIP2535)](#builtin-in-support-for-diamonds-eip2535)\n- [Testing Deployed Contracts](#testing-deployed-contracts)\n- [More Information On Hardhat Tasks](#more-information-on-hardhat-tasks)\n  - [node task](#node-task)\n  - [test task](#test-task)\n  - [run task](#run-task)\n  - [console task](#console-task)\n- [Deploy Scripts: Tags And Dependencies](#deploy-scripts-tags-and-dependencies)\n\n## What is it for ?\n\nThis [hardhat](https://hardhat.dev) plugin adds a mechanism to deploy contracts to any network, keeping track of them and replicating the same environment for testing.\n\nIt also adds a mechanism to associate names to addresses so test and deployment scripts can be reconfigured by simply changing the address a name points to, allowing different configurations per network. This also results in much clearer tests and deployment scripts (no more `accounts[2]` in your code).\n\nThis plugin contains a lot more features too, all geared toward a better developer experience :\n\n- chain configuration export, listing deployed contract, their abi and address, usefull for webapps.\n- library linking at time of deployment\n- deterministic deployment across networks\n- ability to submit contract source to etherscan for verification. Because hardhat-deploy will save all necessary info, it can be executed at any time.\n- deployment dependency system (allowing you to only deploy what is needed).\n- deployment as migration so once a deployment is done, it can be set to never be executed again.\n- deployment retrying (by saving pending tx): so you can feel confident when making a deployment that you can always recover.\n- deployments as test fixture using `evm_snapshot` to speed up testing.\n- ability to create your own test fixture that automatically benefit from `evm_snapshot` to speed up tests using it.\n- combined with [hardhat-deploy-ethers](https://github.com/wighawag/hardhat-deploy-ethers) it has the ability to get ethers contract instance by name (like `await ethers.getContract(\"ContractName\")`).\n- importing previously compiled contract (possibly in different solidity compiler version).\n- importing artifact from external sources (like npm packages), including truffle support\n- importing deployments from external sources (like npm packages), including truffle support\n- ability to log information in `deploy` mode only (while in test the console remains clean).\n- contains helpers to read and execute transaction on deployed contract referring to them by name.\n- These helpers contains options to auto mine on dev environment like ganache (to speed up deployments).\n- save metadata of deployed contract so they can always be fully verified, via [sourcify](https://github.com/ethereum/sourcify) or [etherscan](https://etherscan.io).\n- proxy deployment with ability to upgrade them transparently, only if code changes.\n- diamond deployment with facets, allowing you to focus on what the new version will be. It will generate the diamondCut necessary to reach the new state.\n- watch and deploy: hardhat-deploy can watch both your deploy script and contract code and redeploy on changes.\n- HCR (Hot Contract Replacement): the watch feature combined with proxy or diamond, gives you an experience akin to frontend Hot Module Replacement: Once your contract change, the deployment is executed and your contract retain the same address and same state.\n\n## Installation\n\n### npm install hardhat-deploy\n\n```bash\nnpm install -D hardhat-deploy\n```\n\nAnd add the following statement to your `hardhat.config.js`:\n\n```js\nimport \"hardhat-deploy\";\n```\n\n### TypeScript support\n\nWith hardhad the tsconfig.json is optional.\n\nBut if you add folders to the `include` field in `tsconfig.json` you ll also need to include `hardhat.config.ts` like :\n\n`include\": [\"./hardhat.config.ts\", \"./scripts\", \"./deploy\", \"./test\"]`\n\nfor deploy script (see below) you can write them this way to benefit from typing :\n\n```\nimport {\n  HardhatRuntimeEnvironment,\n  DeployFunction,\n} from \"hardhat/types\";\n\nconst func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {\n  // code here\n};\nexport default func;\n```\n\nTODO update: See a full example of typescript usage here : https://github.com/wighawag/hardhat-deploy-ts-test\n\n### Migrating existing deployment to hardhat-deploy\n\nYou might want to switch your current deployment process to use hardhat-deploy. In that case you probably have some deployments saved elsewhere.\n\nIn order to port them to hardhat-deploy, you'll need to create one `.json` file per contract in the `deployments/<network>` folder (configurable via [paths config](#extra-paths-config)).\n\nThe network folder is simply the hardhat network name (as configured in hardhat.config.js) (accessible at runtime via `hre.network.name`).\nSuch folder need to have a file named `.chainId` containing the chainId as decimal.\n\nFor example for network named \"rinkeby\" (for the corresponding network) the file `deployments/rinkeby/.chainId` would be\n\n```\n4\n```\n\nNote, prior to hardhat 0.6 the chainId was appended to the folder name (expect for some known network name). This has changed and upgrading to 0.6 will require you to change the folder name and add the '.chainId' file.\n\nEach contract file must follow this type (as defined in [src/type-extensions.d.ts](src/type-extensions.d.ts)) :\n\n```ts\nexport interface Deployment {\n  abi: any[];\n  address: string;\n  receipt?: Receipt;\n  transactionHash?: string;\n  contractFilepath?: string;\n  contractName?: string;\n  history?: Deployment[];\n  args?: any[];\n  linkedData?: any;\n  metadata?: string;\n  bytecode?: string;\n  deployedBytecode?: string;\n  userdoc?: any;\n  devdoc?: any;\n  methodIdentifiers?: any;\n  diamondCut?: { address: string; sigs: string[] }[];\n  facets?: { address: string; sigs: string[] }[];\n  storageLayout?: any;\n}\n```\n\nAs you can see, only abi and address are mandatory. But having the other fields allow more feature. For example, metadata and args allow you to benefit from contract code verification.\n\nFor Receipt, the following type is expected:\n\n```ts\nexport type Receipt = {\n  from: string;\n  transactionHash: string;\n  blockHash: string;\n  blockNumber: number;\n  transactionIndex: number;\n  cumulativeGasUsed: string | number;\n  gasUsed: string | number;\n  contractAddress?: string;\n  to?: string;\n  logs?: Log[];\n  events?: any[];\n  logsBloom?: string;\n  byzantium?: boolean;\n  status?: number;\n  confirmations?: number;\n};\n```\n\nHere is an example:\n\nLet sey you have:\n\n- 2 Contract named Greeter and Registry deployed on rinkeby\n- 1 contract named Greeter on mainnet\n- 2 Contract named Greeter and Registry deployed on a network named rinkeby2\n\nYou would get the following folder structure:\n\n```\ndeployments/\n  mainnet/\n    .chainId\n    Greeter.json\n  rinkeby/\n    .chainId\n    Greeter.json\n    Registry.json\n  rinkeby2/\n    .chainId\n    Greeter.json\n    Registry.json\n```\n\nThe reason why hardhat-deploy save chainId in the `.chainId` file is both for\n\n- safety: so that if you were to change the network to point to a different chain, it would not attempt to read the wrong folder and assume that a contract has been deployed while it has not.\n- ability to know the chainId without requring to be connected to a node (and so not dependent on hardhat.config.js settings). Useful for `export` task.\n\n## Hardhat Tasks Availabled/Updated\n\n### hardhat deploy\n\nThis plugin adds the _deploy_ task to Hardhat.\n\nThis task will execute the scripts in the `deploy` folder and save the contract deployments to disk. These deployments are supposed to be saved for example in a git repository. This way they can be accessed later.\n\nWith the deployment saved, it allows you to deploy a contract only if changed were made.\n\nDeploy scripts (also called Deploy functions) can also perform aribtrary logic.\n\nFor further details on how to use it and write deploy script, see [section](#deploy-scripts) below.\n\n#### Options\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice to use by default for transactions executed via hardhat-deploy helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### Flags\n\n`--reset`: This flag reset the deployments from scratch. Previously deployed contract are not considered and deleted from disk.\n\n`--silent`: This flag remove hardhat-deploy log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n### hardhat node\n\nThis plugin modify the _node_ task so that it also execute the deployment script before exposing the server http RPC interface\n\nIt also add the same options as the _deploy_ task with the same functionality. It adds an extra flag:\n\n`--no-deploy` that discard all other options to revert to normal `hardhat node` behavior without any deployment being performed.\n\nNote that the deployments are saved as if the network name is `localhost`. This is because `hardhat node` is expected to be used as localhost: You can for example execute `hardhat --network localhost console` after `node` is running. Doing `builder --network hardhat console` would indeed not do anythong useful. It still take the configuration from `hardhat` in the hardhat.config.js file though.\n\n### hardhat test\n\nThis plugin add to the _test_ task a flag argument `--deploy-fixture` that run the global deployments fixture before the tests and snapshot it.\n\n### hardhat etherscan-verify\n\nThis plugin adds the _etherscan-verify_ task to Hardhat.\n\nThis task will submit the contract source and other info of all deployed contracts to allow etherscan to verify and record the sources.\n\nInstead of using the full solc input, this task will first attempt to send the minimal sources from the metadata.\nBut Etherscan sometime fails due to a bug in solidity compiler (https://github.com/ethereum/solidity/issues/9573). As such this task can fallback on full solc input (see option --solc-input). Note that if your contract was deployed with a previous version of hardhat-deploy, it might not contains the full information.\n\nThis task will also attempt to automatically find the SPDX license in the source.\n\nTo execute that task, you need to specifiy the network to run against :\n\n```\nhardhat --network mainnet etherscan-verify --api-key <apikey>\n```\n\n#### Options\n\n`--api-key <API_KEY>`: Etherscan API key. Optional as such api key can also be set by setting the environment variable : ETHERSCAN_API_KEY\n\n`--license <SPDX>`: specifiy the license to use (using SPDX id) or can be \"UNLICENSED\". Note that etherscan have limited support for licenses, see : https://etherscan.io/contract-license-types\n\n#### Flags\n\n`--solcInput`: allow the use of full solc-input as fallback. Note that the whole source folder will be included in the result of the verification on etherscan.\n\n`--force-license`: This flag force the use of the license specified by --license (useful if your inline SPDX are not compatible with etherscan list)\n\n### hardhat export\n\nThis plugin adds the _export_ task to Hardhat.\n\nThis task will export the contract deployed (saved in `deployments` folder) to a simple format containing only contract addresses and abi, useful for web apps.\n\nOne of the following options need to be set for this task to have any effects :\n\n#### Options\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\nThis last option has some limitations, when combined with the use of external deployments (see [Configuration](#configuration)). If such external deployments were using older version of hardhat-deploy or truffle, the chainId might be missing. In order for these to be exported, the hardhat network config need to explicity state the chainId in the `networks` config of `hardhat.config.js`.\n\n## Hardhat Environment Extensions\n\nThis plugin extends the Hardhat Runtime Environment by adding 4 fields:\n\n- `getNamedAccounts: () => Promise<{ [name: string]: string }>`: a function returning an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [Configuration](#configuration)).\n\n- `getUnamedAccounts: () => Promise<string[]}>`: accounts which has no names, useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`: contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId(): Promise<string>`: offer an easy way to fetch the current chainId.\n\n## Configuration\n\n### namedAccounts (ability to name addresses)\n\nThis plugin extends the `HardhatConfig`'s object with an optional `namedAccounts` field.\n\n`namedAccounts` allows you to associate names to addresses and have them configured per chain.\nThis allows you to have meaningful names in your tests while the addresses match to multi sig in real network for example.\n\n```js\n{\n    namedAccounts: {\n        deployer: {\n            default: 0, // here this will by default take the first account as deployer\n            1: 0, // similarly on mainnet it will take the first account as deployer. Note though that depending on how hardhat network are configured, the account 0 on one network can be different than on another\n            4: '0xA296a3d5F026953e17F472B497eC29a5631FB51B', // but for rinkeby it will be a specific address\n            \"goerli\": '0x84b9514E013710b9dD0811c9Fe46b837a4A0d8E0', //it can also specify a specific netwotk name (specified in hardhat.config.js)\n        },\n        feeCollector:{\n            default: 1, // here this will by default take the second account as feeCollector (so in the test this will be a different account than the deployer)\n            1: '0xa5610E1f289DbDe94F3428A9df22E8B518f65751', // on the mainnet the feeCollector could be a multi sig\n            4: '0xa250ac77360d4e837a13628bC828a2aDf7BabfB3', // on rinkeby it could be another account\n        }\n    }\n}\n```\n\n### extra network's config\n\nhardhat-deploy add 2 new fields to `networks` configuration\n\n`live` : this is not used internally but is useful to perform action on a network whether it is a live network (rinkeby, mainnet, etc) or a temporary one (localhost, hardhat). The default is true (except for localhost and hardhat where the default is false).\n\n`saveDeployments`: this tell whether hardhat-deploy should save the deployments to disk or not. Default to true.\n\n`tags`: network can have tags to represent them. The config is an array and at runtime the hre.network.tags is an object whose fields (the tags) are set to true.\n\nThis is useful to conidtionaly operate on network based on their use case.\n\nExample:\n\n```js\n{\n  networks: {\n    localhost: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"local\"]\n    },\n    hardhat: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"test\", \"local\"]\n    },\n    rinkeby: {\n      live: true,\n      saveDeployments: true,\n      tags: [\"staging\"]\n    }\n  }\n}\n```\n\n### extra paths config\n\nIt also adds fields to `HardhatConfig`'s `ProjectPaths` object.\n\nHere is an example showing the default values :\n\n```js\n{\n    paths: {\n        deploy: 'deploy',\n        deployments: 'deployments',\n        imports: `imports`\n    }\n}\n```\n\nThe deploy folder is expected to contains the deploy script that are executed upon invocation of `hardhat deploy` or `hardhat node`\n\nThe deployment folder will contains the resulting deployments (contract addresses along their abi, bytecode, metadata...). One folder per network and one file per contract.\n\nThe imports folder is expected to contains artifacts that were pre-compiled. Useful if you want to upgrade to a new solidity version but want to keep using previously compiled contracts. The artifact is the same format as normal hardhat artifact, so you can easily copy them over, before switching to a new compiler version.\n\n### Importing deployment from other projects (truffle support too)\n\nIt also add the `external` field to `HardhatConfig`\n\nSuch fiels allows to specify paths for external artifacts or deployments. The use of the `paths` field is not possible because hardhat expects all paths field to be string. It does not accept arrays or objects, see https://github.com/nomiclabs/hardhat/issues/776.\n\nThe external object has 3 fields:\n\n```js\n{\n    external: {\n        artifacts: [\"node_modules/@cartesi/arbitration/build/contracts\"],\n        deployments: {\n          rinkeby: [\"node_modules/@cartesi/arbitration/build/contracts\"],\n        },\n        deploy: [\"node_modules/somepackage/deploy\"]\n    }\n}\n```\n\nThe artifacts fields specify an array of path to look for artifact. it support both hardhat and truffle artifacts.\n\nThe deployments fields specify an object whose field name are the hardhat network and the value is an array of path to look for deployments. It supports both hardhat-deploy and truffle formats.\n\nThe deploy fields specify an array of path that deploy scripts to execute. This allow project to share the deployment procedure. A boon for developer aiming at integrating it as they can get the contracts to be deployed for testing locally.\n\n### Access to Artifacts (non-deployed contract code and abi)\n\nyou can access contract artifact via `getArtifact` function :\n\n```js\nconst { deployments } = require(\"hardhat\");\nconst artifact = await deployments.getArtifact(artifactName);\n```\n\nWith the `hardhat-deploy-ethers` plugin you can get your ethers contract via :\n\n```js\nconst { deployments, ethers } = require(\"hardhat\");\nconst factory = await ethers.getContractFactory(artifactName);\n```\n\nNote that the artifact file need to be either in `artifacts` folder that hardhat generate on compilation or in the `imports` folder where you can store contracts compiled elsewhere. They can also be present in the folder specified in `external.artifacts` see [Importing deployment from other projects](#importing-deployment-from-other-projects-truffle-support-too)\n\n## How to Deploy Contracts\n\n### The `deploy` Task\n\n`hardhat --network <networkName> deploy [options and flags]`\n\nThis is a new task that the plugin adds. As the name suggests it deploys contracts.\nTo be exact it will look for files in the folder `deploy` or whatever was configured in `paths.deploy`, see [paths config](#extra-paths-config)\n\nIt will scan for files in alphabetical order and execute them in turn.\n\n- it will `require` each of these files and execute the exported function with the HRE as argument\n\nNote that running `hardhat deploy` without specifying a network will use the default network. If the default network is an internal ganache or hardhat then nothing will happen as a result but this can be used to ensure the deployment is without issues.\n\nTo specified the network, you can use the builtin hardhat argument `--network <network name>` or set the env variable `HARDHAT_NETWORK`\n\n### Deploy Scripts\n\nThe deploy scripts need to be of the following type :\n\n```js\nexport interface DeployFunction {\n  (env: HardhatRuntimeEnvironment): Promise<void | boolean>;\n  skip?: (env: HardhatRuntimeEnvironment) => Promise<boolean>;\n  tags?: string[];\n  dependencies?: string[];\n  runAtTheEnd?: boolean;\n  id?: string;\n}\n```\n\nThe skip function can be used to skip executing the script under whatever condition. It simply need to resolve a promise to true.\n\nThe tags is a list of string that when the _deploy_ task is executed with, the script will be executed (unless it skips). In other word if the deploy task is executed with a tag that does not belong to that script, that script will not be executed unless it is a dependency of a script that does get executed.\n\nThe dependencies is a list of tag that will be executed if that script is executed. So if the script is executed, every script whose tag match any of the dependency will be executed first.\n\nThe `runAtTheEnd` is a boolean that if set to true, will queue that script to be executed after all other scripts are executed.\n\nThese set of fields allow more flexibility to organize the script. You are not limited to alphabetical order.\n\nFinally the function can return true if it wishes to never be executed again. This can be usfeul to emulate migration scripts that are meant to be executed only once. Once such script return true (async), the `id` field is used so to track execution and if that field is not present when the script return true, it will fails.\n\nIn any case, as a general advice every deploy function should be idempotent. This is so they can always recover from failure or pending transaction.\n\nThis is why the `hre.deployments.deploy` function will by default only deploy if the contract code has changed, making it easier to write idempotent script.\n\nAn example of a deploy script :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnamedAccounts\n}) => {\n  const { deploy } = deployments;\n  const { deployer } = await getNamedAccounts();\n\n  // the following will only deploy \"GenericMetaTxProcessor\" if the contract was never deployed or if the code changed since last deployment\n  await deploy(\"GenericMetaTxProcessor\", {\n    from: deployer,\n    gas: 4000000,\n    args: []\n  });\n};\n```\n\nAs you can see the HRE passed in has 4 new fields :\n\n- `getNamedAccounts` is a function that returns a promise to an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [`namedAccounts`](#namedaccounts)).\n\n- `getUnamedAccounts`: function that return a promise to an array of accounts (which were not used in `getNamedAccounts`), useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`, which contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId` which return a promise for the chainId\n\nThe deploynments field contains the `deploy` function taht allow you to deploy contract and save them. It contains a lot more functions though :\n\n### The `deployments` field\n\nThe deployments field contains several helpers function to deploy contract but also execute transaction.\n\n```js\ndeploy(name: string, options: DeployOptions): Promise<DeployResult>; // deploy a contract\ndiamond: { // deploy diamond based contract (see section below)\n  deploy(name: string, options: DiamondOptions): Promise<DeployResult>;\n};\ndeterministic( // return the determinsitic address as well as a function to deploy the contract, can pass the `salt` field in the option to use different salt\n      name: string,\n      options: Create2DeployOptions\n    ): Promise<{\n      address: Address;\n      deploy(): Promise<DeployResult>;\n    }>;\nfetchIfDifferent(name: string, options: DeployOptions): Promise<boolean>; // return true if new compiled code is different than deployed contract\nsave(name: string, deployment: DeploymentSubmission): Promise<void>; // low level save of deployment\nget(name: string): Promise<Deployment>; // fetch a deployment by name, throw if not existing\ngetOrNull(name: string): Promise<Deployment | null>; // fetch deployment by name, return null if not existing\nall(): Promise<{ [name: string]: Deployment }>; // return all deployments\ngetArtifact(name: string): Promise<Artifact>; // return a hardhat artifact (compiled contract without deployment)\nrun( // execute deployment scripts\n  tags?: string | string[],\n  options?: {\n    resetMemory?: boolean;\n    deletePreviousDeployments?: boolean;\n    writeDeploymentsToFiles?: boolean;\n    export?: string;\n    exportAll?: string;\n  }\n): Promise<{ [name: string]: Deployment }>;\nfixture(tags?: string | string[]): Promise<{ [name: string]: Deployment }>; // execute deployment as fixture for test // use evm_snapshot to revert back\ncreateFixture(func: FixtureFunc, id?: string): () => Promise<any>; // execute a function as fixture using evm_snaphost to revert back each time\nlog(...args: any[]): void; // log data only ig log enabled (disabled in test fixture)\nexecute( // execute function call on contract\n  name: string,\n  options: TxOptions,\n  methodName: string,\n  ...args: any[]\n): Promise<Receipt>;\nrawTx(tx: SimpleTx): Promise<Receipt>; // execute a simple transaction\nread( // make a read-only call to a contract\n  name: string,\n  options: CallOptions,\n  methodName: string,\n  ...args: any[]\n): Promise<any>;\nread(name: string, methodName: string, ...args: any[]): Promise<any>;\n```\n\n#### `deployments.deploy`\n\nThe deploy function as mentioned allow you to deploy a contract and save it under a specific name.\n\nThe deploy function expect 2 parameters: one for the name and one for the options\n\nSee below the full list of fields that the option parameter allows and requires:\n\n```js\nfrom: string; // address (or private key) that will perform the transaction. you can use `getNamedAccounts` to retrived the address you want by name.\ncontract?: // this is an optional field. If not specified it defaults to the contract with the same name as the first parameter\n  | string // this field can be either a string for the name of the contract\n  | { // or abi and bytecode\n      abi: ABI;\n      bytecode: string;\n      deployedBytecode?: string;\n    };\nargs?: any[]; // the list of argument for the constructor (or the upgrade function in case of proxy)\nskipIfAlreadyDeployed?: boolean; // if set it to true, will not attempt to deploy even if the contract deployed under the same name is different\nlog?: boolean; // if true, it will log the result of the deployment (address and gas used)\nlinkedData?: any; // This allow to associate any JSON data to the deployment. Useful for merkle tree data for example\nlibraries?: { [libraryName: string]: Address }; // This let you associate libraries to the deployed contract\nproxy?: boolean | string | ProxyOptions; // This options allow to consider yoru contract as a proxy (see below for more details)\n\n// here some common tx options :\ngasLimit?: string | number | BigNumber;\ngasPrice?: string | BigNumber;\nvalue?: string | BigNumber;\nnonce?: string | number | BigNumber;\n\nestimatedGasLimit?: string | number | BigNumber; // to speed up the estimation, it is possible to provide an upper gasLimit\nestimateGasExtra?: string | number | BigNumber; // this option allow you to add a gas buffer on top of the estimation\n\ndev_forceMine?: boolean; // this force a evm_mine to be executed. this is useful to speed deployment on test network that allow to specify a block delay (ganache for example). This option basically skip the delay by force mining.\ndeterministicDeployment? boolean | string; // if true, it will deploy the contract at a deterministic address based on bytecode and constuctor arguments. The address will be the same across all network. It use create2 opcode for that, if it is a string, the string will be used as the salt.\n```\n\n## Handling contract using libraries\n\nIn the deploy function, one of the `DeployOptions` that can be passed into the function is the `libraries` field.\n\nFirst, deploy the library using the `deploy` function, then when we deploy a contract that needs the the linked library, we can pass the deployed library name and address in as an argument to the `libraries` object.\n\n```js\nconst exampleLibrary = await deploy(\"ExampleLibary\", {\n    from: <deployer>\n});\n\n```\n\nExampleLibrary is now deployed to whatever network is in the context of the environment.\n\nFor example, if we are deploying on Rinkeby, this library will get deployed on rinkeby, and the `exampleLibrary` variable will be an deployment object that contains the abi as well as the deployed address for the contract.\n\nNow that the library is deployed, we can link it in our next deployed contract.\n\n```js\nconst example = await deploy(\"Example\", {\n    from: <deployer>\n    args: [\"This is an example string argument in the constructor for the 'Example' contract\"],\n    libraries: {\n        ExampleLibrary: exampleLibrary.address\n    }\n});\n\n```\n\nThis `libraries` object takes the name of the library, and its deployed address on the network. Multiple libraries can be passed into the `libraries` object.\n\n## Exporting Deployments\n\nApart from deployments saved in the `deployments` folder which contains all information available about the contract (compile time data + deployment data), `hardhat-deploy` allows you to export lightweight file.\n\nThese can be used for example to power your frontend with contract's address and abi.\n\nThis come into 2 flavors.\n\nThe first one is exported via the `--export <file>` option and follow the following format :\n\n```js\nexport interface Export {\n  chainId: string;\n  name: string;\n  contracts: { [name: string]: ContractExport };\n}\n```\n\nwhere name is the name of the network configuration chosen (see hardhat option `--network`)\n\nThe second one is exported via the `--export-all <file>` option and follow the following format :\n\n```js\nexport type MultiExport = {\n  [chainId: string]: { [name: string]: Export }\n};\n```\n\nAs you see the second format include the previous. While in most case you'll need the single export where your application will support only one network, there are case where your app would want to support multiple network at nonce. This second format allow for that.\n\nFurthermore as hardhat support multiple network configuration for the same network (rinkeby, mainnet...), the export-all format will contains each of them grouped by their chainId.\n\n## Deploying and Upgrading Proxies\n\nAs mentioned above, the deploy function can also deploy a contract through a proxy. It can be done without modification of the contract as long as it does not have a constructor (or constructor with zero arguments).\n\nThe Proxy is both ERC-1967 and ERC-173 Compliant\n\nCode can be found [here](solc_0.7/proxy/EIP173Proxy.sol)\n\nTo perform such proxy deployment, you just need to invoke the deploy function with the following options : `{..., proxy: true}`\n\nSee example :\n\n```js\nmodule.exports = async ({ getNamedAccounts, deployments, getChainId }) => {\n  const { deploy } = deployments;\n  const { deployer } = await getNamedAccounts();\n  await deploy(\"Greeter\", {\n    from: deployer,\n    proxy: true\n  });\n};\n```\n\nYou can also set it to `proxy: \"<upgradeMethodName>\"` in which case the function `<upgradeMethodName>` will be executed upon upgrade.\nthe `args` field will be then used for that function instead of the contructor. It is also possible to then have a constructor with the same arguments and have the proxy be disabled. It can be useful if you want to have your contract as upgradeable in a test network but be non-upgradeable on the mainnet. Further documentation need to written for that.\n\nSee example :\n\n```js\nmodule.exports = async ({ getNamedAccounts, deployments, getChainId }) => {\n  const { deploy } = deployments;\n  const { deployer } = await getNamedAccounts();\n  await deploy(\"Greeter\", {\n    from: deployer,\n    proxy: \"postUpgrade\",\n    args: [\"arg1\", 2, 3]\n  });\n};\n```\n\nThe proxy option can also be an object which can set the specific owner that the proxy is going to be managed by.\n\nSee example:\n\n```js\nmodule.exports = async ({ getNamedAccounts, deployments, getChainId }) => {\n  const { deploy } = deployments;\n  const { deployer, greeterOwner } = await getNamedAccounts();\n  await deploy(\"Greeter\", {\n    from: deployer,\n    proxy: {\n      owner: greeterOwner,\n      methodName: \"postUpgrade\"\n    },\n    args: [\"arg1\", 2, 3]\n  });\n};\n```\n\nNote that for the second invokation, this deployment will fails to upgrade the proxy as the `from` which is `deployer` is not the same as the proxy's owner : `greeterOwner`\n\nTo make it work, you have to create a new script that have for `from` field: `greeterOwner`. If such value is a a multi sig or an address not registered as part of hardhat signers, the tx will not be executed but instead an error will be throw, mentionning the tx data necessary to perform the upgrade.\n\n## Builtin-In Support For Diamonds (EIP2535)\n\nThe deployments field also expose the diamond field: `hre.deployments.diamond` that let you deploy [Diamonds](https://eips.ethereum.org/EIPS/eip-2535) in an easy way.\n\nInstead of specifying the facets to cut out or cut in, which the diamond contract expects, you specify the facets you want to end up having on the deployed contract.\n\n`diamond.deploy` expect the facet as names. The name represent the compiled contract name that going to be deployed as facet. In future version you ll be able to specify deployed contract or artifact object as facet.\n\nTo deploy a contract with 3 facet you can do as follow :\n\n```js\nmodule.exports = async ({ getNamedAccounts, deployments, getChainId }) => {\n  const { diamond } = deployments;\n  const { deployer, diamondAdmin } = await getNamedAccounts();\n  await diamond.deploy(\"ADiamondContract\", {\n    from: deployer,\n    owner: diamondAdmin,\n    facets: [\"Facet1\", \"Facet2\", \"Facet3\"]\n  });\n};\n```\n\nif you then later execute the following script:\n\n```js\nmodule.exports = async ({ getNamedAccounts, deployments, getChainId }) => {\n  const { diamond } = deployments;\n  const { deployer, diamondAdmin } = await getNamedAccounts();\n  await diamond.deploy(\"ADiamondContract\", {\n    from: diamondAdmin, // this need to be the diamondAdmin for upgrade\n    owner: diamondAdmin,\n    facets: [\"NewFacet\", \"Facet2\", \"Facet3\"]\n  });\n};\n```\n\nThen the NewFacet will be deployed automatically if needed and then the diamondCut will cut Facet1 out and add NewFacet.\n\nNote that if the code for Facet2 and Facet3 changes, they will also be redeployed automatically and the diamondCuts will replace the existing facets with these new ones.\n\nNote that The Diamond contract's code is part of hardhat-deploy and contains 3 built-in facet that can be removed manually if desired.\nThese facets are used for ownership, diamondCut and diamond loupe.\n\nThe implementation is the [reference implementation by Nick Mudge](https://github.com/mudgen/Diamond)\n\nLike normal proxies you can also execute a function at the time of an upgrade.\n\nThis is done by specifying the execute field in the diamond deploy options :\n\n```js\ndiamond.deploy(\"ADiamondContract\", {\n  from: deployer,\n  owner: diamondAdmin,\n  facets: [\"NewFacet\", \"Facet2\", \"Facet3\"],\n  execute: {\n    methodName: \"postUpgrade\",\n    args: [\"one\", 2, \"0x3\"]\n  }\n});\n```\n\nSince the diamond standard has no builtin mechanism to make the deployment of Diamond with function execution, the Diamond when deployed is actually deployed through a special contract, the `Diamantaire` (see code [here](solc_0.7/diamond/Diamantaire.sol)) that act as factory to build Diamond. It uses deterministic deployment for that so, it is transparently managed by hardhat-deploy.\n\nThe Diamantaire also support the deterministic deployment of Diamond.\nAn extra field can be passed to the Diamond deployment options : `deterministicSalt`. It has to be a non-zero 32bytes string (in hex format).\nNote that if you want to deploy 2 diamonds with same owner, you'll need 2 different deterministicSalt for them to be 2 separate contracts.\n\n## Testing Deployed Contracts\n\nYou can continue using the usual test task :\n\n`hardhat test`\n\nTests can then use the `hre.deployments.fixture` function to run the deployment for the test and snapshot it so that tests don't need to perform all the deployments transaction every time, they simply reuse the snapshot for every test (this leverages `evm_snapshot` and `evm_revert` provided by both `hardhat` and `ganache`). You can for example set them in a `beaforeEach`.\n\nHere is an example of a test :\n\n```js\nconst { deployments } = require(\"hardhat\");\n\ndescribe(\"Token\", () => {\n  beforeEach(async () => {\n    await deployments.fixture();\n  });\n  it(\"testing 1 2 3\", async function() {\n    const Token = await deployments.get(\"Token\"); // Token is available because the fixture was executed\n    console.log(Token.address);\n    const ERC721BidSale = await deployments.get(\"ERC721BidSale\");\n    console.log({ ERC721BidSale });\n  });\n});\n```\n\nIf the deployment scripts are complex, the first test could take while (as the fixture need to execute the deployment) but then from the second test onward, the deployments are never re-executed, instead the fixture will do `evm_revert` and test will run far faster.\n\nTests can also leverage named accounts for clearer test. Combined with `hardhat-deploy-ethers` plugin, you can write succint test :\n\n```js\nconst { ethers, getNamedAccounts } = require(\"hardhat\");\n\ndescribe(\"Token\", () => {\n  beforeEach(async () => {\n    await deployments.fixture();\n  });\n  it(\"testing 1 2 3\", async function() {\n    const { tokenOwner } = await getNamedAccounts();\n    const TokenContract = await ethers.getContract(\"Token\", tokenOwner);\n    await TokenContract.mint(2);\n  });\n});\n```\n\nFurthermore, tests can easily create efficient fixture using `deployments.createFixture`\n\nSee example :\n\n```js\nconst setupTest = deployments.createFixture(async ({deployments, getNamedAccounts, ethers}, options) => {\n  await deployments.fixture(); // ensure you start from a fresh deployments\n  const { tokenOwner } = await getNamedAccounts();\n  const TokenContract = await ethers.getContract(\"Token\", tokenOwner);\n  await TokenContract.mint(10); //this mint is executed once and then `createFixture` will ensure it is snapshotted\n  return {\n    tokenOwner: {\n      address: tokenOwner,\n      TokenContract\n    }\n  };\n};\ndescribe(\"Token\", () => {\n  it(\"testing 1 2 3\", async function() {\n    const {tokenOwner} = await setupTest()\n    await tokenOwner.TokenContract.mint(2);\n  });\n});\n```\n\nWhile this example is trivial, some fixture can requires several transaction and the ability to snapshot them automatically speed up the tests greatly.\n\n## More Information On Hardhat Tasks\n\n### node task\n\nas mentioned above, the node task is slighly modified and augmented with various flag and options\n\n`hardhat node`\n\nIn particulat It adds an argument `--export` that allows you to specify a destination file where the info about the contracts deployed is written.\nYour webapp can then access all contracts information.\n\n### test task\n\n`hardhat test`\n\nthe test task is augmented with one flag argument `--deploy-fixture` that allow to run all deployments in a fixture snapshot before executing the tests. This can speed up tests that use specific tags as the global fixture take precedence (unless specified).\n\nIn other word tests can use `deployments.fixture(<specific tag>)` where specific tag only deploy the minimal contracts under tests, while still benefiting from global deployment snapshot if used.\n\nIf a test need the deployments to only include the specific deployment specified by the tag, it can use the following :\n\n```js\ndeployments.fixture(\"<specific tag>\", { fallbackToGlobal: false });\n```\n\nDue to how snapshot/revert works in hardhat, this means that these test will not be able to benefit from the global fixture snapshot and will have to deploy their contract as part of the fixture call. This is automatix but means that these tests will run slower.\n\n### run task\n\n`hardhat --network <networkName> run <script>`\n\nThe run task act as before but thanks to the `hre.deployments` field it can access deployed contract :\n\n```js\nconst hre = require(\"hardhat\");\nconst { deployments, getNamedAccounts } = hre;\n\n(async () => {\n  console.log(await deployments.all());\n  console.log({ namedAccounts: await getNamedAccounts() });\n})();\n```\n\nYou can also run it directly from the command line as usual.\n\n`HARDHAT_NETWORK=rinkeby node <script>` is the equivalent except it does not load the hardhat environment twice (which the run task does)\n\n### console task\n\n`hardhat console`\n\nThe same applies to the `console` task.\n\n## Deploy Scripts: Tags And Dependencies\n\nIt is possible to execute only specific part of the deployments with `hardhat deploy --tags <tags>`\n\nTags represent what the deploy script acts on. In general it will be a single string value, the name of the contract it deploys or modifies.\n\nThen if another deploy script has such tag as a dependency, then when this latter deploy script has a specific tag and that tag is requested, the dependency will be executed first.\n\nHere is an example of two deploy scripts :\n\n```js\nmodule.exports = async ({ getNamedAccounts, deployments }) => {\n  const { deployIfDifferent, log } = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const { deployer } = namedAccounts;\n  const deployResult = await deploy(\"Token\", {\n    from: deployer,\n    args: [\"hello\", 100]\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Token deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = [\"Token\"];\n```\n\n```js\nmodule.exports = async function({ getNamedAccounts, deployments }) {\n  const { deployIfDifferent, log } = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const { deployer } = namedAccounts;\n  const Token = await deployments.get(\"Token\");\n  const deployResult = await deploy(\"Sale\", {\n    from: deployer,\n    contract: \"ERC721BidSale\",\n    args: [Token.address, 1, 3600]\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Sale deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = [\"Sale\"];\nmodule.exports.dependencies = [\"Token\"]; // this ensure the TOken script above is executed first, so `deployments.get('Token') succeeds\n```\n\nAs you can see the second one depends on the first. This is because the second script depends on a tag that the first script registers as using.\n\nWith that when `hardhat deploy --tags Sale` is executed\n\nthen both scripts will be run, ensuring Sale is ready.\n\nYou can also define the script to run after another script is run by setting `runAtTheEnd` to be true. For example:\n\n```js\nmodule.exports = async function({ getNamedAccounts, deployments }) {\n  const { deployIfDifferent, execute, log } = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const { deployer, admin } = namedAccounts;\n  await execute(\"Sale\", { from: deployer }, \"setAdmin\", admin);\n};\nmodule.exports.tags = [\"Sale\"];\nmodule.exports.runAtTheEnd = true;\n```\n\nTags can also be used in test with `deployments.fixture`. This allow you to test a subset of the deploy script.\n","readmeFilename":"README.md","gitHead":"0ca265150e7634b630f459c7d6d90da077e804db","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.10","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-T2BCQP6MOLVCYJbgbpHwzAsub0gy7aIEoqn9yHU2Rf/t7Qe7oBeXWLjWNH7/8IJJbUOqSZLu1KWaiN5jOr3nFA==","shasum":"4f1c90cb49f8d514811c35d1601ac10aa30ce575","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.10.tgz","fileCount":82,"unpackedSize":2221701,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJflUFyCRA9TVsSAnZWagAANFgP/jwJTCIJSs64PnpKxaVz\nfqOWXIghJ6cHE6bFvdSnmA12wKjPzJ5vXxoXIM/gq/NSddpgEV7AZbEKOXp3\ntYCIg/+PfsAjSQRvu9xpI4duvlpnRjPDvnr0ycvawFPE5Dq2bb4i14Tmjufu\nCIhIQTQMMNTrzs7c++Ob4eKpoThL0coqktuOpciMzMChEk1N3TnSDm+5fA3T\nqusKq19rzLCO4aBEvpnHs4uPBZs8uPzI2R+625qDXE9FlSU+WlwLwvEkUOiZ\ntxRXivS2c7oUto/Ylg/5yOm0jDDYS4uvBypxGCovaidknWYK2TdLbdUqiH0t\n0kawFghOtpAo87bVffa06+hWb3Je6K0x8JC21bmVDgzTeycgQiZo+eP8ermY\nWpdGZs1OUZCsLcWBOs1mGeApf5MYU9rvr8sPX21zgGIHLulvxQ17xEmcBEHs\ncIiN43LQH8/KmzPM5oGaAFor1u2Yw30uGCfid8drXVXWO+RMiU5DaB8smBsn\nocHl2kuKTWcmIITNF8jxFOLjcviMcUZi5LPOJxqeig9Xbk3VdmLjrREttnKg\n4kVG0O5VUrOVsz4Cun5TQGc/GGEqM3kgXmkBombd7Iaf4CKj0Z0Gu3Tmn3gu\ns8kmzIvz6+q5Vf36SFZ/RFvkz4WMCOEZDCJWrovJRhtw27XNUlr6nlxfZW9D\n4iWf\r\n=Il+u\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIFx4JU5EFlou+0Symp2zAxvExouN8+6MXMf//EoUlaz1AiEAjGIhqmqxqSBUSfBFSdqtUU4dN07xcJQQ2PbTL66AIzc="}]},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.10_1603617138178_0.20113250479197142"},"_hasShrinkwrap":false},"0.7.0-beta.11":{"name":"hardhat-deploy","version":"0.7.0-beta.11","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","eslint-plugin-prettier":"^3.1.4","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.0.0","chokidar":"^3.4.0","debug":"^4.1.1","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint:fix":"prettier --write solc*/**/*.sol && prettier --write src/**/*.{js,ts} test/**/*.{js,ts} && eslint --fix .","lint":"prettier --check solc*/**/*.sol && prettier --check src/**/*.{js,ts} test/**/*.{js,ts} && eslint .","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"readme":"[![hardhat](https://hardhat.org/hardhat-plugin-badge.svg?1)](https://hardhat.org)\n\n<h1> hardhat-deploy</h1>\n\n_A Hardhat Plugin For Replicable Deployments And Tests_\n\n[Hardhat](https://hardhat.org) Deployment And Test Plugin.\n\n- [What is it for ?](#what-is-it-for-)\n- [Installation](#installation)\n  - [npm install hardhat-deploy](#npm-install-hardhat-deploy)\n  - [TypeScript support](#typescript-support)\n  - [Migrating existing deployment to hardhat-deploy](#migrating-existing-deployment-to-hardhat-deploy)\n- [Hardhat Tasks Availabled/Updated](#hardhat-tasks-availabledupdated)\n  - [hardhat deploy](#hardhat-deploy)\n    - [Options](#options)\n    - [Flags](#flags)\n  - [hardhat node](#hardhat-node)\n  - [hardhat test](#hardhat-test)\n  - [hardhat etherscan-verify](#hardhat-etherscan-verify)\n    - [Options](#options-1)\n    - [Flags](#flags-1)\n  - [hardhat export](#hardhat-export)\n    - [Options](#options-2)\n- [Hardhat Environment Extensions](#hardhat-environment-extensions)\n- [Configuration](#configuration)\n  - [namedAccounts (ability to name addresses)](#namedaccounts-ability-to-name-addresses)\n  - [extra network's config](#extra-networks-config)\n  - [extra paths config](#extra-paths-config)\n  - [Importing deployment from other projects (truffle support too)](#importing-deployment-from-other-projects-truffle-support-too)\n  - [Access to Artifacts (non-deployed contract code and abi)](#access-to-artifacts-non-deployed-contract-code-and-abi)\n- [How to Deploy Contracts](#how-to-deploy-contracts)\n  - [The `deploy` Task](#the-deploy-task)\n  - [Deploy Scripts](#deploy-scripts)\n  - [The `deployments` field](#the-deployments-field)\n    - [`deployments.deploy`](#deploymentsdeploy)\n- [Handling contract using libraries](#handling-contract-using-libraries)\n- [Exporting Deployments](#exporting-deployments)\n- [Deploying and Upgrading Proxies](#deploying-and-upgrading-proxies)\n- [Builtin-In Support For Diamonds (EIP2535)](#builtin-in-support-for-diamonds-eip2535)\n- [Testing Deployed Contracts](#testing-deployed-contracts)\n- [More Information On Hardhat Tasks](#more-information-on-hardhat-tasks)\n  - [node task](#node-task)\n  - [test task](#test-task)\n  - [run task](#run-task)\n  - [console task](#console-task)\n- [Deploy Scripts: Tags And Dependencies](#deploy-scripts-tags-and-dependencies)\n\n## What is it for ?\n\nThis [hardhat](https://hardhat.dev) plugin adds a mechanism to deploy contracts to any network, keeping track of them and replicating the same environment for testing.\n\nIt also adds a mechanism to associate names to addresses so test and deployment scripts can be reconfigured by simply changing the address a name points to, allowing different configurations per network. This also results in much clearer tests and deployment scripts (no more `accounts[2]` in your code).\n\nThis plugin contains a lot more features too, all geared toward a better developer experience :\n\n- chain configuration export, listing deployed contract, their abi and address, usefull for webapps.\n- library linking at time of deployment\n- deterministic deployment across networks\n- ability to submit contract source to etherscan for verification. Because hardhat-deploy will save all necessary info, it can be executed at any time.\n- deployment dependency system (allowing you to only deploy what is needed).\n- deployment as migration so once a deployment is done, it can be set to never be executed again.\n- deployment retrying (by saving pending tx): so you can feel confident when making a deployment that you can always recover.\n- deployments as test fixture using `evm_snapshot` to speed up testing.\n- ability to create your own test fixture that automatically benefit from `evm_snapshot` to speed up tests using it.\n- combined with [hardhat-deploy-ethers](https://github.com/wighawag/hardhat-deploy-ethers) it has the ability to get ethers contract instance by name (like `await ethers.getContract(\"ContractName\")`).\n- importing previously compiled contract (possibly in different solidity compiler version).\n- importing artifact from external sources (like npm packages), including truffle support\n- importing deployments from external sources (like npm packages), including truffle support\n- ability to log information in `deploy` mode only (while in test the console remains clean).\n- contains helpers to read and execute transaction on deployed contract referring to them by name.\n- These helpers contains options to auto mine on dev environment like ganache (to speed up deployments).\n- save metadata of deployed contract so they can always be fully verified, via [sourcify](https://github.com/ethereum/sourcify) or [etherscan](https://etherscan.io).\n- proxy deployment with ability to upgrade them transparently, only if code changes.\n- diamond deployment with facets, allowing you to focus on what the new version will be. It will generate the diamondCut necessary to reach the new state.\n- watch and deploy: hardhat-deploy can watch both your deploy script and contract code and redeploy on changes.\n- HCR (Hot Contract Replacement): the watch feature combined with proxy or diamond, gives you an experience akin to frontend Hot Module Replacement: Once your contract change, the deployment is executed and your contract retain the same address and same state.\n\n## Installation\n\n### npm install hardhat-deploy\n\n```bash\nnpm install -D hardhat-deploy\n```\n\nAnd add the following statement to your `hardhat.config.js`:\n\n```js\nimport \"hardhat-deploy\";\n```\n\n### TypeScript support\n\nWith hardhad the tsconfig.json is optional.\n\nBut if you add folders to the `include` field in `tsconfig.json` you ll also need to include `hardhat.config.ts` like :\n\n`include\": [\"./hardhat.config.ts\", \"./scripts\", \"./deploy\", \"./test\"]`\n\nfor deploy script (see below) you can write them this way to benefit from typing :\n\n```\nimport {\n  HardhatRuntimeEnvironment,\n  DeployFunction,\n} from \"hardhat/types\";\n\nconst func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {\n  // code here\n};\nexport default func;\n```\n\nTODO update: See a full example of typescript usage here : https://github.com/wighawag/hardhat-deploy-ts-test\n\n### Migrating existing deployment to hardhat-deploy\n\nYou might want to switch your current deployment process to use hardhat-deploy. In that case you probably have some deployments saved elsewhere.\n\nIn order to port them to hardhat-deploy, you'll need to create one `.json` file per contract in the `deployments/<network>` folder (configurable via [paths config](#extra-paths-config)).\n\nThe network folder is simply the hardhat network name (as configured in hardhat.config.js) (accessible at runtime via `hre.network.name`).\nSuch folder need to have a file named `.chainId` containing the chainId as decimal.\n\nFor example for network named \"rinkeby\" (for the corresponding network) the file `deployments/rinkeby/.chainId` would be\n\n```\n4\n```\n\nNote, prior to hardhat 0.6 the chainId was appended to the folder name (expect for some known network name). This has changed and upgrading to 0.6 will require you to change the folder name and add the '.chainId' file.\n\nEach contract file must follow this type (as defined in [src/type-extensions.d.ts](src/type-extensions.d.ts)) :\n\n```ts\nexport interface Deployment {\n  abi: any[];\n  address: string;\n  receipt?: Receipt;\n  transactionHash?: string;\n  contractFilepath?: string;\n  contractName?: string;\n  history?: Deployment[];\n  args?: any[];\n  linkedData?: any;\n  metadata?: string;\n  bytecode?: string;\n  deployedBytecode?: string;\n  userdoc?: any;\n  devdoc?: any;\n  methodIdentifiers?: any;\n  diamondCut?: { address: string; sigs: string[] }[];\n  facets?: { address: string; sigs: string[] }[];\n  storageLayout?: any;\n}\n```\n\nAs you can see, only abi and address are mandatory. But having the other fields allow more feature. For example, metadata and args allow you to benefit from contract code verification.\n\nFor Receipt, the following type is expected:\n\n```ts\nexport type Receipt = {\n  from: string;\n  transactionHash: string;\n  blockHash: string;\n  blockNumber: number;\n  transactionIndex: number;\n  cumulativeGasUsed: string | number;\n  gasUsed: string | number;\n  contractAddress?: string;\n  to?: string;\n  logs?: Log[];\n  events?: any[];\n  logsBloom?: string;\n  byzantium?: boolean;\n  status?: number;\n  confirmations?: number;\n};\n```\n\nHere is an example:\n\nLet sey you have:\n\n- 2 Contract named Greeter and Registry deployed on rinkeby\n- 1 contract named Greeter on mainnet\n- 2 Contract named Greeter and Registry deployed on a network named rinkeby2\n\nYou would get the following folder structure:\n\n```\ndeployments/\n  mainnet/\n    .chainId\n    Greeter.json\n  rinkeby/\n    .chainId\n    Greeter.json\n    Registry.json\n  rinkeby2/\n    .chainId\n    Greeter.json\n    Registry.json\n```\n\nThe reason why hardhat-deploy save chainId in the `.chainId` file is both for\n\n- safety: so that if you were to change the network to point to a different chain, it would not attempt to read the wrong folder and assume that a contract has been deployed while it has not.\n- ability to know the chainId without requring to be connected to a node (and so not dependent on hardhat.config.js settings). Useful for `export` task.\n\n## Hardhat Tasks Availabled/Updated\n\n### hardhat deploy\n\nThis plugin adds the _deploy_ task to Hardhat.\n\nThis task will execute the scripts in the `deploy` folder and save the contract deployments to disk. These deployments are supposed to be saved for example in a git repository. This way they can be accessed later.\n\nWith the deployment saved, it allows you to deploy a contract only if changed were made.\n\nDeploy scripts (also called Deploy functions) can also perform aribtrary logic.\n\nFor further details on how to use it and write deploy script, see [section](#deploy-scripts) below.\n\n#### Options\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice to use by default for transactions executed via hardhat-deploy helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### Flags\n\n`--reset`: This flag reset the deployments from scratch. Previously deployed contract are not considered and deleted from disk.\n\n`--silent`: This flag remove hardhat-deploy log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n### hardhat node\n\nThis plugin modify the _node_ task so that it also execute the deployment script before exposing the server http RPC interface\n\nIt also add the same options as the _deploy_ task with the same functionality. It adds an extra flag:\n\n`--no-deploy` that discard all other options to revert to normal `hardhat node` behavior without any deployment being performed.\n\nNote that the deployments are saved as if the network name is `localhost`. This is because `hardhat node` is expected to be used as localhost: You can for example execute `hardhat --network localhost console` after `node` is running. Doing `builder --network hardhat console` would indeed not do anythong useful. It still take the configuration from `hardhat` in the hardhat.config.js file though.\n\n### hardhat test\n\nThis plugin add to the _test_ task a flag argument `--deploy-fixture` that run the global deployments fixture before the tests and snapshot it.\n\n### hardhat etherscan-verify\n\nThis plugin adds the _etherscan-verify_ task to Hardhat.\n\nThis task will submit the contract source and other info of all deployed contracts to allow etherscan to verify and record the sources.\n\nInstead of using the full solc input, this task will first attempt to send the minimal sources from the metadata.\nBut Etherscan sometime fails due to a bug in solidity compiler (https://github.com/ethereum/solidity/issues/9573). As such this task can fallback on full solc input (see option --solc-input). Note that if your contract was deployed with a previous version of hardhat-deploy, it might not contains the full information.\n\nThis task will also attempt to automatically find the SPDX license in the source.\n\nTo execute that task, you need to specifiy the network to run against :\n\n```\nhardhat --network mainnet etherscan-verify --api-key <apikey>\n```\n\n#### Options\n\n`--api-key <API_KEY>`: Etherscan API key. Optional as such api key can also be set by setting the environment variable : ETHERSCAN_API_KEY\n\n`--license <SPDX>`: specifiy the license to use (using SPDX id) or can be \"UNLICENSED\". Note that etherscan have limited support for licenses, see : https://etherscan.io/contract-license-types\n\n#### Flags\n\n`--solcInput`: allow the use of full solc-input as fallback. Note that the whole source folder will be included in the result of the verification on etherscan.\n\n`--force-license`: This flag force the use of the license specified by --license (useful if your inline SPDX are not compatible with etherscan list)\n\n### hardhat export\n\nThis plugin adds the _export_ task to Hardhat.\n\nThis task will export the contract deployed (saved in `deployments` folder) to a simple format containing only contract addresses and abi, useful for web apps.\n\nOne of the following options need to be set for this task to have any effects :\n\n#### Options\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\nThis last option has some limitations, when combined with the use of external deployments (see [Configuration](#configuration)). If such external deployments were using older version of hardhat-deploy or truffle, the chainId might be missing. In order for these to be exported, the hardhat network config need to explicity state the chainId in the `networks` config of `hardhat.config.js`.\n\n## Hardhat Environment Extensions\n\nThis plugin extends the Hardhat Runtime Environment by adding 4 fields:\n\n- `getNamedAccounts: () => Promise<{ [name: string]: string }>`: a function returning an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [Configuration](#configuration)).\n\n- `getUnamedAccounts: () => Promise<string[]}>`: accounts which has no names, useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`: contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId(): Promise<string>`: offer an easy way to fetch the current chainId.\n\n## Configuration\n\n### namedAccounts (ability to name addresses)\n\nThis plugin extends the `HardhatConfig`'s object with an optional `namedAccounts` field.\n\n`namedAccounts` allows you to associate names to addresses and have them configured per chain.\nThis allows you to have meaningful names in your tests while the addresses match to multi sig in real network for example.\n\n```js\n{\n    namedAccounts: {\n        deployer: {\n            default: 0, // here this will by default take the first account as deployer\n            1: 0, // similarly on mainnet it will take the first account as deployer. Note though that depending on how hardhat network are configured, the account 0 on one network can be different than on another\n            4: '0xA296a3d5F026953e17F472B497eC29a5631FB51B', // but for rinkeby it will be a specific address\n            \"goerli\": '0x84b9514E013710b9dD0811c9Fe46b837a4A0d8E0', //it can also specify a specific netwotk name (specified in hardhat.config.js)\n        },\n        feeCollector:{\n            default: 1, // here this will by default take the second account as feeCollector (so in the test this will be a different account than the deployer)\n            1: '0xa5610E1f289DbDe94F3428A9df22E8B518f65751', // on the mainnet the feeCollector could be a multi sig\n            4: '0xa250ac77360d4e837a13628bC828a2aDf7BabfB3', // on rinkeby it could be another account\n        }\n    }\n}\n```\n\n### extra network's config\n\nhardhat-deploy add 2 new fields to `networks` configuration\n\n`live` : this is not used internally but is useful to perform action on a network whether it is a live network (rinkeby, mainnet, etc) or a temporary one (localhost, hardhat). The default is true (except for localhost and hardhat where the default is false).\n\n`saveDeployments`: this tell whether hardhat-deploy should save the deployments to disk or not. Default to true.\n\n`tags`: network can have tags to represent them. The config is an array and at runtime the hre.network.tags is an object whose fields (the tags) are set to true.\n\nThis is useful to conidtionaly operate on network based on their use case.\n\nExample:\n\n```js\n{\n  networks: {\n    localhost: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"local\"]\n    },\n    hardhat: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"test\", \"local\"]\n    },\n    rinkeby: {\n      live: true,\n      saveDeployments: true,\n      tags: [\"staging\"]\n    }\n  }\n}\n```\n\n### extra paths config\n\nIt also adds fields to `HardhatConfig`'s `ProjectPaths` object.\n\nHere is an example showing the default values :\n\n```js\n{\n    paths: {\n        deploy: 'deploy',\n        deployments: 'deployments',\n        imports: `imports`\n    }\n}\n```\n\nThe deploy folder is expected to contains the deploy script that are executed upon invocation of `hardhat deploy` or `hardhat node`\n\nThe deployment folder will contains the resulting deployments (contract addresses along their abi, bytecode, metadata...). One folder per network and one file per contract.\n\nThe imports folder is expected to contains artifacts that were pre-compiled. Useful if you want to upgrade to a new solidity version but want to keep using previously compiled contracts. The artifact is the same format as normal hardhat artifact, so you can easily copy them over, before switching to a new compiler version.\n\n### Importing deployment from other projects (truffle support too)\n\nIt also add the `external` field to `HardhatConfig`\n\nSuch fiels allows to specify paths for external artifacts or deployments. The use of the `paths` field is not possible because hardhat expects all paths field to be string. It does not accept arrays or objects, see https://github.com/nomiclabs/hardhat/issues/776.\n\nThe external object has 3 fields:\n\n```js\n{\n    external: {\n        artifacts: [\"node_modules/@cartesi/arbitration/build/contracts\"],\n        deployments: {\n          rinkeby: [\"node_modules/@cartesi/arbitration/build/contracts\"],\n        },\n        deploy: [\"node_modules/somepackage/deploy\"]\n    }\n}\n```\n\nThe artifacts fields specify an array of path to look for artifact. it support both hardhat and truffle artifacts.\n\nThe deployments fields specify an object whose field name are the hardhat network and the value is an array of path to look for deployments. It supports both hardhat-deploy and truffle formats.\n\nThe deploy fields specify an array of path that deploy scripts to execute. This allow project to share the deployment procedure. A boon for developer aiming at integrating it as they can get the contracts to be deployed for testing locally.\n\n### Access to Artifacts (non-deployed contract code and abi)\n\nyou can access contract artifact via `getArtifact` function :\n\n```js\nconst { deployments } = require(\"hardhat\");\nconst artifact = await deployments.getArtifact(artifactName);\n```\n\nWith the `hardhat-deploy-ethers` plugin you can get your ethers contract via :\n\n```js\nconst { deployments, ethers } = require(\"hardhat\");\nconst factory = await ethers.getContractFactory(artifactName);\n```\n\nNote that the artifact file need to be either in `artifacts` folder that hardhat generate on compilation or in the `imports` folder where you can store contracts compiled elsewhere. They can also be present in the folder specified in `external.artifacts` see [Importing deployment from other projects](#importing-deployment-from-other-projects-truffle-support-too)\n\n## How to Deploy Contracts\n\n### The `deploy` Task\n\n`hardhat --network <networkName> deploy [options and flags]`\n\nThis is a new task that the plugin adds. As the name suggests it deploys contracts.\nTo be exact it will look for files in the folder `deploy` or whatever was configured in `paths.deploy`, see [paths config](#extra-paths-config)\n\nIt will scan for files in alphabetical order and execute them in turn.\n\n- it will `require` each of these files and execute the exported function with the HRE as argument\n\nNote that running `hardhat deploy` without specifying a network will use the default network. If the default network is an internal ganache or hardhat then nothing will happen as a result but this can be used to ensure the deployment is without issues.\n\nTo specified the network, you can use the builtin hardhat argument `--network <network name>` or set the env variable `HARDHAT_NETWORK`\n\n### Deploy Scripts\n\nThe deploy scripts need to be of the following type :\n\n```js\nexport interface DeployFunction {\n  (env: HardhatRuntimeEnvironment): Promise<void | boolean>;\n  skip?: (env: HardhatRuntimeEnvironment) => Promise<boolean>;\n  tags?: string[];\n  dependencies?: string[];\n  runAtTheEnd?: boolean;\n  id?: string;\n}\n```\n\nThe skip function can be used to skip executing the script under whatever condition. It simply need to resolve a promise to true.\n\nThe tags is a list of string that when the _deploy_ task is executed with, the script will be executed (unless it skips). In other word if the deploy task is executed with a tag that does not belong to that script, that script will not be executed unless it is a dependency of a script that does get executed.\n\nThe dependencies is a list of tag that will be executed if that script is executed. So if the script is executed, every script whose tag match any of the dependency will be executed first.\n\nThe `runAtTheEnd` is a boolean that if set to true, will queue that script to be executed after all other scripts are executed.\n\nThese set of fields allow more flexibility to organize the script. You are not limited to alphabetical order.\n\nFinally the function can return true if it wishes to never be executed again. This can be usfeul to emulate migration scripts that are meant to be executed only once. Once such script return true (async), the `id` field is used so to track execution and if that field is not present when the script return true, it will fails.\n\nIn any case, as a general advice every deploy function should be idempotent. This is so they can always recover from failure or pending transaction.\n\nThis is why the `hre.deployments.deploy` function will by default only deploy if the contract code has changed, making it easier to write idempotent script.\n\nAn example of a deploy script :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnamedAccounts\n}) => {\n  const { deploy } = deployments;\n  const { deployer } = await getNamedAccounts();\n\n  // the following will only deploy \"GenericMetaTxProcessor\" if the contract was never deployed or if the code changed since last deployment\n  await deploy(\"GenericMetaTxProcessor\", {\n    from: deployer,\n    gas: 4000000,\n    args: []\n  });\n};\n```\n\nAs you can see the HRE passed in has 4 new fields :\n\n- `getNamedAccounts` is a function that returns a promise to an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [`namedAccounts`](#namedaccounts)).\n\n- `getUnamedAccounts`: function that return a promise to an array of accounts (which were not used in `getNamedAccounts`), useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`, which contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId` which return a promise for the chainId\n\nThe deploynments field contains the `deploy` function taht allow you to deploy contract and save them. It contains a lot more functions though :\n\n### The `deployments` field\n\nThe deployments field contains several helpers function to deploy contract but also execute transaction.\n\n```js\ndeploy(name: string, options: DeployOptions): Promise<DeployResult>; // deploy a contract\ndiamond: { // deploy diamond based contract (see section below)\n  deploy(name: string, options: DiamondOptions): Promise<DeployResult>;\n};\ndeterministic( // return the determinsitic address as well as a function to deploy the contract, can pass the `salt` field in the option to use different salt\n      name: string,\n      options: Create2DeployOptions\n    ): Promise<{\n      address: Address;\n      deploy(): Promise<DeployResult>;\n    }>;\nfetchIfDifferent(name: string, options: DeployOptions): Promise<boolean>; // return true if new compiled code is different than deployed contract\nsave(name: string, deployment: DeploymentSubmission): Promise<void>; // low level save of deployment\nget(name: string): Promise<Deployment>; // fetch a deployment by name, throw if not existing\ngetOrNull(name: string): Promise<Deployment | null>; // fetch deployment by name, return null if not existing\nall(): Promise<{ [name: string]: Deployment }>; // return all deployments\ngetArtifact(name: string): Promise<Artifact>; // return a hardhat artifact (compiled contract without deployment)\nrun( // execute deployment scripts\n  tags?: string | string[],\n  options?: {\n    resetMemory?: boolean;\n    deletePreviousDeployments?: boolean;\n    writeDeploymentsToFiles?: boolean;\n    export?: string;\n    exportAll?: string;\n  }\n): Promise<{ [name: string]: Deployment }>;\nfixture(tags?: string | string[]): Promise<{ [name: string]: Deployment }>; // execute deployment as fixture for test // use evm_snapshot to revert back\ncreateFixture(func: FixtureFunc, id?: string): () => Promise<any>; // execute a function as fixture using evm_snaphost to revert back each time\nlog(...args: any[]): void; // log data only ig log enabled (disabled in test fixture)\nexecute( // execute function call on contract\n  name: string,\n  options: TxOptions,\n  methodName: string,\n  ...args: any[]\n): Promise<Receipt>;\nrawTx(tx: SimpleTx): Promise<Receipt>; // execute a simple transaction\nread( // make a read-only call to a contract\n  name: string,\n  options: CallOptions,\n  methodName: string,\n  ...args: any[]\n): Promise<any>;\nread(name: string, methodName: string, ...args: any[]): Promise<any>;\n```\n\n#### `deployments.deploy`\n\nThe deploy function as mentioned allow you to deploy a contract and save it under a specific name.\n\nThe deploy function expect 2 parameters: one for the name and one for the options\n\nSee below the full list of fields that the option parameter allows and requires:\n\n```js\nfrom: string; // address (or private key) that will perform the transaction. you can use `getNamedAccounts` to retrived the address you want by name.\ncontract?: // this is an optional field. If not specified it defaults to the contract with the same name as the first parameter\n  | string // this field can be either a string for the name of the contract\n  | { // or abi and bytecode\n      abi: ABI;\n      bytecode: string;\n      deployedBytecode?: string;\n    };\nargs?: any[]; // the list of argument for the constructor (or the upgrade function in case of proxy)\nskipIfAlreadyDeployed?: boolean; // if set it to true, will not attempt to deploy even if the contract deployed under the same name is different\nlog?: boolean; // if true, it will log the result of the deployment (address and gas used)\nlinkedData?: any; // This allow to associate any JSON data to the deployment. Useful for merkle tree data for example\nlibraries?: { [libraryName: string]: Address }; // This let you associate libraries to the deployed contract\nproxy?: boolean | string | ProxyOptions; // This options allow to consider yoru contract as a proxy (see below for more details)\n\n// here some common tx options :\ngasLimit?: string | number | BigNumber;\ngasPrice?: string | BigNumber;\nvalue?: string | BigNumber;\nnonce?: string | number | BigNumber;\n\nestimatedGasLimit?: string | number | BigNumber; // to speed up the estimation, it is possible to provide an upper gasLimit\nestimateGasExtra?: string | number | BigNumber; // this option allow you to add a gas buffer on top of the estimation\n\ndev_forceMine?: boolean; // this force a evm_mine to be executed. this is useful to speed deployment on test network that allow to specify a block delay (ganache for example). This option basically skip the delay by force mining.\ndeterministicDeployment? boolean | string; // if true, it will deploy the contract at a deterministic address based on bytecode and constuctor arguments. The address will be the same across all network. It use create2 opcode for that, if it is a string, the string will be used as the salt.\n```\n\n## Handling contract using libraries\n\nIn the deploy function, one of the `DeployOptions` that can be passed into the function is the `libraries` field.\n\nFirst, deploy the library using the `deploy` function, then when we deploy a contract that needs the the linked library, we can pass the deployed library name and address in as an argument to the `libraries` object.\n\n```js\nconst exampleLibrary = await deploy(\"ExampleLibary\", {\n    from: <deployer>\n});\n\n```\n\nExampleLibrary is now deployed to whatever network is in the context of the environment.\n\nFor example, if we are deploying on Rinkeby, this library will get deployed on rinkeby, and the `exampleLibrary` variable will be an deployment object that contains the abi as well as the deployed address for the contract.\n\nNow that the library is deployed, we can link it in our next deployed contract.\n\n```js\nconst example = await deploy(\"Example\", {\n    from: <deployer>\n    args: [\"This is an example string argument in the constructor for the 'Example' contract\"],\n    libraries: {\n        ExampleLibrary: exampleLibrary.address\n    }\n});\n\n```\n\nThis `libraries` object takes the name of the library, and its deployed address on the network. Multiple libraries can be passed into the `libraries` object.\n\n## Exporting Deployments\n\nApart from deployments saved in the `deployments` folder which contains all information available about the contract (compile time data + deployment data), `hardhat-deploy` allows you to export lightweight file.\n\nThese can be used for example to power your frontend with contract's address and abi.\n\nThis come into 2 flavors.\n\nThe first one is exported via the `--export <file>` option and follow the following format :\n\n```js\nexport interface Export {\n  chainId: string;\n  name: string;\n  contracts: { [name: string]: ContractExport };\n}\n```\n\nwhere name is the name of the network configuration chosen (see hardhat option `--network`)\n\nThe second one is exported via the `--export-all <file>` option and follow the following format :\n\n```js\nexport type MultiExport = {\n  [chainId: string]: { [name: string]: Export }\n};\n```\n\nAs you see the second format include the previous. While in most case you'll need the single export where your application will support only one network, there are case where your app would want to support multiple network at nonce. This second format allow for that.\n\nFurthermore as hardhat support multiple network configuration for the same network (rinkeby, mainnet...), the export-all format will contains each of them grouped by their chainId.\n\n## Deploying and Upgrading Proxies\n\nAs mentioned above, the deploy function can also deploy a contract through a proxy. It can be done without modification of the contract as long as it does not have a constructor (or constructor with zero arguments).\n\nThe Proxy is both ERC-1967 and ERC-173 Compliant\n\nCode can be found [here](solc_0.7/proxy/EIP173Proxy.sol)\n\nTo perform such proxy deployment, you just need to invoke the deploy function with the following options : `{..., proxy: true}`\n\nSee example :\n\n```js\nmodule.exports = async ({ getNamedAccounts, deployments, getChainId }) => {\n  const { deploy } = deployments;\n  const { deployer } = await getNamedAccounts();\n  await deploy(\"Greeter\", {\n    from: deployer,\n    proxy: true\n  });\n};\n```\n\nYou can also set it to `proxy: \"<upgradeMethodName>\"` in which case the function `<upgradeMethodName>` will be executed upon upgrade.\nthe `args` field will be then used for that function instead of the contructor. It is also possible to then have a constructor with the same arguments and have the proxy be disabled. It can be useful if you want to have your contract as upgradeable in a test network but be non-upgradeable on the mainnet. Further documentation need to written for that.\n\nSee example :\n\n```js\nmodule.exports = async ({ getNamedAccounts, deployments, getChainId }) => {\n  const { deploy } = deployments;\n  const { deployer } = await getNamedAccounts();\n  await deploy(\"Greeter\", {\n    from: deployer,\n    proxy: \"postUpgrade\",\n    args: [\"arg1\", 2, 3]\n  });\n};\n```\n\nThe proxy option can also be an object which can set the specific owner that the proxy is going to be managed by.\n\nSee example:\n\n```js\nmodule.exports = async ({ getNamedAccounts, deployments, getChainId }) => {\n  const { deploy } = deployments;\n  const { deployer, greeterOwner } = await getNamedAccounts();\n  await deploy(\"Greeter\", {\n    from: deployer,\n    proxy: {\n      owner: greeterOwner,\n      methodName: \"postUpgrade\"\n    },\n    args: [\"arg1\", 2, 3]\n  });\n};\n```\n\nNote that for the second invokation, this deployment will fails to upgrade the proxy as the `from` which is `deployer` is not the same as the proxy's owner : `greeterOwner`\n\nTo make it work, you have to create a new script that have for `from` field: `greeterOwner`. If such value is a a multi sig or an address not registered as part of hardhat signers, the tx will not be executed but instead an error will be throw, mentionning the tx data necessary to perform the upgrade.\n\n## Builtin-In Support For Diamonds (EIP2535)\n\nThe deployments field also expose the diamond field: `hre.deployments.diamond` that let you deploy [Diamonds](https://eips.ethereum.org/EIPS/eip-2535) in an easy way.\n\nInstead of specifying the facets to cut out or cut in, which the diamond contract expects, you specify the facets you want to end up having on the deployed contract.\n\n`diamond.deploy` expect the facet as names. The name represent the compiled contract name that going to be deployed as facet. In future version you ll be able to specify deployed contract or artifact object as facet.\n\nTo deploy a contract with 3 facet you can do as follow :\n\n```js\nmodule.exports = async ({ getNamedAccounts, deployments, getChainId }) => {\n  const { diamond } = deployments;\n  const { deployer, diamondAdmin } = await getNamedAccounts();\n  await diamond.deploy(\"ADiamondContract\", {\n    from: deployer,\n    owner: diamondAdmin,\n    facets: [\"Facet1\", \"Facet2\", \"Facet3\"]\n  });\n};\n```\n\nif you then later execute the following script:\n\n```js\nmodule.exports = async ({ getNamedAccounts, deployments, getChainId }) => {\n  const { diamond } = deployments;\n  const { deployer, diamondAdmin } = await getNamedAccounts();\n  await diamond.deploy(\"ADiamondContract\", {\n    from: diamondAdmin, // this need to be the diamondAdmin for upgrade\n    owner: diamondAdmin,\n    facets: [\"NewFacet\", \"Facet2\", \"Facet3\"]\n  });\n};\n```\n\nThen the NewFacet will be deployed automatically if needed and then the diamondCut will cut Facet1 out and add NewFacet.\n\nNote that if the code for Facet2 and Facet3 changes, they will also be redeployed automatically and the diamondCuts will replace the existing facets with these new ones.\n\nNote that The Diamond contract's code is part of hardhat-deploy and contains 3 built-in facet that can be removed manually if desired.\nThese facets are used for ownership, diamondCut and diamond loupe.\n\nThe implementation is the [reference implementation by Nick Mudge](https://github.com/mudgen/Diamond)\n\nLike normal proxies you can also execute a function at the time of an upgrade.\n\nThis is done by specifying the execute field in the diamond deploy options :\n\n```js\ndiamond.deploy(\"ADiamondContract\", {\n  from: deployer,\n  owner: diamondAdmin,\n  facets: [\"NewFacet\", \"Facet2\", \"Facet3\"],\n  execute: {\n    methodName: \"postUpgrade\",\n    args: [\"one\", 2, \"0x3\"]\n  }\n});\n```\n\nSince the diamond standard has no builtin mechanism to make the deployment of Diamond with function execution, the Diamond when deployed is actually deployed through a special contract, the `Diamantaire` (see code [here](solc_0.7/diamond/Diamantaire.sol)) that act as factory to build Diamond. It uses deterministic deployment for that so, it is transparently managed by hardhat-deploy.\n\nThe Diamantaire also support the deterministic deployment of Diamond.\nAn extra field can be passed to the Diamond deployment options : `deterministicSalt`. It has to be a non-zero 32bytes string (in hex format).\nNote that if you want to deploy 2 diamonds with same owner, you'll need 2 different deterministicSalt for them to be 2 separate contracts.\n\n## Testing Deployed Contracts\n\nYou can continue using the usual test task :\n\n`hardhat test`\n\nTests can then use the `hre.deployments.fixture` function to run the deployment for the test and snapshot it so that tests don't need to perform all the deployments transaction every time, they simply reuse the snapshot for every test (this leverages `evm_snapshot` and `evm_revert` provided by both `hardhat` and `ganache`). You can for example set them in a `beaforeEach`.\n\nHere is an example of a test :\n\n```js\nconst { deployments } = require(\"hardhat\");\n\ndescribe(\"Token\", () => {\n  beforeEach(async () => {\n    await deployments.fixture();\n  });\n  it(\"testing 1 2 3\", async function() {\n    const Token = await deployments.get(\"Token\"); // Token is available because the fixture was executed\n    console.log(Token.address);\n    const ERC721BidSale = await deployments.get(\"ERC721BidSale\");\n    console.log({ ERC721BidSale });\n  });\n});\n```\n\nIf the deployment scripts are complex, the first test could take while (as the fixture need to execute the deployment) but then from the second test onward, the deployments are never re-executed, instead the fixture will do `evm_revert` and test will run far faster.\n\nTests can also leverage named accounts for clearer test. Combined with `hardhat-deploy-ethers` plugin, you can write succint test :\n\n```js\nconst { ethers, getNamedAccounts } = require(\"hardhat\");\n\ndescribe(\"Token\", () => {\n  beforeEach(async () => {\n    await deployments.fixture();\n  });\n  it(\"testing 1 2 3\", async function() {\n    const { tokenOwner } = await getNamedAccounts();\n    const TokenContract = await ethers.getContract(\"Token\", tokenOwner);\n    await TokenContract.mint(2);\n  });\n});\n```\n\nFurthermore, tests can easily create efficient fixture using `deployments.createFixture`\n\nSee example :\n\n```js\nconst setupTest = deployments.createFixture(async ({deployments, getNamedAccounts, ethers}, options) => {\n  await deployments.fixture(); // ensure you start from a fresh deployments\n  const { tokenOwner } = await getNamedAccounts();\n  const TokenContract = await ethers.getContract(\"Token\", tokenOwner);\n  await TokenContract.mint(10); //this mint is executed once and then `createFixture` will ensure it is snapshotted\n  return {\n    tokenOwner: {\n      address: tokenOwner,\n      TokenContract\n    }\n  };\n};\ndescribe(\"Token\", () => {\n  it(\"testing 1 2 3\", async function() {\n    const {tokenOwner} = await setupTest()\n    await tokenOwner.TokenContract.mint(2);\n  });\n});\n```\n\nWhile this example is trivial, some fixture can requires several transaction and the ability to snapshot them automatically speed up the tests greatly.\n\n## More Information On Hardhat Tasks\n\n### node task\n\nas mentioned above, the node task is slighly modified and augmented with various flag and options\n\n`hardhat node`\n\nIn particulat It adds an argument `--export` that allows you to specify a destination file where the info about the contracts deployed is written.\nYour webapp can then access all contracts information.\n\n### test task\n\n`hardhat test`\n\nthe test task is augmented with one flag argument `--deploy-fixture` that allow to run all deployments in a fixture snapshot before executing the tests. This can speed up tests that use specific tags as the global fixture take precedence (unless specified).\n\nIn other word tests can use `deployments.fixture(<specific tag>)` where specific tag only deploy the minimal contracts under tests, while still benefiting from global deployment snapshot if used.\n\nIf a test need the deployments to only include the specific deployment specified by the tag, it can use the following :\n\n```js\ndeployments.fixture(\"<specific tag>\", { fallbackToGlobal: false });\n```\n\nDue to how snapshot/revert works in hardhat, this means that these test will not be able to benefit from the global fixture snapshot and will have to deploy their contract as part of the fixture call. This is automatix but means that these tests will run slower.\n\n### run task\n\n`hardhat --network <networkName> run <script>`\n\nThe run task act as before but thanks to the `hre.deployments` field it can access deployed contract :\n\n```js\nconst hre = require(\"hardhat\");\nconst { deployments, getNamedAccounts } = hre;\n\n(async () => {\n  console.log(await deployments.all());\n  console.log({ namedAccounts: await getNamedAccounts() });\n})();\n```\n\nYou can also run it directly from the command line as usual.\n\n`HARDHAT_NETWORK=rinkeby node <script>` is the equivalent except it does not load the hardhat environment twice (which the run task does)\n\n### console task\n\n`hardhat console`\n\nThe same applies to the `console` task.\n\n## Deploy Scripts: Tags And Dependencies\n\nIt is possible to execute only specific part of the deployments with `hardhat deploy --tags <tags>`\n\nTags represent what the deploy script acts on. In general it will be a single string value, the name of the contract it deploys or modifies.\n\nThen if another deploy script has such tag as a dependency, then when this latter deploy script has a specific tag and that tag is requested, the dependency will be executed first.\n\nHere is an example of two deploy scripts :\n\n```js\nmodule.exports = async ({ getNamedAccounts, deployments }) => {\n  const { deployIfDifferent, log } = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const { deployer } = namedAccounts;\n  const deployResult = await deploy(\"Token\", {\n    from: deployer,\n    args: [\"hello\", 100]\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Token deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = [\"Token\"];\n```\n\n```js\nmodule.exports = async function({ getNamedAccounts, deployments }) {\n  const { deployIfDifferent, log } = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const { deployer } = namedAccounts;\n  const Token = await deployments.get(\"Token\");\n  const deployResult = await deploy(\"Sale\", {\n    from: deployer,\n    contract: \"ERC721BidSale\",\n    args: [Token.address, 1, 3600]\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Sale deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = [\"Sale\"];\nmodule.exports.dependencies = [\"Token\"]; // this ensure the TOken script above is executed first, so `deployments.get('Token') succeeds\n```\n\nAs you can see the second one depends on the first. This is because the second script depends on a tag that the first script registers as using.\n\nWith that when `hardhat deploy --tags Sale` is executed\n\nthen both scripts will be run, ensuring Sale is ready.\n\nYou can also define the script to run after another script is run by setting `runAtTheEnd` to be true. For example:\n\n```js\nmodule.exports = async function({ getNamedAccounts, deployments }) {\n  const { deployIfDifferent, execute, log } = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const { deployer, admin } = namedAccounts;\n  await execute(\"Sale\", { from: deployer }, \"setAdmin\", admin);\n};\nmodule.exports.tags = [\"Sale\"];\nmodule.exports.runAtTheEnd = true;\n```\n\nTags can also be used in test with `deployments.fixture`. This allow you to test a subset of the deploy script.\n","readmeFilename":"README.md","gitHead":"7b73bbef5059dbd1ece7d37f508cd7f06e7d5fd1","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.11","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-Opx+EltGluFfbx7NyLERTEF4PaainZToBwSHJ3Bks8F/GJI6n0+JHM62qZJcoUPEYpw+HFWSgx7Gs2jbygaQzw==","shasum":"6e331c7be925d49d257d809b8977976601e8f2cd","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.11.tgz","fileCount":82,"unpackedSize":2221297,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJflULtCRA9TVsSAnZWagAARjQP/0u1KBwd2zQmS3c6mP/0\nQETNxcUlxEaCoHt6Tzf9cBPCs3m5lhwsQ8gtVBrcl3vrAliNsHMENqK0zb7t\njJuK0tDaMgd1TyCabmhnGM/oYXFPQQzU6v4HtWbYeUK8FysAtGxqxO6duRkB\n2hvSG8nfNCd1J91lbjdrZpuQ5qrXPDHt0yr33ytYI5nHLCdB9ch81+CATRMX\nt2b0zgHpLTQExMMVKHzEWxUxqh7BdAP+zivwuFfCXS2hHCs6iVLQPSVFZEt5\nrs1+ck1hgxT2J9rsWbZ34RilcTWX7jJ0flA8K9+3tw1TKMPSWHze4CMYOtQP\nzZNDUAiLYOS481nWnS6Lxam/QQ96A5YrmzmbVlTQYxDCq05sEvvl3M2XPXgA\nVo+VUhf0pWXv88G2IYuXsT5pB4xZ5ywCmjk0GPRGixiCxPlKxCMY5+mkptms\n9TC1PvRDQ4vne4Va8pOZiAwA/argPt/Ftk6O1VNnvmUb0JEtMjlf5qXIZsVZ\nkHwh6qBwkg4zCMWxRPOIWyRgcrIG5cT3TLkgd0EpuEaoXY8Ghz/2cf9CG34I\nYvGq0T4ZB/DoZBj0tEgNUmezWugiBbMHfy4iJSWZahWcV1HiiAcahALtjG9m\nEljUVxmoxaa1Ptwd4ivWM5daHVBzxnk0TzNjk651+wVrbNYl+7HYhMYov0Ut\np7xs\r\n=2zmr\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQC3x0XtTjQG8wtwmH5JQrnMW2LuTDp7leH8CfIW4celjwIhAJfAxOZOn+VYRMjpOglMHvOi6WrLhnFbRYEYs/vl0e29"}]},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.11_1603617516958_0.2439469463921471"},"_hasShrinkwrap":false},"0.7.0-beta.12":{"name":"hardhat-deploy","version":"0.7.0-beta.12","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","eslint-plugin-prettier":"^3.1.4","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.0.0","chokidar":"^3.4.0","debug":"^4.1.1","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint:fix":"prettier --write solc*/**/*.sol && prettier --write src/**/*.{js,ts} test/**/*.{js,ts} && eslint --fix .","lint":"prettier --check solc*/**/*.sol && prettier --check src/**/*.{js,ts} test/**/*.{js,ts} && eslint .","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"aa07560728482b2ca03dacdd31eb878d8ffcb283","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.12","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-dnFryWMPVD0ZozyXIvyLyKT2Xb0iAu2MhBVI/IGZFR/aFsTv/T4+hXyae0gawSVYPEzZGpsD4ZhE+lvPdBK9Lg==","shasum":"5f65810c3efc4d457e3eb3486fba8999439fb494","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.12.tgz","fileCount":82,"unpackedSize":2221297,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJflUd5CRA9TVsSAnZWagAAF9gP/RTlfWSYzGlLXM6W4pNS\nRQHNpU0K84HSOgadAlccYposjJqvklXh6KLV2eKCUsNXjMKMW8eraoTBksgl\np8SnuE62IlbPzAUDKw5uIPAKNcGGLEU07zkvdl6ekqmNN3/G3IB1Gcs11D/P\nZJ1McB9w2eDjhe89z7dPSsT8k3EBcmZPiB1HorxvNJ4kalr7tU9Wk5qIvCAT\ntOmASZahJ6rwECIIHgCRVc3JnhC+geO/3X4DxhGN9jNR7Ay63+LBNQhZOhbl\nvKLS+d6QILcC2Lwq1qryfS76ZmxSKwBKV62PGZpI5KB3/ahrjMVr+emmYygp\nD/1O1Pzc0lAixyPk5kYteO7rEyqC3l4UuDKq/58y1/5rijXtEEit2ZJEsjOT\nL98YPIsdWFgjPyvx/BMp5Wcwx+sq3NfCNntoCkcITwzp/A2Gzr8rcxH13bVc\naiRVbnV51QRY0r22VUhXcc4FvdH9rjpzP19WYokyIGIdUFqHglWAuQTHIT63\nrGfHkfH5WmC++Nc6DbTaEL/skH9z+/CFD4oGT8fcJpr6Qie2QkuDy51u1RJI\n9fUi6eZu4evmNewkVEzCTPRc5bvUsQmxCPABcAmOWMqvfbab4v8HZlmmT2Xx\n0kvDqg+yQGxR+R/jfCIaJvmQGbHC3jcosH1IOgTct0THYhm9mGTWMaXhDi+v\n3LIh\r\n=OVHF\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDK5Ki+vjGsHgu8Tx56v276uFAzuShuUIODuL76Pcv3xQIgftuLj6wKv3j1HSDxpm06PDR6jD0oHH4MyKuThMkYuck="}]},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.12_1603618681256_0.011925283635077388"},"_hasShrinkwrap":false},"0.7.0-beta.13":{"name":"hardhat-deploy","version":"0.7.0-beta.13","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","eslint-plugin-prettier":"^3.1.4","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.0.0","chokidar":"^3.4.0","debug":"^4.1.1","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint:fix":"prettier --write solc*/**/*.sol && prettier --write src/**/*.{js,ts} test/**/*.{js,ts} && eslint --fix .","lint":"prettier --check solc*/**/*.sol && prettier --check src/**/*.{js,ts} test/**/*.{js,ts} && eslint .","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"7188866b482974d15fb4c8efb5e15d3751310f67","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.13","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-+6jOg5sl5DHXmfAUBM4bPPg2Uh4LlMXKhvQPJGGOnBWxXI87GyeAck59UqYJuCynng9KX8swkYXEF1nijll0dQ==","shasum":"88810e895064bf14d073bc7b8c08d09d6c5bbf03","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.13.tgz","fileCount":82,"unpackedSize":2221112,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJflVnRCRA9TVsSAnZWagAAjbYP/ApBKQRgIzB+LZgY0oFV\nJP36RCuibmvdj2ctfurSzFbMek31gqbv9V782J2zoNECVK0hZWtpJFqpvMtL\nyR2auXOKxwaizAuIHuT9B5V0GmMNH283na8JVlQ6HpAYudyFdresnuYp/Bcn\n6OlVzT2iQnqHYHkPlYjrC83BBA0YcFuSpTv0/POdJ0VyLYoQH26FOdJsaLjo\nrxbEXnF0fSK5XsbI9bGX2W86q0GHemEFOIka267wGb6HCvr7QuOuAA17Pk/0\njZCiJOwhqryPfjpfvj5z+PCt5O2XI9BJbBw6/mLgJIiVsr0XiRFh101rSKmp\nOejoRZAscxR5RD5Sd19Tnn/m22AqxzOrueyFMVLjn+DUX+6ohKUwC1Yy7IJH\nagKZGSRpUxu2kFGuDuXLOjelkIkqCs8W2ea+XY7KLdfBSXGA+mVmzt0bolXn\n+KnEFJguDTtSeOLw43ufhpJfnX9HlXfjVCU6UynVz4r2UCrUfEZUNRBBrPVO\nHPc+D6K7krgXotMhluxPOkcmN87xNMFJg7NbUI5mC9xQhWDPnNRDLQ1dqFZ6\n8L6ubbx/h3d9h7ykoCiI1himG8UnmeuM7mUndC8RgZh0OBdq6Jz+5Ls4kXIA\nsZE6wivv6bSVUjb/stbbnSSQKmpmdYyh4wlq8lxzy/fO10tz4+WGQya5yoXN\nimXv\r\n=WSeG\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIEErsBxSw+WihndSo/uQMIEM4qyFg4wzwFwFL2JWGg/nAiEA/lwJQgeeCB4y00xwq0hbJrMp21HhSNjY7OUKL38Jt84="}]},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.13_1603623376760_0.5352190757838735"},"_hasShrinkwrap":false},"0.7.0-beta.14":{"name":"hardhat-deploy","version":"0.7.0-beta.14","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","eslint-plugin-prettier":"^3.1.4","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.0.0","chokidar":"^3.4.0","debug":"^4.1.1","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint:fix":"prettier --write solc*/**/*.sol && prettier --write src/**/*.{js,ts} test/**/*.{js,ts} && eslint --fix .","lint":"prettier --check solc*/**/*.sol && prettier --check src/**/*.{js,ts} test/**/*.{js,ts} && eslint .","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"1b11547cbf594817f3198a2c23a32c0c1bcd08e8","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.14","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-E2F32p/Uc9GnCAebfI5wAQt7WdqaOPs6Y0CZ7XsA35DPkFHVIqEg/mBPS6kFEGUeAjXdDPtVJK2cmdGTR1WnOw==","shasum":"fff37f64495f235bb651a43d7d7f9d78c9ffe880","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.14.tgz","fileCount":82,"unpackedSize":2220946,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJflbvrCRA9TVsSAnZWagAARtUP/1YNOJkrw22paAEkbfQA\ng4sWTG1JGp8TVvG0mNaJoo4gOWCZIsJ+8mQFZCiJxdzUo+g68/icO/9XA+bv\neY2mkKvYa80w192M/P6npwxI90d7L0o0L0y/LTcRYQfVAMwZMRjt5vWn8JFi\n/8/jUqZEXLlXNnIDQQsMrq0vwvJ+8JX9zbJJutVvcn6ayTsWpS77KPz29fcm\nmKmp50aJEDB3D7h0FcpBkNKgX7r/sOWPQ2YDs1Ku/s5hhPVnStBhxL317f3I\nDB1P/kldPVNXOUU+MNoS2VM+Ra4DOUwIAAstGnI3wzAXWEyffHaQTnYE6Epj\nQqkFo9ZHSKDc1R77NZsYHzn9D7m5RQY3bMR5A5PNIFfGb4O2OkoF9jlBUwCE\nlDWS5J1SwrQM5uqWLwMyaxNKl51ESwFBagA7X08NN5w6YutjXt8Q3cFBQ8KX\nYfs1ollH+uN2xWTCAMXeKxyYpYO0vVcPu/pVDJcQFzW4sGES1ahEM+bn/A6a\nxACOpLb5/Ddg94OGcbb10oRwynY9vA3UZs/NTRaDCeS3qyLAIfJGrMmPkpbT\nMlEcq9c+QdXW2V6/uiEMcNtge1IUgeE5rLGlPRXEs8HnrdP72zcN3WJYnleK\n3fXDmW95ANVYIQfmOxZdrPm+FinC9ze8guTfpujYyOHVO4m3+q/AjwbUnmfX\n6V5L\r\n=Jpqk\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIGEz7jThinRA74aOt7c39Jk5piipOdCuykZXfLk4ITHsAiEA0KMAcEp6qHwGf0g7VSG1fUaSbzzJoWXYASP+hrHIIJA="}]},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.14_1603648490904_0.13512829134710014"},"_hasShrinkwrap":false},"0.7.0-beta.15":{"name":"hardhat-deploy","version":"0.7.0-beta.15","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","eslint-plugin-prettier":"^3.1.4","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.0.0","chokidar":"^3.4.0","debug":"^4.1.1","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint:fix":"prettier --write solc*/**/*.sol && prettier --write src/**/*.{js,ts} test/**/*.{js,ts} && eslint --fix .","lint":"prettier --check solc*/**/*.sol && prettier --check src/**/*.{js,ts} test/**/*.{js,ts} && eslint .","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"6111c2a589d38c6f1f263e4d9eabd65387664904","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.15","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-ajMxc8l5y1WpZT/zezTP8pVE86hAlh2/DWHcgjF+uOpRZ46Tpp2v0C5eqHC57GSPKxF5D3ApcT7YRkAAjNRudQ==","shasum":"2abf541801139616de12fdc82a774cf13e8a1166","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.15.tgz","fileCount":82,"unpackedSize":2220954,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJflofoCRA9TVsSAnZWagAA12YP/Ayi9Pcc7ghoLwkzxQbj\nxxl4uYJA+xFJyQ4soAT12ybW7aLVAUkjwVmhwjIujRBkBTJlOMaUZe/2afHe\nnYc9/YPSgH4RE/s19kryuEewoMCgOkXYg8CxZOpkFseV//F8yp0CRxWzX52a\nWC7w/RKGpboIJpQzz95bhkt8PtdqeYL5YaffHkYy6zgfRnGGzQ39AIR/LBb9\nhN/4oSrTAZRGY1rWSsmnho7rFMFwrNcluOJvcUrXb+o4yCwBxPtIn3cX8mUi\nV+2qyAOSqXdIWBYWvF7KSzCBoAyyvKKRhfWs2TC5/KSFAZ0NddhX5qLOZ58H\nntVBBIJetVhRvtHPs23DV5aUcFZvYXbjBHUilIBKHlhqQ0FhuVKRgaI/Kxhr\nQiBNWGutGOZD1rAThVvELWJzh7vLpNSNtuWrG91sklupOX3tLjGep5nMR0Tb\ntajAiOinf5x37YyiJPE+j/sLr0wVDvVZrI/Jnt2S+5mymUpW1v8brl2g8wXs\n/N+KiUhMpRvg/YNrzepPCUzfzBo49Car9UGE3huR2L0IvNjlKf9E6YDBlBj5\nXo7ADUPF8Qephr98Ylr78i4rGfgem8nqW0308LZFucplDlkqgDfv2/BCQbHe\nyhYYPVMaxmODqkPCPFrY1tpblQlDG1JBhLSOVZtoEpy8SirLmwAVGn+1TZYM\nJ/hW\r\n=8e6M\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIE4MHv2r6v5/heEWFeb6T6B2b0Kke5MxQEicCEUpOrrBAiEA/yfBFxtBBcj+1wXakUNP398mdxsMZ2ob+cZAkaywwhM="}]},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.15_1603700711694_0.923619676561422"},"_hasShrinkwrap":false},"0.7.0-beta.16":{"name":"hardhat-deploy","version":"0.7.0-beta.16","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","eslint-plugin-prettier":"^3.1.4","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.0.0","chokidar":"^3.4.0","debug":"^4.1.1","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint:fix":"prettier --write solc*/**/*.sol && prettier --write src/**/*.{js,ts} test/**/*.{js,ts} && eslint --fix .","lint":"prettier --check solc*/**/*.sol && prettier --check src/**/*.{js,ts} test/**/*.{js,ts} && eslint .","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"e4c7e3524af5008a117a886f965fb39c1b936dd6","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.16","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-qnJxmvFZW1sqaMDQ55wPgDPD9PrdT0LCapGDjtoRuAxdG+TTuIvhOkx6myvB+7Odlw9ywEZ//rCJwsKabak31A==","shasum":"0c61bd4e09f85e916ee484013e68e038448c69cb","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.16.tgz","fileCount":82,"unpackedSize":2220859,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJflpcACRA9TVsSAnZWagAAA2wQAJuPB+5Gxx2cTeBXUTWx\n3Xosx1qXfMpsrwJVWRDl/PgLyzvoEKSyP9iwvrakU0bCemXAHusjiAZXGQ5Z\nBetb5aRXRHcZDLM7/hPhqeO0QD5sSrqPHTywH60subXKZxtzdqwTGea53UPF\nOAYi6/d5ttsmd/GwD4QEw/fF7M5MYzvgCxrXBk5pCIjctVBRBsaR34daw2CG\nQwsNHqEunF3pVAi5jUkzqr8b7d+AMXvuPLf5Fp3NVOP+LP2jvdz14/l80RLv\n8o6IkwzDcQ9LsNGvxB4LNYLSe+1p4wElk+FoE9G0rJeS9j6woZ/RbhlZ+W/C\nGEP5J3pkJKSQSUWQBCaBfpxkMxeBGiwhMy1uKshQlLgIEH2z7A0QVuVySep9\n9ScgTJlrKcf7JpM2uGMg8NR31b1daSYa7xuDfSkK3qPczEzd/HRqfgmlrkcF\nyrDFqFBFIy0SD5TyqkqHqPkL/MoFb9JevkW/g0Elt/lyhAS68RREmM6XQ7ME\nOshLK0QKS32DkLaNVx34x9Py6Gqz1HAn0F4qJRcjwc0WDkdw4wC7SEAkoinb\nMGUskRv6sushmmJx3svsIpRCIQ8ByV2jghhl9xSApPpTlwLgCmp/2pbqyKlB\nyVAmE+SdE00FYMn+fZPONQwakRLDhdlCbmObguM7n7Ot98rMrQQ3vnaq7zXW\nZs/A\r\n=uLcD\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDymJja/AmDGuDJ0OiSFOQblw9ZPWOl0QsA7Cx+9GWnhQIhAKtckTZm30gRxJbPRWqiU9+ksjfYXcOdrU4Plj6FouKB"}]},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.16_1603704575429_0.9678808555353604"},"_hasShrinkwrap":false},"0.7.0-beta.17":{"name":"hardhat-deploy","version":"0.7.0-beta.17","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","eslint-plugin-prettier":"^3.1.4","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.0.0","chokidar":"^3.4.0","debug":"^4.1.1","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint:fix":"prettier --write solc*/**/*.sol && prettier --write src/**/*.{js,ts} test/**/*.{js,ts} && eslint --fix .","lint":"prettier --check solc*/**/*.sol && prettier --check src/**/*.{js,ts} test/**/*.{js,ts} && eslint .","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"49fe7c6293a247cf900c4ce35df8d5d64c00834c","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.17","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-Kkbc3ETsBsmohHWdp3gfWyXnJZxgG1ldoeuGWklD5W08dR5rg3vNy+blixTVWwOkVzc2INHR8XEYUvp9qdaznw==","shasum":"92af2727600358712e8303b0fb256a0f1f30a85b","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.17.tgz","fileCount":82,"unpackedSize":2220764,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJflxiECRA9TVsSAnZWagAAcuwP/RwJdDt2ffaUz3T7NfzA\nllkoJ9iXIZ44G/xzcib/TorRN4Y1cuUA/PWQ2dKe0StjUmTJrkdWN8lk6lZC\nDjDWIRangH9e3Ggw+sb8QoWk9K7iMdqKHuNm1nChJd5NEbjsUn6F8R9vVe9u\n4Fs50G4z37m+MJq911MYNScJhhFG0cgqHDi42LLBOuUMTV6zdq2Z2JUDxR+7\neMchDEZV2f61XYruuB2VHpML1/sIZ5gj0xqKrRpJjJYgGTVWnTLcOpJJhD48\nuLUX+1BlvOwngMnBpjfnIoKivDyERtvWwi7pfVWYfG4N+JmtDEAkz/2sSSXy\ndQu5bGvnUmVxQE10rLEvlbFnunBnfJsG4bgG36j8Nl+Sw9td0gpQbBPpfD2l\nXuPH2etWtZe5v4HyyVr+SnzV/XhNdeyHZeMKMj64W7GNkDKCOOKDQNxm7nWZ\n6pnZVTEgwmZEA6vdU1gUvfuFW5abkoR8yPmwnJE6R37GiX3ODZn3izl7zzMc\nc5TauHVLsHJeXA5tGRFJQS/k8NmdcE793J0vAo9yQJO5gXYAo1DMHr/EjLuQ\nszbTvZC4hnc55jG3u7a0icRZN5Bn8r/VskA86DopzjXR+t0HHPB1n8HL7Gkd\n8tTZl/ks3sTUWyF6zoaVizmzdHUkuJIKnU3xqjtuiHI9Ky+KnI7F/EfMz/fp\n2yPL\r\n=EE43\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCLhDJv+xRDPpJg7W8d5soUUzriQFSnSe1mWlt9+d1jIQIhAIbLHz83hPCte7pGeyNO1tBU8hqWiRXIn1xWnkAGzodt"}]},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.17_1603737731981_0.38375841488310236"},"_hasShrinkwrap":false},"0.7.0-beta.18":{"name":"hardhat-deploy","version":"0.7.0-beta.18","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","eslint-plugin-prettier":"^3.1.4","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint:fix":"prettier --write solc*/**/*.sol && prettier --write src/**/*.{js,ts} test/**/*.{js,ts} && eslint --fix .","lint":"prettier --check solc*/**/*.sol && prettier --check src/**/*.{js,ts} test/**/*.{js,ts} && eslint .","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"522b0765b40f7e67c6ade0b9df3c8b100162f8f2","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.18","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-SY05L/2+FacNbmtkLGmsH+zDJJc3P0FH5+5VKscx9+Hq6TSQbLeSihVLby26qkChfRQwoWl/WC3+Plfo0BgTMA==","shasum":"8863e04eebff0a1009ddd8f47356e906a8581b9b","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.18.tgz","fileCount":82,"unpackedSize":2220764,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJflycgCRA9TVsSAnZWagAA7ekP/i3QAYbJdXCvrkawxH3D\n1Lzwed24zV6DpIHEikHdfx2mB/Qqx8Zx7Fmgz75swZZ7iLahg8Sv8Nk66GoV\nWnovwp08FuTtmI0E6iedydW6shgZI0sgeTeezxVe9csh06F8UXtjfvtmUjfH\naWPHdklzog+FQRssq49GAsAhQFYFw6l3wVUmYLzTM5eEzcB7mNbpjk0lfGEo\nKeyr5hHKA4BnCaBRf3fHUYlZpANJ8ZX2tZBnzTOmXCt0D42G3fX3mDSQChNr\nX6Jl/azPd+MR6FsNtRzPR2zwviTSmv9ILNrDZxZG9EBvrjWI/trzQ36cXbW/\nC6V/ZFCJN+C08kQrMMPjuyA1Vmnu6Ff2RFh2QYBRMkCmVro1ehpF8PXNiC6M\nux3WUWQhhL05S8yB88foyerIAuvp3hp4rq1bGXcNaF0dPpTX+Rl8Qm0VRWkt\n0LOk6ryNQDjamUWfnVGNW7mWGt/fzW9AnlOi6cYMDjW94yzhVtvujxsdB0xT\n7djoX0Lbis05Eh1SYXxWqQjLku7kK5UgtpXLEG3a9AwkIWQj75Aqoj5/yZyO\neQHNB28UG9P9ErfPjtwDZp8zp70je8kygfFv76Run0wEJ/JfRw6+qtwLuQYY\n0SQ2bStJ0YDi2yfhu9/LPQJm25LOZSndrXE/emG7utxTIs1CxGHQYaiCQvVe\nTT6q\r\n=yGWV\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIAhy4HWYmPr4rm9tMScowwqfFUj2aJBwksYmZEJxcDujAiBqDaQ6zl3yZu4SAc5rS83CoR3E7Tz8L9KpTZrpE9SjVQ=="}]},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.18_1603741471781_0.11747409939827569"},"_hasShrinkwrap":false},"0.7.0-beta.19":{"name":"hardhat-deploy","version":"0.7.0-beta.19","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","eslint-plugin-prettier":"^3.1.4","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint:fix":"prettier --write solc*/**/*.sol && prettier --write src/**/*.{js,ts} test/**/*.{js,ts} && eslint --fix .","lint":"prettier --check solc*/**/*.sol && prettier --check src/**/*.{js,ts} test/**/*.{js,ts} && eslint .","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"18ac9bd60df5c2c93cf892fef4576cac09004fd7","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.19","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-ZzI0jRzsl3ZK2Fw008px5r4rDlpVpm5iA4apmWhu7b46KbiDFrajgUW8wruqYnVK4enVf5gel5iw7Tt6E9Zdsg==","shasum":"2a6824b8eb09177358e16c51e9e643c056acdfe9","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.19.tgz","fileCount":82,"unpackedSize":2220677,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfmSYdCRA9TVsSAnZWagAAu1MP/irp6cV+b0Z+a6iS2CPi\nDH4EVeawM9T+HsgXpDns8LiCAtrPE0ugbB3LpPUUIWUqa2ispB+lfM3QFF5Y\nFTiLl350Odai3Pz9hhpmqpFq+KiK+zsXIWuh/bZ7OCrq4zZ7FFQ4UvogafDH\njJCUsJpNW9Vo8LY/nO2D4xlU9uJK4CiMgpGo2+B4q8izJi4VeW9W7JROHYL/\nwBPRfQZRCQey6qv4nT45/lnkKlDpDlzIc0kbJhkxzwxGg5Ziq/VIDOHsMWsN\nBi0+auC/4+cdGashIFmNs+j13ZMS+rHTwJ0yO5SCP+mIYprumykUO6hsylxa\n+kJ3itjop+FXM8rJ3ADMchqRFL9IBInVtERigTGq1MAFWSotCEny2Z0/f65y\nSOeSRtmgS+gjbZzOpWKsQEMHrYPaaJSaFCmK9vtkl78cBCT46koQtR/L7S3x\nkrNWfj6ikhUmuHKkh7du46s0TBREUPWXDQkvtsWuYjNkYzr3s4p3T89cXsUu\nmu3UuqvPIlqt40G9pcuFgvT6vX2uNIovAH9y3NUKegy0Yo2070T66MXODj4X\nxxH0U3cIwL7p5PnddeWMdCzfAY1/0ftLej+cPsAbTnGo/YZz2rxW4tM1wfy5\n7/TUtBHLClDrLK7QhyWeFOQY5OPE6dtLxqLi8wvW8Bi09yMmxZZjT+p/Y5zG\nwPZM\r\n=IGPA\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDz2ecG9b+IaMAsjQBYnuEAEE7Q2/x4kOkobs2JJNIlygIgcZ56CqSzmUk0ejeWYpsgpWFSfK74s0oxruQajUB5tcU="}]},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.19_1603872284593_0.31454211812520505"},"_hasShrinkwrap":false},"0.7.0-beta.20":{"name":"hardhat-deploy","version":"0.7.0-beta.20","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","eslint-plugin-prettier":"^3.1.4","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint:fix":"prettier --write solc*/**/*.sol && prettier --write src/**/*.{js,ts} test/**/*.{js,ts} && eslint --fix .","lint":"prettier --check solc*/**/*.sol && prettier --check src/**/*.{js,ts} test/**/*.{js,ts} && eslint .","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"bf8efccadb420ed30048ac03fbf3fd6cd3a56a24","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.20","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-Q3SEZnqkBIGICwf2YYQf+HG/TBa9hjGIncNtmW5SB0Hn3a15wlZQ9AywfRt/4zTAarxnzEAhq58H7bPJyWiJAA==","shasum":"5e8056396020d0d96a26b3ad172b84f156ec7007","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.20.tgz","fileCount":83,"unpackedSize":2220493,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfmXDTCRA9TVsSAnZWagAAzrYP/2cChIS5o17DDtVKIn7x\n/v7Qlj4loifXf7Lk8s9jj+hqiU+7Ome+/XBukDXGlTZs4VvShd0jvk5xswH2\nbW9NjZjRiSq9J5ai5AVhW+AqHBtog4/RHAVzF2EmcDJv19WUyJslTIXAKMVl\nsByL9kSBcV7mjG96hNKRYPMtctqmaa7DXiAMn4sDjh5xHSMUzuCDaG0dpl7G\n5F5+eMCqerIQz3hloN+g02kRvciTGr4g/BJ4XK2ZGtbck/nzgFxxxAdlM8NK\nWTlFqZ4HzaIdHcrQb8FRgm3S3/0sLGEoIXW145uTHTgHGoTgJ8w9OdGRdAmS\nIY64bDWbYYCY2uNgveDwdUGXyCtj7VMtOJ7hNUSZFoYwnt6eMtmeblBg0uS6\nr9Y2p9MybgdVaYMUQ10TMumqJWfDISE7uJmrG0GO2Jirzr8w2DjnqXRwJ3u7\n8Vh1tc1yxuKSvoiZz8LHcMa8/588Np/firGnJ3f9F/KYT20VvHCXCpAhUYTd\nO+gU0Z0psdQwJmGW43rFPiC+IY+qhvffVwaHOi035sXGZEP5L51/dc9hvcg4\nvXRiwk2BnaimJGMu0kSLLkgvvhVz+T+Ga+UF9J78gHlGpBZsOfxHltd1qa7O\nNGsPsTPTNyOqCaQT4NTZxjwsTvpRc20P59nCf713tmnkGE4AZq99AOR78WqU\n48ZC\r\n=upTZ\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIFc6/Es9nc9W5o/QPIaKzNzPbfZ6L/XYcLYrfU6xFo7lAiEAvJtS9Tpda9jNWbeXUaNiGhM6+AIV1ENZAU3PAW3aahI="}]},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.20_1603891410249_0.05852242305816646"},"_hasShrinkwrap":false},"0.7.0-beta.21":{"name":"hardhat-deploy","version":"0.7.0-beta.21","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"43c975c42327594e9b93c2821a2d89528eb62ef5","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.21","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-7RfBccY5cNqxyAKLkqLoTXcKSDELBW3oBm0bupeydMSUfsvmc4w+uXez+hoOH7K5g3czDju/UVE1msa/UI07sA==","shasum":"9ede7492a95df49efd64a82eb6dd2b60944d7a3a","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.21.tgz","fileCount":88,"unpackedSize":2227541,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfmwUECRA9TVsSAnZWagAAqywP/0S/m3m1eEz+rVyHuz7r\nYX97BZ/CXctuRiuFb42/9++H9pYMkStav2ETOBDW7gbyEDCJaTYhmszYfU2R\n/UbIDDSS/RmlwA3SZI5BKsxyE0rWctZLXs0aGFFLr3Uft2ykLTAyNZDCmb7m\nRS97djvsD2GwALMyUp2CLezImmh9GIcOEMakVfWQb2zftd8qxQr69+tiFcHa\n44utDqhjj6efCdb+Whw/0rA7k14NSw6cNXyODv0gmLKyMpHVBr+X/lxlSlb4\nUQFDxnWsEunAO6R/B/IrGOpufPAb/8vFoW6tICaxW3FKutUpkb8YYhE4MONE\n19IvGxbuxwQ92Tm4S/jydfyNSuY9eQ2vB0M4+KEfc9hluTiGA/1r4tknQtiK\n/Gd1PknQxu8MQ96ApE90xJn95lcZBk997S8YNF89UHp6YZzAef2vgu21Fr1Y\nyiXSkuGqoYHhwUd9rTcbjufwXOkjZb1VYBNDDJupw28gEi8fH5iogmdof4cX\nGX3UWzPQ9hMF+irKc6KyoSAR15UJJuWb/qzjdJghFZNsQ7eiSpSRU8lSv052\nNCU7G9ptPpi8MLPIFHJIiaRRFFSHpNTbEtZVJ5flBOhhcNUZTUiNS9jBbRIV\nfrj+IKAxbQ3/ltEVUDh3/Lnk1BphFqm9sEXrXOc+SBWxJ9kUmsj30RkhYaJe\nCziE\r\n=uret\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDsdNMRsmCqQZjCNyrNbFjfIwPQgTFMKB5Oesc5yj7nfwIgde5ZuhoMRAbRri6YQVEPVpVdMRyfQIvmIfB7gh3mtlI="}]},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.21_1603994883627_0.2925621287521756"},"_hasShrinkwrap":false},"0.7.0-beta.22":{"name":"hardhat-deploy","version":"0.7.0-beta.22","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"4ab4b32d0a180356e3c48b19e9396741c1d38e05","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.22","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-BxJuGkBwbgGJXXVHHpkLmuRWad7hbgLphHFERBgHtDvw3/99s8CMHOmq9kpzjrlKpRnLCq2BSwy6VJj7X1cVrQ==","shasum":"c2624fed0853056e63c4f81f6635e61c2a68f9ba","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.22.tgz","fileCount":88,"unpackedSize":2227628,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfmzQSCRA9TVsSAnZWagAAuhgP/irCxGyRe/q+zb1+7FdU\nTuNnvSaK6RTp+CdKcuUPbbIWkdzb43BoY7w6NWCh4giUbf7eCV2rvtcAQUc2\nlBAbGVTtge6ZCy8IIeekZgAqEpttTbkD0WOmJd5U+0/RMugpOOk8HSMmVRHN\nQh9OtgLd1WUma7AqI+PqV+0Z+jDQm6T+QEtiG3Tv2CaPxyQ0vEHsccNWvSKx\nNA+mD26Ayyo4CU9X1naUIt/jgp8MDS7hRYxZ07Ic9LT8zlCRfjfW7sSWNDAh\nmLIYjKCC60S/fXEoTamCO48n0D2gGb19qLYpN9sVlUZtbmBSvsOvMKb6/S7j\nA9T/MEsT1rFnkNF8Jv2qf+RIVS/p9T9jlUKfLD51CYeJaEdBOVg36Xg8iKYP\nX6pUPb3U50OQbYNgj4ABMr6tCkprJSxuqOfvZ4ieGTOjuGYF+xHsKwyE/R3I\nEBzrxW0rXoI/weTXbDdwJX8bMAugVzkvFiFQjQF3oC4/zF9TidaHNeiGEKxa\nqRKG6zvQHaEALbxOgZlY83o1TPk3DXTNKtLwkZzEdv2jXSPme7/Vqwcpm9+l\nSAv82JCRppRD0AnWnCrJwlgVcpIX1YeSilGMOJjNrThTXiU0IwF5SnT1Mrcx\n0vVLWw1EW+8CkYepWBPVBolufBc60+Dhiqc0wdcs6L/vQk953YkhE4Eyx+c1\nGkTS\r\n=Cyve\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDcp6la0X3u7K97pR79Qz35rAFIVsW8F7jxluOurkY4dgIgCYY9xusqJ+WIFK6ja6WeS+K3uvm+FvOGXHOWV3T/tk0="}]},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.22_1604006930070_0.34940572793316305"},"_hasShrinkwrap":false},"0.7.0-beta.23":{"name":"hardhat-deploy","version":"0.7.0-beta.23","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"c973c7fe0a488119cdcdfe6154987d745d546ed9","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.23","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-rlfqe3RIO7hF+3gdYQyBUv0S6t91by83SZTBFBDJaLTY7PjsujbT5taUVcMieaFOy37GA8iKQy6srk9sv6mi4A==","shasum":"95a142c9677e0dc61162aea20415303dc9c316b9","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.23.tgz","fileCount":88,"unpackedSize":2237784,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfm1udCRA9TVsSAnZWagAAflsP/ivYt0trpwyWdAdofk7Y\nFMpY5Mw/XGBSglY32rnwYAmxrSYwIpjpcf3DGUb+z2RsuXWKyANPLk4xYtQi\n2OaBTrpPnfHcXPcRSqeLoS3VFsOrOf4tggNZZesOoHUntu4yh5OyI56Fq38Q\nx0amA7z+cDlFB/aXu2cnHeXAQconGQRiv+mtKNd76czwSGhCTmiZAV0jRurR\ndOu6t3z1oNVtAvu2KUgk2vyg76jDNuimzUNragX384IdqLYF57T8iHDm5j50\nMbysujWe9cfih4ZU+l0FVk9ACe6GBEj4XVPDcC+P2yrgMHb8iXW0xaqAVUQ6\n6NP8MOWraCU3sudCB5u3rlwEnHTv37U8JIpahiLKOKYIS814g98SwGL9p/Qe\n/dBZWpNOWQ3cFInuCZdwi5zufl8al2MnQvfZFYr/cO0nCp9Xaek1/Tx4P9nq\nFoIuhvxvvtYvXPlAf1RwSmuWbPZ9cWINrKVRzd2xcZf70VcclCc87whbPJr5\nw64tBugf8SUCHM4tpgUhyhVuC5/jIMHthAEXT7i6Ua6KKgq48zcJEKp8i6CO\n0o7xQCMK0UQBMJ4STdMSi6fgJdm6kDoY+k4GEuJATvHQtX09cE2xt2d4S/LD\nBJLbingSXMH8tK2PrDkWNcP/dC4mBc+GZUMQS4nFlkk1vH+J3Hg0P7wVZiGD\nn8gJ\r\n=7kn3\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIFMfmV9Z4yw6hvhKOwEf/9SovGhDlx//xImcLQAJcXE6AiBGNnuJxp2klC7+DTJ/Qu0wILTJy38XjQyjL9yySaqoUA=="}]},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.23_1604017053154_0.4500992749189461"},"_hasShrinkwrap":false},"0.7.0-beta.24":{"name":"hardhat-deploy","version":"0.7.0-beta.24","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"d6144a233953e2c8750f7ceb93326d63209db7d3","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.24","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-hlp0Jk2wR4qOX3jWNOfyBPEBF9BTR+i2Tbrz7EY574A45GFp9yfWS5lgaD9olKfwlVZp4Hb6NgbpkTt1rw5g0A==","shasum":"abd59355afa049be59d26b471f33bd8c58c5870c","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.24.tgz","fileCount":88,"unpackedSize":2239036,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfnBApCRA9TVsSAnZWagAAOKMQAINC2TovCGtjuD1zl+gN\nWiFf5tU+nxYbZXjGh1HTT5Wv/FJIuFNzu2BZ9DQ88Mv6aNn0HoyIVE6y4IpR\nBKcGZZGnnxydhCpyx+yjrjvmSDiGE7PdbuTB1zbwu7cmRyQ4iGVHxnNXx2jc\nq13c0nSP13NibILmUs7S7WcDGXmBTCPHaxFGIaInR7kInCVkH0qlu97ImW/P\ndMNtKJYlI2+oUYXLcdo4p2pHfm6UWUwHL4eR77yUl2Qgm2GsU/WPx/e0idBL\naJgq+YkmCwuELu2Ao7kqAbsUJ+Xrc2oPzLJk/9W3P1mQyIlM3xH9MyafzSD2\noyYvC18GWAqHQqIPFYfEn8IjTySsXuEdE8Pjid+PvNrFRkGGI8olJ7K0WD+s\nXkECFWyWOXSwZ6qfELrVgmp+PKLg8ul3Yxi0i3JtIqfsLj4Pdfig31FekgSk\n28+kNvBHwd3Gg3lDHpGwZv/oac6TGrl4Ezrj0AgW+y6VkKCJVAanAv9m0u1W\nNjBqTsI25xaVWqEduFMOaFS1wQzBIEz7XkZht8LHkaE4i3fVNnhsJsR6bRND\nfW1eJ2dZKg6buqHMmmf3Z7vMDa8teihHPTAWhwX/QJe67e81V0dxhZMCD2f2\nkPrmBcqDMyp8t1WbS25edzUkA0lOPdNrigp4ajnuMY/i6J/wm6mN7fNKHaAl\nyST4\r\n=z+de\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIHIZdP7qK5gu+bXFuXTDSZDCzQ8DyDOzR/b53N7mPWxaAiEA8+Kqbh4H6CUS1JBfqyg5vmpyYnMo+XQDlc6VJTxwM5g="}]},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.24_1604063272856_0.3828048208015937"},"_hasShrinkwrap":false},"0.7.0-beta.25":{"name":"hardhat-deploy","version":"0.7.0-beta.25","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"6239f31a21398bfbf9fcd9d0ba6cd284dac88a42","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.25","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-G956jqLs/5vvdX7QTXUQThztNQry3sIfz5mDl/F5MKgJYCiPI5Qf5x+HsLVZ6a/j4TqDaoIDGgAVD9zhUr8uqw==","shasum":"905090bd6c8a78521843ef379a2e46bc025df528","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.25.tgz","fileCount":88,"unpackedSize":2239119,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfnBFQCRA9TVsSAnZWagAAD68P/jVwX7zr5p5uiVtqYpPk\nyxJnfcRLpxo9bNJ40SsXz9czGDS1WeueL21pCC659jfim94RutG2s/2CEfp+\n+Zabw47qhTBvWq7X4j/fPlJqbsA7Owpo0qfUlVMGOgxfQqpY1VGWf8h5lCnP\nxPVroaYdc8WftpZkTpZMD5aSkDVarEATAFr/PKmiYY0ptVS6oPTYQCcZeBe5\nGMZXaCdjx1cfczkqGpnoGFvGIbRDHl1JtGGRXc87QKrnQBp4mtR1UjaT3rZt\n/jtDUVxzwU1RpD82/9kZYLIJTQQ+6MKO6wbw2F1GL0oGV8xtQlqwGzEuGSAn\nTGV95be6RDEnq14Zh32iJllK2eQza8Aq5pOU6pRkyH5KnNZIXIWkgUBKQLmu\nkfQRBvdJ1088anDPDZGxthq5wOqu2tRXszK19HxCUztpaUdg7Y04ole3oFdz\nrA7ExH8y2Cc7Xg7r30+ovWnqLLYBZRLTeWKFSNHoUQ0qVYI7SzCOb3iOS0wF\nCtPbfcCFncN1W+y1zeVTY9fjhkkbEvvbsVA4hsRQ/t20Jl8y4xP10IJDMh2M\ntjZ7y5tAJpsfKwMsKJ5+Z5cxIA99sxuGWHQCIlLVr/k2RZvILv6pG3T+OKJP\nwbxEqBT4O6+tkDsrsd8KeZtIuk0yyF9EB5drP/0tykH0BNx5Zdl8mOdy1v4M\nP/Fj\r\n=5MlC\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCZizGWa95Bs1ItTRdn2kHB5rBpoKqcaJ1nEAMshnFWVQIgMldyBHPeIWa38XwtA/9AodqG3n7tBEffG4FpuRRbgxQ="}]},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.25_1604063568322_0.3950884006000772"},"_hasShrinkwrap":false},"0.7.0-beta.27":{"name":"hardhat-deploy","version":"0.7.0-beta.27","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"3f81eeba5bd711d0526fa93119dc8aed39783393","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.27","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-woF07OqsTh+I4HWd1pHzy3LHBEb2JvQ+tFd41nNMNSHDNXY7Cl477EvxSmx/z4HpOuI8AvLPsgeCS0kzLGffqg==","shasum":"afe4a793f8fca01ce42520cbfaa8e30c82ba1235","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.27.tgz","fileCount":88,"unpackedSize":2241227,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfoQ2dCRA9TVsSAnZWagAANxsP/3OPI/jg/2lC+oSPZadY\n6iIleRseNfXYyoW5dktTIbsYRs4R6NO+Tif95UEUoAYHHWhBIRZxwboOT0v9\nHHholCqTk0H77h1+r1M0gaKZ+bkED4gJgiFRt3vsOzaCZ7vGLg1M18rMW6o4\nIqQCvgFimJhbn62YZRqW3Bks4lQrATQI+p4mYRJidQtDvGSMWS4O36zKrd+b\nrtClf/Tqum3UkOqyCcU+qp8MA1JqBx7DgxOXGkzZS7URzujKzNqA2HwS6AAz\nCKcXYpeCLY3POoaxJkAT8xEnITEltLb07mpKHl6XQgiArjWxo3gCjBHJfnZF\nZm+PowVN9PleFIxXssDbGRgjDOEhvsOdoKI4f971IvG7znkaQQfHqalWiD6d\ntuibN3dPNjLQZIofZtLqpi0LkpaGoNn/ejJLxO1ocJxgmEfhuHhstTdo9d6m\nfR993f2Ljz4Ll84EBuQPrXof/Ypnp+wnAmr3oucIvKQzVX7NG4uCiqPuO4l+\nWY2C1qU/eT7lDZF5+DXPlvSWh+vQanbWN/W8fBj9GpJTfdKGPbM5MIdH/c6a\nQzcJ7+u/uALUTm4Mekh5NDyruXuc+t8Ovzwuc78tUQeCOZWHCyrEV/x1yRjz\nLP9y/XmhGKIH8ZDBlWMb9zLXT4Z63vKhYeLwZF9KVJaxOqOx5GlpWPuDnrPM\nIzX1\r\n=V7UM\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCQkJ6GymY0nCpaxdOzboLkY2nKR1HqCwPM3LpcARTZwwIgX9PHKggD9NCgPlhM1L3WKuEZox/EMXNwivPvgkzsWqw="}]},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.27_1604390300495_0.35553879951221834"},"_hasShrinkwrap":false},"0.7.0-beta.28":{"name":"hardhat-deploy","version":"0.7.0-beta.28","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"665b57c0fb76f129b8660611b05682003fcfbb17","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.28","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-oWAVa636zyOXecvLkZ/hpph1PvqwoK0DnqjA21En4amfTjLx5Do6XlrGcNJAKrH9LRTnfg2dc7zmTauBqFM5+g==","shasum":"e71dc7d7a97903773c717818e8ecb7eef8f97a5c","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.28.tgz","fileCount":88,"unpackedSize":2245714,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfobm3CRA9TVsSAnZWagAAwNkP/15oOlW446EHZI0j68yE\neGIXSJNfScWSTDj6uXKA1ElGysuMl+RM/PlWbA/4VNRcpAQuC6PxIu+oX0GN\nlEMVNRIu8xqVa53pwEdvusYbGhpHirsQKnAJ4KPc01vBMyg72IhA8rvHbie1\npnndBZrsNA4Dsqz2oJIBONZ5ogKwlZseT603Ty1kn4LQXALMLnBv834XBSEp\n/aMfjGGJXJg1CC1mUtzApeq3pUlfPTBtUwlX59mmvRxlg0uMHvZLmi3wPP6Y\nBK/j/zXfmNB+AhT3kdQ13wLEr2EwaXIi2+Wl4Fw7qNsGnN8aSMomOMd3wC3L\nOVwctNAo04D3hPt1vriuP3INUgalP1Ka0TqUbdAggUzhPcyj8U6EDrIn9AqI\nOVDdDi3ix0N8ZtzIjLDSwIeq7RwrmMBekptUMykChqG+1SuZdopodlgEt7xY\n/+8LlRScYwBhw5jIGXs0NCrGWxlicMRHnw1bBrWxpOvcIRQaUsd2/w/qoUGz\nlPwugUfxhrFSYxyyLHT92SxZoDRQ3B2ecGgqEjaY4GsvQbBottcDEGOC0/3H\n9cX0wPaoeIqeV8F+rdulSmc/lPlMPuknAoXC6BluXmw3tw5AqZa8E7v1j9WN\nLzVQ/mz8K0vE2QiQHzFgX0gsl2rR8lXakmBAet/NM+pm6PFYEwnFbrsMIZ5C\niXM3\r\n=Q4oL\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIFEK1M6ryNqwWM689hNGlRSe9x+w3qoGOZmUaPLeXzByAiEAj85IsbwAV4h5187LAKu2wlp7dSuudazhhaPeRUECXiM="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.28_1604434358986_0.10960852592513848"},"_hasShrinkwrap":false},"0.7.0-beta.29":{"name":"hardhat-deploy","version":"0.7.0-beta.29","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"a04ad266327f710693357abfacf29ee4f1af56ac","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.29","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-9p6Qz43HuuKJ4mQcgZiA7g1nJ8glG66/7jmHge2G0PGm86OM2MqZyT3HeaXzp83yHGZwunHGuV3KgQ/T6g/PhA==","shasum":"ac1cb368a21296eb0a675939b5d80eba7d299ac0","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.29.tgz","fileCount":88,"unpackedSize":2253964,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJftsbMCRA9TVsSAnZWagAAHg4P/3kFbAzxPDYoZ4dE6npn\n2vlIupHF/dJorkxF2o1ekn0qsffIBFgGTLO9ID/bUsXr0Uua9cQ84eCRGTvB\nNS+Iv2h943PHck779+OuWRcn4op9GxO+1O8sunM3e0O/pvByeVOg+bigAwJd\nLjAjlgzghnJ51H3z2TS7/khC4AC7wYGWNkcvlPQRNjZqwj4QnIKYPVCBEnUK\nZDZdaVbjy0IfxX6hHwKz1cR+at9qOmqRRSGd6yjaoLJMSEgnxmVV0SFI2fyK\nRqSMhnxIjmW8VKngmGg12ITnYzESF1uVRpNis9aWoFlEd+Kmr6Tcg1ylLEVn\n9KV70dMYT1ZU1XZ3x/p9jLUnSAxkhi45TbB8n96J7XXtn6yPEsAXW8SCGOCU\nCaR8+X7zx6uOWG9pWuhgaZZnWnvPlnBmV1yIonUVNBZZrOjyETKm18PsLw+A\nifrUKd1pZ2vtWzEhxXBJgRA3rXu6a6fxvIM3lIkc3IUChmnqASOiuaWUQteD\nk7H4eXTT1pFRg5LAsHV+A19R9AliE8qs8V0cUW948nBfBrtj+NeLH/6y6UYi\nbXxearWQ9pvTmJPSPRL11fruft9pfIZL8j6/6FlivyQc0U6mHniwY0SftihG\nUT9PaUYw969CiCrpZPDqV7Jv7qdqc+rMG+HRpAqMA4pxPFHdvrCg6fwnFYJl\nFR9x\r\n=T4D3\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDL8ohDtnVef0RwZCGVSSP4FtTBHehzB4qTUnyCTiJ/BQIhAPZnieF6aEfkll6PA/ZsYpoVHXEEyHOW/Wf5LGgJ8pwG"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.29_1605813964167_0.5906795997079726"},"_hasShrinkwrap":false},"0.7.0-beta.30":{"name":"hardhat-deploy","version":"0.7.0-beta.30","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"69be84bbbc199f8378ced1a415b8f6354d18d8b7","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.30","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-MColmxi+Ni3Savh9zDhfGD8EI4dUpaF6yUiysXZkv8z7HgMlL6Ho/2c+Z1NEycf1GTJ6p07YpZDD2sLfY3qwDA==","shasum":"51179ee9cf4b93bd9a84841fe408a326bb3d719e","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.30.tgz","fileCount":88,"unpackedSize":2253929,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJft3ltCRA9TVsSAnZWagAALo0P/RDuUOESroIj+SBNkyH3\nmOt4y55D/pXONS2g8w6VK89MicwYDZmkJbkGUDMIOQva09ULG3vnujw/PU4b\nrYyjne2PaSZ9SXyPjrnzPbsbBntN9g75apvtiHl/OxSUUWObQGsvIUXL7BtJ\ngz4sAuUwYMQtKWsTb3RYTyzLhi6mpvXbzOA+TIC3QOpTG7Rc9kh/IhYl9Gw0\nSdw0ZN2NtJ2e8A1IsoEb8anKKS3FHME7Vjr+MMCOkmiBW22A+gssjOa5Lbyu\nWvpxGHq15o4tlQl66VAbqSOapC4W/EDilkDJbg0Zry6c6Swbvh9UKDprGbTK\nJD9hrlvOnr9Bci/8O9ekwLN8rm7uKbNXBOQJmEfCyBukMhSFSSMhz0xGs2hz\nU6Iwc6Ord9gpEZOCNufn9BweZBVfv5M9t2iuq8Ts5o5XY0OqgPHyXb1TSnNe\njNk4+suQa/eaBlrOKkMdmthXEVKFBRYyhP3elVZBIxBF5CHOdEUkxAHYqzYR\n6Fuyw4o59Fgmq97FGMbMJMn7sVqjorWm9wkbESkfL+zX7nClcthBIGvjEaRO\nmk0MQlTuz9bTJUszG4iFwjWcBmGMO52tDY+nazvxZdVWKo2bl1K2yAvXTLZa\nHcU8FWkPfkDygqpHE/z7Iq8Xmue8Jc+l6BJEvRs8y0q2S/TpiJFrKU4MasMH\nTT1p\r\n=0gnN\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIGgu4LkPhP/ojOWXIUIK/vmpQe3BROwmPsOC5xGDYSbjAiEAv/5BACds0hxRW2slwaw/m0YIMCNj5af7rL8EdC5CR4Y="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.30_1605859692450_0.5811747128873384"},"_hasShrinkwrap":false},"0.7.0-beta.31":{"name":"hardhat-deploy","version":"0.7.0-beta.31","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"7ded716d0cfe525f3b95906aa6744120b85a607d","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.31","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-QxngVUtX5u5QHHkW3oTQp4ZA2DZVI2ERQ10tGDxpewRzC3tjTDzcvl3IvOeEASY+bVNNflyNj9LmJDUE+nrO8Q==","shasum":"6b68ae9f4d5df9bcc25782ad32db1e68312cea2d","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.31.tgz","fileCount":89,"unpackedSize":2302414,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfwV2bCRA9TVsSAnZWagAAxkgP/0xQj/PMoSYNvCvkHWEv\nz9AOLxNdOEUX247gJFIu0ZlFkt61B8mHLH6qgM7/6xSGEvyoBryDQI+yHmoc\nHf2yEeOJL6meE39CJOrJ//XWMmD6zHsTJauKXASBWgbj1HyFQWiewqyKHjZI\nA7dX0DbbD5CI2W59eLy+8nTmfRc8oLiYheTONrvCdWuqF1a84gIFd92XbIN3\n0EJ0IVQ82VQyxnHgxaZJ2aThKdpc/yW9sQByYpRBQVdcOdxAtS+x6NmgdoPo\n9kdOxsOWVqSo6vXF9IWIVn1zGk5PyqM2EuTUxcrGKzLckjPzqklXqoiJ/dCW\nBCRfyd7z6EgP4mhvXsdgRl5eCTPw5UyvmUhFfCQAz9uh/j1O2MzvRzU729OI\nQYAbBHKP6Ja2Hijzvw7pZ0ina+x3cC/6IolxvCbcW21/5/W6TyW1EOdz3GV9\nXREIjGuZ3rufuyBkxkFu4VcYThcoHPSdjAmej5LoNrXYK/FZcYIDBfeO2h8J\n9dAIwh/qocyI2HNKNkMX9Cqq9cUmitJTLMFcykn3ArGJk48G6I+IGP3VBpMz\nvEUMe4bAsQhwJ5Hq0JawsyLD8gwNq7Esq99p7nRSLBFN1toaUfITNwWuUoj5\nT6KLgfuDGJrHLFSgCrr1/vmsoFMYc/7cuz4guSo+56MQb6C5elgvCQUDWJxd\nKE8B\r\n=UqYZ\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDe1hP5Mw6vXmfDOTu/lWAtwWOLfAKa4mnKzOF/OkNE6QIgAeUlJVgfmxBHtljRJ8g+u42yU158G+Vi1OGIvqeKwsc="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.31_1606507930418_0.6321530084840099"},"_hasShrinkwrap":false},"0.7.0-beta.32":{"name":"hardhat-deploy","version":"0.7.0-beta.32","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"b15b50f062863b27e6c0a34638db01936ec08b3e","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.32","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-po+vW+gtmqls/Od1kc9btDeza6sR+DHbVi1KaiS5tgYLyCbDnf4Ih+2UjGQMDsaJbYxK/19jOOf5rfRsOaTAzA==","shasum":"24fc91d7cda12be3ee97f929db8bc6a629030f80","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.32.tgz","fileCount":89,"unpackedSize":2302478,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfwhvjCRA9TVsSAnZWagAAgrQP+wdME0njRjVFODN29dwX\n57KwrNf4QUhsk7z44Ju88aHmpWRd2BFE5qxv4x8vxUhkRbvMpAMNAXIHH3la\nm8Gru0FnAIlYE4ipPL+eyzRYzcsq2mzfRq7sgUsDzb4QhMYjaYNN9v5KjrxI\nyWvJYBrhsAtTXdSEqS3cfCEWA+kBYELDS+0ggoSpeFXT7cJ+5I1Pgsiqr+gP\nNk27XKak8NI6AD8vzbNmPyk+2GH3Xoji2CQ9CFfbvzYkuHDmS5qJNtwKROJi\nlBcAuLiThzK4/XAkS4k1+GC9tBjgeE1KGD+QylS8GqCAf1DVDDiDTukxv6uX\nxbeDabt25QAc0a7Q5VVMCRPSSLXe2tbacU2rQABoSOmvA1RHhWUufQgcbHY3\nVzTNo1iaSkkEum4Tax/DMMc/E3Z9P28zIk0l4sPjM7ZKpfJzjPc1OKyPFqUQ\n2+W6HVJ2Xu+vOfu9oVeqlekY+qszMhfPAhgiG1k1k6MSF/fAMK6ZNYksSFqe\ncWynaWBc9OivH4jra3JPGIVjRCdrHZi7vIZDKV+0FOgTozBkxu8fw67w97OF\npNP9Jx9AXu5uCook6NyURlfAzjBjO4tgfr0dMyzbydKaO1gwW2pivxgcmWXD\ndZA9G9QC+WU2tmsEa5GMmr1yj6JSMzpcwzAYYKa1FrYhUeoyGCrvrXHTXIqa\nIwIG\r\n=Ikqm\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDEcX95p3dlUIdxOw4gWOh2VO9QZznJpNqGtgFCGe7tDgIgA//PqnrTLbJ82gwgFtC7TURV0WMcT6PaolCdxUBxZ2M="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.32_1606556642530_0.42033396201101136"},"_hasShrinkwrap":false},"0.7.0-beta.33":{"name":"hardhat-deploy","version":"0.7.0-beta.33","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"5b89a3be4eae41185196097c2789607503c546cf","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.33","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-cQBiH/SFIIzgYOE4drAOrtzlV9u21bqfZ35jC8iMvKr6rodLRbuojsGO9dKTgyZBTn1LLAhr2XZpNmPSYY0/Xg==","shasum":"3d4d335b3d4de1eebe570d74db7a25098be1bc9f","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.33.tgz","fileCount":94,"unpackedSize":2315196,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfxTN7CRA9TVsSAnZWagAAztcP/0kF5JVZ98eN9vAo3a61\nQ4pTwKTfOpd8tIoaTHq5sssfdFrWflUKMgeGVfGBXeK8vi5b1Uk5U8s/kdpV\n1WPTbF34jxwpe/5lVdDo6/Si30sV/BNsDZ4loceIS2JAIlGxBzc7Wan8HD4E\nBJS5kavjXi8K4IsT3Q0hBX9+5ezJ7O+Kn662rdT7kAlBCJHZCdeWxMSfbxo/\nYz7EMSaJJIf3JkN71fWPSij9307+h54SasRd7G9OAr+VPR33w1IE3EkVGt6D\nmYRayHAQzhEFYY0nO+yL0DrEKbdywFUWk2fzU+/3arpbZIlYGI9MYhNmkTDa\nMi+IQgcVvdCNsFTL/D1gA6Z+fJqGZzbxytiuVVkpFNmd35DPeIF273yt9U04\nxNZdb9BjMLS7nLgVNKbDrvGHr4N7xTMVJQEkXQMQrwOj620OzbhWQ6SlcW2Y\nSVGKCvbCOVmO4N4829GpLIH9FZikWv8ODUzZr5BdGGXduQh2Iidd5WevopRB\ngVUD9vxpYHoKorUEI+XGm+TpMDQG5zYhjoELtfvwuXoM1lnK1DWp3lYyp0/q\n2AmyisOp61Hwzjg/rU36910hKNcfsamHKz6nKtPPapWILrTE8Kp3ju8OVFk0\n0BYC+lE2K8c8eEW6nBnAVdqqKJKV+eYoBeLWy18HSiF9xdRQYgEF2o8srzRd\npCG6\r\n=Qtk6\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDX24kjqV9kzmmYbsDKpWIM/CawGAqbP34duZIwt+OLPgIhAMWl6HnS23TqfOGGR+X9yioiO2kKRDqlllQrNUBKHqnH"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.33_1606759290725_0.5079812785259334"},"_hasShrinkwrap":false},"0.7.0-beta.34":{"name":"hardhat-deploy","version":"0.7.0-beta.34","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"2c7afa42f7c669a29d7fdc5a38d12a0c18b73b60","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.34","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-zCa7BDgHCyvZ4ctwfzszikeVMh1GT4SyYqXh8XrxOrJ+BvG+Nk67gyV2MwhBwUenlWc4KddMoN+WiXJSkgqxRA==","shasum":"0920e66c1f328ef5bf7686111ab5ddd574c069ae","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.34.tgz","fileCount":94,"unpackedSize":2314844,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfxhlMCRA9TVsSAnZWagAAXeQP/RYnAGn7vRf/7JV5B3Oo\nwf5VmAci2GVkCk+a94DX+hTt0sKAZXYTvnSu9qKbL9ChMbtIrPstBLTkhV1J\nCh3QpVIg9n7r2SVRlyzgPpch2wqfCDZAK/DRq9tKNmcgaDwdGXFgHL7H8UMW\n/D5YgPnUVsumKeoI/xjDjduT+V+QXR3MLKoOlkgmaMtw+0VI4aQOWXBhoJXi\nVAlwHR0kPYm8U0hoW5DzWdVB9iRIIBPXm4tyWrb/Lrli3DQZsBr+Ej19YGZR\nWWOqk8fZ07n7WLSRN9hCSxVA1Bx03btFl9fuI9c1nlGPG9mrSUTRO19GrUBF\n/oUoD+X8RZ4UzaxF00YGDcY+xg/zxCbGlOC+RVsWi0SUZM3yyiujIAZJEYSy\nlHVvh6x9XhhBvxKtZxTGBcguyiDi0FirK/rEclnsE6eLy6nNC7m7RVQInmU5\n9rOIgkYaUd4x/tyz/GqANH1ZgKaMp8SBl2geNs5phPdU+uNt+9bYDrmKEgLS\nemFFmgzT45QyBb/Wfe58XO4kuuH8rF52kk5DqTguCsJRduuWKuBFmn+fpzoX\nYU9bNEwvsXfFXGue53YLapm4KTm3NZZBuMJPc7PYdx8CUDaBh6WQxQu3xd07\nQip2V9Msb+TfjNnGRF5TOfeTPYrngYTNgH6bg4G5a+UWoSFh/VyGyzxwybzk\nDWZM\r\n=jO+U\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIAMIxychLkCcM69+X2h2pnEsDDCFDSN3sWAz9fj3zh4TAiAsTn3DNN+EsJyCaPtrWz2rymZKsuU4F3J5p9lTivRD9w=="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.34_1606818123534_0.07350835856055715"},"_hasShrinkwrap":false},"0.7.0-beta.35":{"name":"hardhat-deploy","version":"0.7.0-beta.35","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"fc524e609ee1c8cb6cf14dbdba7641b947ea6429","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.35","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-5l0k1xZzrdRZgFGHEGfgypM4PlhqyYBF+ToADz8oTRH+7fwWyK9424MA6qI8z373Ogm7Y0kUQTRqNHicYrepAw==","shasum":"64347ca80c678811db419db6542a699f0883a5f0","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.35.tgz","fileCount":94,"unpackedSize":2315051,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfxh1ICRA9TVsSAnZWagAAc6MP/ij/rtNyEYmUBUXu8fle\nQXuoz7ApKnzibwgdMIb0buGNSCJ64jGqLq5/nazNQh+fPeQZgvYhfRzDEtrw\nbD7W2D7d4zfY9JMWkd5HyefcPghV9odZO35GUEWyzRjZHvtCw/ti72APNE4A\nYOefyaOZdCWJLZP7w4lYs3xP1e6UlvQ1Vqlxz6VedOwzlPeNo/CxCJovgA25\nZlO4vAY41SQxsSHCR6G25vRgOkiVZalo3TgArenLrPTRVNdtQ+6h7VSpRNq/\nRdg4NGpJFTeamT5uCsSjGnCWJwf1epPp06CsmAOTbBfx7bMb6QnXdJzQ0HFy\nWBecATEosCHNrtk6EvpIBJEsv05gnz83qAdYlASdXsUVNcIdTa/gc0njlXpq\nzGNBwxpVsuM1AHUpWBYbfAYrakDcsJxh30jCDEapPOQM46banE2F48tXcyJ2\nF/YetwQ4/cqD4s6f8lLJRQpDNTeYXU4+Md/Oj3Mhe1vr5bKkcCwhnXuMRpyb\nrZF2KMwrd1Or2qsNHlXGcTIp6cwe1WegRu+t/ej5mBQJi5HGvf95BUPH7tz7\nDg5JRdOdBgPTYR6OScfUMn1Hk2OiZMemfJUF0oHC3OhoZp5YnC2Uxpdb/kqZ\nExiyH20yuq7Lhv6J8UYhiv8TZ/D80H1XzKQeWFfe+aceefC3IS8cMRBp8hci\nyOWF\r\n=4Llh\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIAp0emzNEX9hG7b6DTwrCFG5ugOFVdiP0o+Y1TruF0XHAiEA0oNY+qR+AfUsqXrj3SzIrWeyjLNOWzi0M6sVmsySpAQ="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.35_1606819143408_0.9586448960422453"},"_hasShrinkwrap":false},"0.7.0-beta.36":{"name":"hardhat-deploy","version":"0.7.0-beta.36","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"f8ebefd84944b70d8a8e6effdcd48a79cc82cf5d","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.36","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-Hf5z7374TuAceHPu/bEl56iChBymX5UFwr7xqoHy/so92kJbUXMgImJSpv/wYWcNQ4qFDptfJmtX82zNT6angA==","shasum":"5acf6d90e778d43d9b5e9ad89932eede0d52fd8b","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.36.tgz","fileCount":94,"unpackedSize":2320011,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfy1fXCRA9TVsSAnZWagAALZMP/0Wd9KHAuxCbo4UNyTXb\nOirz0iJKJM8Pol/GYJIf7cwFzJHuuObnr5i9x0G/oLZ3ZrykinldrGG0vcqg\n4G6SgDy+Q1leovwAGWbvJfjtMWZ4pxXozMTd/jQ99jqImKLRm+N1ysCKpRoG\nxBW5lHHXTffpJq36NIAPzBEnAAEcakk5Ji5KTAuZKE6D2+ywyhzTKKKMi9vT\nIAtoilmEBQdRAgWdd8wZvYemfmxd4hELt2A4ZLmi7QO7bI4D8DYvNo17Vh7G\nMhwdu0o0N+dOkup6eqmXNO8lBzy2llzWc3d0yTNfOZmQbreR8JIj2Ik/jOgT\nWhkX32qzXkiU6IyzozeTsmhXbnD75wrlRbJaUjzApOH9J6GHZXLiAGjHytgo\noT87dRqA4THlZR4yETbf7Z0EDPSOqMTdfoV3qyYUYn029ki9SrsKhLgZX72G\nKv6lnBZSdHcCHnhEdAaQYkqkjUO6lhUhx/lj6XTeDgz5/Mj75qdaNyrDp1Nr\nihW1vJhWF7ejGwI/TR4yD6YDB4hQIUUiKZVmXv6wRZM9sGNbAJfQZ9XChk+/\nJg5VTMR+TnANqFvd96t4uMf+QGJRj6NtgfQOEpAH/GuB6Qv95nuQw+liCQVG\nCvHfSBgpFFtZXhkRjc/kXRtkRJVB8FyTxEUfUUTRD1JarY/8Lt1AExc6r8u/\nMSdh\r\n=sUhQ\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCGaFa8KM0HKe3EppOVGveRFcd2c1mAFJ4JAxb/8VYWAwIhAKshhaHkFup+LIyxtuoLnPMoZTccxUu+ojGsSR7JxB/h"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.36_1607161814653_0.6833939949438044"},"_hasShrinkwrap":false},"0.7.0-beta.37":{"name":"hardhat-deploy","version":"0.7.0-beta.37","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"18405182c731fb5e535eb5440884783527e0caac","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.37","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-s4+EqnvhmUzfO8en99S+Cbx/wi1Qz7iGQwhutlyaVt2A8hsgmUvx258pXPtDaIsW1BC40QVfVRlwF4uS4SJwww==","shasum":"d2101ce3d13620f443564e4bfe47023356728803","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.37.tgz","fileCount":94,"unpackedSize":2320802,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfy73nCRA9TVsSAnZWagAAIVMP/iFULf8LY9btuhEFTaLW\nlWV9qt/yPyHZnmfQD5U/yND0vdCf17awDhThDrlK3bNqrSq96K6gzgHglBYw\niDoc8vCgxZiiPjQ9/kccIm86g9ThTNc7+Jp/13ZSYaQyCBgBnG4fXwAJZPxl\neFL/E+EXUq9KhLlnp1OjlambHaBJLK6ggay7On569fDPnYBx3RO+1WeOzCRb\npPe4Y+rbB9VYNw0ZSSQ7lPzROpzDEmiQwejFRa+Vj2iHlPpjNA2Y3zvCU1BQ\nUUad+8ug+eww9k76iR64QVOwdz/CK075cknh/v8ImstRe27qMInK3bzJTAXb\n7ed/EalQwh6RAMWmkAeiY5bieSfcNuZ1CNAba/cnZyzT26a3OnEy9I1rrwVM\nNK+heU1FouApU4o6G4q2hSDrZyplBSVaESLF+CH4m/egWZAuVbgSiXIvT7b+\nGaT7NOI4PK+vhoj2hFKwcFn3dov6IN7j3YrSRg6NhQqh/XOrTf4LTMQJPPeJ\n1xsz12iweV3YfxUZwTwv1Mmb6RwZi3mgC7RpJJ6hUbNx3MUsKDcmF3jWuKiQ\nM2CLg2p7c20HDisXxZw6nSWl+AuocsmXGz1njjVlza5B5GMz8U7M095gTC3c\nv7SMpWYatxnN54BWWbVHXonPmefJpa9RJv3Nee3iDhWTieG7L0vRpqpyuSp3\nNfUT\r\n=ESbt\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIA9oxtYTfXJTn7+doQeuAzpGBKnjfyOyC4/ZuZlAoRy2AiB6geCwMlVkFGyIE70rhXgkgaKrYz/L3K4MKZkoM2qBpA=="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.37_1607187942815_0.7733682791616454"},"_hasShrinkwrap":false},"0.7.0-beta.38":{"name":"hardhat-deploy","version":"0.7.0-beta.38","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"4a03db29065eb0c4623003e1e949a78656b2fb23","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.38","_nodeVersion":"12.18.3","_npmVersion":"6.14.6","dist":{"integrity":"sha512-kXW11G5oGrZDmcWtVYcYXiiYrIrWkpPs8f+zbHogOy+X0ot/RicmS80tZXBIU16Enf3t8pAVhu85t4cuUjUUIA==","shasum":"9ad32e78aabcafe2180d203d2b46db037839f593","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.38.tgz","fileCount":94,"unpackedSize":2320962,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJf0K27CRA9TVsSAnZWagAAgJgQAKNzZHqabrbIc6KHDdNs\ngCwKHXotnGL8J6xKOUVKWhi8vkiC1L8r+62r9Kkna5T5T9OAyj6joCsa21Nn\nmKMkp/MSz2z9sbYB+ai/OS47V+Hm8hxas2SO2c8nY/skdfzCq2UWKbDF5oMa\nn0j54EJu5lvXGSho0SxmGmprLT71Rt7OaV6JCQ9CstsZshjV0ZN/GPJMaG62\nSKWIaDcdLRqLTA1hHDfIiyVTjI01yYcYhstVbVc3rdvp8CBVCDVlC5aDYJkl\nUGDrQQc47juMFw4fRqmQHDqMViZReOrJixC2zaOjTSegqr3bJLJ0hURdQU6W\nVlluD+5wk73GpyvhXbJrjgp1MqP9YbCdkIKy+OSXEsPl6t8AyGbEDIez1a4o\nhu9vd9fQ11RsDzBXE5Hrj5HZNUAW821KT42R4q1TP3s1IHzXjElyYZ//C0Er\n41t62xEgRsMPxEjf448VLhHb4Ra3cYedJJOZCgKe6txzxjBk19aUHeP7m4/k\nCN4b2xMMks/tmJod/FNAMtJ0zlRc/N28DqXgP+w+njgcSWbfNr+UNdVcuPOt\nvszGFDuSZnmURbcCsLn1fWmvaD1MMtiAXrx9sYFLLnnH1SXEKJ4GLujEzRun\nyMRoAgSNMDgilIsiqSra+7PVDoPCJapoFGr2psRLK9Q9mXDmBN7gqnZlCrJD\nHLgs\r\n=nXhT\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQD4Fa6dtN3umA9ZWGew0qDE8MxWDyIgh0pwhbZYs6g+OAIgFj+jMMdA6k2Yti+26jJrVuwlHCSB6phFarWWOwyD2nA="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.38_1607511482984_0.27757260166758013"},"_hasShrinkwrap":false},"0.7.0-beta.39":{"name":"hardhat-deploy","version":"0.7.0-beta.39","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"0a8fbc3e45a03635c1dc560138b64e40fda11dea","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.39","_nodeVersion":"12.20.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-CBsvWkp16n6FGQxXw4A9rC9ug6P26ophUTRyWiim/sMITO7NAlxWTVNWCu+rgk7amDtkEfJ8PSMKmNl/naRNAw==","shasum":"3aeab46164b0cefc990dedbeb611236080fdd122","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.39.tgz","fileCount":94,"unpackedSize":2321037,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJf4w7YCRA9TVsSAnZWagAArrUP/AvMvILa+tnr6SZfnP8m\nmRBUR+/gMwCi38KYzJCHO1i4PYQ2lce1fd16zbR/B9Nhc7Uwr/DvpLv0xmyJ\nrSyxHhHLj0qxAJJWc1l4wmfYSRqYQuz9jeQ8PyzD9OkR5QV6DQhUAy+jfw+B\n2hEdAPQURFJV9d9mlzh7PG7jJMseX1et4cYHuua2/Lr/QuqVwKm/8YD+JEFz\npxXLSvD+5zLjbN2Jfh9LJrTOSJuZ3T/zLLiCVZjBz1hP8st+EZ9xBzaMgkTK\nMs45ATezggntgViq0ROWTwTWgJr9qa+a/aovxYcQoOWMh01eOcMVeNTKQ0vn\ndB0nsxo7qpReZY7i9hOa3y6PYOoDr5m/i1UsufayDLRPqGuUEB9pzfxbSJz6\nhKo+rbS7+c0udIiC87u6s+g2/DvhdUsmKQ+coZlBPhtNhzREHBWArvuoNJe9\nolfvZvf/VfQfu/KpNMpf4wrxzb3DMpneJ69A5BRhNE3GlTxzxrGKFIpyG2Ti\nT9zrIghdxFfgoDFLla7C0LBEuI4aL4kJTmKfU7C3zST5WUnYwGpcJCXbemIV\nia8K3BeQhxB48Pj1N0xTdGMLC9Yg8JGsYX6EQ/m/LUiugc3o82obKQsjASRh\nG4nBqyQPIICGKUIX0AzM/xwJYEwRws5+OuZ+fhTRTdDprSgklrxj9YpSc1ID\n4bcL\r\n=xyJ4\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIE8zcXoQ7uJB0IgigM/kWflaSQ84n/Z9SKGdYnvbVewOAiEA8W9hvSG0/+YNjvnEN3gum3Ps99MAN+iLZDdu/MdkYTY="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.39_1608715991839_0.7312024299379118"},"_hasShrinkwrap":false},"0.7.0-beta.40":{"name":"hardhat-deploy","version":"0.7.0-beta.40","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.19.2","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"8a215f6df7db40364af0e8b4f1577c8e8db12992","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.40","_nodeVersion":"12.20.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-GW/OY2gTgZPSlRMI4uToJfKUET3gSNlMpGGI4rKHeqR56mUeT32ab6e7q6UYcO7fleldx4UTRUYeyizDrKe35Q==","shasum":"917828ee9288e929e82437839946621ec1c8cb46","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.40.tgz","fileCount":94,"unpackedSize":2321964,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJf9ij3CRA9TVsSAnZWagAA9rQP/3q7WWq0GamhbOthhCON\n5XqbEEv1EZLEXcMC8oBvprrpnaKAWhXtWwkz64v5VYnNC3pZK6oGHngH3L9w\nhMKaFSOAiZDpy4yENGm7z15hyy9HLvkgRelP1gwxfaiR4O947RwwAoX6TxAA\n71/clfo7cUJfO38Ra3F2ZF0Ao3MqsCe70FMGuzrkwQqNY+Tha8aYRt2ymbar\na1boQEoOF2jemuMCgoeSgjzC2qiYvlDBkmOstcRtcduzKYr9/c0yjeHkicBb\neK8KaQAWGmxeiBzoBqGczZ32k+e14vc339BaYXwoLbhIfiC4lbvbT/A4/X9T\ncGgjGOmcTRQmbG/H7TlPjzVYjgIPvfVvEM2wK8Y50fFPNfDpkIriI9iN1Jot\nIp2RzgAADCEN0GzSvRPbxvNiH1CmsnSS9OT8e677H0Jj33z9z84nUUrSM5Xl\nDZ8HVhdJvHIzCESo5q4lTT1o9g6d0jAWv5LDAl0/w7A1RTRYsUL1EI8Z5Jep\nTDfTgFJF4c7UaRPM9yfQhjicm5SI1zMIaU0Yru4ABUMAjLAwIlhpclyXqofj\nSuw5sW7mpqpa+SbHvWF4FV9HAVenyg3xBYCtiZ0wsm5PoZr3rQKmdPEfmlAL\nGXsQ6xvmQC22y3O+1XNf2euVjKnDahXf/oXd6NMnY9j1850weKdGwMBhrGH2\nr3ra\r\n=wWbX\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQC24JAXyOjcKG0j9BtofyKV6N1GuOHfWeRJMwtY6Igv/AIhAJ+rQqIQMIpk1CmORnd8R92NRo7CogUVESYLfRI6cavi"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.40_1609967862684_0.9563424909519616"},"_hasShrinkwrap":false},"0.7.0-beta.41":{"name":"hardhat-deploy","version":"0.7.0-beta.41","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"c5450ee71370a520a1d1ad600d6c36a79e980b57","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.41","_nodeVersion":"12.20.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-8xgRRo2UmQRoJYFibSmSauZDP5qVtGde8YAHYDJj+o/lHw02eZomKEdLBGTwSmQJpKJHQbsvL3MAXsK1BeS5JA==","shasum":"14f4c8934f6685f80ce4d21822038b9873731e52","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.41.tgz","fileCount":94,"unpackedSize":2322039,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJf9ktuCRA9TVsSAnZWagAA/I0P/0vzi+jbSiUiXeMbWsU2\nZeCpXJbd+nSyWCRBeXsbYgbq8blnqw7QjzveQxZEOv8mlW/3SguF5GjL3Wqe\nNHjAaZL5mOLLib92EaBhp0mqLL+w6HkG2wN1YpMtic7iOme8q5gqinmC4cLq\njAJrwNb5h8pZmLE3RBHmGLLoiFcv8Eon/xrVpBGYd9RyozfCM2Tyd1JB4BP6\nNX1/l/KPlyd31cFgJ2j7exUNEAhcA9cHs4F4B5moPbvMqjYzu9t1t7V/B0fe\ni5Z73/p94hAWL0NQz1wN43DvgYr8kG3bk1XCplv8fvM7VipM5QJqrkogg+/5\nLG50f2Xux9tlSCwFyI7ipXJcNx33LXV8f6H0AEbrePH7rgDMmNwy2MzF6DWy\noOx385dT62vj7rW6badb/baN6yn+VrlRklM/kQ2o0R0QcjH4IMH+hppOFiJ0\nG1vwhb9B9IYs/YSyExtffVDXxHzGH6mw9uouS3Kr/4ai/jeSJ7IorrnRhfi3\nv85K/LvJea0ovZp5XJvS7McGt0CSX2+L8+WwKNaPNyWFY+EALvmC2NQ8vvoO\n9YSPImofrXdhlPWsfu+t01kloPnwBc+ZpZrY0iitAWUsraOuUbz/BUxcoXRW\nL31V5ykb8nnNFidV463hMjTjB2PVotgYQFUFoIIAcNOxottHVVtfScDAjbhR\nkj/X\r\n=Fx2t\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIHMUwNY/9mwE1bM1Ct8/asPRYi3NReIjxhP01EgJDp6oAiA9oY3VGWecr86VyL/oNV2NLc27pZ3ly93dKz80FRqWDg=="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.41_1609976685533_0.7002381168379022"},"_hasShrinkwrap":false},"0.7.0-beta.42":{"name":"hardhat-deploy","version":"0.7.0-beta.42","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"9f3b98fc233a1b40fa6fad055258e0170a9dc0cf","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.42","_nodeVersion":"12.20.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-Rm933vi9DlRqGu838dm+vsCkRvtsrp237fI+H9TAg7tuB+aUN7OhQrVmEzPoKwTBVGjbKg/KOY+KWgX/tSz/Hg==","shasum":"39fe68687b5529b3e28e8269859218d04e1cc16e","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.42.tgz","fileCount":94,"unpackedSize":2322295,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJf9vxGCRA9TVsSAnZWagAAEL0QAKQNe7qyLD+FFZIcNiEv\njlDtfv0OV1hdKcbMX9vPjptMfkIQ/w8B9HYfPpWNxcK1zso+7MMJCQ6lGdTx\niUGImYw+enAUgDHI8r9r2yAakAfeQkvKG8QPH4oQESJUUeB9/hiEoPCe3SIf\nfGYzFHyO8afiDPANnxqHxjfFFI1PORW8IAJRLDD/hy4BxefWC9zs5an4IVrA\nypKX3PFPt23HYcfaIrh1uwoeB7t/HNeO91Jy6weT4sev9HI5EfMoaSwkP3Kv\n/eWDkz7tX9U9QBdsQzp4rrYABjRI9oEOComfLyO7cr3hIkBBtdXNnpRdkeF/\ngSTr4BaMQQpcAuFWgLOfq5V1Ff4594R97Fr4NSS7TowUiNYbbbwMhskbPIBD\nS1XVeeT1tqJiuVuMTypEb98udITdfN7+pa99PCAqmUxXwIurXxWu0AM89EVI\n9qWc7WKRCmGSt7xy5pgTuCO6TTTjOt3WpzInAMW09PBpxnfV2VBvQjXCrMir\nRRVWkL9CErmzNunDE0vl2IvRIP0AA3BsLE6xpoUQQ9Wvi52yR66MqsXL9Zq0\n1+lx4uM43DrT5QXC99IqTHo0l+wC0axrMYXspUD7RIZHFMRhZ0vk3LalBez0\nM2JdW56Fpu/iijMLh6wF/wcrK5ZvuPNqxaWtrvRVhq7fk0BMkyFJ8YRwomuO\nqXK5\r\n=UJGd\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIAzOeR4vlJdvBLM3pMRcxsJ7oND5wUs0IsS4wMZZZ2zRAiBFj3Si4KsaoxCsYFTPGE/5umIgXjJRJj1sjQdF7KPPfA=="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.42_1610021958252_0.871008457389365"},"_hasShrinkwrap":false},"0.7.0-beta.43":{"name":"hardhat-deploy","version":"0.7.0-beta.43","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"1b831fb6e45f489b7783a466ab65ec64bded2a40","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.43","_nodeVersion":"12.20.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-nDaBYyfNeaAbuDx2q7DUwO9Z1+A1luPbgoEcygVoPR9TNMVyV1fKh4Kgvlw3gcR5anRvo8VJHRbpiQzponD4JA==","shasum":"466243bfe558a298d595ba9a76e8f01019fad056","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.43.tgz","fileCount":94,"unpackedSize":2322480,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJf91HHCRA9TVsSAnZWagAA8FsQAI5dAb5J6O/f6ZkRrAB/\no9YsjssXceNOaWGBykGG/n9JZaCUCiq3FPqcWnYiNLWCPsJtGE679SqhdsCy\njM51LPyjcOPqa0ouB8TOushOblO6QDDsRRMGbuyWzlE77X/QAMz1V8xtJmrr\nA6Bh3gU/qTdIm2hIFGbSy1cUpr7ZzF3d+KZ1SGcRSBlua3Cwh/HurpkX0JDf\n0BSsNY6SUTJd/l359P2DjwRPrjZJ45wTSj7pG8QPzvM5zrh/yJdh2D0RkZcm\nOc7jxzZVoYzLWQqGjmyUtZcXnqA8NelplUGXcIMgcB0cul2RIXOGT3+jq1YK\nQq3pB7lh9wakATd6ZUnwuPOAHm7dALuP2kKUDcs6PKctvPKoVH0slZVDEfbf\nkn2HZdmYQRTkOwzDMeKBkha9KQWFtXxlyaE4ltIlKBpxr0jKVJwNLS4jSTYK\n21neTAWR+p9yaWY3EQsUN1eTnNVT60BjGYwu40CT83bAPo5tddjJYrPk1EBh\nyk0XN0ZYAqmR2t4KwzOE7WAwbg7KUw+/Z/r6ZLIb143u+dxQ81GA2kOc0aW1\n1w8RIKjskh6+ZaYgrGMTQbOo6OFzTyCrk8PtB5kK/55iAKIDCs8nHe1kZvmc\nq8UZ5ln0cZNQWwZQLdRTXP12JNIoRwenaTtW1ZegfWdyn7mBZUdzqqyz5LfG\novXc\r\n=kg/u\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIBIhoFXctOQ1jpEEZoO/7fpUBCnWzVpMJK4wu94gZFpSAiAtzhip0TEVSrijhTwmEniA8U8DKa+XMNRHR02iFS6Brg=="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.43_1610043846400_0.6804268570305747"},"_hasShrinkwrap":false},"0.7.0-beta.44":{"name":"hardhat-deploy","version":"0.7.0-beta.44","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"83953c3f51a206edee68f51157158c685c1b496a","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.44","_nodeVersion":"12.20.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-eIM8RrLDgD12wINTdduYshxqNP/uz9qMCgao37jl6iiZ2LwHkNTL/X+RtTVfq/vS7bvLW7qpjymHJiak5rd1Pg==","shasum":"e03eb60765d4ecc3711dc7aadaba60c64b1d381c","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.44.tgz","fileCount":94,"unpackedSize":2323175,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJf/Dt1CRA9TVsSAnZWagAAhJAQAJs4bGpItORfsTQBTEqU\n6z6B1/tQCslTTjwRIRdeURqmHEORPktTQxRtlHB1Miu6OtilbBThwHAH4WTt\ndAfG4xrW5SPXTVYLlyApX22KOV6MZGPvWnEZ3BlopZ8HUpuSIVNe3qYmVH3V\nc9b6NBVbBcyPwJLymhqKTjTuznunTL5NecfEa+3eE5PcsYJz01kB6W7pVHrc\nWbtAdWk+wjnURNywMuuCaT6bXMa3cUhul/JrhYUP9k1jhHbkuxfy+GATt/XI\noC/BUNHwntOxi7IX+Lnjw87JDB/poHRCIzEYqAyg86YXrjmjmByUEiVsCxD/\ngHPRg+uUsarBaKW9rXSh+tF/SGubkd7uW0OisFBaER93Hdtt5Pjwy254DAnN\nNJ8YQ5JNclgBDF7yNVtriFmtp+T4ctdiDNjKHoirXoDsep5VimkWDirw8+Kf\nyO0jTu0dMwx219SjOTZzIJx70P+VHVQQW5ifjhtAlrWSYF0yf26y8N4SJuLM\ntcs21trxxdUbI0JY/C0KdvW/K+TA/JN0ymgSRoLikMjpSTFyCmo8Loj4cAVx\ngrDAVcP5ruWEZHvfF4DFIoMc81uMBQRSZYHvtVTCKqtPWWpuSqFyfI6dEyQ5\nnxMIChKy9rUNRtxAklNhS+AGJ1BiTVuzDPYDRFIC02ozs/8eYJzvXs4L4JYu\nUMso\r\n=jDpw\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCcxqpFkke94cQM2/ljlkKF84iBYaQALS3t/7AzBLAYUQIgCVwc1l6CjM9VxAdmSaucOx/IJcoVCQjoDUkCHRhFYw4="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.44_1610365812593_0.11684285448089904"},"_hasShrinkwrap":false},"0.7.0-beta.45":{"name":"hardhat-deploy","version":"0.7.0-beta.45","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"ad70a48c55b2cf48cafcae3a8d2954e21de2223b","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.45","_nodeVersion":"12.20.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-pWl11O3X92kE88P5pQfPTxpM9tBes0RGD78JygQpiE0lOFaO0vm65H1dLX1F63gKyW+IMXM0Kf7xRAwSLtt7nQ==","shasum":"fa81f3368e83b0195323da9fd04923c80e968e90","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.45.tgz","fileCount":94,"unpackedSize":2333741,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgLrE4CRA9TVsSAnZWagAA/ewP/0kAY/fUeXjLJco0uTzu\nO8WHZht6OBeC0mtE09snVsENlY8bZtsSgtlFjoaY8Lg0ofTyXUNA2biX1FJJ\ntOhaHbKuVayBfFjDPi1y6oaL+MmtHK4aRA0ZkNHdiWwMEPrG/J8Bz9e0FwB5\nRkJ+tOwadKxf0NaMGf7nQuwBE2VrW0dQf8EH3O9QfuZpWZLjQonYlmmRL5v0\nlfFpi/iyMjqRlZVzl/ZQyUrifvZA/+hTf5f2kZNA+QFuETbTPJgfwOmJ8YbE\nRrQWt5Mt4qhnjMUKXH0f9edfcFoCc43KuaN28jDgRnbXF3fncvgw+Xb5CAT1\nNAQZhVGkqQ9t0pszUBS7Y41CL9Zh1tsbjgbGtBe2agoAlvlanmWKxiAKYIOT\nzfba2jCyNQv4L1n5nBlgK5e6jzsU66JQJCU61GOisR9OPPMWUTcLAi1/m8hm\nI4rxsPO1gBB0ifngjszHA3mVi7axsuFNniwyOZT1ZMW5ztokVKMTOKzYXcHo\nqvj/lBcj7UxEV1q1gwhHyTFAXujm0TiuRbwW/FvQlNsV7YpMltNuU4/tQ+dx\nPaZVv4rYETBes6FS+hnYvapnChOhTVEgsoQds1KLhxv9267JEWmumACgYx4p\nM6aMVw+FP+Gmt+PgpRobrE+avHWTYq9xgnbNKPWV4Fr60ctH+0zqxivfd4Vq\nXL5y\r\n=CLrL\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDETbBYLeogg1Qjw5acW5+kJqGfaU+6I9GSVt4jugqmvAIgLgpvjdjONqXxdUsfbOJ9nsICiVku5EmGTeH4ZGIn3Hs="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.45_1613672759857_0.6613255815910144"},"_hasShrinkwrap":false},"0.7.0-beta.46":{"name":"hardhat-deploy","version":"0.7.0-beta.46","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"fad474bb1ce9ab72936c683cff70a9f0e4dbdc29","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.46","_nodeVersion":"12.20.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-VADqekd40MYHWVQxz3jn+C7Vtfv7qPboZZYH7N8wLtPU/ZcGvEQRgB4LBkOeuwQd/80MIXwSBOrnN4x6LjIauA==","shasum":"6caa34a534e7d40e0f2d98a26b90e154d5004e1b","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.46.tgz","fileCount":94,"unpackedSize":2334334,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgNN/QCRA9TVsSAnZWagAAz28P/1QDNrG+7i5jvojl9ndz\nMxa/xq320rtLZU2QvcdjlMN1rQRmoV8ghU7E4rUVxRgflyvV5Omw/+h/UIIM\nXwSW/Wrm2MDOfTO7L1SWGePGSLhK2BV8HP1LVtiT495NjB70sfpk68y+qhrq\nOMQy35Zbl66E9IKAjj/Yk4X0R+mFpCpZkuDdY6fUGTG20phnopDXk5pcVwS+\nTbZvqXWJjmvC1vmeicOTOXrWftwtA9oXNtW1mX67Ewh5nPCNDT7+mMHbX42t\nI49P3OIseqZgOJCB+aRsOqOcbXpTiuogIZwQqD+vrLf9ojeQ/x2xV/g6pQwD\njCkyiN1zhzvb3uM0SscnoyYoaskH63Wxbb7eH1P14SlWImS/TTm4n4h8Vmod\n+Kg7+rqnWup9G2XDIoPiV7Qt26ZA4JWymx75pfN7m13lF9mjwzQhWrbiNK9c\n25hC2awhKOo5ZU/gv+blV6iOZqp3vbdIS5YPpdD9eiSJDxnQIDFcHvHx/a2t\n/SGPgKhJSmtKRCGXGr3udT8tSQLKhKcQqVubJutKBZPyEXIeVwAArtKc4McY\n/s5JGGfzcmkzIg5Qy3YQeoMx1gn4C0GDFnMIQkZOb04gx8yiwlY3rImJ/L5B\nporgCA+Qr5Rv9u3PjkuejKzBtFgNLLFXJkbNDGWQ/CfXMT0sHAlOOOa1wVCD\nYkgH\r\n=gSrJ\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIB5BrATGVsox9vg2JtlypH8PS32zRnojR90Y41rhG5jtAiAS/+eAKjS7tJRaUl95gXlsKR9OuH2VqEP3wUzirKFDuQ=="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.46_1614077903801_0.8542869098028345"},"_hasShrinkwrap":false},"0.7.0-beta.47":{"name":"hardhat-deploy","version":"0.7.0-beta.47","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"d411d2533c2aa9c4fc848bd05c0529dfa4fb024e","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.47","_nodeVersion":"12.20.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-7YknSJ2o+ZsYMUtgNg1CW4pj++2cwOpDi4omyCXyktY9Plgudo9vNJwGHxgYU6bLQ6uhCGqICP4WL23beZGsZw==","shasum":"974afd2c070e95437842b05bb24ade84962b4057","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.47.tgz","fileCount":94,"unpackedSize":2335668,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgR6uUCRA9TVsSAnZWagAADVcP/0NFFBeG1phJjAJ6Pl4N\nKRnVjYXqNkC4MUFzvTlQGD+VKEI+N7DcUjvOcii7qDoUa9LgoKVXGNdDOa0v\nND/I8MI5kOmbydAVM0JpqyDMGmzBQqaAbTcT8cuaq5AWLLl5jxco+zV0Vb/N\ngXTJzZg+h+xT9K5LSDxrNBb1chMA8ZFdFbqLQj9rIlC5u5lvjzag6h3ghNxS\n7oSWFwU6y5Nrol53//Pq0E7VkumXoOIh3DjxLEu+7RZcKcDf8qdBBpDCfX5G\nl15mT5HvSbvyOj7RJQFGEbayzaXy78yfeOgdl2T00mv1TFnA7E9Syuup5Fut\np+/0shIqXtlU+03s9vrf2g61JoeUmtn9I38gchBqSO0aQf7z4Zf5An0lM50i\nDaHN7g6Q7PHmSvObEV/FB19Dol3EgEz9ED3dA5CDurDV9sllyiBFMlserXwA\ncZ5i+e2h59R9sKhdb63db8qyAjJ8WQ2GUR156jqFmkb98nmxyTXcxlaQyRLD\nTvGfmGV10XFA6JRSv/rzNr/+IiUy6Xc0mnc6QbEU0Hj8+ERUPsVfy4/0BZA/\nI0UO18etmXI4qe/KetRe+zKJ9xVQgfjWO7phAFSYRgQ6VM6paYYxY+UjQjwH\np5GtP2WKkWM7rC+WoEZPhpGu7gvGGWt9bzHiwDN74D5JxNuSp2BVAGEUvmw7\nU076\r\n=FFMY\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIEGjN0S7e3g1r0MeGCIxI4ceuOc6AgtSeivuriJR4EWZAiBMEt2LoWt+ts6zuf8M2myR5kJDhwsaW6dPbyqkcjALmQ=="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.47_1615309715350_0.03669878040501251"},"_hasShrinkwrap":false},"0.7.0-beta.48":{"name":"hardhat-deploy","version":"0.7.0-beta.48","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"e82ddb0240b5b96df11b58e6c8bd025dd5f76036","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.48","_nodeVersion":"12.20.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-Wn8xRpQdjrNf4fUHdx8ik0/qzccpdn9Ghi3sM7JYZ06/EYM1T48358Dv2MZWZmfI+1ZTlBaA9cLyN1R21+3yUQ==","shasum":"33384aaca1f170c9cd162d9c0f0bda1e59ab01fb","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.48.tgz","fileCount":94,"unpackedSize":2334964,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgS0B3CRA9TVsSAnZWagAA/mUQAJMYy5wFo+PWIJkgG8MN\np1ATVQoR3+p+LhoKGG8TK0+thnglXSbbTY9hL1M5BKz3nRt8zmU+OUyypu6M\nAi6C6EyY5/LAJ+mhVpQhmbTWf6AGPNlrpkCYitN8KQHO7vso36P7x2/ZODZD\nDH+r3C5irW/QcC9cA7ADCmdSAQkXgJ8AoGXbNvV5oFTIz8vSiH/uAvzLl85A\nlyMWH7xwaLBImfPRBVe/JG9dBY6wBfe7+qGmbzivKMqU0ZqITZ3AdKZrDgRT\n5fz22Y1sAKUNib1lKZAM8QA3b8iTBjHVR2B7JS7xJaVSnnj76Eo6tAO4naMj\njC4ytzlouTagi39Z/8MSP37/GHvbKo5CO7y3qmcsruuCnR0EeGRMT7QIAviq\ngpCj/09FMrKYToX8eoWitbxLAtSo8mxA88CrJKBfMtn4473GM/w/VQOW4pfC\nSOR6cfMgRFEZw4IjC1B6VtdIJcVjrZ0A4P6rFM6IGAvE0uyaQ/CFfttvwNa9\naxS7LIMmNnD9PYKGEz8TDsjNJYAU/PHPC4j3INMOlrdcFr9tcDKsAgDromkU\nxz27OEq+4V7JAtp0G6mOEhfkFhTLdgGlSyaPL5yJs0eNgE2qCzwnIE5U/O5b\n8Wtgqha0RbimChmjL6yyl6mBnJXZhDTADyF4n0dpzMVt1eXi2PUKGie/om9n\nuWxi\r\n=GXnr\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQC+S3G7euX4xf+/rjJx+3BVI/k1kZrjVWdhzLc0iS64gAIgO3nrVrPBaBQh2Lb/viCjNsXngENqZK/I6Jlqd1VvHyI="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.48_1615544438405_0.005848324522291337"},"_hasShrinkwrap":false},"0.7.0-beta.49":{"name":"hardhat-deploy","version":"0.7.0-beta.49","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"5ea8f50c0e79506b424edecaa1ddd96084a95096","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.49","_nodeVersion":"12.20.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-FHfy/+fuYqLPD3h3tMN/jOVs5XejIhdu6k/otAAQodK76DsBNYlRD4EtJ+yz74BGtqT+iIO0vUyLJtF56qLEpQ==","shasum":"e77ff7f90cbf5d5a0b8c5abea9e051cbb4aa1bea","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.49.tgz","fileCount":94,"unpackedSize":2343344,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgWNsCCRA9TVsSAnZWagAANSMP/Rg6Dm6E4dWCue/crSyv\nffH1Q0gJ9IvIOoNamR+KEJIKg3naasRfFc0xRvVygnyo+nG/Xkp/kaJKXCQj\nDQVJfPUUwBMNjvFamjjNCe4X4wwZUn4ytdT/Dyyl11mY+RjAyp8C/DMlvtTX\nCumeroOJRGPNw3my8vr5KmxK1b8OtuW9jrPqeTwsY6kdm++FEE7gqe1mu+hk\n3o1xeBNQTbNKq8kIosRgB4twqpfo9b6FjaAYfTtNn9SxVgmU9OtrrnZ/+glf\nfS7EurzaUJ31imLwO3etLgk8yGZ9S4Cs17q3e+KURBr9/lNtuDD5iK9b2rOi\nh0n5CLVYlZXNVFZqmDqglloBCPTtJ6567CfRPyTyr/sxYdfy4BPu4wNlNvjD\neEQz+Ju0uwSjNuPvWB385kHe2bz60HZQMuergKTz2scjRLyqto0dGdK+9Exl\n+GfGtUZ76siZ0c4xE0U5TdvcsSN8GuBRvjzAoXuf0PTCUAhMVkWfgTjog//r\ng+MzlP16AY3SG0NqyFsmjh/FtEUddWL+a8/q8UpFp/ULq9WXwmnKrp9QlxUC\nD51J73UNL3aDKXEo0Eici+BDqS3omygChSM5r0V91JKeK37CSaloZhX65/wN\nXZOzfD9zT+bzSCi1RaG8k5aCfIe5pr+4jYVKJoqY8LnNdfni5CV+V7yCfeLZ\naM2X\r\n=SeDa\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCEJvSs+MnbbCVv//as0ozs7w8wlIfymMzyW9IGQmOZ7AIhANSNERnoUXbQPRrJ873VirCng+8ouTg/GMmGCqHRdnBV"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.49_1616435970187_0.8558868859059974"},"_hasShrinkwrap":false},"0.7.0-beta.50":{"name":"hardhat-deploy","version":"0.7.0-beta.50","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"9da5ba55e2f519e7b84cf458e46d5d311160184f","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.50","_nodeVersion":"12.20.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-WSt/wQYy4TLgwXZrvC4PNM+zpngX8nldhE8/pZ6B7JxovU9LwLhgqa9pvPST+sOhr7fTuBGrO7XyTVq2TgK6YQ==","shasum":"e9e8ae0a6b566303f784aa74311d945cc109b857","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.50.tgz","fileCount":95,"unpackedSize":2346005,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgWZ4tCRA9TVsSAnZWagAALOoP/RneSstl8twHUnzmvfMQ\nBwt+wH90/MLSnk3p++GRO8g+uZm2d6GDgjia8w+6Wvuei5sfMy/W/Ane9tpk\nytfyGebPKTVlJs/qNm+wjbfdl+wpr3uWpaBXhTc5RmusqSQU0EVWJ0YO3dZ+\n1w0SSu1PNFPZmRMgQaRU4ppknH3g9Lx79pYzTdhjT6oC+Gp9R5dVp+u/w5oL\nyzy18rfaojNIgMmQunrOMRJrT3NdaZ2SujliteXXeUCfLCk/62R9jJdND4BH\n44YVQC+R0po3q1qDHjmexp4ZAHNMlcDJhr+cp6Ttmt9qT347m80JzA8fI2cC\nOX4O8B1g3GJxVeqHR3OyXft2iiuialvNnvw+8PS2+CN8xX7TVxYQh55OpSAc\nJRem3N8837Of3+k3zBMU+vam8ofxEMZ1q0dk2+50r9fKiIkPrKjut6CvHgmM\nnyBqYg5PcAJA72KS5topyUOipDbRn26jXzv0hlrz5DmoD+wPwZC5darK4+wA\nhjgwNPAUmLg60dd7No3aTTPGD73N1V2YP43hoZFijEHTeKSuJJpm8dIta5vf\n15Toh81hMtIpa4+njPebc1hYYMTCpqvGZ/3vPWaxlHlQ+KxQrTyLcSSVP4dQ\nz87yvZUdWhSt2oWL1e0JdrXWTB+3jwQCZxTQ12J/kaqEHRQsTK/ae0NzToZ+\nieKK\r\n=rqhE\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCICZVw5z01F3LvAtp2FNmAs1VGUEcyrUx27N0rHpGsTobAiEA2LARH3U3HOutsMkJa97Stagw0DP+6+EtyOXmNIBPFCA="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.50_1616485932453_0.8982188598916385"},"_hasShrinkwrap":false},"0.7.0-beta.51":{"name":"hardhat-deploy","version":"0.7.0-beta.51","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/hardware-wallets":"^5.0.14","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"70350116bb65e1b931a5563ebfe178ae61df6adf","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.51","_nodeVersion":"12.20.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-OO77CNyMI3Hmm1/PlfOIyQQU3EJv4JNp6xpLwXtKkUU3/Smj0JZPsIcYXLORFdEfVURyj/0u813RgQOUBsjYWA==","shasum":"d8a48faad6b051636dbc88c79d88b836dcb4b6df","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.51.tgz","fileCount":95,"unpackedSize":2353569,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgX4OdCRA9TVsSAnZWagAAFikP/3vlv3VRDHXvOsLfTKtY\nggjPwm3S9YA66qHVui9kgyZkkAgEiqOpMLXLplRMEeaVB1mnE88k/EM8Nl4P\naHwZdJxrecI9++ZTRCo6aWCYBJkFle34DhBkenLQuZ+el+ngTWVL54v3uXvE\n2NfytPCKu2aV9C/berlkcVovkKVJsS6LPo4j+Yw57Uabjj0H2XmcYJMbaU3M\nCiVhUi8isXHlNWAdtB/aYJ6yVVYvraVDIZpqYysAQqIFEVAn4Kiyb5nFih26\nJtnxIIU5owd6OYQvtNd8yPQKVopZajj5bK8z9UB3i8+7GIWid17DbOCOMMVg\nn6z3x2aMo5MyUmV+/1Ava9Of4EbA35D0/wBNAa9EKnuPkBMujPSfSnQjOPa+\nZo+AkerEiotH4FUMmaht5AGPD1mi7s7PJx2j9KmGHq+IfSfSwTrvbMFBhH53\n7QnFgn0aSAqTvvtRvFzPNGqjEmFGHaSJfct2st9Ts2duPa+k7L15AJ/amNOb\nYI/hFAvhqLKDTMoyyE85zh333FE4KTHb57RI8MkZGB8NQC5Yh1Cz4LRR0nm2\nmm6Mfdz2F1TgLbX0RS1v9vxgBbipM/I8nMuOjT4tfxLn/MoONwMrh8B1KSZb\nVb3/fbkZSosNreeHHINc8a51Zhy5MbRCzWf6XZl8ETYOjTSeGwQY1Q7XdST2\nRvd/\r\n=ojtB\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQD8Wj0U1fT+JOwrK5Mq8quMfTQ2uFZeulfg1rb4lDLIVgIhAINKQjLiHV3yiT24xdbb9n2ju5fA4MY3TD4NDiA1BRB0"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.51_1616872348241_0.5651175355622668"},"_hasShrinkwrap":false},"0.7.0-beta.52":{"name":"hardhat-deploy","version":"0.7.0-beta.52","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/hardware-wallets":"^5.0.14","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"543483c520f0d78787a77d90c84cfd51b332d7cc","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.52","_nodeVersion":"12.20.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-Ac2+GU3yjcyikztDr3IqGPW1GCkhhWhVDVAAqn6CkUHhPmZVGFyUA7TQVgcFXQ0Q/oe80fakbBhZzQTQ5+X/Ew==","shasum":"bce383477c8e587ec909d66a8b6b4845b04c4335","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.52.tgz","fileCount":95,"unpackedSize":2356979,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgX6lnCRA9TVsSAnZWagAA4pcP/2xcZ1TFC2qA3so2S7Gv\nz7eUBAs+dfi9DCCUU9ZmKJMj0+w3+E94yz8jKleo5fw7VvdzE0KeMApzC18K\neqJfIsWH51jM0Dk/OSPY7NmKaXglFAj5bw6PQsNFEf7VYlIkMPn+BJ8RSz1U\nLc8vWzctwdG9D90SNHEE1WBVM6VLgc+S1tM6ZKP7tIsJunyEmqiQrc/xzcET\nfCP/hSX+uFqkCKMhvQGl5xWSN6QYgMRf1H//loom7O41ifECpCo2XLzxlcmT\n6Vug1gwV726PZ34xynQybGzYyHlSEye4suGnYvUed0DFfx80hrzhmlK9sneX\nvC3FLvr0Ix21Htkdck2HnN5iOUmgCmOQgAatHYx+FbfEbtCQZd2VPzHXHQhy\nD9uy1ISt17U5EifzgUI0axHdP1BrizyemWQdbkyo9AfBEeDen0GYMgaQ8dhp\nokgghtM7bA+nu1QH3uEqudILpwazLh1l7TgED9WNOe0qx5L4WBL1fVe1CQ16\nmN07yYeDL8lr7PBM7DqD4FpqeQuS+q9RCSoikawAbTpefePxW8DE5T+LMG9f\nsqbYjHUS66+OjVYbVuu5XLltSAlFbYodG1nBcKcycSqDPnpwRM3G4KoWFwy7\nSkECIgpfg/fxt8LJPNDO62D4QV5htuhs4tX7cEgdE1VFXCiSCf92D58Ek5XX\nuWER\r\n=qn5N\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCnGlbOI48bN84k35HFR2nqLX8jNqxtnaaqcA5N86XygwIhAPtHvoSMoVU9d1GbXIzi+eN8/8bMFCWF+v+uprDak1CI"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.52_1616882022847_0.09732227986567477"},"_hasShrinkwrap":false},"0.7.0-beta.53":{"name":"hardhat-deploy","version":"0.7.0-beta.53","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/hardware-wallets":"^5.0.14","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"94092e7c84de88411bf715b2a8f50da0f54f0211","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.53","_nodeVersion":"12.20.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-BweCADuVkg2TsJKiq9FVW1DDM/DuKt+I6rWr2sdmdb/Av+O8yqyEOgseQbUiB8/RF2/c1s8QDi4b4Bu9cAax6w==","shasum":"f049978a1ccbb3c578b59df47476fcd83df734e9","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.53.tgz","fileCount":113,"unpackedSize":3202664,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgYRs9CRA9TVsSAnZWagAAR/MP/RXJhMVVJAwCARB6T9ML\n6yrI3thcq4/9tS9mmUDpBcjZGncj0pfpdidP8mKKagtxEwgf8UoGHQzB7s9u\nv4fYs7gw0t8x2BRY1GdnkvodHPNS/B+UFcLpnvDsqj/lVNiH17bfRJWMSJfm\nIHZ5zVXmWuf30zFWQ2OcpI3du2edgsrbd4lBfZSYI75B9LEyXMqRAxzhOb0q\n3QH1GoOszomSlhWI3yNI2U0cwTiUos7Kjh+LSiXE5PqSFyosc1aXKoQsii8k\nGo44N6BhcDYBdYtQrbXaIN3x42lP4KhzNYhRKvK2DHTTZXg/kH73k+wEE2Cf\ndgF6u0boRj0WftvYUUoyvq9OVAdVwWVGJWqCP7Cv4tYmiy8TXT8TFEGUwMsB\ndfFd1rvnqQ/Q1cuCxSi3LZ64HECEujqgj9BoJDdEFF/8Rbw47epgsh73mMEz\nPqLmCsEMnZJAGnMC6xPLGXSf09AKfFl2uZw9CayMfQfHXf5jmhVzhQee+ZYs\nSgECVau9t3E3qaBxLwcV0jwgwh75jFAGijb0lt1neg3N8nBETCxQ4vWMisHk\nq9IxYPZgPPVYWTYisexSI6eJPAE0cjhwJNB25x9TkNZrv+KPb87b55FMpiFP\n4oL8sA1B3OBFLEY3upbSsKcNRP7hLMuWRqBZYxHUKecBHTNWWbrdNsETcLJV\nm2ve\r\n=8BSN\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCtCSKET330JuGCmNnKBRF/KyXRCOuULHbOppRVS7Vw4QIgWA6sTkNHqokDb5WJ5dBVSpN2XLs632jEUP0eKMLaeXQ="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.53_1616976700774_0.7185240506162842"},"_hasShrinkwrap":false},"0.7.0-beta.54":{"name":"hardhat-deploy","version":"0.7.0-beta.54","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/hardware-wallets":"^5.0.14","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"b4a8037c6d687cb736b960e0f96148839142fae7","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.54","_nodeVersion":"12.20.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-FFZYWELQZv6IxLbfb/ZU+XVU3vxXKd0EuLSGb2IFW9RHY349uFUyz2H5YjC4HakEUGqiTX49m8j68hG1Tya8zg==","shasum":"9397047f11e59886602f52be568ba8822b575ac8","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.54.tgz","fileCount":113,"unpackedSize":3203177,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgYifqCRA9TVsSAnZWagAAOP4P/AohGcwA4SPKiGowzC3w\nqNWUuNqdmwE9Gfi4RX/sTmj+mPrkAmgoCkeKCIkj2iRtG3t54tCa95dmfpQK\nWW2hibzPne87Wib2epGaxNYG7z0ti+BF605p1WtJxzPKIcEiq6zyOWp7NLed\nXdwmPqFA8pqMit1KlJR2ni9iOS006b2usKXW0afLDul2ERqdjlgr9T/UhGgD\n4qBofV/1j575hvk8b2wPUtza76LgltZynY9UHnghGFrGK8yC8ycb/DKsUPQK\nNgV6jtXg6zBYca1JlRvxZRszdcfKnPfSSJFIrrIk9aF4wccFpQcAtIgDXESl\nec8ouy7ay9kAkJUoZ89moXkrfAVPfyx+ZQiRqcp8CoLFS1N5QB86LC6QkjRO\nga8qEMZ6TOSiDxxTj14AvIO0YTxEb9A8JTOP+RRy2LgN9U4YLVmf4Bvk50FB\nbkqB6/Eja7y7Sj3PR7LXELaCbQZuLaIKqW+VzwXqRYuHT0K6MxAmlxjXDlAE\nXAEVBMm0Nwwe1rjROXx6B8FWNK5Wus0vkP+kk931oXoniYAr7c3QQATPI8g+\nkd1Vf3gFniVdKP+ifYCI5hf4DYFhn0cKrVNFPavYXop6kYt1y4/pfUuu6Zu2\nLZKf/MeiN0Pfv9lpAxtgqo5waQM788F/yeAGQIqAywvaSknzMm4UqCxKOi5e\naEgp\r\n=8lrt\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCiBr/Fmm7NKlSO8mAJS+t09RLBCAL7s5vkwTFz4+D7gAIhAOLobxRj3uLM2nTFEbfjG7xTGoI0kFWcKaSGVXLWrFXE"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.54_1617045481299_0.6938912234919941"},"_hasShrinkwrap":false},"0.7.0-beta.55":{"name":"hardhat-deploy","version":"0.7.0-beta.55","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/hardware-wallets":"^5.0.14","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"7719b3f7d84f61fccfdd1aa75580c839ce14b3dc","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.55","_nodeVersion":"12.20.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-dE3wbM+yGdLudKG5164xPJFhF5AGljMjHJ8rgAXzXq+7iyBdSJRV0YNLnyLU7ykk/kMDT4A6P+cDhJnYUtZUng==","shasum":"3be055e63a554d70f0ad7b2f8a9b9568b48cad32","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.55.tgz","fileCount":113,"unpackedSize":3203324,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgYwIXCRA9TVsSAnZWagAAEBwQAJSLCSvVdPeEzD5Ey2Vd\nNd8KQnWEwhDra8xEhSO1yW6BXKakY4nLuQdh5xEGt4MRikxKoyQLtzqG5U2+\njPxEqOUQqIVCoGLNwoGIl/n/rnktUNonBb23vmcg0a5szW52dNwkjFKD7Pxp\nB3lO8/oLLLgmqCqBioOuH9jjAcTlgLZHax6RM59noWXeyxETt5NZAjpqG+ZV\nvzL7d+uX2MJAYRi50hkhE45kdFbbjhkmcgUz2gzhI5A3TIO6f8AC7bw0nhPw\np77vvCE+ve2fT4J5Cb8YLe5keeSTaWwtA4NI1MvAN9kcR2g+Ngly/XMVm1at\n9H4VPx2NCCvxpNEcnhm4bp1rxpxJ5gwy34nyxZjCq2BYrw7nBnivKuAiyz/B\n1FdbHTmjrBXaW3O3GL7HlTdDcihQ8BWo0gUYqwJQdndGg6XLEf0XxXZV7p2f\nY6jd1Xul5E2DF/DXO1ujz5q4pKLERhC7J4bcVa0efj6LxK/c9NORhlCq/AHL\niE/UmBRbB8zbmN0/ArlNHVniPploak8y6Ssd5VrnDo64ZNwN7FEPeUPL28RZ\nOP0Zgrp7aPGfDmyE4AYWVWQeYb5f6c4lM1AnP/jCKBoadms9dVoTVCUPWbLi\nMARUvx7EoCoxIjPaRpBlE7BSJqc4godyUpq7YV9BWoa+42yTcDZz3Gg02BIU\nJu78\r\n=v/ic\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQC/W3O6R+DAWj4qkF7SgmTkKyJxtyyxIq49CVJs5WyUCwIgQnXvn8HsBsyWU/743D8Mz5HQyRHvsbpvkjeeoxoqF24="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.55_1617101334536_0.6371029688327485"},"_hasShrinkwrap":false},"0.7.0-beta.56":{"name":"hardhat-deploy","version":"0.7.0-beta.56","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/hardware-wallets":"^5.0.14","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"9bf606d08b9425c1b4e908e3c5c0c7c84ec8b9fc","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.56","_nodeVersion":"12.20.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-cohMcj6YiFWjmqbSPpxomfmXzipTM+cTmuD2JDU+LO+nO/TTYXdYbwjmT88eSmYr8oLTbFtvB5DMFTlhwuHPtg==","shasum":"a8b218a628a49334afb1aacae6cc8b38be1cd22f","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.56.tgz","fileCount":111,"unpackedSize":7144873,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgZEE1CRA9TVsSAnZWagAA7SMP/2ib1vuIZ2tUKM6ZPfx1\n645l9Ldscyw/Z4suHnxCwj+dbQayTswH+CUi37oE4k+nUGGBYM7HU5UyZ+Za\nMRfCi0n67oEf/O4HR4pF+tFWBymTrBeI+1Kk+cwHg2sF6ZUW8nNH2eb255+o\n39dSKCdA9BqTek9iUlyYPIkfh4nC7pSGbA4jI+12SpOSAbeodfAqZs5ajCQL\nQWGgAAMyiJq8KT4vU/8SHiVzbrLAO2t5Q8Wi7+Mv9swON7PEsvBbryXpYx9h\n/Fxk6bqWyBD/erd0sMJvnZBbM29TWUFWFXu79pKqcBt/2oKRNPjFjpLZJCp7\n5U1xOFkiThgw9W4k8YaobHqwLUA3MyBsh+XVPBh9YDGQpip/zy/FKrd2xuWw\nLUKmFjxNjCOOmU4ag/eWRXbShWISKZ1WzF7w/M1mnrIL8wUq4ictvkHVGXA0\npZAReTL9FUS4g6YRwCjhWfE9WtboS8egKZ12VvlRpyXUl/tt54Rd+FwXzyO+\n7kF8ktV3d5ij4T65S5dc2bY9EO5U4Vc6v0mB6GfNJlVoXV2K90XwOQuwI2Sn\n4A7qPnwlfZseFdCmC13ODZGgRLeHuVlj4cMZFiG+wslT1JObQ8OaMainiOVT\nfBUTMoGR3cjbobElA6Y0pAoHUbJC5QIIq5d4KxjiCi6yiQlTPbVjhHxdfGf9\nA//+\r\n=nE0V\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIBo3JxUj1ZUGI5idaDaJKT1ib9Jdz9QwkTJyTNjXVwTxAiAXzNO3gVSnxVsDI8XOQswCbrPucZRIyeakgglKOYgYDg=="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.56_1617183028468_0.17625264146305186"},"_hasShrinkwrap":false},"0.7.0-beta.57":{"name":"hardhat-deploy","version":"0.7.0-beta.57","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/hardware-wallets":"^5.0.14","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"07d9aa43310319af4fbc04936c71c08a6ef4bb71","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.57","_nodeVersion":"12.20.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-tNuNJ6U70L+LMnGttIHn/EIxdv25G/oxR/bVINEE6ORepmdPi0a8tlZahMmnpg0Hh3fn+lcnPZVws6gdl2eBAA==","shasum":"11e635c263d8b7b7469e5ec402f194cebc7a36c3","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.57.tgz","fileCount":111,"unpackedSize":7152164,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgZXLvCRA9TVsSAnZWagAAIR8P/3uCCWPMWhcog5j/4YME\n7OUlG923Y2x62011c22VSlWD+FAcUPzwCuAKtezA2iNipWOxZZhha8CbZ/aE\nQYuq4drNDiYwykH+sZntaq9twniERo6Vrr+sBu10XZ7gMvnG1h5Zu4RjHTVA\nABxTfnwudjpirCeNh/0R4vkPzFwcUSbwftRiNAPhd+6d5OXVEKpJ+VDuS0/3\nBARityypfPMR94JDJovyHlxnpdPGCGhWwdBh30BEH5sekR8j39gyNGotg/an\nq2NpzZeFFuy/nzP9I/f8pGF/UvOnHsso5bn+K7u27B41/xns0Td8vAnK25ZE\nnfeVyVaLo/iLwF0nS1X+WCQJDu+5vsw7fMgokb6j6UnIT6/AZYw5gOdTvEgI\nSaabrP2B8HTKlZBeJH+Cf6A08qyLSut/EzZpP0QAgBihhHReHDJFYwgd7NyY\nbGbiZbl6D1ZhL7HmO7xD2KcBBVvDdIhYl5tnvRMcb9PF3kxspExJ9wogQVay\nuO+Tr30o1VzrMcwrTCfPT4ifW0MDkgxjRX8CB6Sa2OEg7gPiIKraLuC+qc5f\nJokV9JY7Gj5Duv+X6nR3pIb0RokbObd1HcYTQzVGE+Q6SBiX4gJw+b1vCr9E\nfAkAR/JWe7R1dHQmK5J41rAsbHDjGry01cGrgvaQJ6MXIHNTjfuZbQWdF0pX\nYDb5\r\n=Nz+T\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCo0t4CwSxPbFqGbcOw/TeLgChzbRJRQPMRE3N0800rRAIgYIKPGiSU7UdwZhlrOmfhtCUYCnhu/1Pm+qJ/ulEuaHk="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.57_1617261294522_0.5572527531759457"},"_hasShrinkwrap":false},"0.7.0-beta.58":{"name":"hardhat-deploy","version":"0.7.0-beta.58","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/hardware-wallets":"^5.0.14","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"9698753a2f46d5c98d6fad403588db8d00539f04","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0-beta.58","_nodeVersion":"14.0.0","_npmVersion":"6.14.4","dist":{"integrity":"sha512-QQzxrH2ho0Qc26haFf1eEcTWHFFK690SdtRd+LfxyHUNHNkHZQhvy8FQHRJRWgvpx59xzrfL+XrBuEfgLTLM3g==","shasum":"2fc5b6d56ccdded57101ee3b2789f2250498760b","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0-beta.58.tgz","fileCount":111,"unpackedSize":7155087,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgaKyZCRA9TVsSAnZWagAAmrMP/1MgoPyICqcI6PnaZonX\nUPgSBoCbaRdCoY4mG3RrWgRzMTy2hxTdD87J2eZIxDnypoqEDy39TJjCWzYm\nRMoE2MAzsdsrCcGz2nw0kTfXZnvkSNl6F90DE4Hm3Ir73PeiitLM30e5LVbG\nS5HE15gDTY61vgoMKvs/E7nHUYGKXho3E+iS/mox1xdWsaJyfrUjEQ202co+\nZnFJcGwl928TbBhBbDBWLivmCLVhGfGVWUxO1Q2ya9QbdVv9uIO0s9QLOX4p\npAJZyYIqY68R+KzhbvPN4vCcGljHkl6Ed6Oa0iJtreR7HBOmOHPorPtU7U16\nWGVSPwdhMXp0ENXiL/Y3fnJQ1ysWsYFsR51QuW279DLXvNYXWOCAmDXZS/g6\ndivRlVUN8nJOljrOzJB39+rlW9tKoHKWh87ktsSSyjhR1jk3/cWiIuBvS/Jj\nOW+5hhhGDFJ0SLG+xh6s32pNlKSWJgFF7oqEDYd3toXs1udIxAiAOiVma++F\nwNxm/M+M6D0hGX4TXyhsEzj2rk87Oz9xP0RrL4qNo/xHDb5QYUDIb9yjJM6v\nckBd/GJTbDyPjDaQPtIBD1RpR6sycUFKifu30Pt6jwztoIVY8EVA66u2CA+e\noZbtggeFZ2wSRA7lsogL/SpLb9Yy0GCS6Sbeop8wJaPwezVzmPg8QZEb+Iqs\nzzaZ\r\n=IiRu\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCNAmUWOv/V2T8qMCqd41pFULbGdRQhGRZZ3a9GuGEYEQIhALxxA6KwP14jvD/MP4hBc+zAb+IhGmkNtELssldwCR8k"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0-beta.58_1617472665260_0.23880706858370004"},"_hasShrinkwrap":false},"0.7.0":{"name":"hardhat-deploy","version":"0.7.0","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/hardware-wallets":"^5.0.14","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"10269818d886528730ebf7b04f691f1a9c31cced","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.0","_nodeVersion":"14.0.0","_npmVersion":"6.14.4","dist":{"integrity":"sha512-yjWnjXEhzCjKJoilg19g/13WV/zVTuvzzT3t6naRUY5LxX6Cz7/hfEJofevwSLsGxBWGAFjyM4XU+cPAepP/Dg==","shasum":"553b7186b7b4656d3a9c064efa8bd0ef40a949bf","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.0.tgz","fileCount":111,"unpackedSize":7159515,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgaZ5YCRA9TVsSAnZWagAAeIgQAJFShisYHncJcr+qVnKY\namLPVTNWRS3IINjGQCy8ltBq0vbdoa55S2XwflUG+q/TKC7PfEtFNz5Xu2Ut\nkG20+SRS5WbXA8oEZlxe+6kSBXcSdBHv7Zjc0ukuo7qhPiROFjdmNVMk1Ohj\njnsqoiRdOQ0EX/ZJzh4cs/VK6TrPLd+5Kw1bL0d4kxVk19DUtjH6VIcCf5cG\nWaTXZGCaDsu83XVNP1TyZu+owdHad8fbbjvkAloIRwZbcW3nOLJkXbJiVtCx\nx8k+Ei9XPow4NykW2t7yx/hf17fOEzmnQqB5Q2HiPbZkBH9SYeBbX1af4nNu\ntcNpFw+GOIzYCxvv7zio3oEWZaU23foQem1Fhf3nLjSeHHf+nknK8+AzJQk7\nuiQLN8nbynNBPalZbKLk0OWbUO9S8DTEiS1GZlEcBlgwBzBWAbsl45DncD9J\nz0oVWSQuMp1el7p02vrhR9veUilnj6uqlGNiqHUaiUlZd7deVlZBivyfdXfR\ns7M7A+wWjiNCWzMmMUjgR1z/5XJR+xfB6R02Tt2gNgZEwzyqPhZdWsyOy/58\nkhGq8dxxIEk5QYm8MbMX5mDqCMT4qciQS7vrbtK0/8YAeR7E5g6iTP9kFwat\nArYHsm1b9FmfXQZ8QVnptUHJWodspmEiHr/mCw9tl9oMFL26stLjVL9JkkSC\nroQV\r\n=fKOL\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDjaREkIgUTVIw5r8IJIk92hib/ozIj0jEvYjXE8wu4uwIhAO7RwhXYXHcn64yvjMQJPr+SYwnrWLkyuI/avQ6T2A5y"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.0_1617534551177_0.6961173541150532"},"_hasShrinkwrap":false},"0.8.0-next.0":{"name":"hardhat-deploy","version":"0.8.0-next.0","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/hardware-wallets":"^5.0.14","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"readme":"<h1> hardhat-deploy</h1>\n\n_A [Hardhat](https://hardhat.org) Plugin For Replicable Deployments And Easy Testing_\n\n- [What is it for ?](#what-is-it-for-)\n- [hardhat-deploy in a nutshell](#hardhat-deploy-in-a-nutshell)\n- [Installation](#installation)\n  - [npm install hardhat-deploy](#npm-install-hardhat-deploy)\n  - [TypeScript support](#typescript-support)\n  - [Migrating existing deployment to hardhat-deploy](#migrating-existing-deployment-to-hardhat-deploy)\n- [Hardhat Tasks Available/Updated](#hardhat-tasks-availableupdated)\n  - [1. hardhat deploy](#1-hardhat-deploy)\n    - [**Options**](#options)\n    - [**Flags**](#flags)\n  - [2. hardhat node](#2-hardhat-node)\n    - [**Options**](#options-1)\n    - [**Flags**](#flags-1)\n  - [3. hardhat test](#3-hardhat-test)\n  - [4. hardhat etherscan-verify](#4-hardhat-etherscan-verify)\n  - [5. hardhat sourcify](#5-hardhat-sourcify)\n    - [**Options**](#options-2)\n  - [6. hardhat export](#6-hardhat-export)\n    - [**Options**](#options-3)\n- [Hardhat Environment Extensions](#hardhat-environment-extensions)\n- [Configuration](#configuration)\n  - [**1. namedAccounts (ability to name addresses)**](#1-namedaccounts-ability-to-name-addresses)\n  - [**2. extra hardhat.config networks' options**](#2-extra-hardhatconfig-networks-options)\n  - [**3. extra hardhat.config paths' options**](#3-extra-hardhatconfig-paths-options)\n  - [Importing deployment from other projects (with truffle support)](#importing-deployment-from-other-projects-with-truffle-support)\n  - [Access to Artifacts (non-deployed contract code and abi)](#access-to-artifacts-non-deployed-contract-code-and-abi)\n- [How to Deploy Contracts](#how-to-deploy-contracts)\n  - [The `deploy` Task](#the-deploy-task)\n  - [Deploy Scripts](#deploy-scripts)\n  - [The `deployments` field](#the-deployments-field)\n    - [`deployments.deploy`](#deploymentsdeploy)\n- [Handling contract using libraries](#handling-contract-using-libraries)\n- [Exporting Deployments](#exporting-deployments)\n- [Deploying and Upgrading Proxies](#deploying-and-upgrading-proxies)\n- [Testing Deployed Contracts](#testing-deployed-contracts)\n  - [Creating Fixtures](#creating-fixtures)\n- [More Information On Hardhat Tasks](#more-information-on-hardhat-tasks)\n  - [**1. node task**](#1-node-task)\n  - [**2. test task**](#2-test-task)\n  - [**3. run task**](#3-run-task)\n  - [**4. console task**](#4-console-task)\n- [Deploy Scripts: Tags And Dependencies](#deploy-scripts-tags-and-dependencies)\n- [Builtin-In Support For Diamonds (EIP2535)](#builtin-in-support-for-diamonds-eip2535)\n- [Testing Deployed Contracts](#testing-deployed-contracts)\n  - [Creating Fixtures](#creating-fixtures)\n- [Deploy Scripts: Tags And Dependencies](#deploy-scripts-tags-and-dependencies)\n\n## What is it for ?\n\nThis [hardhat](https://hardhat.dev) plugin adds a mechanism to deploy contracts to any network, keeping track of them and replicating the same environment for testing.\n\nIt also adds a mechanism to associate names to addresses, so test and deployment scripts can be reconfigured by simply changing the address a name points to, allowing different configurations per network. This also results in much clearer tests and deployment scripts (no more `accounts[0]` in your code).\n\nThis plugin contains a lot more features too, all geared toward a better developer experience :\n\n- chain configuration export\n- listing deployed contracts' addresses and their abis (useful for webapps)\n- library linking at time of deployment.\n- deterministic deployment across networks.\n- support for specific deploy script per network (L1 vs L2 for example)\n- deployment dependency system (allowing you to only deploy what is needed).\n- deployment retrying (by saving pending tx): so you can feel confident when making a deployment that you can always recover.\n- deployments as test fixture using `evm_snapshot` to speed up testing.\n- ability to create your own test fixture that automatically benefits from `evm_snapshot`'s tests speed-up boost\n- combined with [hardhat-deploy-ethers](https://github.com/wighawag/hardhat-deploy-ethers) it has the ability to get ethers contract instance by name (like `await ethers.getContract(\"ContractName\")`).\n- importing artifact from external sources (like npm packages), including truffle support.\n- importing deployments from external sources (like npm packages), including truffle support.\n- ability to log information in `deploy` mode only (while in test the console remains clean).\n- contains helpers to read and execute transaction on deployed contract referring to them by name.\n- These helpers contains options to auto mine on dev network (to speed up test deployments).\n- save metadata of deployed contract so they can always be fully verified, via [sourcify](https://sourcify.dev) or [etherscan](https://etherscan.io).\n- ability to submit contract source to etherscan and sourcify for verification at any time. (Because **hardhat-deploy** will save all the necessary info, it can be executed at any time.)\n- support harhdat's fork feature so deployment can be accessed even when run through fork.\n- named accounts are automatically impersonnated too, so you can perform tx as if you had their private.\n- proxy deployment with ability to upgrade them transparently, only if code changes.\n- this include support for [openzeppelin](https://openzeppelin.com) transparent proxies\n- diamond deployment with facets, allowing you to focus on what the new version will be. It will generate the diamondCut necessary to reach the new state.\n- watch and deploy: **hardhat-deploy** can watch both your deploy script and contract code and redeploy on changes.\n- HCR (Hot Contract Replacement): the watch feature combined with proxy or diamond, gives you an experience akin to frontend Hot Module Replacement: once your contract changes, the deployment is executed and your contract retains the same address and same state, allowing you to tweak your contracts while debugging your front-end.\n\n## hardhat-deploy in a nutshell\n\nBefore going into the details, here is a very simple summary of the basic feature of **hardhat-deploy**.\n\n**hardhat-deploy** allows you to write [`deploy scripts`](#deploy-scripts) in the `deploy` folder. Each of these files that look as follows will be executed in turn when you execute the following task: `hardhat --network <networkName> deploy`\n\n```js\n// deploy/00_deploy_my_contract.js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('MyContract', {\n    from: deployer,\n    args: ['Hello'],\n    log: true,\n  });\n};\nmodule.exports.tags = ['MyContract'];\n```\n\nFurthermore you can also ensure these scripts are executed in test too by calling `await deployments.fixture(['MyContract'])` in your test.\nThis is optimized, so if multiple tests use the same contract, the deployment will be executed once and each test will start with the exact same state.\n\nThis is a huge benefit for testing since you are not required to replicate the deployment procedure in your tests. The tag feature (as seen in the script above) and [dependencies](#deploy-scripts-tags-and-dependencies) will also make your life easier when writing complex deployment procedures.\n\nYou can even group deploy scripts in different sub folder and ensure they are executed in their logical order.\n\nFurthermore hardhat-deploy can also support a multi-chain settings like L1, L2 with multiple deploy folder specific to each network.\n\nThere is a tutorial covering the basics here : https://github.com/wighawag/tutorial-hardhat-deploy\n\n## Installation\n\n### npm install hardhat-deploy\n\n```bash\nnpm install -D hardhat-deploy\n```\n\nAnd add the following statement to your `hardhat.config.js`:\n\n```js\nrequire('hardhat-deploy');\n```\n\nif you use `ethers.js` we recommend you also install `hardhat-deploy-ethers` which add extra features to access deployments as ethers contract.\n\nSince `hardhat-deploy-ethers` is a fork of `@nomiclabs/hardhat-ethers` and that other plugin might have an hardcoded dependency on `@nomiclabs/hardhat-etehrs` the best way to install `hardhat-deploy-ethers` and ensure compatibility is the following:\n\n```bash\nnpm install --save-dev  @nomiclabs/hardhat-ethers@npm:hardhat-deploy-ethers ethers\n```\n\nWhich means you then need to do `require(\"@nomiclabs/hardhat-ethers\")` instead of `require(\"hardhat-deploy-ethers\")` in your `hardhat.config.js` file.\n\nMore details on `hardhat-deploy-ethers` repo : https://github.com/wighawag/hardhat-deploy-ethers#readme\n\n### TypeScript support\n\nWith hardhat the tsconfig.json is optional.\n\nBut if you add folders to the `include` field in `tsconfig.json`, you ll also need to include `hardhat.config.ts` like :\n\n`include\": [\"./hardhat.config.ts\", \"./scripts\", \"./deploy\", \"./test\"]`\n\nfor deploy script (see below) you can write them this way to benefit from typing :\n\n```ts\nimport {HardhatRuntimeEnvironment} from 'hardhat/types';\nimport {DeployFunction} from 'hardhat-deploy/types';\n\nconst func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {\n  // code here\n};\nexport default func;\n```\n\nSee a template that uses **hardhat-deploy** here : https://github.com/wighawag/template-ethereum-contracts\n\nThis repo has also some examples branch that exemplify specific features, like the forking testing here : https://github.com/wighawag/template-ethereum-contracts/tree/examples/fork-test\n\n### Migrating existing deployment to hardhat-deploy\n\n(Only needed for existing project that already deployed contracts and has the deployment information available **(at minimum, address and abi)**)\n\nYou might want to switch your current deployment process to use **hardhat-deploy**. In that case you probably have some deployments saved elsewhere.\n\nIn order to port them to **hardhat-deploy**, you'll need to create one `.json` file per contract in the `deployments/<network>` folder (configurable via [paths config](#extra-paths-config)).\n\nThe network folder is simply the hardhat network name (as configured in hardhat.config.js) (accessible at runtime via `hre.network.name`).\nSuch folder need to have a file named `.chainId` containing the chainId as decimal.\n\nFor example for network named \"rinkeby\" (for the corresponding network) the file `deployments/rinkeby/.chainId` would be\n\n```\n4\n```\n\nNote, prior to hardhat 0.6 the chainId was appended to the folder name (expect for some known network name). This has changed and upgrading to 0.6 will require you to change the folder name and add the '.chainId' file.\n\nEach contract file must follow this type (as defined in [types.ts](types.ts)) :\n\n```ts\nexport interface Deployment {\n  address: Address;\n  abi: ABI;\n  receipt?: Receipt;\n  transactionHash?: string;\n  history?: Deployment[];\n  implementation?: string;\n  args?: any[];\n  linkedData?: any;\n  solcInputHash?: string;\n  metadata?: string;\n  bytecode?: string;\n  deployedBytecode?: string;\n  libraries?: Libraries;\n  userdoc?: any;\n  devdoc?: any;\n  methodIdentifiers?: any;\n  diamondCut?: FacetCut[];\n  facets?: Facet[];\n  storageLayout?: any;\n  gasEstimates?: any;\n}\n```\n\nAs you can see, only abi and address are mandatory. But having the other fields allow more feature. For example, metadata and args allow you to benefit from contract code verification.\n\nFor Receipt, the following type is expected:\n\n```ts\nexport type Receipt = {\n  from: string;\n  transactionHash: string;\n  blockHash: string;\n  blockNumber: number;\n  transactionIndex: number;\n  cumulativeGasUsed: string;\n  gasUsed: string;\n  contractAddress?: string;\n  to?: string;\n  logs?: Log[];\n  events?: any[];\n  logsBloom?: string;\n  byzantium?: boolean;\n  status?: number;\n  confirmations?: number;\n};\n```\n\nHere is an example:\n\nLet sey you have:\n\n- 2 Contract named Greeter and Registry deployed on rinkeby\n- 1 contract named Greeter on mainnet\n- 2 Contract named Greeter and Registry deployed on a network named rinkeby2\n\nYou would get the following folder structure:\n\n```\ndeployments/\n  mainnet/\n    .chainId\n    Greeter.json\n  rinkeby/\n    .chainId\n    Greeter.json\n    Registry.json\n  rinkeby2/\n    .chainId\n    Greeter.json\n    Registry.json\n```\n\nThe reason why **hardhat-deploy** save chainId in the `.chainId` file is both for\n\n- safety: so that if you were to change the network name to point to a different chain, it would not attempt to read the wrong folder and assume that a contract has been deployed while it has not.\n- ability to know the chainId without requring to be connected to a node (and so not dependent on hardhat.config.js settings). Useful for `export` task.\n\n---\n\n## Hardhat Tasks Available/Updated\n\nhardhat deploy add several task to hardhat. It also modify existing one, adding new options and new behavior. All of these are described here:\n\n---\n\n### 1. hardhat deploy\n\n---\n\nThis plugin adds the _deploy_ task to Hardhat.\n\nThis task will execute the scripts in the `deploy` folder and save the contract deployments to disk. These deployments are supposed to be saved for example in a git repository. This way they can be accessed later. But you are free to save them elsewhere and get them back via your mechanism of choice.\n\nWith the deployment saved, it allows you to deploy a contract only if changes were made.\n\nDeploy scripts (also called Deploy functions) can also perform aribtrary logic.\n\nFor further details on how to use it and write deploy script, see [section](#deploy-scripts) below.\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployments, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice (in wei) to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--reset`: This flag resets the deployments from scratch. Previously deployed contract are not considered and deleted from disk.\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n---\n\n### 2. hardhat node\n\n---\n\nThis plugin modify the _node_ task so that it also execute the deployment script before exposing the server http RPC interface\n\nIt add similar options than the `deploy` task :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n`--forkDeployments <networkName>`: defaults to `localhost`; this option allows you to specify the network to fetch the deployment from when running in fork mode. This is necessary as hardhat fork feature does not track the fork's network: <https://github.com/nomiclabs/hardhat/issues/1164>\n\n`--asNetwork <networkName`: default to `localhost` (or the value specified by `--forkDeployments` if any), this option allows you to specify the network name to be used for **hardhat-deploy** functionality, like which folder the resulting deployment should be saved to.\n\n#### **Flags**\n\n`--noReset`: This flag prevent the reseting of the existing deployments. This is usually not desired when running the `node` task as a network is created from scratch and previous deployemnt are irrelevant.\n\n`--show-accounts`: this flag will output the account private keys\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n`--no-deploy` that discard all other options to revert to normal `hardhat node` behavior without any deployment being performed.\n\nNote that the deployments are saved as if the network name is `localhost`. This is because `hardhat node` is expected to be used as localhost: You can for example execute `hardhat --network localhost console` after `node` is running. Doing `builder --network hardhat console` would indeed not do anything useful. It still take the configuration from `hardhat` in the hardhat.config.js file though.\n\n---\n\n### 3. hardhat test\n\n---\n\nThis plugin adds a flag argument `--deploy-fixture` to the _test_ task that runs the global deployments fixture before the tests and snapshots it. This will generaly speed up the tests.\n\n---\n\n### 4. hardhat etherscan-verify\n\n---\n\nThis plugin adds the _etherscan-verify_ task to Hardhat.\n\nThis task will submit the contract source and other info of all deployed contracts to allow etherscan to verify and record the sources.\n\nInstead of using the full solc input, this task will first attempt to send the minimal sources from the metadata.\nBut Etherscan sometime fails due to a bug in solidity compiler (<https://github.com/ethereum/solidity/issues/9573>). As such this task can fallback on full solc input (see option --solc-input). Note that if your contract was deployed with a previous version of **hardhat-deploy**, it might not contains the full information. The issue seems to be fully resolved since solc version 0.8.\n\nThis task will also attempt to automatically find the SPDX license in the source.\n\nTo execute that task, you need to specifiy the network to run against :\n\n```bash\nhardhat --network mainnet etherscan-verify --api-key <apikey>\n```\n\n#### **Options**\n\n`--api-key <api key>`: let you specify your etherscan api key. Alternatively, you can provide it via the env variable `ETHERSCAN_API_KEY`\n\n`--license <SPDX license id>`: SPDX license (useful if SPDX is not listed in the sources), need to be supported by etherscan: https://etherscan.io/contract-license-types\n\n`--force-license`: if set, will force the use of the license specified by --license option, ignoring the one in the source (useful for license not supported by etherscan)\n\n`--solc-input`: fallback on solc-input id needed (useful when etherscan fails on the minimum sources, see https://github.com/ethereum/solidity/issues/9573)\n\n---\n\n### 5. hardhat sourcify\n\n---\n\nThis plugin adds the _sourcify_ task to Hardhat.\n\nSimilar to `hardhat etherscan-verify` this task will submit the contract source and other info of all deployed contracts to sourcify.\n\n```bash\nhardhat --network mainnet sourcify\n```\n\nLater this task might instead pin the metadata to ipfs, so sourcify can automatically verify them.\n\n#### **Options**\n\n`--endpoint <endpoint>`: specify the sourcify endpoint, default to https://sourcify.dev/server/\n\n`--write-failing-metadata`: if set and the sourcify task fails to verify, the metadata file will be written to disk, so you can more easily figure out what has gone wrong.\n\n---\n\n### 6. hardhat export\n\n---\n\nThis plugin adds the _export_ task to Hardhat.\n\nThis task will export the contract deployed (saved in `deployments` folder) to a file with a simple format containing only contract addresses and abi, useful for web apps.\n\nOne of the following options need to be set for this task to have any effects :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\nThis last option has some limitations, when combined with the use of external deployments (see [Configuration](#configuration)). If such external deployments were using older version of **hardhat-deploy** or truffle, the chainId might be missing. In order for these to be exported, the hardhat network config need to explicity state the chainId in the `networks` config of `hardhat.config.js`.\n\n---\n\n---\n\n## Hardhat Environment Extensions\n\nThis plugin extends the Hardhat Runtime Environment by adding 4 fields:\n\n- `getNamedAccounts: () => Promise<{ [name: string]: string }>`: a function returning an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [Configuration](#configuration)).\n\n- `getUnnamedAccounts: () => Promise<string[]}>`: accounts which has no names, useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`: contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId(): Promise<string>`: offer an easy way to fetch the current chainId.\n\n---\n\n---\n\n## Configuration\n\n---\n\n### **1. namedAccounts (ability to name addresses)**\n\n---\n\nThis plugin extends the `HardhatConfig`'s object with an optional `namedAccounts` field.\n\n`namedAccounts` allows you to associate names to addresses and have them configured per chain.\nThis allows you to have meaningful names in your tests while the addresses match to multi sig in real network for example.\n\n```js\n{\n    namedAccounts: {\n        deployer: {\n            default: 0, // here this will by default take the first account as deployer\n            1: 0, // similarly on mainnet it will take the first account as deployer. Note though that depending on how hardhat network are configured, the account 0 on one network can be different than on another\n            4: '0xA296a3d5F026953e17F472B497eC29a5631FB51B', // but for rinkeby it will be a specific address\n            \"goerli\": '0x84b9514E013710b9dD0811c9Fe46b837a4A0d8E0', //it can also specify a specific netwotk name (specified in hardhat.config.js)\n        },\n        feeCollector:{\n            default: 1, // here this will by default take the second account as feeCollector (so in the test this will be a different account than the deployer)\n            1: '0xa5610E1f289DbDe94F3428A9df22E8B518f65751', // on the mainnet the feeCollector could be a multi sig\n            4: '0xa250ac77360d4e837a13628bC828a2aDf7BabfB3', // on rinkeby it could be another account\n        }\n    }\n}\n```\n\n<!-- You can also specify addresses with the `ledger://` prefix. In which case the account fetched will still be the corresponding address, but behind the scene, the transaction will be created via the hardware waller. Currently the feature is not working very well though and better support is needed. -->\n\n---\n\n### **2. extra hardhat.config networks' options**\n\n---\n\n**hardhat-deploy** add 4 new fields to `networks` configuration\n\n`live` : this is not used internally but is useful to perform action on a network whether it is a live network (rinkeby, mainnet, etc) or a temporary one (localhost, hardhat). The default is true (except for localhost and hardhat where the default is false).\n\n`saveDeployments`: this tell whether **hardhat-deploy** should save the deployments to disk or not. Default to true, except for the hardhat network.\n\n`tags`: network can have tags to represent them. The config is an array and at runtime the hre.network.tags is an object whose fields (the tags) are set to true.\n\nThis is useful to conidtionaly operate on network based on their use case.\n\nExample:\n\n```js\n{\n  networks: {\n    localhost: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"local\"]\n    },\n    hardhat: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"test\", \"local\"]\n    },\n    rinkeby: {\n      live: true,\n      saveDeployments: true,\n      tags: [\"staging\"]\n    }\n  }\n}\n```\n\n`deploy`: the deploy field override the paths.deploy option and let you define a set of folder containing the deploy scripts to be executed for this network.\n\nYou can thus have one network that will be executing L1 deployment and other L2 deployments, etc...\n\n---\n\n### **3. extra hardhat.config paths' options**\n\n---\n\nIt also adds fields to `HardhatConfig`'s `ProjectPaths` object.\n\nHere is an example showing the default values :\n\n```js\n{\n    paths: {\n        deploy: 'deploy',\n        deployments: 'deployments',\n        imports: 'imports'\n    }\n}\n```\n\nThe deploy folder is expected to contains the deploy script that are executed upon invocation of `hardhat deploy` or `hardhat node`.\nIt can also be an array of folder path.\n\nThe deployment folder will contains the resulting deployments (contract addresses along their abi, bytecode, metadata...). One folder per network and one file per contract.\n\nThe imports folder is expected to contains artifacts that were pre-compiled. Useful if you want to upgrade to a new solidity version but want to keep using previously compiled contracts. The artifact is the same format as normal hardhat artifact, so you can easily copy them over, before switching to a new compiler version.\n\n---\n\n### Importing deployment from other projects (with truffle support)\n\nIt also add the `external` field to `HardhatConfig`\n\nSuch fiels allows to specify paths for external artifacts or deployments.\n\nThe external object has 2 fields:\n\n```js\n{\n    external: {\n        contracts: [\n          {\n            artifacts: \"node_modules/@cartesi/arbitration/export/artifacts\",\n            deploy: \"node_modules/@cartesi/arbitration/export/deploy\"\n          },\n          {\n            artifacts: \"node_modules/someotherpackage/artifacts\",\n          }\n        ],\n        deployments: {\n          rinkeby: [\"node_modules/@cartesi/arbitration/build/contracts\"],\n        },\n    }\n}\n```\n\nThe contract field specify an array of object which itself have 2 fields.\n\n- artifacts: (mandatory) it is a path to an artifact folder. This support both hardhat and truffle artifacts.\n- deploy: (optional) it specifies a path to a folder where reside deploy script. The deploy script have only access to the artifact specified in the artifacts field. This allow project to share their deployment procedure. A boon for developer aiming at integrating it as they can get the contracts to be deployed for testing locally.\n\nThe deployments fields specify an object whose field name are the hardhat network and the value is an array of path to look for deployments. It supports both **hardhat-deploy** and truffle formats.\n\n---\n\n### Access to Artifacts (non-deployed contract code and abi)\n\nyou can access contract artifact via `getArtifact` function :\n\n```js\nconst {deployments} = require('hardhat');\nconst artifact = await deployments.getArtifact(artifactName);\n```\n\nWith the `hardhat-deploy-ethers` plugin you can get your ethers contract via :\n\n```js\nconst {deployments, ethers} = require('hardhat');\nconst factory = await ethers.getContractFactory(artifactName);\n```\n\nNote that the artifact file need to be either in `artifacts` folder that hardhat generate on compilation or in the `imports` folder where you can store contracts compiled elsewhere. They can also be present in the folder specified in `external.artifacts` see [Importing deployment from other projects](#importing-deployment-from-other-projects-truffle-support-too)\n\n---\n\n---\n\n## How to Deploy Contracts\n\n---\n\n### The `deploy` Task\n\n`hardhat --network <networkName> deploy [options and flags]`\n\nThis is a new task that the plugin adds. As the name suggests it deploys contracts.\nTo be exact it will look for files in the folder `deploy` or whatever was configured in `paths.deploy`, see [paths config](#extra-paths-config)\n\nIt will scan for files in alphabetical order and execute them in turn.\n\n- it will `require` each of these files and execute the exported function with the HRE as argument\n\nNote that running `hardhat deploy` without specifying a network will use the default network. If the default network is hardhat (the default's default) then nothing will happen as a result but this can be used to ensure the deployment is without issues.\n\nTo specified the network, you can use the builtin hardhat argument `--network <network name>` or set the env variable `HARDHAT_NETWORK`\n\n---\n\n### Deploy Scripts\n\nThe deploy scripts need to be of the following type :\n\n```js\nexport interface DeployFunction {\n  (env: HardhatRuntimeEnvironment): Promise<void | boolean>;\n  skip?: (env: HardhatRuntimeEnvironment) => Promise<boolean>;\n  tags?: string[];\n  dependencies?: string[];\n  runAtTheEnd?: boolean;\n  id?: string;\n}\n```\n\nThe skip function can be used to skip executing the script under whatever condition. It simply need to resolve a promise to true.\n\nThe tags is a list of string that when the _deploy_ task is executed with, the script will be executed (unless it skips). In other word if the deploy task is executed with a tag that does not belong to that script, that script will not be executed unless it is a dependency of a script that does get executed.\n\nThe dependencies is a list of tag that will be executed if that script is executed. So if the script is executed, every script whose tag match any of the dependency will be executed first.\n\nThe `runAtTheEnd` is a boolean that if set to true, will queue that script to be executed after all other scripts are executed.\n\nThese set of fields allow more flexibility to organize the scripts. You are not limited to alphabetical order.\n\nFinally the function can return true if it wishes to never be executed again. This can be usfeul to emulate migration scripts that are meant to be executed only once. Once such script return true (async), the `id` field is used so to track execution and if that field is not present when the script return true, it will fails.\n\nIn any case, as a general advice every deploy function should be idempotent. This is so they can always recover from failure or pending transaction.\n\nThis is why the `hre.deployments.deploy` function will by default only deploy if the contract code has changed, making it easier to write idempotent script.\n\nAn example of a deploy script :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  // the following will only deploy \"GenericMetaTxProcessor\" if the contract was never deployed or if the code changed since last deployment\n  await deploy('GenericMetaTxProcessor', {\n    from: deployer,\n    gasLimit: 4000000,\n    args: [],\n  });\n};\n```\n\nAs you can see the HRE passed in has 4 new fields :\n\n- `getNamedAccounts` is a function that returns a promise to an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [`namedAccounts`](#namedaccounts)).\n\n- `getUnnamedAccounts`: function that return a promise to an array of accounts (which were not used in `getNamedAccounts`), useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`, which contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId` which return a promise for the chainId\n\nThe deploynments field contains the `deploy` function taht allow you to deploy contract and save them. It contains a lot more functions though :\n\n---\n\n### The `deployments` field\n\nThe deployments field contains several helpers function to deploy contract but also execute transaction.\n\n```ts\nexport interface DeploymentsExtension {\n  deploy(name: string, options: DeployOptions): Promise<DeployResult>; // deploy a contract\n  diamond: {\n    // deploy diamond based contract (see section below)\n    deploy(name: string, options: DiamondOptions): Promise<DeployResult>;\n  };\n  deterministic( // return the determinsitic address as well as a function to deploy the contract, can pass the `salt` field in the option to use different salt\n    name: string,\n    options: Create2DeployOptions\n  ): Promise<{\n    address: Address;\n    deploy(): Promise<DeployResult>;\n  }>;\n  fetchIfDifferent( // return true if new compiled code is different than deployed contract\n    name: string,\n    options: DeployOptions\n  ): Promise<{differences: boolean; address?: string}>;\n  save(name: string, deployment: DeploymentSubmission): Promise<void>; // low level save of deployment\n  get(name: string): Promise<Deployment>; // fetch a deployment by name, throw if not existing\n  getOrNull(name: string): Promise<Deployment | null>; // fetch deployment by name, return null if not existing\n  getDeploymentsFromAddress(address: string): Promise<Deployment[]>;\n  all(): Promise<{[name: string]: Deployment}>; // return all deployments\n  getArtifact(name: string): Promise<Artifact>; // return a hardhat artifact (compiled contract without deployment)\n  getExtendedArtifact(name: string): Promise<ExtendedArtifact>; // return a extended artifact (with more info) (compiled contract without deployment)\n  run( // execute deployment scripts\n    tags?: string | string[],\n    options?: {\n      resetMemory?: boolean;\n      deletePreviousDeployments?: boolean;\n      writeDeploymentsToFiles?: boolean;\n      export?: string;\n      exportAll?: string;\n    }\n  ): Promise<{[name: string]: Deployment}>;\n  fixture( // execute deployment as fixture for test // use evm_snapshot to revert back\n    tags?: string | string[],\n    options?: {fallbackToGlobal?: boolean; keepExistingDeployments?: boolean}\n  ): Promise<{[name: string]: Deployment}>;\n  createFixture<T, O>( // execute a function as fixture using evm_snaphost to revert back each time\n    func: FixtureFunc<T, O>,\n    id?: string\n  ): (options?: O) => Promise<T>;\n  log(...args: any[]): void; // log data only ig log enabled (disabled in test fixture)\n\n  execute( // execute function call on contract\n    name: string,\n    options: TxOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<Receipt>;\n  rawTx(tx: SimpleTx): Promise<Receipt>; // execute a simple transaction\n  catchUnknownSigner( // you can wrap other function with this function and it will catch failure due to missing signer with the details of the tx to be executed\n    action: Promise<any> | (() => Promise<any>),\n    options?: {log?: boolean}\n  ): Promise<null | {\n    from: string;\n    to?: string;\n    value?: string;\n    data?: string;\n  }>;\n  read( // make a read-only call to a contract\n    name: string,\n    options: CallOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<any>;\n  read(name: string, methodName: string, ...args: any[]): Promise<any>;\n  // rawCall(to: Address, data: string): Promise<any>; // TODO ?\n}\n```\n\n---\n\n#### `deployments.deploy`\n\n---\n\nThe deploy function as mentioned allow you to deploy a contract and save it under a specific name.\n\nThe deploy function expect 2 parameters: one for the name and one for the options\n\nSee below the full list of fields that the option parameter allows and requires:\n\n```ts\nexport interface DeployOptions = {\n  from: string; // address (or private key) that will perform the transaction. you can use `getNamedAccounts` to retrived the address you want by name.\n  contract?: // this is an optional field. If not specified it defaults to the contract with the same name as the first parameter\n    | string // this field can be either a string for the name of the contract\n    | { // or abi and bytecode\n        abi: ABI;\n        bytecode: string;\n        deployedBytecode?: string;\n      };\n  args?: any[]; // the list of argument for the constructor (or the upgrade function in case of proxy)\n  skipIfAlreadyDeployed?: boolean; // if set it to true, will not attempt to deploy even if the contract deployed under the same name is different\n  log?: boolean; // if true, it will log the result of the deployment (tx hash, address and gas used)\n  linkedData?: any; // This allow to associate any JSON data to the deployment. Useful for merkle tree data for example\n  libraries?: { [libraryName: string]: Address }; // This let you associate libraries to the deployed contract\n  proxy?: boolean | string | ProxyOptions; // This options allow to consider your contract as a proxy (see below for more details)\n\n  // here some common tx options :\n  gasLimit?: string | number | BigNumber;\n  gasPrice?: string | BigNumber;\n  value?: string | BigNumber;\n  nonce?: string | number | BigNumber;\n\n  estimatedGasLimit?: string | number | BigNumber; // to speed up the estimation, it is possible to provide an upper gasLimit\n  estimateGasExtra?: string | number | BigNumber; // this option allow you to add a gas buffer on top of the estimation\n\n  autoMine?: boolean; // this force a evm_mine to be executed. this is useful to speed deployment on test network that allow to specify a block delay (ganache for example). This option basically skip the delay by force mining.\n  deterministicDeployment? boolean | string; // if true, it will deploy the contract at a deterministic address based on bytecode and constuctor arguments. The address will be the same across all network. It use create2 opcode for that, if it is a string, the string will be used as the salt.\n};\n```\n\n---\n\n---\n\n## Handling contract using libraries\n\nIn the deploy function, one of the `DeployOptions` that can be passed into the function is the `libraries` field.\n\nFirst, deploy the library using the `deploy` function, then when we deploy a contract that needs the the linked library, we can pass the deployed library name and address in as an argument to the `libraries` object.\n\n```js\nconst exampleLibrary = await deploy(\"ExampleLibary\", {\n    from: <deployer>\n});\n\n```\n\nExampleLibrary is now deployed to whatever network is in the context of the environment.\n\nFor example, if we are deploying on Rinkeby, this library will get deployed on rinkeby, and the `exampleLibrary` variable will be a deployment object that contains the abi as well as the deployed address for the contract.\n\nNow that the library is deployed, we can link it in our next deployed contract.\n\n```js\nconst example = await deploy(\"Example\", {\n    from: <deployer>\n    args: [\"This is an example string argument in the constructor for the 'Example' contract\"],\n    libraries: {\n        ExampleLibrary: exampleLibrary.address\n    }\n});\n\n```\n\nThis `libraries` object takes the name of the library, and its deployed address on the network. Multiple libraries can be passed into the `libraries` object.\n\n---\n\n---\n\n## Exporting Deployments\n\nApart from deployments saved in the `deployments` folder which contains all information available about the contract (compile time data + deployment data), `hardhat-deploy` allows you to export lightweight files.\n\nThese can be used for example to power your frontend with contract's address and abi.\n\nThis come into 2 flavors.\n\nThe first one is exported via the `--export <file>` option and follow the following format :\n\n```js\nexport interface Export {\n  chainId: string;\n  name: string;\n  contracts: {[name: string]: ContractExport};\n}\n```\n\nwhere name is the name of the network configuration chosen (see hardhat option `--network`)\n\nThe second one is exported via the `--export-all <file>` option and follow the following format :\n\n```js\nexport type MultiExport = {\n  [chainId: string]: {[name: string]: Export},\n};\n```\n\nAs you see the second format include the previous. While in most case you'll need the single export where your application will support only one network, there are case where your app would want to support multiple network at nonce. This second format allow for that.\n\nFurthermore as hardhat support multiple network configuration for the same network (rinkeby, mainnet...), the export-all format will contains each of them grouped by their chainId.\n\n---\n\n---\n\n## Deploying and Upgrading Proxies\n\nAs mentioned above, the deploy function can also deploy a contract through a proxy. It can be done without modification of the contract as long as it does not have a constructor (or constructor with zero arguments).\n\nThe default Proxy is both ERC-1967 and ERC-173 Compliant, but other proxy can be specified, like openzeppelin transparent proxies.\n\nCode for the default Proxy can be found [here](solc_0.7/proxy/EIP173Proxy.sol)\n\nTo perform such proxy deployment, you just need to invoke the deploy function with the following options : `{..., proxy: true}`\n\nSee example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: true,\n  });\n};\n```\n\nYou can also set it to `proxy: \"<upgradeMethodName>\"` in which case the function `<upgradeMethodName>` will be executed upon upgrade.\nthe `args` field will be then used for that function instead of the contructor. It is also possible to then have a constructor with the same arguments and have the proxy be disabled. It can be useful if you want to have your contract as upgradeable in a test network but be non-upgradeable on the mainnet.\n\nSee example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: 'postUpgrade',\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nThe proxy option can also be an object which can set the specific owner that the proxy is going to be managed by.\n\nSee example:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: {\n      owner: greeterOwner,\n      methodName: 'postUpgrade',\n    },\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nNote that for the second invokation, this deployment will fails to upgrade the proxy as the `from` which is `deployer` is not the same as the proxy's owner : `greeterOwner`\n\nTo make it work, you have to create a new script that have for `from` field: `greeterOwner`. If such value is a a multi sig or an address not registered as part of hardhat signers, the tx will not be executed but instead an error will be throw. That error can be caught up via deployments.catchUnknwonSigner function so you get the necessary tx details to execute it elsewhere.\n\nThe full proxy options is as follow:\n\n```ts\nexport interface ProxyOptions {\n  owner?: Address; // this set the owner of the proxy. further upgrade will need to be executed from that owner\n  methodName?: string; // method to be executed when the implementation is modified.\n  proxyContract?: string | ArtifactData; // default to \"EIP173Proxy\". See below for more details\n  viaAdminContract?: // allow to specify a contract that act as a middle man to perform upgrades. Useful and Recommended for Transparent Proxies\n  | string\n    | {\n        name: string;\n        artifact?: string | ArtifactData;\n      };\n}\n```\n\nThe `proxyContract` field allow you to specify your own Proxy contract. If it is a string, it will first attemp to get an artifact with that name. If not found it will fallback on the following if\n\nit matches:\n\n- `EIP173Proxy`: use the default Proxy that is EIP-173 compliant\n\n- `EIP173ProxyWithReceive`: Same as above except that the proxy contains a receive hook to accept empty ETH payment\n\n- `OpenZeppelinTransparentProxy`: Use Openzeppelin Transparent Proxy (slightly modified as openzeppelin's one hardcode the msg.sender as first owner, see code [here](solc_0.7\\openzeppelin\\proxy\\TransparentUpgradeableProxy.sol))\n  When this option is chosen, the `DefaultProxyAdmin` is also used as admin since Transparent Proxy kind of need an intermediarry contract for administration. This can be configired via the `viaAdminContract` option\n\n- `OptimizedTransparentProxy`: This contract is similar to above, except that it is optimized to not require storage read for the admin on every call.\n\n## Builtin-In Support For Diamonds (EIP2535)\n\nThe deployments field also expose the diamond field: `hre.deployments.diamond` that let you deploy [Diamonds](https://eips.ethereum.org/EIPS/eip-2535) in an easy way.\n\nInstead of specifying the facets to cut out or cut in, which the diamond contract expects, you specify the facets you want to end up having on the deployed contract.\n\n`diamond.deploy` expect the facet as names. The names represent contract to be deployed as facet. In future version you ll be able to specify deployed contract or artifact object as facet.\n\nTo deploy a contract with 3 facet you can do as follow :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: deployer,\n    owner: diamondAdmin,\n    facets: ['Facet1', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nif you then later execute the following script:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: diamondAdmin, // this need to be the diamondAdmin for upgrade\n    owner: diamondAdmin,\n    facets: ['NewFacet', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nThen the NewFacet will be deployed automatically if needed and then the diamondCut will cut Facet1 out and add NewFacet.\n\nNote that if the code for Facet2 and Facet3 changes, they will also be redeployed automatically and the diamondCuts will replace the existing facets with these new ones.\n\nNote that The Diamond contract's code is part of hardhat-deploy and contains 3 built-in facet that can be removed manually if desired.\nThese facets are used for ownership, diamondCut and diamond loupe.\n\nThe implementation is the [reference implementation by Nick Mudge](https://github.com/mudgen/diamond-3)\n\nLike normal proxies you can also execute a function at the time of an upgrade.\n\nThis is done by specifying the execute field in the diamond deploy options :\n\n```js\ndiamond.deploy('ADiamondContract', {\n  from: deployer,\n  owner: diamondAdmin,\n  facets: ['NewFacet', 'Facet2', 'Facet3'],\n  execute: {\n    methodName: 'postUpgrade',\n    args: ['one', 2, '0x3'],\n  },\n});\n```\n\nSince the diamond standard has no builtin mechanism to make the deployment of Diamond with function execution, the Diamond when deployed is actually deployed through a special contract, the `Diamantaire` (see code [here](solc_0.7/diamond/Diamantaire.sol)) that act as factory to build Diamond. It uses deterministic deployment for that so, it is transparently managed by hardhat-deploy. It also embed the implementation of the builtin facet, removing the need to have different instances of each live.\n\n<!-- The Diamantaire also support the deterministic deployment of Diamonds.\nAn extra field can be passed to the Diamond deployment options : `deterministicSalt`. It has to be a non-zero 32bytes string (in hex format).\nNote that if you want to deploy 2 diamonds with same owner, you'll need 2 different deterministicSalt for them to be 2 separate contracts. -->\n\n## Testing Deployed Contracts\n\nYou can continue using the usual test task :\n\n`hardhat test`\n\nTests can then use the `hre.deployments.fixture` function to run the deployment for the test and snapshot it so that tests don't need to perform all the deployments transaction every time, they simply reuse the snapshot for every test (this leverages `evm_snapshot` and `evm_revert` provided by both `hardhat` and `ganache`). You can for example set them in a `beaforeEach`.\n\nHere is an example of a test :\n\n```js\nconst {deployments} = require('hardhat');\n\ndescribe('Token', () => {\n  beforeEach(async () => {\n    await deployments.fixture();\n  });\n  it('testing 1 2 3', async function () {\n    const Token = await deployments.get('Token'); // Token is available because the fixture was executed\n    console.log(Token.address);\n    const ERC721BidSale = await deployments.get('ERC721BidSale');\n    console.log({ERC721BidSale});\n  });\n});\n```\n\nIf the deployment scripts are complex, the first test could take while (as the fixture need to execute the deployment) but then from the second test onward, the deployments are never re-executed, instead the fixture will do `evm_revert` and test will run far faster.\n\nTests can also leverage named accounts for clearer test. Combined with `hardhat-deploy-ethers` plugin, you can write succint test :\n\n```js\nconst {ethers, getNamedAccounts} = require('hardhat');\n\ndescribe('Token', () => {\n  beforeEach(async () => {\n    await deployments.fixture();\n  });\n  it('testing 1 2 3', async function () {\n    const {tokenOwner} = await getNamedAccounts();\n    const TokenContract = await ethers.getContract('Token', tokenOwner);\n    await TokenContract.mint(2).then((tx) => tx.wait());\n  });\n});\n```\n\n---\n\n### Creating Fixtures\n\nFurthermore, tests can easily create efficient fixture using `deployments.createFixture`\n\nSee example :\n\n```js\nconst setupTest = deployments.createFixture(async ({deployments, getNamedAccounts, ethers}, options) => {\n  await deployments.fixture(); // ensure you start from a fresh deployments\n  const { tokenOwner } = await getNamedAccounts();\n  const TokenContract = await ethers.getContract(\"Token\", tokenOwner);\n  await TokenContract.mint(10).then(tx => tx.wait()); //this mint is executed once and then `createFixture` will ensure it is snapshotted\n  return {\n    tokenOwner: {\n      address: tokenOwner,\n      TokenContract\n    }\n  };\n};\ndescribe(\"Token\", () => {\n  it(\"testing 1 2 3\", async function() {\n    const {tokenOwner} = await setupTest()\n    await tokenOwner.TokenContract.mint(2);\n  });\n});\n```\n\nWhile this example is trivial, some fixture can requires several transaction and the ability to snapshot them automatically speed up the tests greatly.\n\n---\n\n---\n\n## More Information On Hardhat Tasks\n\n---\n\n### **1. node task**\n\nas mentioned above, the node task is slighly modified and augmented with various flags and options\n\n`hardhat node`\n\nIn particulat it adds an argument `--export` that allows you to specify a destination file where the info about the contracts deployed is written.\nYour webapp can then access all contracts information.\n\n---\n\n### **2. test task**\n\n`hardhat test`\n\nthe test task is augmented with one flag argument `--deploy-fixture` that allows to run all deployments in a fixture snapshot before executing the tests. This can speed up the tests that use specific tags as the global fixture take precedence (unless specified).\n\nIn other word tests can use `deployments.fixture(<specific tag>)` where specific tag only deploys the minimal contracts for tests, while still benefiting from global deployment snapshot if used.\n\nIf a test needs the deployments to only include the specific deployment specified by the tag, it can use the following :\n\n```js\ndeployments.fixture('<specific tag>', {fallbackToGlobal: false});\n```\n\nDue to how snapshot/revert works in hardhat, this means that these tests will not benefit from the global fixture snapshot and will have to deploy their contracts as part of the fixture call. This is automatic but means that these tests will run slower.\n\n---\n\n### **3. run task**\n\n`hardhat --network <networkName> run <script>`\n\nThe run task act as before but thanks to the `hre.deployments` field it can access deployed contract :\n\n```js\nconst hre = require('hardhat');\nconst {deployments, getNamedAccounts} = hre;\n\n(async () => {\n  console.log(await deployments.all());\n  console.log({namedAccounts: await getNamedAccounts()});\n})();\n```\n\nYou can also run it directly from the command line as usual.\n\n`HARDHAT_NETWORK=rinkeby node <script>` is the equivalent except it does not load the hardhat environment twice (which the run task does)\n\n---\n\n### **4. console task**\n\n`hardhat console`\n\nThe same applies to the `console` task.\n\n---\n\n## Deploy Scripts: Tags And Dependencies\n\n---\n\nIt is possible to execute only specific parts of the deployments with `hardhat deploy --tags <tags>`\n\nTags represent what the deploy script acts on. In general it will be a single string value, the name of the contract it deploys or modifies.\n\nThen if another deploy script has such tag as a dependency, then when this latter deploy script has a specific tag and that tag is requested, the dependency will be executed first.\n\nHere is an example of two deploy scripts :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const deployResult = await deploy('Token', {\n    from: deployer,\n    args: ['hello', 100],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Token deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Token'];\n```\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const Token = await deployments.get('Token');\n  const deployResult = await deploy('Sale', {\n    from: deployer,\n    contract: 'ERC721BidSale',\n    args: [Token.address, 1, 3600],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Sale deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.dependencies = ['Token']; // this ensure the Token script above is executed first, so `deployments.get('Token')` succeeds\n```\n\nAs you can see the second one depends on the first. This is because the second script depends on a tag that the first script registers as using.\n\nWith that when `hardhat deploy --tags Sale` is executed\n\nthen both scripts will be run, ensuring Sale is ready.\n\nYou can also define the script to run after another script is run by setting `runAtTheEnd` to be true. For example:\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, execute, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer, admin} = namedAccounts;\n  await execute('Sale', {from: deployer}, 'setAdmin', admin);\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.runAtTheEnd = true;\n```\n\nTags can also be used in test with `deployments.fixture`. This allow you to test a subset of the deploy script.\n","readmeFilename":"README.md","gitHead":"74c35d7616274c0e968209a2eaa276c0220f190b","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.8.0-next.0","_nodeVersion":"14.0.0","_npmVersion":"6.14.4","dist":{"integrity":"sha512-+mii027h0FWMuZ7zf5nBKLOLvFPrHfdoq2qVhN5cR6rW0pkxgWf90BlJz0qPZe3w5Hb9EYDrjEbAY2zGQMioSg==","shasum":"de7e8affc1f0f150fcde468221663b9f113de83b","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.8.0-next.0.tgz","fileCount":111,"unpackedSize":7171458,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgaaDGCRA9TVsSAnZWagAAKvQP/0PHTYHbVJBhVy+j8ont\n2cHTFgwcz6lkTIyTTiWuq/GWDgi0+FJqmOVVnGl7bVrxNLlBdb8C03PDoyHZ\nxLNgxgABIb495qW7EzP2CQR6Soolm7Z6PVhcDsklPhpZYD4VXeHkGD9bIzUS\nUT91dSQBSkgREnbCC3ruJQRsLRtimj8Dg6J9OL22JCS9yXu7FcxJlXivGdiZ\nAFtQJoMcXDoyWnsnrF85aMFAyXu0oJ75/Epo+9C8XZrYwm64F2P+eJfGpVp8\nuQfwZNcBA4plJyQ3sWgnKBcGGMoASf7DE0jW2D+nlXm1F0Aell0l2TTxHrMB\nvT+HGNJWbQW3l0gNfHat9vFR9xh2VNmYrz8PZGt040nWxMcJ9IK2c5+nE8TW\n16YbT+wWx+iX1xKiKw6vsvIcL4AaQgOOv+dmg8aX9s/unwf5ZY6v1xniJtFW\nuV1k5vT6PkSdR9/hPXMAxG/gYdpk6JagocDEvsqVZWQZt99eRbn0am2YYn2L\nmpZnn/gVZdBZsTiimRpAFyesgPAx8dIqgiEJWBw6tgDzAtE5GOUHGTrNEnlz\nV8XaLHc5BZ1LcnVwvZZ4L//7nC0uiClPPJJ2lGM8FyCAsPtLVcZRmugOCIku\nCGChPZ0+Ouyv1R+QKa4IcujvGKFIpxaK+pRDYWr9Z9CqTSa9Cgtv9BG8VNf3\nGh7R\r\n=YCQy\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCmfV3+61HIxG6H74oyjoCFyqDBa84A1eubvf8BExc3tQIhAOMBappOzI03NHk3eUgIt/tuHtoyh/Hbx+ezLW5b5NE9"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.8.0-next.0_1617535173791_0.14304323534196195"},"_hasShrinkwrap":false},"0.7.1":{"name":"hardhat-deploy","version":"0.7.1","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/hardware-wallets":"^5.0.14","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"acd7c0a76a7171a08de1852ce647231042db2c5b","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.1","_nodeVersion":"14.0.0","_npmVersion":"6.14.4","dist":{"integrity":"sha512-fRX4prBdxMxV1vYxKunuf785nd4tChP67DHLkFyue7CqctXGvhYMaEmGqFdzEwJn8rH9w+J/JKyR3vc1cZAdHw==","shasum":"df39f81e6c97132081a27e171f63e93e25f92520","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.1.tgz","fileCount":111,"unpackedSize":7160449,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgaaULCRA9TVsSAnZWagAAl30QAJWmjgkm844ohatvWAYk\njpQFRim5GCGGTR0oHjtyXO6SWzPQ4u54ln0FqnFo5jIFYxWHmG/nYLUb4mwN\nTVA8wzqLzSMVXPpIDJZBHBgwv0kugoWtYz1ufsiDZwTruLWXoeA4BMo1oBpQ\n+E/AYF8ySI7gzLmYIyajQGxmD2gac9EBgwQoWqNyyef4+sETlqDhzhOtMXzC\nC2NNnprWh7IaQfpG6IPkWDnAkVPgvkIiRtJ+5Z/ByE9P5gyk/yVGhmanPktG\nwf4FstLY57pvyGONrgKzUjRKikbmgx7BEuKw8AsR9NN3ldjIamh1z/0uUPx/\nHOcekKy4yzyT1qSRbfhBVzlXAMWmx3dFz0BRg5NEAhWyi7nfx29n1JU007Lt\nx7lnSUwYXexdy9M0dRSSEirhiITxqRipL4fvM6HMaeUsY28Gg+H6fLMSD5Yp\n8PSwypYlfNzbI8fWjSvUl5XLbGbdx8jNyFLazAHtNV58BMSRudx6YtpO9WVx\nI4/77WXiGgOuh9gK+Dm/jaoByZKIRCpe64SkY3PapWvzI1z4tkR4g79n0zF2\nvCltmE5ddvnSQEc+9hlK50zy/XZamiDS2cV9YQnLak838xWJ6E6vYuvK0TTx\nKykGMo8i7Rdb/dN9kyKz7dVtBqS3ZB+PLsnRcdTc5Ea7GsU3zqSB5Q+uPMTx\nqi+J\r\n=7Fwr\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIBsC6B+ArwXvrEnDn4OY/2JVYMyzZM5+xID6y5rRoqaOAiABBaIz8sR5oAg17mOajvqzLAYXVwr9G2rniYF0VmVL7g=="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.1_1617536266763_0.3159865417288057"},"_hasShrinkwrap":false},"0.8.0-next.1":{"name":"hardhat-deploy","version":"0.8.0-next.1","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/hardware-wallets":"^5.0.14","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"readme":"<h1> hardhat-deploy</h1>\n\n_A [Hardhat](https://hardhat.org) Plugin For Replicable Deployments And Easy Testing_\n\n- [What is it for ?](#what-is-it-for-)\n- [hardhat-deploy in a nutshell](#hardhat-deploy-in-a-nutshell)\n- [Installation](#installation)\n  - [npm install hardhat-deploy](#npm-install-hardhat-deploy)\n  - [TypeScript support](#typescript-support)\n  - [Migrating existing deployment to hardhat-deploy](#migrating-existing-deployment-to-hardhat-deploy)\n- [Hardhat Tasks Available/Updated](#hardhat-tasks-availableupdated)\n  - [1. hardhat deploy](#1-hardhat-deploy)\n    - [**Options**](#options)\n    - [**Flags**](#flags)\n  - [2. hardhat node](#2-hardhat-node)\n    - [**Options**](#options-1)\n    - [**Flags**](#flags-1)\n  - [3. hardhat test](#3-hardhat-test)\n  - [4. hardhat etherscan-verify](#4-hardhat-etherscan-verify)\n  - [5. hardhat sourcify](#5-hardhat-sourcify)\n    - [**Options**](#options-2)\n  - [6. hardhat export](#6-hardhat-export)\n    - [**Options**](#options-3)\n- [Hardhat Environment Extensions](#hardhat-environment-extensions)\n- [Configuration](#configuration)\n  - [**1. namedAccounts (ability to name addresses)**](#1-namedaccounts-ability-to-name-addresses)\n  - [**2. extra hardhat.config networks' options**](#2-extra-hardhatconfig-networks-options)\n  - [**3. extra hardhat.config paths' options**](#3-extra-hardhatconfig-paths-options)\n  - [Importing deployment from other projects (with truffle support)](#importing-deployment-from-other-projects-with-truffle-support)\n  - [Access to Artifacts (non-deployed contract code and abi)](#access-to-artifacts-non-deployed-contract-code-and-abi)\n- [How to Deploy Contracts](#how-to-deploy-contracts)\n  - [The `deploy` Task](#the-deploy-task)\n  - [Deploy Scripts](#deploy-scripts)\n  - [The `deployments` field](#the-deployments-field)\n    - [`deployments.deploy`](#deploymentsdeploy)\n- [Handling contract using libraries](#handling-contract-using-libraries)\n- [Exporting Deployments](#exporting-deployments)\n- [Deploying and Upgrading Proxies](#deploying-and-upgrading-proxies)\n- [Testing Deployed Contracts](#testing-deployed-contracts)\n  - [Creating Fixtures](#creating-fixtures)\n- [More Information On Hardhat Tasks](#more-information-on-hardhat-tasks)\n  - [**1. node task**](#1-node-task)\n  - [**2. test task**](#2-test-task)\n  - [**3. run task**](#3-run-task)\n  - [**4. console task**](#4-console-task)\n- [Deploy Scripts: Tags And Dependencies](#deploy-scripts-tags-and-dependencies)\n- [Builtin-In Support For Diamonds (EIP2535)](#builtin-in-support-for-diamonds-eip2535)\n- [Testing Deployed Contracts](#testing-deployed-contracts)\n  - [Creating Fixtures](#creating-fixtures)\n- [Deploy Scripts: Tags And Dependencies](#deploy-scripts-tags-and-dependencies)\n\n## What is it for ?\n\nThis [hardhat](https://hardhat.dev) plugin adds a mechanism to deploy contracts to any network, keeping track of them and replicating the same environment for testing.\n\nIt also adds a mechanism to associate names to addresses, so test and deployment scripts can be reconfigured by simply changing the address a name points to, allowing different configurations per network. This also results in much clearer tests and deployment scripts (no more `accounts[0]` in your code).\n\nThis plugin contains a lot more features too, all geared toward a better developer experience :\n\n- chain configuration export\n- listing deployed contracts' addresses and their abis (useful for webapps)\n- library linking at time of deployment.\n- deterministic deployment across networks.\n- support for specific deploy script per network (L1 vs L2 for example)\n- deployment dependency system (allowing you to only deploy what is needed).\n- deployment retrying (by saving pending tx): so you can feel confident when making a deployment that you can always recover.\n- deployments as test fixture using `evm_snapshot` to speed up testing.\n- ability to create your own test fixture that automatically benefits from `evm_snapshot`'s tests speed-up boost\n- combined with [hardhat-deploy-ethers](https://github.com/wighawag/hardhat-deploy-ethers) it has the ability to get ethers contract instance by name (like `await ethers.getContract(\"ContractName\")`).\n- importing artifact from external sources (like npm packages), including truffle support.\n- importing deployments from external sources (like npm packages), including truffle support.\n- ability to log information in `deploy` mode only (while in test the console remains clean).\n- contains helpers to read and execute transaction on deployed contract referring to them by name.\n- These helpers contains options to auto mine on dev network (to speed up test deployments).\n- save metadata of deployed contract so they can always be fully verified, via [sourcify](https://sourcify.dev) or [etherscan](https://etherscan.io).\n- ability to submit contract source to etherscan and sourcify for verification at any time. (Because **hardhat-deploy** will save all the necessary info, it can be executed at any time.)\n- support harhdat's fork feature so deployment can be accessed even when run through fork.\n- named accounts are automatically impersonnated too, so you can perform tx as if you had their private.\n- proxy deployment with ability to upgrade them transparently, only if code changes.\n- this include support for [openzeppelin](https://openzeppelin.com) transparent proxies\n- diamond deployment with facets, allowing you to focus on what the new version will be. It will generate the diamondCut necessary to reach the new state.\n- watch and deploy: **hardhat-deploy** can watch both your deploy script and contract code and redeploy on changes.\n- HCR (Hot Contract Replacement): the watch feature combined with proxy or diamond, gives you an experience akin to frontend Hot Module Replacement: once your contract changes, the deployment is executed and your contract retains the same address and same state, allowing you to tweak your contracts while debugging your front-end.\n\n## hardhat-deploy in a nutshell\n\nBefore going into the details, here is a very simple summary of the basic feature of **hardhat-deploy**.\n\n**hardhat-deploy** allows you to write [`deploy scripts`](#deploy-scripts) in the `deploy` folder. Each of these files that look as follows will be executed in turn when you execute the following task: `hardhat --network <networkName> deploy`\n\n```js\n// deploy/00_deploy_my_contract.js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('MyContract', {\n    from: deployer,\n    args: ['Hello'],\n    log: true,\n  });\n};\nmodule.exports.tags = ['MyContract'];\n```\n\nFurthermore you can also ensure these scripts are executed in test too by calling `await deployments.fixture(['MyContract'])` in your test.\nThis is optimized, so if multiple tests use the same contract, the deployment will be executed once and each test will start with the exact same state.\n\nThis is a huge benefit for testing since you are not required to replicate the deployment procedure in your tests. The tag feature (as seen in the script above) and [dependencies](#deploy-scripts-tags-and-dependencies) will also make your life easier when writing complex deployment procedures.\n\nYou can even group deploy scripts in different sub folder and ensure they are executed in their logical order.\n\nFurthermore hardhat-deploy can also support a multi-chain settings like L1, L2 with multiple deploy folder specific to each network.\n\nThere is a tutorial covering the basics here : https://github.com/wighawag/tutorial-hardhat-deploy\n\n## Installation\n\n### npm install hardhat-deploy\n\n```bash\nnpm install -D hardhat-deploy\n```\n\nAnd add the following statement to your `hardhat.config.js`:\n\n```js\nrequire('hardhat-deploy');\n```\n\nif you use `ethers.js` we recommend you also install `hardhat-deploy-ethers` which add extra features to access deployments as ethers contract.\n\nSince `hardhat-deploy-ethers` is a fork of `@nomiclabs/hardhat-ethers` and that other plugin might have an hardcoded dependency on `@nomiclabs/hardhat-etehrs` the best way to install `hardhat-deploy-ethers` and ensure compatibility is the following:\n\n```bash\nnpm install --save-dev  @nomiclabs/hardhat-ethers@npm:hardhat-deploy-ethers ethers\n```\n\nWhich means you then need to do `require(\"@nomiclabs/hardhat-ethers\")` instead of `require(\"hardhat-deploy-ethers\")` in your `hardhat.config.js` file.\n\nMore details on `hardhat-deploy-ethers` repo : https://github.com/wighawag/hardhat-deploy-ethers#readme\n\n### TypeScript support\n\nWith hardhat the tsconfig.json is optional.\n\nBut if you add folders to the `include` field in `tsconfig.json`, you ll also need to include `hardhat.config.ts` like :\n\n`include\": [\"./hardhat.config.ts\", \"./scripts\", \"./deploy\", \"./test\"]`\n\nfor deploy script (see below) you can write them this way to benefit from typing :\n\n```ts\nimport {HardhatRuntimeEnvironment} from 'hardhat/types';\nimport {DeployFunction} from 'hardhat-deploy/types';\n\nconst func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {\n  // code here\n};\nexport default func;\n```\n\nSee a template that uses **hardhat-deploy** here : https://github.com/wighawag/template-ethereum-contracts\n\nThis repo has also some examples branch that exemplify specific features, like the forking testing here : https://github.com/wighawag/template-ethereum-contracts/tree/examples/fork-test\n\n### Migrating existing deployment to hardhat-deploy\n\n(Only needed for existing project that already deployed contracts and has the deployment information available **(at minimum, address and abi)**)\n\nYou might want to switch your current deployment process to use **hardhat-deploy**. In that case you probably have some deployments saved elsewhere.\n\nIn order to port them to **hardhat-deploy**, you'll need to create one `.json` file per contract in the `deployments/<network>` folder (configurable via [paths config](#extra-paths-config)).\n\nThe network folder is simply the hardhat network name (as configured in hardhat.config.js) (accessible at runtime via `hre.network.name`).\nSuch folder need to have a file named `.chainId` containing the chainId as decimal.\n\nFor example for network named \"rinkeby\" (for the corresponding network) the file `deployments/rinkeby/.chainId` would be\n\n```\n4\n```\n\nNote, prior to hardhat 0.6 the chainId was appended to the folder name (expect for some known network name). This has changed and upgrading to 0.6 will require you to change the folder name and add the '.chainId' file.\n\nEach contract file must follow this type (as defined in [types.ts](types.ts)) :\n\n```ts\nexport interface Deployment {\n  address: Address;\n  abi: ABI;\n  receipt?: Receipt;\n  transactionHash?: string;\n  history?: Deployment[];\n  implementation?: string;\n  args?: any[];\n  linkedData?: any;\n  solcInputHash?: string;\n  metadata?: string;\n  bytecode?: string;\n  deployedBytecode?: string;\n  libraries?: Libraries;\n  userdoc?: any;\n  devdoc?: any;\n  methodIdentifiers?: any;\n  diamondCut?: FacetCut[];\n  facets?: Facet[];\n  storageLayout?: any;\n  gasEstimates?: any;\n}\n```\n\nAs you can see, only abi and address are mandatory. But having the other fields allow more feature. For example, metadata and args allow you to benefit from contract code verification.\n\nFor Receipt, the following type is expected:\n\n```ts\nexport type Receipt = {\n  from: string;\n  transactionHash: string;\n  blockHash: string;\n  blockNumber: number;\n  transactionIndex: number;\n  cumulativeGasUsed: string;\n  gasUsed: string;\n  contractAddress?: string;\n  to?: string;\n  logs?: Log[];\n  events?: any[];\n  logsBloom?: string;\n  byzantium?: boolean;\n  status?: number;\n  confirmations?: number;\n};\n```\n\nHere is an example:\n\nLet sey you have:\n\n- 2 Contract named Greeter and Registry deployed on rinkeby\n- 1 contract named Greeter on mainnet\n- 2 Contract named Greeter and Registry deployed on a network named rinkeby2\n\nYou would get the following folder structure:\n\n```\ndeployments/\n  mainnet/\n    .chainId\n    Greeter.json\n  rinkeby/\n    .chainId\n    Greeter.json\n    Registry.json\n  rinkeby2/\n    .chainId\n    Greeter.json\n    Registry.json\n```\n\nThe reason why **hardhat-deploy** save chainId in the `.chainId` file is both for\n\n- safety: so that if you were to change the network name to point to a different chain, it would not attempt to read the wrong folder and assume that a contract has been deployed while it has not.\n- ability to know the chainId without requring to be connected to a node (and so not dependent on hardhat.config.js settings). Useful for `export` task.\n\n---\n\n## Hardhat Tasks Available/Updated\n\nhardhat deploy add several task to hardhat. It also modify existing one, adding new options and new behavior. All of these are described here:\n\n---\n\n### 1. hardhat deploy\n\n---\n\nThis plugin adds the _deploy_ task to Hardhat.\n\nThis task will execute the scripts in the `deploy` folder and save the contract deployments to disk. These deployments are supposed to be saved for example in a git repository. This way they can be accessed later. But you are free to save them elsewhere and get them back via your mechanism of choice.\n\nWith the deployment saved, it allows you to deploy a contract only if changes were made.\n\nDeploy scripts (also called Deploy functions) can also perform aribtrary logic.\n\nFor further details on how to use it and write deploy script, see [section](#deploy-scripts) below.\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployments, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice (in wei) to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--reset`: This flag resets the deployments from scratch. Previously deployed contract are not considered and deleted from disk.\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n---\n\n### 2. hardhat node\n\n---\n\nThis plugin modify the _node_ task so that it also execute the deployment script before exposing the server http RPC interface\n\nIt add similar options than the `deploy` task :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n`--forkDeployments <networkName>`: defaults to `localhost`; this option allows you to specify the network to fetch the deployment from when running in fork mode. This is necessary as hardhat fork feature does not track the fork's network: <https://github.com/nomiclabs/hardhat/issues/1164>\n\n`--asNetwork <networkName`: default to `localhost` (or the value specified by `--forkDeployments` if any), this option allows you to specify the network name to be used for **hardhat-deploy** functionality, like which folder the resulting deployment should be saved to.\n\n#### **Flags**\n\n`--noReset`: This flag prevent the reseting of the existing deployments. This is usually not desired when running the `node` task as a network is created from scratch and previous deployemnt are irrelevant.\n\n`--show-accounts`: this flag will output the account private keys\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n`--no-deploy` that discard all other options to revert to normal `hardhat node` behavior without any deployment being performed.\n\nNote that the deployments are saved as if the network name is `localhost`. This is because `hardhat node` is expected to be used as localhost: You can for example execute `hardhat --network localhost console` after `node` is running. Doing `builder --network hardhat console` would indeed not do anything useful. It still take the configuration from `hardhat` in the hardhat.config.js file though.\n\n---\n\n### 3. hardhat test\n\n---\n\nThis plugin adds a flag argument `--deploy-fixture` to the _test_ task that runs the global deployments fixture before the tests and snapshots it. This will generaly speed up the tests.\n\n---\n\n### 4. hardhat etherscan-verify\n\n---\n\nThis plugin adds the _etherscan-verify_ task to Hardhat.\n\nThis task will submit the contract source and other info of all deployed contracts to allow etherscan to verify and record the sources.\n\nInstead of using the full solc input, this task will first attempt to send the minimal sources from the metadata.\nBut Etherscan sometime fails due to a bug in solidity compiler (<https://github.com/ethereum/solidity/issues/9573>). As such this task can fallback on full solc input (see option --solc-input). Note that if your contract was deployed with a previous version of **hardhat-deploy**, it might not contains the full information. The issue seems to be fully resolved since solc version 0.8.\n\nThis task will also attempt to automatically find the SPDX license in the source.\n\nTo execute that task, you need to specifiy the network to run against :\n\n```bash\nhardhat --network mainnet etherscan-verify --api-key <apikey>\n```\n\n#### **Options**\n\n`--api-key <api key>`: let you specify your etherscan api key. Alternatively, you can provide it via the env variable `ETHERSCAN_API_KEY`\n\n`--license <SPDX license id>`: SPDX license (useful if SPDX is not listed in the sources), need to be supported by etherscan: https://etherscan.io/contract-license-types\n\n`--force-license`: if set, will force the use of the license specified by --license option, ignoring the one in the source (useful for license not supported by etherscan)\n\n`--solc-input`: fallback on solc-input id needed (useful when etherscan fails on the minimum sources, see https://github.com/ethereum/solidity/issues/9573)\n\n---\n\n### 5. hardhat sourcify\n\n---\n\nThis plugin adds the _sourcify_ task to Hardhat.\n\nSimilar to `hardhat etherscan-verify` this task will submit the contract source and other info of all deployed contracts to sourcify.\n\n```bash\nhardhat --network mainnet sourcify\n```\n\nLater this task might instead pin the metadata to ipfs, so sourcify can automatically verify them.\n\n#### **Options**\n\n`--endpoint <endpoint>`: specify the sourcify endpoint, default to https://sourcify.dev/server/\n\n`--write-failing-metadata`: if set and the sourcify task fails to verify, the metadata file will be written to disk, so you can more easily figure out what has gone wrong.\n\n---\n\n### 6. hardhat export\n\n---\n\nThis plugin adds the _export_ task to Hardhat.\n\nThis task will export the contract deployed (saved in `deployments` folder) to a file with a simple format containing only contract addresses and abi, useful for web apps.\n\nOne of the following options need to be set for this task to have any effects :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\nThis last option has some limitations, when combined with the use of external deployments (see [Configuration](#configuration)). If such external deployments were using older version of **hardhat-deploy** or truffle, the chainId might be missing. In order for these to be exported, the hardhat network config need to explicity state the chainId in the `networks` config of `hardhat.config.js`.\n\n---\n\n---\n\n## Hardhat Environment Extensions\n\nThis plugin extends the Hardhat Runtime Environment by adding 4 fields:\n\n- `getNamedAccounts: () => Promise<{ [name: string]: string }>`: a function returning an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [Configuration](#configuration)).\n\n- `getUnnamedAccounts: () => Promise<string[]}>`: accounts which has no names, useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`: contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId(): Promise<string>`: offer an easy way to fetch the current chainId.\n\n---\n\n---\n\n## Configuration\n\n---\n\n### **1. namedAccounts (ability to name addresses)**\n\n---\n\nThis plugin extends the `HardhatConfig`'s object with an optional `namedAccounts` field.\n\n`namedAccounts` allows you to associate names to addresses and have them configured per chain.\nThis allows you to have meaningful names in your tests while the addresses match to multi sig in real network for example.\n\n```js\n{\n    namedAccounts: {\n        deployer: {\n            default: 0, // here this will by default take the first account as deployer\n            1: 0, // similarly on mainnet it will take the first account as deployer. Note though that depending on how hardhat network are configured, the account 0 on one network can be different than on another\n            4: '0xA296a3d5F026953e17F472B497eC29a5631FB51B', // but for rinkeby it will be a specific address\n            \"goerli\": '0x84b9514E013710b9dD0811c9Fe46b837a4A0d8E0', //it can also specify a specific netwotk name (specified in hardhat.config.js)\n        },\n        feeCollector:{\n            default: 1, // here this will by default take the second account as feeCollector (so in the test this will be a different account than the deployer)\n            1: '0xa5610E1f289DbDe94F3428A9df22E8B518f65751', // on the mainnet the feeCollector could be a multi sig\n            4: '0xa250ac77360d4e837a13628bC828a2aDf7BabfB3', // on rinkeby it could be another account\n        }\n    }\n}\n```\n\n<!-- You can also specify addresses with the `ledger://` prefix. In which case the account fetched will still be the corresponding address, but behind the scene, the transaction will be created via the hardware waller. Currently the feature is not working very well though and better support is needed. -->\n\n---\n\n### **2. extra hardhat.config networks' options**\n\n---\n\n**hardhat-deploy** add 4 new fields to `networks` configuration\n\n`live` : this is not used internally but is useful to perform action on a network whether it is a live network (rinkeby, mainnet, etc) or a temporary one (localhost, hardhat). The default is true (except for localhost and hardhat where the default is false).\n\n`saveDeployments`: this tell whether **hardhat-deploy** should save the deployments to disk or not. Default to true, except for the hardhat network.\n\n`tags`: network can have tags to represent them. The config is an array and at runtime the hre.network.tags is an object whose fields (the tags) are set to true.\n\nThis is useful to conidtionaly operate on network based on their use case.\n\nExample:\n\n```js\n{\n  networks: {\n    localhost: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"local\"]\n    },\n    hardhat: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"test\", \"local\"]\n    },\n    rinkeby: {\n      live: true,\n      saveDeployments: true,\n      tags: [\"staging\"]\n    }\n  }\n}\n```\n\n`deploy`: the deploy field override the paths.deploy option and let you define a set of folder containing the deploy scripts to be executed for this network.\n\nYou can thus have one network that will be executing L1 deployment and other L2 deployments, etc...\n\n---\n\n### **3. extra hardhat.config paths' options**\n\n---\n\nIt also adds fields to `HardhatConfig`'s `ProjectPaths` object.\n\nHere is an example showing the default values :\n\n```js\n{\n    paths: {\n        deploy: 'deploy',\n        deployments: 'deployments',\n        imports: 'imports'\n    }\n}\n```\n\nThe deploy folder is expected to contains the deploy script that are executed upon invocation of `hardhat deploy` or `hardhat node`.\nIt can also be an array of folder path.\n\nThe deployment folder will contains the resulting deployments (contract addresses along their abi, bytecode, metadata...). One folder per network and one file per contract.\n\nThe imports folder is expected to contains artifacts that were pre-compiled. Useful if you want to upgrade to a new solidity version but want to keep using previously compiled contracts. The artifact is the same format as normal hardhat artifact, so you can easily copy them over, before switching to a new compiler version.\n\n---\n\n### Importing deployment from other projects (with truffle support)\n\nIt also add the `external` field to `HardhatConfig`\n\nSuch fiels allows to specify paths for external artifacts or deployments.\n\nThe external object has 2 fields:\n\n```js\n{\n    external: {\n        contracts: [\n          {\n            artifacts: \"node_modules/@cartesi/arbitration/export/artifacts\",\n            deploy: \"node_modules/@cartesi/arbitration/export/deploy\"\n          },\n          {\n            artifacts: \"node_modules/someotherpackage/artifacts\",\n          }\n        ],\n        deployments: {\n          rinkeby: [\"node_modules/@cartesi/arbitration/build/contracts\"],\n        },\n    }\n}\n```\n\nThe contract field specify an array of object which itself have 2 fields.\n\n- artifacts: (mandatory) it is a path to an artifact folder. This support both hardhat and truffle artifacts.\n- deploy: (optional) it specifies a path to a folder where reside deploy script. The deploy script have only access to the artifact specified in the artifacts field. This allow project to share their deployment procedure. A boon for developer aiming at integrating it as they can get the contracts to be deployed for testing locally.\n\nThe deployments fields specify an object whose field name are the hardhat network and the value is an array of path to look for deployments. It supports both **hardhat-deploy** and truffle formats.\n\n---\n\n### Access to Artifacts (non-deployed contract code and abi)\n\nyou can access contract artifact via `getArtifact` function :\n\n```js\nconst {deployments} = require('hardhat');\nconst artifact = await deployments.getArtifact(artifactName);\n```\n\nWith the `hardhat-deploy-ethers` plugin you can get your ethers contract via :\n\n```js\nconst {deployments, ethers} = require('hardhat');\nconst factory = await ethers.getContractFactory(artifactName);\n```\n\nNote that the artifact file need to be either in `artifacts` folder that hardhat generate on compilation or in the `imports` folder where you can store contracts compiled elsewhere. They can also be present in the folder specified in `external.artifacts` see [Importing deployment from other projects](#importing-deployment-from-other-projects-truffle-support-too)\n\n---\n\n---\n\n## How to Deploy Contracts\n\n---\n\n### The `deploy` Task\n\n`hardhat --network <networkName> deploy [options and flags]`\n\nThis is a new task that the plugin adds. As the name suggests it deploys contracts.\nTo be exact it will look for files in the folder `deploy` or whatever was configured in `paths.deploy`, see [paths config](#extra-paths-config)\n\nIt will scan for files in alphabetical order and execute them in turn.\n\n- it will `require` each of these files and execute the exported function with the HRE as argument\n\nNote that running `hardhat deploy` without specifying a network will use the default network. If the default network is hardhat (the default's default) then nothing will happen as a result but this can be used to ensure the deployment is without issues.\n\nTo specified the network, you can use the builtin hardhat argument `--network <network name>` or set the env variable `HARDHAT_NETWORK`\n\n---\n\n### Deploy Scripts\n\nThe deploy scripts need to be of the following type :\n\n```js\nexport interface DeployFunction {\n  (env: HardhatRuntimeEnvironment): Promise<void | boolean>;\n  skip?: (env: HardhatRuntimeEnvironment) => Promise<boolean>;\n  tags?: string[];\n  dependencies?: string[];\n  runAtTheEnd?: boolean;\n  id?: string;\n}\n```\n\nThe skip function can be used to skip executing the script under whatever condition. It simply need to resolve a promise to true.\n\nThe tags is a list of string that when the _deploy_ task is executed with, the script will be executed (unless it skips). In other word if the deploy task is executed with a tag that does not belong to that script, that script will not be executed unless it is a dependency of a script that does get executed.\n\nThe dependencies is a list of tag that will be executed if that script is executed. So if the script is executed, every script whose tag match any of the dependency will be executed first.\n\nThe `runAtTheEnd` is a boolean that if set to true, will queue that script to be executed after all other scripts are executed.\n\nThese set of fields allow more flexibility to organize the scripts. You are not limited to alphabetical order.\n\nFinally the function can return true if it wishes to never be executed again. This can be usfeul to emulate migration scripts that are meant to be executed only once. Once such script return true (async), the `id` field is used so to track execution and if that field is not present when the script return true, it will fails.\n\nIn any case, as a general advice every deploy function should be idempotent. This is so they can always recover from failure or pending transaction.\n\nThis is why the `hre.deployments.deploy` function will by default only deploy if the contract code has changed, making it easier to write idempotent script.\n\nAn example of a deploy script :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  // the following will only deploy \"GenericMetaTxProcessor\" if the contract was never deployed or if the code changed since last deployment\n  await deploy('GenericMetaTxProcessor', {\n    from: deployer,\n    gasLimit: 4000000,\n    args: [],\n  });\n};\n```\n\nAs you can see the HRE passed in has 4 new fields :\n\n- `getNamedAccounts` is a function that returns a promise to an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [`namedAccounts`](#namedaccounts)).\n\n- `getUnnamedAccounts`: function that return a promise to an array of accounts (which were not used in `getNamedAccounts`), useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`, which contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId` which return a promise for the chainId\n\nThe deploynments field contains the `deploy` function taht allow you to deploy contract and save them. It contains a lot more functions though :\n\n---\n\n### The `deployments` field\n\nThe deployments field contains several helpers function to deploy contract but also execute transaction.\n\n```ts\nexport interface DeploymentsExtension {\n  deploy(name: string, options: DeployOptions): Promise<DeployResult>; // deploy a contract\n  diamond: {\n    // deploy diamond based contract (see section below)\n    deploy(name: string, options: DiamondOptions): Promise<DeployResult>;\n  };\n  deterministic( // return the determinsitic address as well as a function to deploy the contract, can pass the `salt` field in the option to use different salt\n    name: string,\n    options: Create2DeployOptions\n  ): Promise<{\n    address: Address;\n    deploy(): Promise<DeployResult>;\n  }>;\n  fetchIfDifferent( // return true if new compiled code is different than deployed contract\n    name: string,\n    options: DeployOptions\n  ): Promise<{differences: boolean; address?: string}>;\n  save(name: string, deployment: DeploymentSubmission): Promise<void>; // low level save of deployment\n  get(name: string): Promise<Deployment>; // fetch a deployment by name, throw if not existing\n  getOrNull(name: string): Promise<Deployment | null>; // fetch deployment by name, return null if not existing\n  getDeploymentsFromAddress(address: string): Promise<Deployment[]>;\n  all(): Promise<{[name: string]: Deployment}>; // return all deployments\n  getArtifact(name: string): Promise<Artifact>; // return a hardhat artifact (compiled contract without deployment)\n  getExtendedArtifact(name: string): Promise<ExtendedArtifact>; // return a extended artifact (with more info) (compiled contract without deployment)\n  run( // execute deployment scripts\n    tags?: string | string[],\n    options?: {\n      resetMemory?: boolean;\n      deletePreviousDeployments?: boolean;\n      writeDeploymentsToFiles?: boolean;\n      export?: string;\n      exportAll?: string;\n    }\n  ): Promise<{[name: string]: Deployment}>;\n  fixture( // execute deployment as fixture for test // use evm_snapshot to revert back\n    tags?: string | string[],\n    options?: {fallbackToGlobal?: boolean; keepExistingDeployments?: boolean}\n  ): Promise<{[name: string]: Deployment}>;\n  createFixture<T, O>( // execute a function as fixture using evm_snaphost to revert back each time\n    func: FixtureFunc<T, O>,\n    id?: string\n  ): (options?: O) => Promise<T>;\n  log(...args: any[]): void; // log data only ig log enabled (disabled in test fixture)\n\n  execute( // execute function call on contract\n    name: string,\n    options: TxOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<Receipt>;\n  rawTx(tx: SimpleTx): Promise<Receipt>; // execute a simple transaction\n  catchUnknownSigner( // you can wrap other function with this function and it will catch failure due to missing signer with the details of the tx to be executed\n    action: Promise<any> | (() => Promise<any>),\n    options?: {log?: boolean}\n  ): Promise<null | {\n    from: string;\n    to?: string;\n    value?: string;\n    data?: string;\n  }>;\n  read( // make a read-only call to a contract\n    name: string,\n    options: CallOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<any>;\n  read(name: string, methodName: string, ...args: any[]): Promise<any>;\n  // rawCall(to: Address, data: string): Promise<any>; // TODO ?\n}\n```\n\n---\n\n#### `deployments.deploy`\n\n---\n\nThe deploy function as mentioned allow you to deploy a contract and save it under a specific name.\n\nThe deploy function expect 2 parameters: one for the name and one for the options\n\nSee below the full list of fields that the option parameter allows and requires:\n\n```ts\nexport interface DeployOptions = {\n  from: string; // address (or private key) that will perform the transaction. you can use `getNamedAccounts` to retrived the address you want by name.\n  contract?: // this is an optional field. If not specified it defaults to the contract with the same name as the first parameter\n    | string // this field can be either a string for the name of the contract\n    | { // or abi and bytecode\n        abi: ABI;\n        bytecode: string;\n        deployedBytecode?: string;\n      };\n  args?: any[]; // the list of argument for the constructor (or the upgrade function in case of proxy)\n  skipIfAlreadyDeployed?: boolean; // if set it to true, will not attempt to deploy even if the contract deployed under the same name is different\n  log?: boolean; // if true, it will log the result of the deployment (tx hash, address and gas used)\n  linkedData?: any; // This allow to associate any JSON data to the deployment. Useful for merkle tree data for example\n  libraries?: { [libraryName: string]: Address }; // This let you associate libraries to the deployed contract\n  proxy?: boolean | string | ProxyOptions; // This options allow to consider your contract as a proxy (see below for more details)\n\n  // here some common tx options :\n  gasLimit?: string | number | BigNumber;\n  gasPrice?: string | BigNumber;\n  value?: string | BigNumber;\n  nonce?: string | number | BigNumber;\n\n  estimatedGasLimit?: string | number | BigNumber; // to speed up the estimation, it is possible to provide an upper gasLimit\n  estimateGasExtra?: string | number | BigNumber; // this option allow you to add a gas buffer on top of the estimation\n\n  autoMine?: boolean; // this force a evm_mine to be executed. this is useful to speed deployment on test network that allow to specify a block delay (ganache for example). This option basically skip the delay by force mining.\n  deterministicDeployment? boolean | string; // if true, it will deploy the contract at a deterministic address based on bytecode and constuctor arguments. The address will be the same across all network. It use create2 opcode for that, if it is a string, the string will be used as the salt.\n};\n```\n\n---\n\n---\n\n## Handling contract using libraries\n\nIn the deploy function, one of the `DeployOptions` that can be passed into the function is the `libraries` field.\n\nFirst, deploy the library using the `deploy` function, then when we deploy a contract that needs the the linked library, we can pass the deployed library name and address in as an argument to the `libraries` object.\n\n```js\nconst exampleLibrary = await deploy(\"ExampleLibary\", {\n    from: <deployer>\n});\n\n```\n\nExampleLibrary is now deployed to whatever network is in the context of the environment.\n\nFor example, if we are deploying on Rinkeby, this library will get deployed on rinkeby, and the `exampleLibrary` variable will be a deployment object that contains the abi as well as the deployed address for the contract.\n\nNow that the library is deployed, we can link it in our next deployed contract.\n\n```js\nconst example = await deploy(\"Example\", {\n    from: <deployer>\n    args: [\"This is an example string argument in the constructor for the 'Example' contract\"],\n    libraries: {\n        ExampleLibrary: exampleLibrary.address\n    }\n});\n\n```\n\nThis `libraries` object takes the name of the library, and its deployed address on the network. Multiple libraries can be passed into the `libraries` object.\n\n---\n\n---\n\n## Exporting Deployments\n\nApart from deployments saved in the `deployments` folder which contains all information available about the contract (compile time data + deployment data), `hardhat-deploy` allows you to export lightweight files.\n\nThese can be used for example to power your frontend with contract's address and abi.\n\nThis come into 2 flavors.\n\nThe first one is exported via the `--export <file>` option and follow the following format :\n\n```js\nexport interface Export {\n  chainId: string;\n  name: string;\n  contracts: {[name: string]: ContractExport};\n}\n```\n\nwhere name is the name of the network configuration chosen (see hardhat option `--network`)\n\nThe second one is exported via the `--export-all <file>` option and follow the following format :\n\n```js\nexport type MultiExport = {\n  [chainId: string]: {[name: string]: Export},\n};\n```\n\nAs you see the second format include the previous. While in most case you'll need the single export where your application will support only one network, there are case where your app would want to support multiple network at nonce. This second format allow for that.\n\nFurthermore as hardhat support multiple network configuration for the same network (rinkeby, mainnet...), the export-all format will contains each of them grouped by their chainId.\n\n---\n\n---\n\n## Deploying and Upgrading Proxies\n\nAs mentioned above, the deploy function can also deploy a contract through a proxy. It can be done without modification of the contract as long as it does not have a constructor (or constructor with zero arguments).\n\nThe default Proxy is both ERC-1967 and ERC-173 Compliant, but other proxy can be specified, like openzeppelin transparent proxies.\n\nCode for the default Proxy can be found [here](solc_0.7/proxy/EIP173Proxy.sol)\n\nTo perform such proxy deployment, you just need to invoke the deploy function with the following options : `{..., proxy: true}`\n\nSee example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: true,\n  });\n};\n```\n\nYou can also set it to `proxy: \"<upgradeMethodName>\"` in which case the function `<upgradeMethodName>` will be executed upon upgrade.\nthe `args` field will be then used for that function instead of the contructor. It is also possible to then have a constructor with the same arguments and have the proxy be disabled. It can be useful if you want to have your contract as upgradeable in a test network but be non-upgradeable on the mainnet.\n\nSee example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: 'postUpgrade',\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nThe proxy option can also be an object which can set the specific owner that the proxy is going to be managed by.\n\nSee example:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: {\n      owner: greeterOwner,\n      methodName: 'postUpgrade',\n    },\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nNote that for the second invokation, this deployment will fails to upgrade the proxy as the `from` which is `deployer` is not the same as the proxy's owner : `greeterOwner`\n\nTo make it work, you have to create a new script that have for `from` field: `greeterOwner`. If such value is a a multi sig or an address not registered as part of hardhat signers, the tx will not be executed but instead an error will be throw. That error can be caught up via deployments.catchUnknwonSigner function so you get the necessary tx details to execute it elsewhere.\n\nThe full proxy options is as follow:\n\n```ts\nexport interface ProxyOptions {\n  owner?: Address; // this set the owner of the proxy. further upgrade will need to be executed from that owner\n  methodName?: string; // method to be executed when the implementation is modified.\n  proxyContract?: string | ArtifactData; // default to \"EIP173Proxy\". See below for more details\n  viaAdminContract?: // allow to specify a contract that act as a middle man to perform upgrades. Useful and Recommended for Transparent Proxies\n  | string\n    | {\n        name: string;\n        artifact?: string | ArtifactData;\n      };\n}\n```\n\nThe `proxyContract` field allow you to specify your own Proxy contract. If it is a string, it will first attemp to get an artifact with that name. If not found it will fallback on the following if\n\nit matches:\n\n- `EIP173Proxy`: use the default Proxy that is EIP-173 compliant\n\n- `EIP173ProxyWithReceive`: Same as above except that the proxy contains a receive hook to accept empty ETH payment\n\n- `OpenZeppelinTransparentProxy`: Use Openzeppelin Transparent Proxy (slightly modified as openzeppelin's one hardcode the msg.sender as first owner, see code [here](solc_0.7\\openzeppelin\\proxy\\TransparentUpgradeableProxy.sol))\n  When this option is chosen, the `DefaultProxyAdmin` is also used as admin since Transparent Proxy kind of need an intermediarry contract for administration. This can be configired via the `viaAdminContract` option\n\n- `OptimizedTransparentProxy`: This contract is similar to above, except that it is optimized to not require storage read for the admin on every call.\n\n## Builtin-In Support For Diamonds (EIP2535)\n\nThe deployments field also expose the diamond field: `hre.deployments.diamond` that let you deploy [Diamonds](https://eips.ethereum.org/EIPS/eip-2535) in an easy way.\n\nInstead of specifying the facets to cut out or cut in, which the diamond contract expects, you specify the facets you want to end up having on the deployed contract.\n\n`diamond.deploy` expect the facet as names. The names represent contract to be deployed as facet. In future version you ll be able to specify deployed contract or artifact object as facet.\n\nTo deploy a contract with 3 facet you can do as follow :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: deployer,\n    owner: diamondAdmin,\n    facets: ['Facet1', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nif you then later execute the following script:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: diamondAdmin, // this need to be the diamondAdmin for upgrade\n    owner: diamondAdmin,\n    facets: ['NewFacet', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nThen the NewFacet will be deployed automatically if needed and then the diamondCut will cut Facet1 out and add NewFacet.\n\nNote that if the code for Facet2 and Facet3 changes, they will also be redeployed automatically and the diamondCuts will replace the existing facets with these new ones.\n\nNote that The Diamond contract's code is part of hardhat-deploy and contains 3 built-in facet that can be removed manually if desired.\nThese facets are used for ownership, diamondCut and diamond loupe.\n\nThe implementation is the [reference implementation by Nick Mudge](https://github.com/mudgen/diamond-3)\n\nLike normal proxies you can also execute a function at the time of an upgrade.\n\nThis is done by specifying the execute field in the diamond deploy options :\n\n```js\ndiamond.deploy('ADiamondContract', {\n  from: deployer,\n  owner: diamondAdmin,\n  facets: ['NewFacet', 'Facet2', 'Facet3'],\n  execute: {\n    methodName: 'postUpgrade',\n    args: ['one', 2, '0x3'],\n  },\n});\n```\n\nSince the diamond standard has no builtin mechanism to make the deployment of Diamond with function execution, the Diamond when deployed is actually deployed through a special contract, the `Diamantaire` (see code [here](solc_0.7/diamond/Diamantaire.sol)) that act as factory to build Diamond. It uses deterministic deployment for that so, it is transparently managed by hardhat-deploy. It also embed the implementation of the builtin facet, removing the need to have different instances of each live.\n\n<!-- The Diamantaire also support the deterministic deployment of Diamonds.\nAn extra field can be passed to the Diamond deployment options : `deterministicSalt`. It has to be a non-zero 32bytes string (in hex format).\nNote that if you want to deploy 2 diamonds with same owner, you'll need 2 different deterministicSalt for them to be 2 separate contracts. -->\n\n## Testing Deployed Contracts\n\nYou can continue using the usual test task :\n\n`hardhat test`\n\nTests can then use the `hre.deployments.fixture` function to run the deployment for the test and snapshot it so that tests don't need to perform all the deployments transaction every time, they simply reuse the snapshot for every test (this leverages `evm_snapshot` and `evm_revert` provided by both `hardhat` and `ganache`). You can for example set them in a `beaforeEach`.\n\nHere is an example of a test :\n\n```js\nconst {deployments} = require('hardhat');\n\ndescribe('Token', () => {\n  beforeEach(async () => {\n    await deployments.fixture();\n  });\n  it('testing 1 2 3', async function () {\n    const Token = await deployments.get('Token'); // Token is available because the fixture was executed\n    console.log(Token.address);\n    const ERC721BidSale = await deployments.get('ERC721BidSale');\n    console.log({ERC721BidSale});\n  });\n});\n```\n\nIf the deployment scripts are complex, the first test could take while (as the fixture need to execute the deployment) but then from the second test onward, the deployments are never re-executed, instead the fixture will do `evm_revert` and test will run far faster.\n\nTests can also leverage named accounts for clearer test. Combined with `hardhat-deploy-ethers` plugin, you can write succint test :\n\n```js\nconst {ethers, getNamedAccounts} = require('hardhat');\n\ndescribe('Token', () => {\n  beforeEach(async () => {\n    await deployments.fixture();\n  });\n  it('testing 1 2 3', async function () {\n    const {tokenOwner} = await getNamedAccounts();\n    const TokenContract = await ethers.getContract('Token', tokenOwner);\n    await TokenContract.mint(2).then((tx) => tx.wait());\n  });\n});\n```\n\n---\n\n### Creating Fixtures\n\nFurthermore, tests can easily create efficient fixture using `deployments.createFixture`\n\nSee example :\n\n```js\nconst setupTest = deployments.createFixture(async ({deployments, getNamedAccounts, ethers}, options) => {\n  await deployments.fixture(); // ensure you start from a fresh deployments\n  const { tokenOwner } = await getNamedAccounts();\n  const TokenContract = await ethers.getContract(\"Token\", tokenOwner);\n  await TokenContract.mint(10).then(tx => tx.wait()); //this mint is executed once and then `createFixture` will ensure it is snapshotted\n  return {\n    tokenOwner: {\n      address: tokenOwner,\n      TokenContract\n    }\n  };\n};\ndescribe(\"Token\", () => {\n  it(\"testing 1 2 3\", async function() {\n    const {tokenOwner} = await setupTest()\n    await tokenOwner.TokenContract.mint(2);\n  });\n});\n```\n\nWhile this example is trivial, some fixture can requires several transaction and the ability to snapshot them automatically speed up the tests greatly.\n\n---\n\n---\n\n## More Information On Hardhat Tasks\n\n---\n\n### **1. node task**\n\nas mentioned above, the node task is slighly modified and augmented with various flags and options\n\n`hardhat node`\n\nIn particulat it adds an argument `--export` that allows you to specify a destination file where the info about the contracts deployed is written.\nYour webapp can then access all contracts information.\n\n---\n\n### **2. test task**\n\n`hardhat test`\n\nthe test task is augmented with one flag argument `--deploy-fixture` that allows to run all deployments in a fixture snapshot before executing the tests. This can speed up the tests that use specific tags as the global fixture take precedence (unless specified).\n\nIn other word tests can use `deployments.fixture(<specific tag>)` where specific tag only deploys the minimal contracts for tests, while still benefiting from global deployment snapshot if used.\n\nIf a test needs the deployments to only include the specific deployment specified by the tag, it can use the following :\n\n```js\ndeployments.fixture('<specific tag>', {fallbackToGlobal: false});\n```\n\nDue to how snapshot/revert works in hardhat, this means that these tests will not benefit from the global fixture snapshot and will have to deploy their contracts as part of the fixture call. This is automatic but means that these tests will run slower.\n\n---\n\n### **3. run task**\n\n`hardhat --network <networkName> run <script>`\n\nThe run task act as before but thanks to the `hre.deployments` field it can access deployed contract :\n\n```js\nconst hre = require('hardhat');\nconst {deployments, getNamedAccounts} = hre;\n\n(async () => {\n  console.log(await deployments.all());\n  console.log({namedAccounts: await getNamedAccounts()});\n})();\n```\n\nYou can also run it directly from the command line as usual.\n\n`HARDHAT_NETWORK=rinkeby node <script>` is the equivalent except it does not load the hardhat environment twice (which the run task does)\n\n---\n\n### **4. console task**\n\n`hardhat console`\n\nThe same applies to the `console` task.\n\n---\n\n## Deploy Scripts: Tags And Dependencies\n\n---\n\nIt is possible to execute only specific parts of the deployments with `hardhat deploy --tags <tags>`\n\nTags represent what the deploy script acts on. In general it will be a single string value, the name of the contract it deploys or modifies.\n\nThen if another deploy script has such tag as a dependency, then when this latter deploy script has a specific tag and that tag is requested, the dependency will be executed first.\n\nHere is an example of two deploy scripts :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const deployResult = await deploy('Token', {\n    from: deployer,\n    args: ['hello', 100],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Token deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Token'];\n```\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const Token = await deployments.get('Token');\n  const deployResult = await deploy('Sale', {\n    from: deployer,\n    contract: 'ERC721BidSale',\n    args: [Token.address, 1, 3600],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Sale deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.dependencies = ['Token']; // this ensure the Token script above is executed first, so `deployments.get('Token')` succeeds\n```\n\nAs you can see the second one depends on the first. This is because the second script depends on a tag that the first script registers as using.\n\nWith that when `hardhat deploy --tags Sale` is executed\n\nthen both scripts will be run, ensuring Sale is ready.\n\nYou can also define the script to run after another script is run by setting `runAtTheEnd` to be true. For example:\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, execute, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer, admin} = namedAccounts;\n  await execute('Sale', {from: deployer}, 'setAdmin', admin);\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.runAtTheEnd = true;\n```\n\nTags can also be used in test with `deployments.fixture`. This allow you to test a subset of the deploy script.\n","readmeFilename":"README.md","gitHead":"3e0d44d44d6789fb56a64f884afdc1d41c34469e","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.8.0-next.1","_nodeVersion":"14.0.0","_npmVersion":"6.14.4","dist":{"integrity":"sha512-twf2aQ8/JVCVW08rnhaXa7CWfdOc2WhksaTYcn4iMolpFEoFuf+6dhbwrNAkvH/bsCMBIBWn//wbq+FXLodivA==","shasum":"2b8867c310a56b9b74179e1a9c278685eb08e499","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.8.0-next.1.tgz","fileCount":111,"unpackedSize":7172452,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgatQGCRA9TVsSAnZWagAAQbUP/2ieztn/isEyvDNEoepJ\nCcUDRxcu394fikBsLxYAfo8waLmsD/wuCopBgZQ9SC/ovtH0e4A8jetJii5x\nwKm+JiGFV5Yhp5zwWrOmyHdQwOxIxPdoed11hU6UH0hxitK3HffE/n1TdsrU\nyoFn9Kg0whb7nSEkGakw2EG0I13Ni0zyqIji9tfJeH77CPPz2x8eDqzkBpnA\nQMysDmd/veuM/YXTxUtg20I3N/cRlsrkXHqncJtd3Naro/nptxOWDnx550oC\n0BD0H7iDo0J0Hec6622i5hdXdrAbqJ7d6mP5sbkF1mb+ED45ut3P2WImTbi5\nVUsZJugzNLG0LJH3Yw48QRQ6ouf69LJIH9iqo0iemXzZYqRAPf5cAyrHjf9/\nLHSfEW4nsdE4PfBmEF6WbNxQSwV0Kxs+1rK4KXramXQoMiyIlcKAObhrMMNt\nKquof/VMXxoYfrO4UQOoDWjXDDTEiPO27xkad2MJvuEnettoyFQ/6JDy7NXp\nbpGedsrFgR+JVcngNNi9eWQsh716xfgtQciyLr7bLnAU7SbAIKrXWALL3LVT\nlXifjTKDck5ghJwzoAGj7ZGm0915nNhGx/2ry4/EspdFMJPVpXzggt4g5V3Z\nmShde+wvJQhQ2obvm8XBfAvK90mNSBqxM2Z3VFr2Dy0e58jak78T2PLaKyLi\nHWu9\r\n=TBlN\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCrtuMWc7hkLt/ZlGkyVy6zZ4CUTnkEutjyVHfNPwp2GgIgOIX/yoQK8KXMOcj1W7p+u8DJwO98w7Avveacv2Hez3w="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.8.0-next.1_1617613829826_0.4497482346722319"},"_hasShrinkwrap":false},"0.8.0-next.2":{"name":"hardhat-deploy","version":"0.8.0-next.2","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/hardware-wallets":"^5.0.14","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"readme":"<h1> hardhat-deploy</h1>\n\n_A [Hardhat](https://hardhat.org) Plugin For Replicable Deployments And Easy Testing_\n\n- [What is it for ?](#what-is-it-for-)\n- [hardhat-deploy in a nutshell](#hardhat-deploy-in-a-nutshell)\n- [Installation](#installation)\n  - [npm install hardhat-deploy](#npm-install-hardhat-deploy)\n  - [TypeScript support](#typescript-support)\n  - [Migrating existing deployment to hardhat-deploy](#migrating-existing-deployment-to-hardhat-deploy)\n- [Hardhat Tasks Available/Updated](#hardhat-tasks-availableupdated)\n  - [1. hardhat deploy](#1-hardhat-deploy)\n    - [**Options**](#options)\n    - [**Flags**](#flags)\n  - [2. hardhat node](#2-hardhat-node)\n    - [**Options**](#options-1)\n    - [**Flags**](#flags-1)\n  - [3. hardhat test](#3-hardhat-test)\n  - [4. hardhat etherscan-verify](#4-hardhat-etherscan-verify)\n  - [5. hardhat sourcify](#5-hardhat-sourcify)\n    - [**Options**](#options-2)\n  - [6. hardhat export](#6-hardhat-export)\n    - [**Options**](#options-3)\n- [Hardhat Environment Extensions](#hardhat-environment-extensions)\n- [Configuration](#configuration)\n  - [**1. namedAccounts (ability to name addresses)**](#1-namedaccounts-ability-to-name-addresses)\n  - [**2. extra hardhat.config networks' options**](#2-extra-hardhatconfig-networks-options)\n  - [**3. extra hardhat.config paths' options**](#3-extra-hardhatconfig-paths-options)\n  - [Importing deployment from other projects (with truffle support)](#importing-deployment-from-other-projects-with-truffle-support)\n  - [Access to Artifacts (non-deployed contract code and abi)](#access-to-artifacts-non-deployed-contract-code-and-abi)\n- [How to Deploy Contracts](#how-to-deploy-contracts)\n  - [The `deploy` Task](#the-deploy-task)\n  - [Deploy Scripts](#deploy-scripts)\n  - [The `deployments` field](#the-deployments-field)\n    - [`deployments.deploy`](#deploymentsdeploy)\n- [Handling contract using libraries](#handling-contract-using-libraries)\n- [Exporting Deployments](#exporting-deployments)\n- [Deploying and Upgrading Proxies](#deploying-and-upgrading-proxies)\n- [Testing Deployed Contracts](#testing-deployed-contracts)\n  - [Creating Fixtures](#creating-fixtures)\n- [More Information On Hardhat Tasks](#more-information-on-hardhat-tasks)\n  - [**1. node task**](#1-node-task)\n  - [**2. test task**](#2-test-task)\n  - [**3. run task**](#3-run-task)\n  - [**4. console task**](#4-console-task)\n- [Deploy Scripts: Tags And Dependencies](#deploy-scripts-tags-and-dependencies)\n- [Builtin-In Support For Diamonds (EIP2535)](#builtin-in-support-for-diamonds-eip2535)\n- [Testing Deployed Contracts](#testing-deployed-contracts)\n  - [Creating Fixtures](#creating-fixtures)\n- [Deploy Scripts: Tags And Dependencies](#deploy-scripts-tags-and-dependencies)\n\n## What is it for ?\n\nThis [hardhat](https://hardhat.dev) plugin adds a mechanism to deploy contracts to any network, keeping track of them and replicating the same environment for testing.\n\nIt also adds a mechanism to associate names to addresses, so test and deployment scripts can be reconfigured by simply changing the address a name points to, allowing different configurations per network. This also results in much clearer tests and deployment scripts (no more `accounts[0]` in your code).\n\nThis plugin contains a lot more features too, all geared toward a better developer experience :\n\n- chain configuration export\n- listing deployed contracts' addresses and their abis (useful for webapps)\n- library linking at time of deployment.\n- deterministic deployment across networks.\n- support for specific deploy script per network (L1 vs L2 for example)\n- deployment dependency system (allowing you to only deploy what is needed).\n- deployment retrying (by saving pending tx): so you can feel confident when making a deployment that you can always recover.\n- deployments as test fixture using `evm_snapshot` to speed up testing.\n- ability to create your own test fixture that automatically benefits from `evm_snapshot`'s tests speed-up boost\n- combined with [hardhat-deploy-ethers](https://github.com/wighawag/hardhat-deploy-ethers) it has the ability to get ethers contract instance by name (like `await ethers.getContract(\"ContractName\")`).\n- importing artifact from external sources (like npm packages), including truffle support.\n- importing deployments from external sources (like npm packages), including truffle support.\n- ability to log information in `deploy` mode only (while in test the console remains clean).\n- contains helpers to read and execute transaction on deployed contract referring to them by name.\n- These helpers contains options to auto mine on dev network (to speed up test deployments).\n- save metadata of deployed contract so they can always be fully verified, via [sourcify](https://sourcify.dev) or [etherscan](https://etherscan.io).\n- ability to submit contract source to etherscan and sourcify for verification at any time. (Because **hardhat-deploy** will save all the necessary info, it can be executed at any time.)\n- support harhdat's fork feature so deployment can be accessed even when run through fork.\n- named accounts are automatically impersonnated too, so you can perform tx as if you had their private.\n- proxy deployment with ability to upgrade them transparently, only if code changes.\n- this include support for [openzeppelin](https://openzeppelin.com) transparent proxies\n- diamond deployment with facets, allowing you to focus on what the new version will be. It will generate the diamondCut necessary to reach the new state.\n- watch and deploy: **hardhat-deploy** can watch both your deploy script and contract code and redeploy on changes.\n- HCR (Hot Contract Replacement): the watch feature combined with proxy or diamond, gives you an experience akin to frontend Hot Module Replacement: once your contract changes, the deployment is executed and your contract retains the same address and same state, allowing you to tweak your contracts while debugging your front-end.\n\n## hardhat-deploy in a nutshell\n\nBefore going into the details, here is a very simple summary of the basic feature of **hardhat-deploy**.\n\n**hardhat-deploy** allows you to write [`deploy scripts`](#deploy-scripts) in the `deploy` folder. Each of these files that look as follows will be executed in turn when you execute the following task: `hardhat --network <networkName> deploy`\n\n```js\n// deploy/00_deploy_my_contract.js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('MyContract', {\n    from: deployer,\n    args: ['Hello'],\n    log: true,\n  });\n};\nmodule.exports.tags = ['MyContract'];\n```\n\nFurthermore you can also ensure these scripts are executed in test too by calling `await deployments.fixture(['MyContract'])` in your test.\nThis is optimized, so if multiple tests use the same contract, the deployment will be executed once and each test will start with the exact same state.\n\nThis is a huge benefit for testing since you are not required to replicate the deployment procedure in your tests. The tag feature (as seen in the script above) and [dependencies](#deploy-scripts-tags-and-dependencies) will also make your life easier when writing complex deployment procedures.\n\nYou can even group deploy scripts in different sub folder and ensure they are executed in their logical order.\n\nFurthermore hardhat-deploy can also support a multi-chain settings like L1, L2 with multiple deploy folder specific to each network.\n\nThere is a tutorial covering the basics here : https://github.com/wighawag/tutorial-hardhat-deploy\n\n## Installation\n\n### npm install hardhat-deploy\n\n```bash\nnpm install -D hardhat-deploy\n```\n\nAnd add the following statement to your `hardhat.config.js`:\n\n```js\nrequire('hardhat-deploy');\n```\n\nif you use `ethers.js` we recommend you also install `hardhat-deploy-ethers` which add extra features to access deployments as ethers contract.\n\nSince `hardhat-deploy-ethers` is a fork of `@nomiclabs/hardhat-ethers` and that other plugin might have an hardcoded dependency on `@nomiclabs/hardhat-etehrs` the best way to install `hardhat-deploy-ethers` and ensure compatibility is the following:\n\n```bash\nnpm install --save-dev  @nomiclabs/hardhat-ethers@npm:hardhat-deploy-ethers ethers\n```\n\nWhich means you then need to do `require(\"@nomiclabs/hardhat-ethers\")` instead of `require(\"hardhat-deploy-ethers\")` in your `hardhat.config.js` file.\n\nMore details on `hardhat-deploy-ethers` repo : https://github.com/wighawag/hardhat-deploy-ethers#readme\n\n### TypeScript support\n\nWith hardhat the tsconfig.json is optional.\n\nBut if you add folders to the `include` field in `tsconfig.json`, you ll also need to include `hardhat.config.ts` like :\n\n`include\": [\"./hardhat.config.ts\", \"./scripts\", \"./deploy\", \"./test\"]`\n\nfor deploy script (see below) you can write them this way to benefit from typing :\n\n```ts\nimport {HardhatRuntimeEnvironment} from 'hardhat/types';\nimport {DeployFunction} from 'hardhat-deploy/types';\n\nconst func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {\n  // code here\n};\nexport default func;\n```\n\nSee a template that uses **hardhat-deploy** here : https://github.com/wighawag/template-ethereum-contracts\n\nThis repo has also some examples branch that exemplify specific features, like the forking testing here : https://github.com/wighawag/template-ethereum-contracts/tree/examples/fork-test\n\n### Migrating existing deployment to hardhat-deploy\n\n(Only needed for existing project that already deployed contracts and has the deployment information available **(at minimum, address and abi)**)\n\nYou might want to switch your current deployment process to use **hardhat-deploy**. In that case you probably have some deployments saved elsewhere.\n\nIn order to port them to **hardhat-deploy**, you'll need to create one `.json` file per contract in the `deployments/<network>` folder (configurable via [paths config](#extra-paths-config)).\n\nThe network folder is simply the hardhat network name (as configured in hardhat.config.js) (accessible at runtime via `hre.network.name`).\nSuch folder need to have a file named `.chainId` containing the chainId as decimal.\n\nFor example for network named \"rinkeby\" (for the corresponding network) the file `deployments/rinkeby/.chainId` would be\n\n```\n4\n```\n\nNote, prior to hardhat 0.6 the chainId was appended to the folder name (expect for some known network name). This has changed and upgrading to 0.6 will require you to change the folder name and add the '.chainId' file.\n\nEach contract file must follow this type (as defined in [types.ts](types.ts)) :\n\n```ts\nexport interface Deployment {\n  address: Address;\n  abi: ABI;\n  receipt?: Receipt;\n  transactionHash?: string;\n  history?: Deployment[];\n  implementation?: string;\n  args?: any[];\n  linkedData?: any;\n  solcInputHash?: string;\n  metadata?: string;\n  bytecode?: string;\n  deployedBytecode?: string;\n  libraries?: Libraries;\n  userdoc?: any;\n  devdoc?: any;\n  methodIdentifiers?: any;\n  diamondCut?: FacetCut[];\n  facets?: Facet[];\n  storageLayout?: any;\n  gasEstimates?: any;\n}\n```\n\nAs you can see, only abi and address are mandatory. But having the other fields allow more feature. For example, metadata and args allow you to benefit from contract code verification.\n\nFor Receipt, the following type is expected:\n\n```ts\nexport type Receipt = {\n  from: string;\n  transactionHash: string;\n  blockHash: string;\n  blockNumber: number;\n  transactionIndex: number;\n  cumulativeGasUsed: string;\n  gasUsed: string;\n  contractAddress?: string;\n  to?: string;\n  logs?: Log[];\n  events?: any[];\n  logsBloom?: string;\n  byzantium?: boolean;\n  status?: number;\n  confirmations?: number;\n};\n```\n\nHere is an example:\n\nLet sey you have:\n\n- 2 Contract named Greeter and Registry deployed on rinkeby\n- 1 contract named Greeter on mainnet\n- 2 Contract named Greeter and Registry deployed on a network named rinkeby2\n\nYou would get the following folder structure:\n\n```\ndeployments/\n  mainnet/\n    .chainId\n    Greeter.json\n  rinkeby/\n    .chainId\n    Greeter.json\n    Registry.json\n  rinkeby2/\n    .chainId\n    Greeter.json\n    Registry.json\n```\n\nThe reason why **hardhat-deploy** save chainId in the `.chainId` file is both for\n\n- safety: so that if you were to change the network name to point to a different chain, it would not attempt to read the wrong folder and assume that a contract has been deployed while it has not.\n- ability to know the chainId without requring to be connected to a node (and so not dependent on hardhat.config.js settings). Useful for `export` task.\n\n---\n\n## Hardhat Tasks Available/Updated\n\nhardhat deploy add several task to hardhat. It also modify existing one, adding new options and new behavior. All of these are described here:\n\n---\n\n### 1. hardhat deploy\n\n---\n\nThis plugin adds the _deploy_ task to Hardhat.\n\nThis task will execute the scripts in the `deploy` folder and save the contract deployments to disk. These deployments are supposed to be saved for example in a git repository. This way they can be accessed later. But you are free to save them elsewhere and get them back via your mechanism of choice.\n\nWith the deployment saved, it allows you to deploy a contract only if changes were made.\n\nDeploy scripts (also called Deploy functions) can also perform aribtrary logic.\n\nFor further details on how to use it and write deploy script, see [section](#deploy-scripts) below.\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployments, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice (in wei) to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--reset`: This flag resets the deployments from scratch. Previously deployed contract are not considered and deleted from disk.\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n---\n\n### 2. hardhat node\n\n---\n\nThis plugin modify the _node_ task so that it also execute the deployment script before exposing the server http RPC interface\n\nIt add similar options than the `deploy` task :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n`--forkDeployments <networkName>`: defaults to `localhost`; this option allows you to specify the network to fetch the deployment from when running in fork mode. This is necessary as hardhat fork feature does not track the fork's network: <https://github.com/nomiclabs/hardhat/issues/1164>\n\n`--asNetwork <networkName`: default to `localhost` (or the value specified by `--forkDeployments` if any), this option allows you to specify the network name to be used for **hardhat-deploy** functionality, like which folder the resulting deployment should be saved to.\n\n#### **Flags**\n\n`--noReset`: This flag prevent the reseting of the existing deployments. This is usually not desired when running the `node` task as a network is created from scratch and previous deployemnt are irrelevant.\n\n`--show-accounts`: this flag will output the account private keys\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n`--no-deploy` that discard all other options to revert to normal `hardhat node` behavior without any deployment being performed.\n\nNote that the deployments are saved as if the network name is `localhost`. This is because `hardhat node` is expected to be used as localhost: You can for example execute `hardhat --network localhost console` after `node` is running. Doing `builder --network hardhat console` would indeed not do anything useful. It still take the configuration from `hardhat` in the hardhat.config.js file though.\n\n---\n\n### 3. hardhat test\n\n---\n\nThis plugin adds a flag argument `--deploy-fixture` to the _test_ task that runs the global deployments fixture before the tests and snapshots it. This will generaly speed up the tests.\n\n---\n\n### 4. hardhat etherscan-verify\n\n---\n\nThis plugin adds the _etherscan-verify_ task to Hardhat.\n\nThis task will submit the contract source and other info of all deployed contracts to allow etherscan to verify and record the sources.\n\nInstead of using the full solc input, this task will first attempt to send the minimal sources from the metadata.\nBut Etherscan sometime fails due to a bug in solidity compiler (<https://github.com/ethereum/solidity/issues/9573>). As such this task can fallback on full solc input (see option --solc-input). Note that if your contract was deployed with a previous version of **hardhat-deploy**, it might not contains the full information. The issue seems to be fully resolved since solc version 0.8.\n\nThis task will also attempt to automatically find the SPDX license in the source.\n\nTo execute that task, you need to specifiy the network to run against :\n\n```bash\nhardhat --network mainnet etherscan-verify --api-key <apikey>\n```\n\n#### **Options**\n\n`--api-key <api key>`: let you specify your etherscan api key. Alternatively, you can provide it via the env variable `ETHERSCAN_API_KEY`\n\n`--license <SPDX license id>`: SPDX license (useful if SPDX is not listed in the sources), need to be supported by etherscan: https://etherscan.io/contract-license-types\n\n`--force-license`: if set, will force the use of the license specified by --license option, ignoring the one in the source (useful for license not supported by etherscan)\n\n`--solc-input`: fallback on solc-input id needed (useful when etherscan fails on the minimum sources, see https://github.com/ethereum/solidity/issues/9573)\n\n---\n\n### 5. hardhat sourcify\n\n---\n\nThis plugin adds the _sourcify_ task to Hardhat.\n\nSimilar to `hardhat etherscan-verify` this task will submit the contract source and other info of all deployed contracts to sourcify.\n\n```bash\nhardhat --network mainnet sourcify\n```\n\nLater this task might instead pin the metadata to ipfs, so sourcify can automatically verify them.\n\n#### **Options**\n\n`--endpoint <endpoint>`: specify the sourcify endpoint, default to https://sourcify.dev/server/\n\n`--write-failing-metadata`: if set and the sourcify task fails to verify, the metadata file will be written to disk, so you can more easily figure out what has gone wrong.\n\n---\n\n### 6. hardhat export\n\n---\n\nThis plugin adds the _export_ task to Hardhat.\n\nThis task will export the contract deployed (saved in `deployments` folder) to a file with a simple format containing only contract addresses and abi, useful for web apps.\n\nOne of the following options need to be set for this task to have any effects :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\nThis last option has some limitations, when combined with the use of external deployments (see [Configuration](#configuration)). If such external deployments were using older version of **hardhat-deploy** or truffle, the chainId might be missing. In order for these to be exported, the hardhat network config need to explicity state the chainId in the `networks` config of `hardhat.config.js`.\n\n---\n\n---\n\n## Hardhat Environment Extensions\n\nThis plugin extends the Hardhat Runtime Environment by adding 4 fields:\n\n- `getNamedAccounts: () => Promise<{ [name: string]: string }>`: a function returning an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [Configuration](#configuration)).\n\n- `getUnnamedAccounts: () => Promise<string[]}>`: accounts which has no names, useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`: contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId(): Promise<string>`: offer an easy way to fetch the current chainId.\n\n---\n\n---\n\n## Configuration\n\n---\n\n### **1. namedAccounts (ability to name addresses)**\n\n---\n\nThis plugin extends the `HardhatConfig`'s object with an optional `namedAccounts` field.\n\n`namedAccounts` allows you to associate names to addresses and have them configured per chain.\nThis allows you to have meaningful names in your tests while the addresses match to multi sig in real network for example.\n\n```js\n{\n    namedAccounts: {\n        deployer: {\n            default: 0, // here this will by default take the first account as deployer\n            1: 0, // similarly on mainnet it will take the first account as deployer. Note though that depending on how hardhat network are configured, the account 0 on one network can be different than on another\n            4: '0xA296a3d5F026953e17F472B497eC29a5631FB51B', // but for rinkeby it will be a specific address\n            \"goerli\": '0x84b9514E013710b9dD0811c9Fe46b837a4A0d8E0', //it can also specify a specific netwotk name (specified in hardhat.config.js)\n        },\n        feeCollector:{\n            default: 1, // here this will by default take the second account as feeCollector (so in the test this will be a different account than the deployer)\n            1: '0xa5610E1f289DbDe94F3428A9df22E8B518f65751', // on the mainnet the feeCollector could be a multi sig\n            4: '0xa250ac77360d4e837a13628bC828a2aDf7BabfB3', // on rinkeby it could be another account\n        }\n    }\n}\n```\n\n<!-- You can also specify addresses with the `ledger://` prefix. In which case the account fetched will still be the corresponding address, but behind the scene, the transaction will be created via the hardware waller. Currently the feature is not working very well though and better support is needed. -->\n\n---\n\n### **2. extra hardhat.config networks' options**\n\n---\n\n**hardhat-deploy** add 4 new fields to `networks` configuration\n\n`live` : this is not used internally but is useful to perform action on a network whether it is a live network (rinkeby, mainnet, etc) or a temporary one (localhost, hardhat). The default is true (except for localhost and hardhat where the default is false).\n\n`saveDeployments`: this tell whether **hardhat-deploy** should save the deployments to disk or not. Default to true, except for the hardhat network.\n\n`tags`: network can have tags to represent them. The config is an array and at runtime the hre.network.tags is an object whose fields (the tags) are set to true.\n\nThis is useful to conidtionaly operate on network based on their use case.\n\nExample:\n\n```js\n{\n  networks: {\n    localhost: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"local\"]\n    },\n    hardhat: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"test\", \"local\"]\n    },\n    rinkeby: {\n      live: true,\n      saveDeployments: true,\n      tags: [\"staging\"]\n    }\n  }\n}\n```\n\n`deploy`: the deploy field override the paths.deploy option and let you define a set of folder containing the deploy scripts to be executed for this network.\n\nYou can thus have one network that will be executing L1 deployment and other L2 deployments, etc...\n\n---\n\n### **3. extra hardhat.config paths' options**\n\n---\n\nIt also adds fields to `HardhatConfig`'s `ProjectPaths` object.\n\nHere is an example showing the default values :\n\n```js\n{\n    paths: {\n        deploy: 'deploy',\n        deployments: 'deployments',\n        imports: 'imports'\n    }\n}\n```\n\nThe deploy folder is expected to contains the deploy script that are executed upon invocation of `hardhat deploy` or `hardhat node`.\nIt can also be an array of folder path.\n\nThe deployment folder will contains the resulting deployments (contract addresses along their abi, bytecode, metadata...). One folder per network and one file per contract.\n\nThe imports folder is expected to contains artifacts that were pre-compiled. Useful if you want to upgrade to a new solidity version but want to keep using previously compiled contracts. The artifact is the same format as normal hardhat artifact, so you can easily copy them over, before switching to a new compiler version.\n\n---\n\n### Importing deployment from other projects (with truffle support)\n\nIt also add the `external` field to `HardhatConfig`\n\nSuch fiels allows to specify paths for external artifacts or deployments.\n\nThe external object has 2 fields:\n\n```js\n{\n    external: {\n        contracts: [\n          {\n            artifacts: \"node_modules/@cartesi/arbitration/export/artifacts\",\n            deploy: \"node_modules/@cartesi/arbitration/export/deploy\"\n          },\n          {\n            artifacts: \"node_modules/someotherpackage/artifacts\",\n          }\n        ],\n        deployments: {\n          rinkeby: [\"node_modules/@cartesi/arbitration/build/contracts\"],\n        },\n    }\n}\n```\n\nThe contract field specify an array of object which itself have 2 fields.\n\n- artifacts: (mandatory) it is a path to an artifact folder. This support both hardhat and truffle artifacts.\n- deploy: (optional) it specifies a path to a folder where reside deploy script. The deploy script have only access to the artifact specified in the artifacts field. This allow project to share their deployment procedure. A boon for developer aiming at integrating it as they can get the contracts to be deployed for testing locally.\n\nThe deployments fields specify an object whose field name are the hardhat network and the value is an array of path to look for deployments. It supports both **hardhat-deploy** and truffle formats.\n\n---\n\n### Access to Artifacts (non-deployed contract code and abi)\n\nyou can access contract artifact via `getArtifact` function :\n\n```js\nconst {deployments} = require('hardhat');\nconst artifact = await deployments.getArtifact(artifactName);\n```\n\nWith the `hardhat-deploy-ethers` plugin you can get your ethers contract via :\n\n```js\nconst {deployments, ethers} = require('hardhat');\nconst factory = await ethers.getContractFactory(artifactName);\n```\n\nNote that the artifact file need to be either in `artifacts` folder that hardhat generate on compilation or in the `imports` folder where you can store contracts compiled elsewhere. They can also be present in the folder specified in `external.artifacts` see [Importing deployment from other projects](#importing-deployment-from-other-projects-truffle-support-too)\n\n---\n\n---\n\n## How to Deploy Contracts\n\n---\n\n### The `deploy` Task\n\n`hardhat --network <networkName> deploy [options and flags]`\n\nThis is a new task that the plugin adds. As the name suggests it deploys contracts.\nTo be exact it will look for files in the folder `deploy` or whatever was configured in `paths.deploy`, see [paths config](#extra-paths-config)\n\nIt will scan for files in alphabetical order and execute them in turn.\n\n- it will `require` each of these files and execute the exported function with the HRE as argument\n\nNote that running `hardhat deploy` without specifying a network will use the default network. If the default network is hardhat (the default's default) then nothing will happen as a result but this can be used to ensure the deployment is without issues.\n\nTo specified the network, you can use the builtin hardhat argument `--network <network name>` or set the env variable `HARDHAT_NETWORK`\n\n---\n\n### Deploy Scripts\n\nThe deploy scripts need to be of the following type :\n\n```js\nexport interface DeployFunction {\n  (env: HardhatRuntimeEnvironment): Promise<void | boolean>;\n  skip?: (env: HardhatRuntimeEnvironment) => Promise<boolean>;\n  tags?: string[];\n  dependencies?: string[];\n  runAtTheEnd?: boolean;\n  id?: string;\n}\n```\n\nThe skip function can be used to skip executing the script under whatever condition. It simply need to resolve a promise to true.\n\nThe tags is a list of string that when the _deploy_ task is executed with, the script will be executed (unless it skips). In other word if the deploy task is executed with a tag that does not belong to that script, that script will not be executed unless it is a dependency of a script that does get executed.\n\nThe dependencies is a list of tag that will be executed if that script is executed. So if the script is executed, every script whose tag match any of the dependency will be executed first.\n\nThe `runAtTheEnd` is a boolean that if set to true, will queue that script to be executed after all other scripts are executed.\n\nThese set of fields allow more flexibility to organize the scripts. You are not limited to alphabetical order.\n\nFinally the function can return true if it wishes to never be executed again. This can be usfeul to emulate migration scripts that are meant to be executed only once. Once such script return true (async), the `id` field is used so to track execution and if that field is not present when the script return true, it will fails.\n\nIn any case, as a general advice every deploy function should be idempotent. This is so they can always recover from failure or pending transaction.\n\nThis is why the `hre.deployments.deploy` function will by default only deploy if the contract code has changed, making it easier to write idempotent script.\n\nAn example of a deploy script :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  // the following will only deploy \"GenericMetaTxProcessor\" if the contract was never deployed or if the code changed since last deployment\n  await deploy('GenericMetaTxProcessor', {\n    from: deployer,\n    gasLimit: 4000000,\n    args: [],\n  });\n};\n```\n\nAs you can see the HRE passed in has 4 new fields :\n\n- `getNamedAccounts` is a function that returns a promise to an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [`namedAccounts`](#namedaccounts)).\n\n- `getUnnamedAccounts`: function that return a promise to an array of accounts (which were not used in `getNamedAccounts`), useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`, which contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId` which return a promise for the chainId\n\nThe deploynments field contains the `deploy` function taht allow you to deploy contract and save them. It contains a lot more functions though :\n\n---\n\n### The `deployments` field\n\nThe deployments field contains several helpers function to deploy contract but also execute transaction.\n\n```ts\nexport interface DeploymentsExtension {\n  deploy(name: string, options: DeployOptions): Promise<DeployResult>; // deploy a contract\n  diamond: {\n    // deploy diamond based contract (see section below)\n    deploy(name: string, options: DiamondOptions): Promise<DeployResult>;\n  };\n  deterministic( // return the determinsitic address as well as a function to deploy the contract, can pass the `salt` field in the option to use different salt\n    name: string,\n    options: Create2DeployOptions\n  ): Promise<{\n    address: Address;\n    deploy(): Promise<DeployResult>;\n  }>;\n  fetchIfDifferent( // return true if new compiled code is different than deployed contract\n    name: string,\n    options: DeployOptions\n  ): Promise<{differences: boolean; address?: string}>;\n  save(name: string, deployment: DeploymentSubmission): Promise<void>; // low level save of deployment\n  get(name: string): Promise<Deployment>; // fetch a deployment by name, throw if not existing\n  getOrNull(name: string): Promise<Deployment | null>; // fetch deployment by name, return null if not existing\n  getDeploymentsFromAddress(address: string): Promise<Deployment[]>;\n  all(): Promise<{[name: string]: Deployment}>; // return all deployments\n  getArtifact(name: string): Promise<Artifact>; // return a hardhat artifact (compiled contract without deployment)\n  getExtendedArtifact(name: string): Promise<ExtendedArtifact>; // return a extended artifact (with more info) (compiled contract without deployment)\n  run( // execute deployment scripts\n    tags?: string | string[],\n    options?: {\n      resetMemory?: boolean;\n      deletePreviousDeployments?: boolean;\n      writeDeploymentsToFiles?: boolean;\n      export?: string;\n      exportAll?: string;\n    }\n  ): Promise<{[name: string]: Deployment}>;\n  fixture( // execute deployment as fixture for test // use evm_snapshot to revert back\n    tags?: string | string[],\n    options?: {fallbackToGlobal?: boolean; keepExistingDeployments?: boolean}\n  ): Promise<{[name: string]: Deployment}>;\n  createFixture<T, O>( // execute a function as fixture using evm_snaphost to revert back each time\n    func: FixtureFunc<T, O>,\n    id?: string\n  ): (options?: O) => Promise<T>;\n  log(...args: any[]): void; // log data only ig log enabled (disabled in test fixture)\n\n  execute( // execute function call on contract\n    name: string,\n    options: TxOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<Receipt>;\n  rawTx(tx: SimpleTx): Promise<Receipt>; // execute a simple transaction\n  catchUnknownSigner( // you can wrap other function with this function and it will catch failure due to missing signer with the details of the tx to be executed\n    action: Promise<any> | (() => Promise<any>),\n    options?: {log?: boolean}\n  ): Promise<null | {\n    from: string;\n    to?: string;\n    value?: string;\n    data?: string;\n  }>;\n  read( // make a read-only call to a contract\n    name: string,\n    options: CallOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<any>;\n  read(name: string, methodName: string, ...args: any[]): Promise<any>;\n  // rawCall(to: Address, data: string): Promise<any>; // TODO ?\n}\n```\n\n---\n\n#### `deployments.deploy`\n\n---\n\nThe deploy function as mentioned allow you to deploy a contract and save it under a specific name.\n\nThe deploy function expect 2 parameters: one for the name and one for the options\n\nSee below the full list of fields that the option parameter allows and requires:\n\n```ts\nexport interface DeployOptions = {\n  from: string; // address (or private key) that will perform the transaction. you can use `getNamedAccounts` to retrived the address you want by name.\n  contract?: // this is an optional field. If not specified it defaults to the contract with the same name as the first parameter\n    | string // this field can be either a string for the name of the contract\n    | { // or abi and bytecode\n        abi: ABI;\n        bytecode: string;\n        deployedBytecode?: string;\n      };\n  args?: any[]; // the list of argument for the constructor (or the upgrade function in case of proxy)\n  skipIfAlreadyDeployed?: boolean; // if set it to true, will not attempt to deploy even if the contract deployed under the same name is different\n  log?: boolean; // if true, it will log the result of the deployment (tx hash, address and gas used)\n  linkedData?: any; // This allow to associate any JSON data to the deployment. Useful for merkle tree data for example\n  libraries?: { [libraryName: string]: Address }; // This let you associate libraries to the deployed contract\n  proxy?: boolean | string | ProxyOptions; // This options allow to consider your contract as a proxy (see below for more details)\n\n  // here some common tx options :\n  gasLimit?: string | number | BigNumber;\n  gasPrice?: string | BigNumber;\n  value?: string | BigNumber;\n  nonce?: string | number | BigNumber;\n\n  estimatedGasLimit?: string | number | BigNumber; // to speed up the estimation, it is possible to provide an upper gasLimit\n  estimateGasExtra?: string | number | BigNumber; // this option allow you to add a gas buffer on top of the estimation\n\n  autoMine?: boolean; // this force a evm_mine to be executed. this is useful to speed deployment on test network that allow to specify a block delay (ganache for example). This option basically skip the delay by force mining.\n  deterministicDeployment? boolean | string; // if true, it will deploy the contract at a deterministic address based on bytecode and constuctor arguments. The address will be the same across all network. It use create2 opcode for that, if it is a string, the string will be used as the salt.\n};\n```\n\n---\n\n---\n\n## Handling contract using libraries\n\nIn the deploy function, one of the `DeployOptions` that can be passed into the function is the `libraries` field.\n\nFirst, deploy the library using the `deploy` function, then when we deploy a contract that needs the the linked library, we can pass the deployed library name and address in as an argument to the `libraries` object.\n\n```js\nconst exampleLibrary = await deploy(\"ExampleLibary\", {\n    from: <deployer>\n});\n\n```\n\nExampleLibrary is now deployed to whatever network is in the context of the environment.\n\nFor example, if we are deploying on Rinkeby, this library will get deployed on rinkeby, and the `exampleLibrary` variable will be a deployment object that contains the abi as well as the deployed address for the contract.\n\nNow that the library is deployed, we can link it in our next deployed contract.\n\n```js\nconst example = await deploy(\"Example\", {\n    from: <deployer>\n    args: [\"This is an example string argument in the constructor for the 'Example' contract\"],\n    libraries: {\n        ExampleLibrary: exampleLibrary.address\n    }\n});\n\n```\n\nThis `libraries` object takes the name of the library, and its deployed address on the network. Multiple libraries can be passed into the `libraries` object.\n\n---\n\n---\n\n## Exporting Deployments\n\nApart from deployments saved in the `deployments` folder which contains all information available about the contract (compile time data + deployment data), `hardhat-deploy` allows you to export lightweight files.\n\nThese can be used for example to power your frontend with contract's address and abi.\n\nThis come into 2 flavors.\n\nThe first one is exported via the `--export <file>` option and follow the following format :\n\n```js\nexport interface Export {\n  chainId: string;\n  name: string;\n  contracts: {[name: string]: ContractExport};\n}\n```\n\nwhere name is the name of the network configuration chosen (see hardhat option `--network`)\n\nThe second one is exported via the `--export-all <file>` option and follow the following format :\n\n```js\nexport type MultiExport = {\n  [chainId: string]: {[name: string]: Export},\n};\n```\n\nAs you see the second format include the previous. While in most case you'll need the single export where your application will support only one network, there are case where your app would want to support multiple network at nonce. This second format allow for that.\n\nFurthermore as hardhat support multiple network configuration for the same network (rinkeby, mainnet...), the export-all format will contains each of them grouped by their chainId.\n\n---\n\n---\n\n## Deploying and Upgrading Proxies\n\nAs mentioned above, the deploy function can also deploy a contract through a proxy. It can be done without modification of the contract as long as it does not have a constructor (or constructor with zero arguments).\n\nThe default Proxy is both ERC-1967 and ERC-173 Compliant, but other proxy can be specified, like openzeppelin transparent proxies.\n\nCode for the default Proxy can be found [here](solc_0.7/proxy/EIP173Proxy.sol)\n\nTo perform such proxy deployment, you just need to invoke the deploy function with the following options : `{..., proxy: true}`\n\nSee example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: true,\n  });\n};\n```\n\nYou can also set it to `proxy: \"<upgradeMethodName>\"` in which case the function `<upgradeMethodName>` will be executed upon upgrade.\nthe `args` field will be then used for that function instead of the contructor. It is also possible to then have a constructor with the same arguments and have the proxy be disabled. It can be useful if you want to have your contract as upgradeable in a test network but be non-upgradeable on the mainnet.\n\nSee example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: 'postUpgrade',\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nThe proxy option can also be an object which can set the specific owner that the proxy is going to be managed by.\n\nSee example:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: {\n      owner: greeterOwner,\n      methodName: 'postUpgrade',\n    },\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nNote that for the second invokation, this deployment will fails to upgrade the proxy as the `from` which is `deployer` is not the same as the proxy's owner : `greeterOwner`\n\nTo make it work, you have to create a new script that have for `from` field: `greeterOwner`. If such value is a a multi sig or an address not registered as part of hardhat signers, the tx will not be executed but instead an error will be throw. That error can be caught up via deployments.catchUnknwonSigner function so you get the necessary tx details to execute it elsewhere.\n\nThe full proxy options is as follow:\n\n```ts\nexport interface ProxyOptions {\n  owner?: Address; // this set the owner of the proxy. further upgrade will need to be executed from that owner\n  methodName?: string; // method to be executed when the implementation is modified.\n  proxyContract?: string | ArtifactData; // default to \"EIP173Proxy\". See below for more details\n  viaAdminContract?: // allow to specify a contract that act as a middle man to perform upgrades. Useful and Recommended for Transparent Proxies\n  | string\n    | {\n        name: string;\n        artifact?: string | ArtifactData;\n      };\n}\n```\n\nThe `proxyContract` field allow you to specify your own Proxy contract. If it is a string, it will first attemp to get an artifact with that name. If not found it will fallback on the following if\n\nit matches:\n\n- `EIP173Proxy`: use the default Proxy that is EIP-173 compliant\n\n- `EIP173ProxyWithReceive`: Same as above except that the proxy contains a receive hook to accept empty ETH payment\n\n- `OpenZeppelinTransparentProxy`: Use Openzeppelin Transparent Proxy (slightly modified as openzeppelin's one hardcode the msg.sender as first owner, see code [here](solc_0.7\\openzeppelin\\proxy\\TransparentUpgradeableProxy.sol))\n  When this option is chosen, the `DefaultProxyAdmin` is also used as admin since Transparent Proxy kind of need an intermediarry contract for administration. This can be configired via the `viaAdminContract` option\n\n- `OptimizedTransparentProxy`: This contract is similar to above, except that it is optimized to not require storage read for the admin on every call.\n\n## Builtin-In Support For Diamonds (EIP2535)\n\nThe deployments field also expose the diamond field: `hre.deployments.diamond` that let you deploy [Diamonds](https://eips.ethereum.org/EIPS/eip-2535) in an easy way.\n\nInstead of specifying the facets to cut out or cut in, which the diamond contract expects, you specify the facets you want to end up having on the deployed contract.\n\n`diamond.deploy` expect the facet as names. The names represent contract to be deployed as facet. In future version you ll be able to specify deployed contract or artifact object as facet.\n\nTo deploy a contract with 3 facet you can do as follow :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: deployer,\n    owner: diamondAdmin,\n    facets: ['Facet1', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nif you then later execute the following script:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: diamondAdmin, // this need to be the diamondAdmin for upgrade\n    owner: diamondAdmin,\n    facets: ['NewFacet', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nThen the NewFacet will be deployed automatically if needed and then the diamondCut will cut Facet1 out and add NewFacet.\n\nNote that if the code for Facet2 and Facet3 changes, they will also be redeployed automatically and the diamondCuts will replace the existing facets with these new ones.\n\nNote that The Diamond contract's code is part of hardhat-deploy and contains 3 built-in facet that can be removed manually if desired.\nThese facets are used for ownership, diamondCut and diamond loupe.\n\nThe implementation is the [reference implementation by Nick Mudge](https://github.com/mudgen/diamond-3)\n\nLike normal proxies you can also execute a function at the time of an upgrade.\n\nThis is done by specifying the execute field in the diamond deploy options :\n\n```js\ndiamond.deploy('ADiamondContract', {\n  from: deployer,\n  owner: diamondAdmin,\n  facets: ['NewFacet', 'Facet2', 'Facet3'],\n  execute: {\n    methodName: 'postUpgrade',\n    args: ['one', 2, '0x3'],\n  },\n});\n```\n\nSince the diamond standard has no builtin mechanism to make the deployment of Diamond with function execution, the Diamond when deployed is actually deployed through a special contract, the `Diamantaire` (see code [here](solc_0.7/diamond/Diamantaire.sol)) that act as factory to build Diamond. It uses deterministic deployment for that so, it is transparently managed by hardhat-deploy. It also embed the implementation of the builtin facet, removing the need to have different instances of each live.\n\n<!-- The Diamantaire also support the deterministic deployment of Diamonds.\nAn extra field can be passed to the Diamond deployment options : `deterministicSalt`. It has to be a non-zero 32bytes string (in hex format).\nNote that if you want to deploy 2 diamonds with same owner, you'll need 2 different deterministicSalt for them to be 2 separate contracts. -->\n\n## Testing Deployed Contracts\n\nYou can continue using the usual test task :\n\n`hardhat test`\n\nTests can then use the `hre.deployments.fixture` function to run the deployment for the test and snapshot it so that tests don't need to perform all the deployments transaction every time, they simply reuse the snapshot for every test (this leverages `evm_snapshot` and `evm_revert` provided by both `hardhat` and `ganache`). You can for example set them in a `beaforeEach`.\n\nHere is an example of a test :\n\n```js\nconst {deployments} = require('hardhat');\n\ndescribe('Token', () => {\n  beforeEach(async () => {\n    await deployments.fixture();\n  });\n  it('testing 1 2 3', async function () {\n    const Token = await deployments.get('Token'); // Token is available because the fixture was executed\n    console.log(Token.address);\n    const ERC721BidSale = await deployments.get('ERC721BidSale');\n    console.log({ERC721BidSale});\n  });\n});\n```\n\nIf the deployment scripts are complex, the first test could take while (as the fixture need to execute the deployment) but then from the second test onward, the deployments are never re-executed, instead the fixture will do `evm_revert` and test will run far faster.\n\nTests can also leverage named accounts for clearer test. Combined with `hardhat-deploy-ethers` plugin, you can write succint test :\n\n```js\nconst {ethers, getNamedAccounts} = require('hardhat');\n\ndescribe('Token', () => {\n  beforeEach(async () => {\n    await deployments.fixture();\n  });\n  it('testing 1 2 3', async function () {\n    const {tokenOwner} = await getNamedAccounts();\n    const TokenContract = await ethers.getContract('Token', tokenOwner);\n    await TokenContract.mint(2).then((tx) => tx.wait());\n  });\n});\n```\n\n---\n\n### Creating Fixtures\n\nFurthermore, tests can easily create efficient fixture using `deployments.createFixture`\n\nSee example :\n\n```js\nconst setupTest = deployments.createFixture(async ({deployments, getNamedAccounts, ethers}, options) => {\n  await deployments.fixture(); // ensure you start from a fresh deployments\n  const { tokenOwner } = await getNamedAccounts();\n  const TokenContract = await ethers.getContract(\"Token\", tokenOwner);\n  await TokenContract.mint(10).then(tx => tx.wait()); //this mint is executed once and then `createFixture` will ensure it is snapshotted\n  return {\n    tokenOwner: {\n      address: tokenOwner,\n      TokenContract\n    }\n  };\n};\ndescribe(\"Token\", () => {\n  it(\"testing 1 2 3\", async function() {\n    const {tokenOwner} = await setupTest()\n    await tokenOwner.TokenContract.mint(2);\n  });\n});\n```\n\nWhile this example is trivial, some fixture can requires several transaction and the ability to snapshot them automatically speed up the tests greatly.\n\n---\n\n---\n\n## More Information On Hardhat Tasks\n\n---\n\n### **1. node task**\n\nas mentioned above, the node task is slighly modified and augmented with various flags and options\n\n`hardhat node`\n\nIn particulat it adds an argument `--export` that allows you to specify a destination file where the info about the contracts deployed is written.\nYour webapp can then access all contracts information.\n\n---\n\n### **2. test task**\n\n`hardhat test`\n\nthe test task is augmented with one flag argument `--deploy-fixture` that allows to run all deployments in a fixture snapshot before executing the tests. This can speed up the tests that use specific tags as the global fixture take precedence (unless specified).\n\nIn other word tests can use `deployments.fixture(<specific tag>)` where specific tag only deploys the minimal contracts for tests, while still benefiting from global deployment snapshot if used.\n\nIf a test needs the deployments to only include the specific deployment specified by the tag, it can use the following :\n\n```js\ndeployments.fixture('<specific tag>', {fallbackToGlobal: false});\n```\n\nDue to how snapshot/revert works in hardhat, this means that these tests will not benefit from the global fixture snapshot and will have to deploy their contracts as part of the fixture call. This is automatic but means that these tests will run slower.\n\n---\n\n### **3. run task**\n\n`hardhat --network <networkName> run <script>`\n\nThe run task act as before but thanks to the `hre.deployments` field it can access deployed contract :\n\n```js\nconst hre = require('hardhat');\nconst {deployments, getNamedAccounts} = hre;\n\n(async () => {\n  console.log(await deployments.all());\n  console.log({namedAccounts: await getNamedAccounts()});\n})();\n```\n\nYou can also run it directly from the command line as usual.\n\n`HARDHAT_NETWORK=rinkeby node <script>` is the equivalent except it does not load the hardhat environment twice (which the run task does)\n\n---\n\n### **4. console task**\n\n`hardhat console`\n\nThe same applies to the `console` task.\n\n---\n\n## Deploy Scripts: Tags And Dependencies\n\n---\n\nIt is possible to execute only specific parts of the deployments with `hardhat deploy --tags <tags>`\n\nTags represent what the deploy script acts on. In general it will be a single string value, the name of the contract it deploys or modifies.\n\nThen if another deploy script has such tag as a dependency, then when this latter deploy script has a specific tag and that tag is requested, the dependency will be executed first.\n\nHere is an example of two deploy scripts :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const deployResult = await deploy('Token', {\n    from: deployer,\n    args: ['hello', 100],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Token deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Token'];\n```\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const Token = await deployments.get('Token');\n  const deployResult = await deploy('Sale', {\n    from: deployer,\n    contract: 'ERC721BidSale',\n    args: [Token.address, 1, 3600],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Sale deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.dependencies = ['Token']; // this ensure the Token script above is executed first, so `deployments.get('Token')` succeeds\n```\n\nAs you can see the second one depends on the first. This is because the second script depends on a tag that the first script registers as using.\n\nWith that when `hardhat deploy --tags Sale` is executed\n\nthen both scripts will be run, ensuring Sale is ready.\n\nYou can also define the script to run after another script is run by setting `runAtTheEnd` to be true. For example:\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, execute, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer, admin} = namedAccounts;\n  await execute('Sale', {from: deployer}, 'setAdmin', admin);\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.runAtTheEnd = true;\n```\n\nTags can also be used in test with `deployments.fixture`. This allow you to test a subset of the deploy script.\n","readmeFilename":"README.md","gitHead":"cb9f57d1d619682bfbd44dd0d8d0f6f3693b8bf2","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.8.0-next.2","_nodeVersion":"14.16.0","_npmVersion":"6.14.11","dist":{"integrity":"sha512-Pl6zu0E3Xi+3pmGy/mD2XqEGjcjqtDpUwg0XekJFey7LEiISuPHCaX4maLSqu9HVvBJdZEL4HKNZkpJy5bz8rA==","shasum":"de119f6628998e83a9cc1fc5e2473db0d5219732","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.8.0-next.2.tgz","fileCount":111,"unpackedSize":7174206,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJga0+BCRA9TVsSAnZWagAAwQIQAKRYU8yQMp7SP6T7Jcgz\nhvchRfN5VIdSOvQ+e1nYzcam52EAYHMjJkS4crcUZtTeOBba25B5DRXEjJ0m\nZAlXB9xo0J5g94H17HIe09E4ksKVDdlJhGuhfBUpZ+2zo4wq/YCM6h87N9VW\nKryCzPMZiKxC0tk/53ZqBTCWIjCLDSt6e3r3kgJosxmR81RF1jch/815nFqG\niJoLSM1sRd1halQJc8ShXli321/YQaTMsjpEzLf3oQfM5CBFIzcoOPq/0Dq2\nhhNN4xfvsAbP2u1o0bmkONyDd5a5SqKzQvYPyYvk+srgGL8jXJTXOMQVnSFG\n+Qmo2g6pou4BK/6vYe3gxyUzHV7fHftjqAwnyuMn8EA3RvMowBqNf9dc+gga\n5c+VP4uTwxgAvsdf85vimUXRGVRYHOG2hoapHDFTEgWdYAynfvYBPJAfovuL\nq7X2R3AWcki+9Q8ibvvhXeDc6fjUeGduORKi1qL0MPRG5B9W1orR5YPnrCq8\nL5qzyVqw7CE+9rPyt6vtRyop2CpXF+rpkINO0XkfZN57MwJ9792weI3JW+l0\njQsRN7bxqrJFBsRJ44iRKwfJWrJiyWJ6kfl8CPXHh34fy8Z5QxQ07KOIM7Zh\nnJppqlSn7Jo+ZyNik9DS0dc3KjMXpB6ho+En2Yax1j+QG6kdc+JkkuF9Z03D\ne+sQ\r\n=cMyA\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDlKglT327X6CybemH8qifeURr4syMhQx8vkusp1ndPrwIhAO7zIqsya2oW79w7jB3bWsuubp4XQvrBrLAeZGmil5pg"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.8.0-next.2_1617645440465_0.8802096974013418"},"_hasShrinkwrap":false},"0.7.2":{"name":"hardhat-deploy","version":"0.7.2","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/hardware-wallets":"^5.0.14","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"6fd617859f9970fc750c0eeef703de1296ea6f82","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.2","_nodeVersion":"14.16.0","_npmVersion":"6.14.11","dist":{"integrity":"sha512-o5F/B2NkSu0cjkPjblu7sIwYzrFG/sEnA58dzJ9d/0RUaHZ9gezaL1X9Q85Nbo4wRXn+8ElM0RptKAOtQc6ITA==","shasum":"9229312bb03a152c373b1fb921df9aac9911070e","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.2.tgz","fileCount":116,"unpackedSize":7163983,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgbD7bCRA9TVsSAnZWagAAk9AP/0NmhWI7JHA0YN8zw81k\nC7b71BDyKhT58gm/eZPPQf859LIL3VEdSSAWiEcguDQUzFAZ/nt6O/FamLE5\nTkUQ8rtAX/1m9zncMME3MYJZk+GXEkMhCvcsmfBxRI9jtCRHeIkK4v6OtrfJ\nfJMZ6YPYO+zERbuF11izkt4nMM+U7cbygcJ9oY0F/dAAeCMkE2jg1VhD/PSU\nfwsIegwlFRc5xjjBmn4AQX2hwkA+gasa/SjGKIo8Pxr8n8aameg9Dpk8702S\nc66A+KGK47KxX/yooMQq9CBtYGfKPxm8yFVc61i1R/i7uWlHjakBvpzi59ON\n81yV3naOue4jestW5m4/yrLibW5AkCA7pcOj5AbOxpX2w6+g7nCUuFnIORcF\ncWvRjV18kD3MhPiha84o1x8guaasRvuKVODJ5T2Q0ZZQRS7eQTrotoqMT8bW\n9zWVc64+DBEra3UmRsKAHRr1FezT9rQ1X/npnxdCwFumkC/fx+72wDKvzI5u\nGN0aIGQ16fWPKQKmQMtCxFwdHMDziYgc58lIFeUkia7PcELDC/Cq5u5MEgSM\nk8wdUk2mnbTFL0M5JKNn5STmqWOoU0EGEyKxlZOwgDAU59jOJOpQxvE6tJ/s\nDAd2S9mR7h/INRv0WrTN0uLR9AtaLPe5+D+arGg2yf7ef+5SoEJOW8uLe92u\nBKzE\r\n=JNHA\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIA3aGwiDh77OEQI6qfytrc41jv8Y8uHXN4PqidsZIFg4AiEAwex7zdZNebnpgLn+o252U0qQyRF4aNBQQ2tDW/7EHdM="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.2_1617706714857_0.39330379367273904"},"_hasShrinkwrap":false},"0.8.0-next.3":{"name":"hardhat-deploy","version":"0.8.0-next.3","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/hardware-wallets":"^5.0.14","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"readme":"<h1> hardhat-deploy</h1>\n\n_A [Hardhat](https://hardhat.org) Plugin For Replicable Deployments And Easy Testing_\n\n- [What is it for ?](#what-is-it-for-)\n- [hardhat-deploy in a nutshell](#hardhat-deploy-in-a-nutshell)\n- [Installation](#installation)\n  - [npm install hardhat-deploy](#npm-install-hardhat-deploy)\n  - [TypeScript support](#typescript-support)\n  - [Migrating existing deployment to hardhat-deploy](#migrating-existing-deployment-to-hardhat-deploy)\n- [Hardhat Tasks Available/Updated](#hardhat-tasks-availableupdated)\n  - [1. hardhat deploy](#1-hardhat-deploy)\n    - [**Options**](#options)\n    - [**Flags**](#flags)\n  - [2. hardhat node](#2-hardhat-node)\n    - [**Options**](#options-1)\n    - [**Flags**](#flags-1)\n  - [3. hardhat test](#3-hardhat-test)\n  - [4. hardhat etherscan-verify](#4-hardhat-etherscan-verify)\n  - [5. hardhat sourcify](#5-hardhat-sourcify)\n    - [**Options**](#options-2)\n  - [6. hardhat export](#6-hardhat-export)\n    - [**Options**](#options-3)\n- [Hardhat Environment Extensions](#hardhat-environment-extensions)\n- [Configuration](#configuration)\n  - [**1. namedAccounts (ability to name addresses)**](#1-namedaccounts-ability-to-name-addresses)\n  - [**2. extra hardhat.config networks' options**](#2-extra-hardhatconfig-networks-options)\n  - [**3. extra hardhat.config paths' options**](#3-extra-hardhatconfig-paths-options)\n  - [Importing deployment from other projects (with truffle support)](#importing-deployment-from-other-projects-with-truffle-support)\n  - [Access to Artifacts (non-deployed contract code and abi)](#access-to-artifacts-non-deployed-contract-code-and-abi)\n- [How to Deploy Contracts](#how-to-deploy-contracts)\n  - [The `deploy` Task](#the-deploy-task)\n  - [Deploy Scripts](#deploy-scripts)\n  - [The `deployments` field](#the-deployments-field)\n    - [`deployments.deploy`](#deploymentsdeploy)\n- [Handling contract using libraries](#handling-contract-using-libraries)\n- [Exporting Deployments](#exporting-deployments)\n- [Deploying and Upgrading Proxies](#deploying-and-upgrading-proxies)\n- [Testing Deployed Contracts](#testing-deployed-contracts)\n  - [Creating Fixtures](#creating-fixtures)\n- [More Information On Hardhat Tasks](#more-information-on-hardhat-tasks)\n  - [**1. node task**](#1-node-task)\n  - [**2. test task**](#2-test-task)\n  - [**3. run task**](#3-run-task)\n  - [**4. console task**](#4-console-task)\n- [Deploy Scripts: Tags And Dependencies](#deploy-scripts-tags-and-dependencies)\n- [Builtin-In Support For Diamonds (EIP2535)](#builtin-in-support-for-diamonds-eip2535)\n- [Testing Deployed Contracts](#testing-deployed-contracts)\n  - [Creating Fixtures](#creating-fixtures)\n- [Deploy Scripts: Tags And Dependencies](#deploy-scripts-tags-and-dependencies)\n\n## What is it for ?\n\nThis [hardhat](https://hardhat.dev) plugin adds a mechanism to deploy contracts to any network, keeping track of them and replicating the same environment for testing.\n\nIt also adds a mechanism to associate names to addresses, so test and deployment scripts can be reconfigured by simply changing the address a name points to, allowing different configurations per network. This also results in much clearer tests and deployment scripts (no more `accounts[0]` in your code).\n\nThis plugin contains a lot more features too, all geared toward a better developer experience :\n\n- chain configuration export\n- listing deployed contracts' addresses and their abis (useful for webapps)\n- library linking at time of deployment.\n- deterministic deployment across networks.\n- support for specific deploy script per network (L1 vs L2 for example)\n- deployment dependency system (allowing you to only deploy what is needed).\n- deployment retrying (by saving pending tx): so you can feel confident when making a deployment that you can always recover.\n- deployments as test fixture using `evm_snapshot` to speed up testing.\n- ability to create your own test fixture that automatically benefits from `evm_snapshot`'s tests speed-up boost\n- combined with [hardhat-deploy-ethers](https://github.com/wighawag/hardhat-deploy-ethers) it has the ability to get ethers contract instance by name (like `await ethers.getContract(\"ContractName\")`).\n- importing artifact from external sources (like npm packages), including truffle support.\n- importing deployments from external sources (like npm packages), including truffle support.\n- ability to log information in `deploy` mode only (while in test the console remains clean).\n- contains helpers to read and execute transaction on deployed contract referring to them by name.\n- These helpers contains options to auto mine on dev network (to speed up test deployments).\n- save metadata of deployed contract so they can always be fully verified, via [sourcify](https://sourcify.dev) or [etherscan](https://etherscan.io).\n- ability to submit contract source to etherscan and sourcify for verification at any time. (Because **hardhat-deploy** will save all the necessary info, it can be executed at any time.)\n- support harhdat's fork feature so deployment can be accessed even when run through fork.\n- named accounts are automatically impersonnated too, so you can perform tx as if you had their private.\n- proxy deployment with ability to upgrade them transparently, only if code changes.\n- this include support for [openzeppelin](https://openzeppelin.com) transparent proxies\n- diamond deployment with facets, allowing you to focus on what the new version will be. It will generate the diamondCut necessary to reach the new state.\n- watch and deploy: **hardhat-deploy** can watch both your deploy script and contract code and redeploy on changes.\n- HCR (Hot Contract Replacement): the watch feature combined with proxy or diamond, gives you an experience akin to frontend Hot Module Replacement: once your contract changes, the deployment is executed and your contract retains the same address and same state, allowing you to tweak your contracts while debugging your front-end.\n\n## hardhat-deploy in a nutshell\n\nBefore going into the details, here is a very simple summary of the basic feature of **hardhat-deploy**.\n\n**hardhat-deploy** allows you to write [`deploy scripts`](#deploy-scripts) in the `deploy` folder. Each of these files that look as follows will be executed in turn when you execute the following task: `hardhat --network <networkName> deploy`\n\n```js\n// deploy/00_deploy_my_contract.js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('MyContract', {\n    from: deployer,\n    args: ['Hello'],\n    log: true,\n  });\n};\nmodule.exports.tags = ['MyContract'];\n```\n\nFurthermore you can also ensure these scripts are executed in test too by calling `await deployments.fixture(['MyContract'])` in your test.\nThis is optimized, so if multiple tests use the same contract, the deployment will be executed once and each test will start with the exact same state.\n\nThis is a huge benefit for testing since you are not required to replicate the deployment procedure in your tests. The tag feature (as seen in the script above) and [dependencies](#deploy-scripts-tags-and-dependencies) will also make your life easier when writing complex deployment procedures.\n\nYou can even group deploy scripts in different sub folder and ensure they are executed in their logical order.\n\nFurthermore hardhat-deploy can also support a multi-chain settings like L1, L2 with multiple deploy folder specific to each network.\n\nThere is a tutorial covering the basics here : https://github.com/wighawag/tutorial-hardhat-deploy\n\n## Installation\n\n### npm install hardhat-deploy\n\n```bash\nnpm install -D hardhat-deploy\n```\n\nAnd add the following statement to your `hardhat.config.js`:\n\n```js\nrequire('hardhat-deploy');\n```\n\nif you use `ethers.js` we recommend you also install `hardhat-deploy-ethers` which add extra features to access deployments as ethers contract.\n\nSince `hardhat-deploy-ethers` is a fork of `@nomiclabs/hardhat-ethers` and that other plugin might have an hardcoded dependency on `@nomiclabs/hardhat-etehrs` the best way to install `hardhat-deploy-ethers` and ensure compatibility is the following:\n\n```bash\nnpm install --save-dev  @nomiclabs/hardhat-ethers@npm:hardhat-deploy-ethers ethers\n```\n\nWhich means you then need to do `require(\"@nomiclabs/hardhat-ethers\")` instead of `require(\"hardhat-deploy-ethers\")` in your `hardhat.config.js` file.\n\nMore details on `hardhat-deploy-ethers` repo : https://github.com/wighawag/hardhat-deploy-ethers#readme\n\n### TypeScript support\n\nWith hardhat the tsconfig.json is optional.\n\nBut if you add folders to the `include` field in `tsconfig.json`, you ll also need to include `hardhat.config.ts` like :\n\n`include\": [\"./hardhat.config.ts\", \"./scripts\", \"./deploy\", \"./test\"]`\n\nfor deploy script (see below) you can write them this way to benefit from typing :\n\n```ts\nimport {HardhatRuntimeEnvironment} from 'hardhat/types';\nimport {DeployFunction} from 'hardhat-deploy/types';\n\nconst func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {\n  // code here\n};\nexport default func;\n```\n\nSee a template that uses **hardhat-deploy** here : https://github.com/wighawag/template-ethereum-contracts\n\nThis repo has also some examples branch that exemplify specific features, like the forking testing here : https://github.com/wighawag/template-ethereum-contracts/tree/examples/fork-test\n\n### Migrating existing deployment to hardhat-deploy\n\n(Only needed for existing project that already deployed contracts and has the deployment information available **(at minimum, address and abi)**)\n\nYou might want to switch your current deployment process to use **hardhat-deploy**. In that case you probably have some deployments saved elsewhere.\n\nIn order to port them to **hardhat-deploy**, you'll need to create one `.json` file per contract in the `deployments/<network>` folder (configurable via [paths config](#extra-paths-config)).\n\nThe network folder is simply the hardhat network name (as configured in hardhat.config.js) (accessible at runtime via `hre.network.name`).\nSuch folder need to have a file named `.chainId` containing the chainId as decimal.\n\nFor example for network named \"rinkeby\" (for the corresponding network) the file `deployments/rinkeby/.chainId` would be\n\n```\n4\n```\n\nNote, prior to hardhat 0.6 the chainId was appended to the folder name (expect for some known network name). This has changed and upgrading to 0.6 will require you to change the folder name and add the '.chainId' file.\n\nEach contract file must follow this type (as defined in [types.ts](types.ts)) :\n\n```ts\nexport interface Deployment {\n  address: Address;\n  abi: ABI;\n  receipt?: Receipt;\n  transactionHash?: string;\n  history?: Deployment[];\n  implementation?: string;\n  args?: any[];\n  linkedData?: any;\n  solcInputHash?: string;\n  metadata?: string;\n  bytecode?: string;\n  deployedBytecode?: string;\n  libraries?: Libraries;\n  userdoc?: any;\n  devdoc?: any;\n  methodIdentifiers?: any;\n  diamondCut?: FacetCut[];\n  facets?: Facet[];\n  storageLayout?: any;\n  gasEstimates?: any;\n}\n```\n\nAs you can see, only abi and address are mandatory. But having the other fields allow more feature. For example, metadata and args allow you to benefit from contract code verification.\n\nFor Receipt, the following type is expected:\n\n```ts\nexport type Receipt = {\n  from: string;\n  transactionHash: string;\n  blockHash: string;\n  blockNumber: number;\n  transactionIndex: number;\n  cumulativeGasUsed: string;\n  gasUsed: string;\n  contractAddress?: string;\n  to?: string;\n  logs?: Log[];\n  events?: any[];\n  logsBloom?: string;\n  byzantium?: boolean;\n  status?: number;\n  confirmations?: number;\n};\n```\n\nHere is an example:\n\nLet sey you have:\n\n- 2 Contract named Greeter and Registry deployed on rinkeby\n- 1 contract named Greeter on mainnet\n- 2 Contract named Greeter and Registry deployed on a network named rinkeby2\n\nYou would get the following folder structure:\n\n```\ndeployments/\n  mainnet/\n    .chainId\n    Greeter.json\n  rinkeby/\n    .chainId\n    Greeter.json\n    Registry.json\n  rinkeby2/\n    .chainId\n    Greeter.json\n    Registry.json\n```\n\nThe reason why **hardhat-deploy** save chainId in the `.chainId` file is both for\n\n- safety: so that if you were to change the network name to point to a different chain, it would not attempt to read the wrong folder and assume that a contract has been deployed while it has not.\n- ability to know the chainId without requring to be connected to a node (and so not dependent on hardhat.config.js settings). Useful for `export` task.\n\n---\n\n## Hardhat Tasks Available/Updated\n\nhardhat deploy add several task to hardhat. It also modify existing one, adding new options and new behavior. All of these are described here:\n\n---\n\n### 1. hardhat deploy\n\n---\n\nThis plugin adds the _deploy_ task to Hardhat.\n\nThis task will execute the scripts in the `deploy` folder and save the contract deployments to disk. These deployments are supposed to be saved for example in a git repository. This way they can be accessed later. But you are free to save them elsewhere and get them back via your mechanism of choice.\n\nWith the deployment saved, it allows you to deploy a contract only if changes were made.\n\nDeploy scripts (also called Deploy functions) can also perform aribtrary logic.\n\nFor further details on how to use it and write deploy script, see [section](#deploy-scripts) below.\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployments, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice (in wei) to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--reset`: This flag resets the deployments from scratch. Previously deployed contract are not considered and deleted from disk.\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n---\n\n### 2. hardhat node\n\n---\n\nThis plugin modify the _node_ task so that it also execute the deployment script before exposing the server http RPC interface\n\nIt add similar options than the `deploy` task :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n`--forkDeployments <networkName>`: defaults to `localhost`; this option allows you to specify the network to fetch the deployment from when running in fork mode. This is necessary as hardhat fork feature does not track the fork's network: <https://github.com/nomiclabs/hardhat/issues/1164>\n\n`--asNetwork <networkName`: default to `localhost` (or the value specified by `--forkDeployments` if any), this option allows you to specify the network name to be used for **hardhat-deploy** functionality, like which folder the resulting deployment should be saved to.\n\n#### **Flags**\n\n`--noReset`: This flag prevent the reseting of the existing deployments. This is usually not desired when running the `node` task as a network is created from scratch and previous deployemnt are irrelevant.\n\n`--show-accounts`: this flag will output the account private keys\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n`--no-deploy` that discard all other options to revert to normal `hardhat node` behavior without any deployment being performed.\n\nNote that the deployments are saved as if the network name is `localhost`. This is because `hardhat node` is expected to be used as localhost: You can for example execute `hardhat --network localhost console` after `node` is running. Doing `builder --network hardhat console` would indeed not do anything useful. It still take the configuration from `hardhat` in the hardhat.config.js file though.\n\n---\n\n### 3. hardhat test\n\n---\n\nThis plugin adds a flag argument `--deploy-fixture` to the _test_ task that runs the global deployments fixture before the tests and snapshots it. This will generaly speed up the tests.\n\n---\n\n### 4. hardhat etherscan-verify\n\n---\n\nThis plugin adds the _etherscan-verify_ task to Hardhat.\n\nThis task will submit the contract source and other info of all deployed contracts to allow etherscan to verify and record the sources.\n\nInstead of using the full solc input, this task will first attempt to send the minimal sources from the metadata.\nBut Etherscan sometime fails due to a bug in solidity compiler (<https://github.com/ethereum/solidity/issues/9573>). As such this task can fallback on full solc input (see option --solc-input). Note that if your contract was deployed with a previous version of **hardhat-deploy**, it might not contains the full information. The issue seems to be fully resolved since solc version 0.8.\n\nThis task will also attempt to automatically find the SPDX license in the source.\n\nTo execute that task, you need to specifiy the network to run against :\n\n```bash\nhardhat --network mainnet etherscan-verify --api-key <apikey>\n```\n\n#### **Options**\n\n`--api-key <api key>`: let you specify your etherscan api key. Alternatively, you can provide it via the env variable `ETHERSCAN_API_KEY`\n\n`--license <SPDX license id>`: SPDX license (useful if SPDX is not listed in the sources), need to be supported by etherscan: https://etherscan.io/contract-license-types\n\n`--force-license`: if set, will force the use of the license specified by --license option, ignoring the one in the source (useful for license not supported by etherscan)\n\n`--solc-input`: fallback on solc-input id needed (useful when etherscan fails on the minimum sources, see https://github.com/ethereum/solidity/issues/9573)\n\n---\n\n### 5. hardhat sourcify\n\n---\n\nThis plugin adds the _sourcify_ task to Hardhat.\n\nSimilar to `hardhat etherscan-verify` this task will submit the contract source and other info of all deployed contracts to sourcify.\n\n```bash\nhardhat --network mainnet sourcify\n```\n\nLater this task might instead pin the metadata to ipfs, so sourcify can automatically verify them.\n\n#### **Options**\n\n`--endpoint <endpoint>`: specify the sourcify endpoint, default to https://sourcify.dev/server/\n\n`--write-failing-metadata`: if set and the sourcify task fails to verify, the metadata file will be written to disk, so you can more easily figure out what has gone wrong.\n\n---\n\n### 6. hardhat export\n\n---\n\nThis plugin adds the _export_ task to Hardhat.\n\nThis task will export the contract deployed (saved in `deployments` folder) to a file with a simple format containing only contract addresses and abi, useful for web apps.\n\nOne of the following options need to be set for this task to have any effects :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\nThis last option has some limitations, when combined with the use of external deployments (see [Configuration](#configuration)). If such external deployments were using older version of **hardhat-deploy** or truffle, the chainId might be missing. In order for these to be exported, the hardhat network config need to explicity state the chainId in the `networks` config of `hardhat.config.js`.\n\n---\n\n---\n\n## Hardhat Environment Extensions\n\nThis plugin extends the Hardhat Runtime Environment by adding 4 fields:\n\n- `getNamedAccounts: () => Promise<{ [name: string]: string }>`: a function returning an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [Configuration](#configuration)).\n\n- `getUnnamedAccounts: () => Promise<string[]}>`: accounts which has no names, useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`: contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId(): Promise<string>`: offer an easy way to fetch the current chainId.\n\n---\n\n---\n\n## Configuration\n\n---\n\n### **1. namedAccounts (ability to name addresses)**\n\n---\n\nThis plugin extends the `HardhatConfig`'s object with an optional `namedAccounts` field.\n\n`namedAccounts` allows you to associate names to addresses and have them configured per chain.\nThis allows you to have meaningful names in your tests while the addresses match to multi sig in real network for example.\n\n```js\n{\n    namedAccounts: {\n        deployer: {\n            default: 0, // here this will by default take the first account as deployer\n            1: 0, // similarly on mainnet it will take the first account as deployer. Note though that depending on how hardhat network are configured, the account 0 on one network can be different than on another\n            4: '0xA296a3d5F026953e17F472B497eC29a5631FB51B', // but for rinkeby it will be a specific address\n            \"goerli\": '0x84b9514E013710b9dD0811c9Fe46b837a4A0d8E0', //it can also specify a specific netwotk name (specified in hardhat.config.js)\n        },\n        feeCollector:{\n            default: 1, // here this will by default take the second account as feeCollector (so in the test this will be a different account than the deployer)\n            1: '0xa5610E1f289DbDe94F3428A9df22E8B518f65751', // on the mainnet the feeCollector could be a multi sig\n            4: '0xa250ac77360d4e837a13628bC828a2aDf7BabfB3', // on rinkeby it could be another account\n        }\n    }\n}\n```\n\n<!-- You can also specify addresses with the `ledger://` prefix. In which case the account fetched will still be the corresponding address, but behind the scene, the transaction will be created via the hardware waller. Currently the feature is not working very well though and better support is needed. -->\n\n---\n\n### **2. extra hardhat.config networks' options**\n\n---\n\n**hardhat-deploy** add 4 new fields to `networks` configuration\n\n`live` : this is not used internally but is useful to perform action on a network whether it is a live network (rinkeby, mainnet, etc) or a temporary one (localhost, hardhat). The default is true (except for localhost and hardhat where the default is false).\n\n`saveDeployments`: this tell whether **hardhat-deploy** should save the deployments to disk or not. Default to true, except for the hardhat network.\n\n`tags`: network can have tags to represent them. The config is an array and at runtime the hre.network.tags is an object whose fields (the tags) are set to true.\n\nThis is useful to conidtionaly operate on network based on their use case.\n\nExample:\n\n```js\n{\n  networks: {\n    localhost: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"local\"]\n    },\n    hardhat: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"test\", \"local\"]\n    },\n    rinkeby: {\n      live: true,\n      saveDeployments: true,\n      tags: [\"staging\"]\n    }\n  }\n}\n```\n\n`deploy`: the deploy field override the paths.deploy option and let you define a set of folder containing the deploy scripts to be executed for this network.\n\nYou can thus have one network that will be executing L1 deployment and other L2 deployments, etc...\n\n---\n\n### **3. extra hardhat.config paths' options**\n\n---\n\nIt also adds fields to `HardhatConfig`'s `ProjectPaths` object.\n\nHere is an example showing the default values :\n\n```js\n{\n    paths: {\n        deploy: 'deploy',\n        deployments: 'deployments',\n        imports: 'imports'\n    }\n}\n```\n\nThe deploy folder is expected to contains the deploy script that are executed upon invocation of `hardhat deploy` or `hardhat node`.\nIt can also be an array of folder path.\n\nThe deployment folder will contains the resulting deployments (contract addresses along their abi, bytecode, metadata...). One folder per network and one file per contract.\n\nThe imports folder is expected to contains artifacts that were pre-compiled. Useful if you want to upgrade to a new solidity version but want to keep using previously compiled contracts. The artifact is the same format as normal hardhat artifact, so you can easily copy them over, before switching to a new compiler version.\n\n---\n\n### Importing deployment from other projects (with truffle support)\n\nIt also add the `external` field to `HardhatConfig`\n\nSuch fiels allows to specify paths for external artifacts or deployments.\n\nThe external object has 2 fields:\n\n```js\n{\n    external: {\n        contracts: [\n          {\n            artifacts: \"node_modules/@cartesi/arbitration/export/artifacts\",\n            deploy: \"node_modules/@cartesi/arbitration/export/deploy\"\n          },\n          {\n            artifacts: \"node_modules/someotherpackage/artifacts\",\n          }\n        ],\n        deployments: {\n          rinkeby: [\"node_modules/@cartesi/arbitration/build/contracts\"],\n        },\n    }\n}\n```\n\nThe contract field specify an array of object which itself have 2 fields.\n\n- artifacts: (mandatory) it is a path to an artifact folder. This support both hardhat and truffle artifacts.\n- deploy: (optional) it specifies a path to a folder where reside deploy script. The deploy script have only access to the artifact specified in the artifacts field. This allow project to share their deployment procedure. A boon for developer aiming at integrating it as they can get the contracts to be deployed for testing locally.\n\nThe deployments fields specify an object whose field name are the hardhat network and the value is an array of path to look for deployments. It supports both **hardhat-deploy** and truffle formats.\n\n---\n\n### Access to Artifacts (non-deployed contract code and abi)\n\nyou can access contract artifact via `getArtifact` function :\n\n```js\nconst {deployments} = require('hardhat');\nconst artifact = await deployments.getArtifact(artifactName);\n```\n\nWith the `hardhat-deploy-ethers` plugin you can get your ethers contract via :\n\n```js\nconst {deployments, ethers} = require('hardhat');\nconst factory = await ethers.getContractFactory(artifactName);\n```\n\nNote that the artifact file need to be either in `artifacts` folder that hardhat generate on compilation or in the `imports` folder where you can store contracts compiled elsewhere. They can also be present in the folder specified in `external.artifacts` see [Importing deployment from other projects](#importing-deployment-from-other-projects-truffle-support-too)\n\n---\n\n---\n\n## How to Deploy Contracts\n\n---\n\n### The `deploy` Task\n\n`hardhat --network <networkName> deploy [options and flags]`\n\nThis is a new task that the plugin adds. As the name suggests it deploys contracts.\nTo be exact it will look for files in the folder `deploy` or whatever was configured in `paths.deploy`, see [paths config](#extra-paths-config)\n\nIt will scan for files in alphabetical order and execute them in turn.\n\n- it will `require` each of these files and execute the exported function with the HRE as argument\n\nNote that running `hardhat deploy` without specifying a network will use the default network. If the default network is hardhat (the default's default) then nothing will happen as a result but this can be used to ensure the deployment is without issues.\n\nTo specified the network, you can use the builtin hardhat argument `--network <network name>` or set the env variable `HARDHAT_NETWORK`\n\n---\n\n### Deploy Scripts\n\nThe deploy scripts need to be of the following type :\n\n```js\nexport interface DeployFunction {\n  (env: HardhatRuntimeEnvironment): Promise<void | boolean>;\n  skip?: (env: HardhatRuntimeEnvironment) => Promise<boolean>;\n  tags?: string[];\n  dependencies?: string[];\n  runAtTheEnd?: boolean;\n  id?: string;\n}\n```\n\nThe skip function can be used to skip executing the script under whatever condition. It simply need to resolve a promise to true.\n\nThe tags is a list of string that when the _deploy_ task is executed with, the script will be executed (unless it skips). In other word if the deploy task is executed with a tag that does not belong to that script, that script will not be executed unless it is a dependency of a script that does get executed.\n\nThe dependencies is a list of tag that will be executed if that script is executed. So if the script is executed, every script whose tag match any of the dependency will be executed first.\n\nThe `runAtTheEnd` is a boolean that if set to true, will queue that script to be executed after all other scripts are executed.\n\nThese set of fields allow more flexibility to organize the scripts. You are not limited to alphabetical order.\n\nFinally the function can return true if it wishes to never be executed again. This can be usfeul to emulate migration scripts that are meant to be executed only once. Once such script return true (async), the `id` field is used so to track execution and if that field is not present when the script return true, it will fails.\n\nIn any case, as a general advice every deploy function should be idempotent. This is so they can always recover from failure or pending transaction.\n\nThis is why the `hre.deployments.deploy` function will by default only deploy if the contract code has changed, making it easier to write idempotent script.\n\nAn example of a deploy script :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  // the following will only deploy \"GenericMetaTxProcessor\" if the contract was never deployed or if the code changed since last deployment\n  await deploy('GenericMetaTxProcessor', {\n    from: deployer,\n    gasLimit: 4000000,\n    args: [],\n  });\n};\n```\n\nAs you can see the HRE passed in has 4 new fields :\n\n- `getNamedAccounts` is a function that returns a promise to an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [`namedAccounts`](#namedaccounts)).\n\n- `getUnnamedAccounts`: function that return a promise to an array of accounts (which were not used in `getNamedAccounts`), useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`, which contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId` which return a promise for the chainId\n\nThe deploynments field contains the `deploy` function taht allow you to deploy contract and save them. It contains a lot more functions though :\n\n---\n\n### The `deployments` field\n\nThe deployments field contains several helpers function to deploy contract but also execute transaction.\n\n```ts\nexport interface DeploymentsExtension {\n  deploy(name: string, options: DeployOptions): Promise<DeployResult>; // deploy a contract\n  diamond: {\n    // deploy diamond based contract (see section below)\n    deploy(name: string, options: DiamondOptions): Promise<DeployResult>;\n  };\n  deterministic( // return the determinsitic address as well as a function to deploy the contract, can pass the `salt` field in the option to use different salt\n    name: string,\n    options: Create2DeployOptions\n  ): Promise<{\n    address: Address;\n    deploy(): Promise<DeployResult>;\n  }>;\n  fetchIfDifferent( // return true if new compiled code is different than deployed contract\n    name: string,\n    options: DeployOptions\n  ): Promise<{differences: boolean; address?: string}>;\n  save(name: string, deployment: DeploymentSubmission): Promise<void>; // low level save of deployment\n  get(name: string): Promise<Deployment>; // fetch a deployment by name, throw if not existing\n  getOrNull(name: string): Promise<Deployment | null>; // fetch deployment by name, return null if not existing\n  getDeploymentsFromAddress(address: string): Promise<Deployment[]>;\n  all(): Promise<{[name: string]: Deployment}>; // return all deployments\n  getArtifact(name: string): Promise<Artifact>; // return a hardhat artifact (compiled contract without deployment)\n  getExtendedArtifact(name: string): Promise<ExtendedArtifact>; // return a extended artifact (with more info) (compiled contract without deployment)\n  run( // execute deployment scripts\n    tags?: string | string[],\n    options?: {\n      resetMemory?: boolean;\n      deletePreviousDeployments?: boolean;\n      writeDeploymentsToFiles?: boolean;\n      export?: string;\n      exportAll?: string;\n    }\n  ): Promise<{[name: string]: Deployment}>;\n  fixture( // execute deployment as fixture for test // use evm_snapshot to revert back\n    tags?: string | string[],\n    options?: {fallbackToGlobal?: boolean; keepExistingDeployments?: boolean}\n  ): Promise<{[name: string]: Deployment}>;\n  createFixture<T, O>( // execute a function as fixture using evm_snaphost to revert back each time\n    func: FixtureFunc<T, O>,\n    id?: string\n  ): (options?: O) => Promise<T>;\n  log(...args: any[]): void; // log data only ig log enabled (disabled in test fixture)\n\n  execute( // execute function call on contract\n    name: string,\n    options: TxOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<Receipt>;\n  rawTx(tx: SimpleTx): Promise<Receipt>; // execute a simple transaction\n  catchUnknownSigner( // you can wrap other function with this function and it will catch failure due to missing signer with the details of the tx to be executed\n    action: Promise<any> | (() => Promise<any>),\n    options?: {log?: boolean}\n  ): Promise<null | {\n    from: string;\n    to?: string;\n    value?: string;\n    data?: string;\n  }>;\n  read( // make a read-only call to a contract\n    name: string,\n    options: CallOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<any>;\n  read(name: string, methodName: string, ...args: any[]): Promise<any>;\n  // rawCall(to: Address, data: string): Promise<any>; // TODO ?\n}\n```\n\n---\n\n#### `deployments.deploy`\n\n---\n\nThe deploy function as mentioned allow you to deploy a contract and save it under a specific name.\n\nThe deploy function expect 2 parameters: one for the name and one for the options\n\nSee below the full list of fields that the option parameter allows and requires:\n\n```ts\nexport interface DeployOptions = {\n  from: string; // address (or private key) that will perform the transaction. you can use `getNamedAccounts` to retrived the address you want by name.\n  contract?: // this is an optional field. If not specified it defaults to the contract with the same name as the first parameter\n    | string // this field can be either a string for the name of the contract\n    | { // or abi and bytecode\n        abi: ABI;\n        bytecode: string;\n        deployedBytecode?: string;\n      };\n  args?: any[]; // the list of argument for the constructor (or the upgrade function in case of proxy)\n  skipIfAlreadyDeployed?: boolean; // if set it to true, will not attempt to deploy even if the contract deployed under the same name is different\n  log?: boolean; // if true, it will log the result of the deployment (tx hash, address and gas used)\n  linkedData?: any; // This allow to associate any JSON data to the deployment. Useful for merkle tree data for example\n  libraries?: { [libraryName: string]: Address }; // This let you associate libraries to the deployed contract\n  proxy?: boolean | string | ProxyOptions; // This options allow to consider your contract as a proxy (see below for more details)\n\n  // here some common tx options :\n  gasLimit?: string | number | BigNumber;\n  gasPrice?: string | BigNumber;\n  value?: string | BigNumber;\n  nonce?: string | number | BigNumber;\n\n  estimatedGasLimit?: string | number | BigNumber; // to speed up the estimation, it is possible to provide an upper gasLimit\n  estimateGasExtra?: string | number | BigNumber; // this option allow you to add a gas buffer on top of the estimation\n\n  autoMine?: boolean; // this force a evm_mine to be executed. this is useful to speed deployment on test network that allow to specify a block delay (ganache for example). This option basically skip the delay by force mining.\n  deterministicDeployment? boolean | string; // if true, it will deploy the contract at a deterministic address based on bytecode and constuctor arguments. The address will be the same across all network. It use create2 opcode for that, if it is a string, the string will be used as the salt.\n};\n```\n\n---\n\n---\n\n## Handling contract using libraries\n\nIn the deploy function, one of the `DeployOptions` that can be passed into the function is the `libraries` field.\n\nFirst, deploy the library using the `deploy` function, then when we deploy a contract that needs the the linked library, we can pass the deployed library name and address in as an argument to the `libraries` object.\n\n```js\nconst exampleLibrary = await deploy(\"ExampleLibary\", {\n    from: <deployer>\n});\n\n```\n\nExampleLibrary is now deployed to whatever network is in the context of the environment.\n\nFor example, if we are deploying on Rinkeby, this library will get deployed on rinkeby, and the `exampleLibrary` variable will be a deployment object that contains the abi as well as the deployed address for the contract.\n\nNow that the library is deployed, we can link it in our next deployed contract.\n\n```js\nconst example = await deploy(\"Example\", {\n    from: <deployer>\n    args: [\"This is an example string argument in the constructor for the 'Example' contract\"],\n    libraries: {\n        ExampleLibrary: exampleLibrary.address\n    }\n});\n\n```\n\nThis `libraries` object takes the name of the library, and its deployed address on the network. Multiple libraries can be passed into the `libraries` object.\n\n---\n\n---\n\n## Exporting Deployments\n\nApart from deployments saved in the `deployments` folder which contains all information available about the contract (compile time data + deployment data), `hardhat-deploy` allows you to export lightweight files.\n\nThese can be used for example to power your frontend with contract's address and abi.\n\nThis come into 2 flavors.\n\nThe first one is exported via the `--export <file>` option and follow the following format :\n\n```js\nexport interface Export {\n  chainId: string;\n  name: string;\n  contracts: {[name: string]: ContractExport};\n}\n```\n\nwhere name is the name of the network configuration chosen (see hardhat option `--network`)\n\nThe second one is exported via the `--export-all <file>` option and follow the following format :\n\n```js\nexport type MultiExport = {\n  [chainId: string]: {[name: string]: Export},\n};\n```\n\nAs you see the second format include the previous. While in most case you'll need the single export where your application will support only one network, there are case where your app would want to support multiple network at nonce. This second format allow for that.\n\nFurthermore as hardhat support multiple network configuration for the same network (rinkeby, mainnet...), the export-all format will contains each of them grouped by their chainId.\n\n---\n\n---\n\n## Deploying and Upgrading Proxies\n\nAs mentioned above, the deploy function can also deploy a contract through a proxy. It can be done without modification of the contract as long as it does not have a constructor (or constructor with zero arguments).\n\nThe default Proxy is both ERC-1967 and ERC-173 Compliant, but other proxy can be specified, like openzeppelin transparent proxies.\n\nCode for the default Proxy can be found [here](solc_0.7/proxy/EIP173Proxy.sol)\n\nTo perform such proxy deployment, you just need to invoke the deploy function with the following options : `{..., proxy: true}`\n\nSee example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: true,\n  });\n};\n```\n\nYou can also set it to `proxy: \"<upgradeMethodName>\"` in which case the function `<upgradeMethodName>` will be executed upon upgrade.\nthe `args` field will be then used for that function instead of the contructor. It is also possible to then have a constructor with the same arguments and have the proxy be disabled. It can be useful if you want to have your contract as upgradeable in a test network but be non-upgradeable on the mainnet.\n\nSee example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: 'postUpgrade',\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nThe proxy option can also be an object which can set the specific owner that the proxy is going to be managed by.\n\nSee example:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: {\n      owner: greeterOwner,\n      methodName: 'postUpgrade',\n    },\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nNote that for the second invokation, this deployment will fails to upgrade the proxy as the `from` which is `deployer` is not the same as the proxy's owner : `greeterOwner`\n\nTo make it work, you have to create a new script that have for `from` field: `greeterOwner`. If such value is a a multi sig or an address not registered as part of hardhat signers, the tx will not be executed but instead an error will be throw. That error can be caught up via deployments.catchUnknwonSigner function so you get the necessary tx details to execute it elsewhere.\n\nThe full proxy options is as follow:\n\n```ts\nexport interface ProxyOptions {\n  owner?: Address; // this set the owner of the proxy. further upgrade will need to be executed from that owner\n  methodName?: string; // method to be executed when the implementation is modified.\n  proxyContract?: string | ArtifactData; // default to \"EIP173Proxy\". See below for more details\n  viaAdminContract?: // allow to specify a contract that act as a middle man to perform upgrades. Useful and Recommended for Transparent Proxies\n  | string\n    | {\n        name: string;\n        artifact?: string | ArtifactData;\n      };\n}\n```\n\nThe `proxyContract` field allow you to specify your own Proxy contract. If it is a string, it will first attemp to get an artifact with that name. If not found it will fallback on the following if\n\nit matches:\n\n- `EIP173Proxy`: use the default Proxy that is EIP-173 compliant\n\n- `EIP173ProxyWithReceive`: Same as above except that the proxy contains a receive hook to accept empty ETH payment\n\n- `OpenZeppelinTransparentProxy`: Use Openzeppelin Transparent Proxy (slightly modified as openzeppelin's one hardcode the msg.sender as first owner, see code [here](solc_0.7\\openzeppelin\\proxy\\TransparentUpgradeableProxy.sol))\n  When this option is chosen, the `DefaultProxyAdmin` is also used as admin since Transparent Proxy kind of need an intermediarry contract for administration. This can be configired via the `viaAdminContract` option\n\n- `OptimizedTransparentProxy`: This contract is similar to above, except that it is optimized to not require storage read for the admin on every call.\n\n## Builtin-In Support For Diamonds (EIP2535)\n\nThe deployments field also expose the diamond field: `hre.deployments.diamond` that let you deploy [Diamonds](https://eips.ethereum.org/EIPS/eip-2535) in an easy way.\n\nInstead of specifying the facets to cut out or cut in, which the diamond contract expects, you specify the facets you want to end up having on the deployed contract.\n\n`diamond.deploy` expect the facet as names. The names represent contract to be deployed as facet. In future version you ll be able to specify deployed contract or artifact object as facet.\n\nTo deploy a contract with 3 facet you can do as follow :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: deployer,\n    owner: diamondAdmin,\n    facets: ['Facet1', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nif you then later execute the following script:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: diamondAdmin, // this need to be the diamondAdmin for upgrade\n    owner: diamondAdmin,\n    facets: ['NewFacet', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nThen the NewFacet will be deployed automatically if needed and then the diamondCut will cut Facet1 out and add NewFacet.\n\nNote that if the code for Facet2 and Facet3 changes, they will also be redeployed automatically and the diamondCuts will replace the existing facets with these new ones.\n\nNote that The Diamond contract's code is part of hardhat-deploy and contains 3 built-in facet that can be removed manually if desired.\nThese facets are used for ownership, diamondCut and diamond loupe.\n\nThe implementation is the [reference implementation by Nick Mudge](https://github.com/mudgen/diamond-3)\n\nLike normal proxies you can also execute a function at the time of an upgrade.\n\nThis is done by specifying the execute field in the diamond deploy options :\n\n```js\ndiamond.deploy('ADiamondContract', {\n  from: deployer,\n  owner: diamondAdmin,\n  facets: ['NewFacet', 'Facet2', 'Facet3'],\n  execute: {\n    methodName: 'postUpgrade',\n    args: ['one', 2, '0x3'],\n  },\n});\n```\n\nSince the diamond standard has no builtin mechanism to make the deployment of Diamond with function execution, the Diamond when deployed is actually deployed through a special contract, the `Diamantaire` (see code [here](solc_0.7/diamond/Diamantaire.sol)) that act as factory to build Diamond. It uses deterministic deployment for that so, it is transparently managed by hardhat-deploy. It also embed the implementation of the builtin facet, removing the need to have different instances of each live.\n\n<!-- The Diamantaire also support the deterministic deployment of Diamonds.\nAn extra field can be passed to the Diamond deployment options : `deterministicSalt`. It has to be a non-zero 32bytes string (in hex format).\nNote that if you want to deploy 2 diamonds with same owner, you'll need 2 different deterministicSalt for them to be 2 separate contracts. -->\n\n## Testing Deployed Contracts\n\nYou can continue using the usual test task :\n\n`hardhat test`\n\nTests can then use the `hre.deployments.fixture` function to run the deployment for the test and snapshot it so that tests don't need to perform all the deployments transaction every time, they simply reuse the snapshot for every test (this leverages `evm_snapshot` and `evm_revert` provided by both `hardhat` and `ganache`). You can for example set them in a `beaforeEach`.\n\nHere is an example of a test :\n\n```js\nconst {deployments} = require('hardhat');\n\ndescribe('Token', () => {\n  beforeEach(async () => {\n    await deployments.fixture();\n  });\n  it('testing 1 2 3', async function () {\n    const Token = await deployments.get('Token'); // Token is available because the fixture was executed\n    console.log(Token.address);\n    const ERC721BidSale = await deployments.get('ERC721BidSale');\n    console.log({ERC721BidSale});\n  });\n});\n```\n\nIf the deployment scripts are complex, the first test could take while (as the fixture need to execute the deployment) but then from the second test onward, the deployments are never re-executed, instead the fixture will do `evm_revert` and test will run far faster.\n\nTests can also leverage named accounts for clearer test. Combined with `hardhat-deploy-ethers` plugin, you can write succint test :\n\n```js\nconst {ethers, getNamedAccounts} = require('hardhat');\n\ndescribe('Token', () => {\n  beforeEach(async () => {\n    await deployments.fixture();\n  });\n  it('testing 1 2 3', async function () {\n    const {tokenOwner} = await getNamedAccounts();\n    const TokenContract = await ethers.getContract('Token', tokenOwner);\n    await TokenContract.mint(2).then((tx) => tx.wait());\n  });\n});\n```\n\n---\n\n### Creating Fixtures\n\nFurthermore, tests can easily create efficient fixture using `deployments.createFixture`\n\nSee example :\n\n```js\nconst setupTest = deployments.createFixture(async ({deployments, getNamedAccounts, ethers}, options) => {\n  await deployments.fixture(); // ensure you start from a fresh deployments\n  const { tokenOwner } = await getNamedAccounts();\n  const TokenContract = await ethers.getContract(\"Token\", tokenOwner);\n  await TokenContract.mint(10).then(tx => tx.wait()); //this mint is executed once and then `createFixture` will ensure it is snapshotted\n  return {\n    tokenOwner: {\n      address: tokenOwner,\n      TokenContract\n    }\n  };\n};\ndescribe(\"Token\", () => {\n  it(\"testing 1 2 3\", async function() {\n    const {tokenOwner} = await setupTest()\n    await tokenOwner.TokenContract.mint(2);\n  });\n});\n```\n\nWhile this example is trivial, some fixture can requires several transaction and the ability to snapshot them automatically speed up the tests greatly.\n\n---\n\n---\n\n## More Information On Hardhat Tasks\n\n---\n\n### **1. node task**\n\nas mentioned above, the node task is slighly modified and augmented with various flags and options\n\n`hardhat node`\n\nIn particulat it adds an argument `--export` that allows you to specify a destination file where the info about the contracts deployed is written.\nYour webapp can then access all contracts information.\n\n---\n\n### **2. test task**\n\n`hardhat test`\n\nthe test task is augmented with one flag argument `--deploy-fixture` that allows to run all deployments in a fixture snapshot before executing the tests. This can speed up the tests that use specific tags as the global fixture take precedence (unless specified).\n\nIn other word tests can use `deployments.fixture(<specific tag>)` where specific tag only deploys the minimal contracts for tests, while still benefiting from global deployment snapshot if used.\n\nIf a test needs the deployments to only include the specific deployment specified by the tag, it can use the following :\n\n```js\ndeployments.fixture('<specific tag>', {fallbackToGlobal: false});\n```\n\nDue to how snapshot/revert works in hardhat, this means that these tests will not benefit from the global fixture snapshot and will have to deploy their contracts as part of the fixture call. This is automatic but means that these tests will run slower.\n\n---\n\n### **3. run task**\n\n`hardhat --network <networkName> run <script>`\n\nThe run task act as before but thanks to the `hre.deployments` field it can access deployed contract :\n\n```js\nconst hre = require('hardhat');\nconst {deployments, getNamedAccounts} = hre;\n\n(async () => {\n  console.log(await deployments.all());\n  console.log({namedAccounts: await getNamedAccounts()});\n})();\n```\n\nYou can also run it directly from the command line as usual.\n\n`HARDHAT_NETWORK=rinkeby node <script>` is the equivalent except it does not load the hardhat environment twice (which the run task does)\n\n---\n\n### **4. console task**\n\n`hardhat console`\n\nThe same applies to the `console` task.\n\n---\n\n## Deploy Scripts: Tags And Dependencies\n\n---\n\nIt is possible to execute only specific parts of the deployments with `hardhat deploy --tags <tags>`\n\nTags represent what the deploy script acts on. In general it will be a single string value, the name of the contract it deploys or modifies.\n\nThen if another deploy script has such tag as a dependency, then when this latter deploy script has a specific tag and that tag is requested, the dependency will be executed first.\n\nHere is an example of two deploy scripts :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const deployResult = await deploy('Token', {\n    from: deployer,\n    args: ['hello', 100],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Token deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Token'];\n```\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const Token = await deployments.get('Token');\n  const deployResult = await deploy('Sale', {\n    from: deployer,\n    contract: 'ERC721BidSale',\n    args: [Token.address, 1, 3600],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Sale deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.dependencies = ['Token']; // this ensure the Token script above is executed first, so `deployments.get('Token')` succeeds\n```\n\nAs you can see the second one depends on the first. This is because the second script depends on a tag that the first script registers as using.\n\nWith that when `hardhat deploy --tags Sale` is executed\n\nthen both scripts will be run, ensuring Sale is ready.\n\nYou can also define the script to run after another script is run by setting `runAtTheEnd` to be true. For example:\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, execute, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer, admin} = namedAccounts;\n  await execute('Sale', {from: deployer}, 'setAdmin', admin);\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.runAtTheEnd = true;\n```\n\nTags can also be used in test with `deployments.fixture`. This allow you to test a subset of the deploy script.\n","readmeFilename":"README.md","gitHead":"0276a0959efb4416d89d47f6f5db087e86592e41","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.8.0-next.3","_nodeVersion":"14.16.0","_npmVersion":"6.14.11","dist":{"integrity":"sha512-WXMD9hQTiuU8u8Wg4Kd8X/ObMus6+5Y/C+157PB0IBkDlPOvSn/w6CfkVVjXOmZ7Hju8OTnnk66LRwfw81rQZA==","shasum":"82e774c313fd1bb9f81545df5bb3db22029166d6","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.8.0-next.3.tgz","fileCount":116,"unpackedSize":7177889,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgbEKuCRA9TVsSAnZWagAAR7AP/0Vc7D0zyYNTp3gkvWmp\nFwjoIEcPUCvRvrkJgg5RgSKtAG9ffpKGlT0cADbz1K4/1HiqhooWEa5zXH6z\n/yRVKpk6E2ZUd5wHpyEA8xHJA9c7ipKlfLNKijF6EfnsEBBG9AtFrUad6VpM\nUBNbm4LN1ZOsZXgM7MVhwzjVB6gmPw/SrVAWGk+lOVkDDGWD8dLjooa9pbEJ\nPUSQhdfHtgh6FKylaJ7HdIjRCYHs6JyZrabnxF/UopqHcj6PUfB1rBh5DXjS\nO8S0KmdQjSvMJ4YmU8rdDCNPNB+mPMoAvDVCShnHXsV//Ea+oD5EzOgRopms\nyD2Hm3OBSDBsnsQU4MR+0Z+xxT+XA8cBGe1BHJ7TaTjfj8ZjSlTYNq5Wf9DO\n+bKu8mPBvzd1hmOczfcXfnj/PSpDfEGsC+WXHti37sSUsDx2z+Qw24q6DCPE\nZ9ulXX/vcZ+DNu1dg/ojJIWxjRWYA9j73u/Bo4Z/b91/t7mvnJn768imKCLf\nTazXlFa4kv8Kq2LCcvMpy2xlvt2bsHSSfolD5WeI3uzBRbm/EiGNX+18zOgE\n8aIppLQ9pQgnPdHENrU8P2YMB9IjIxAvSiz9U+d23Uu1S+9voQvAFavdaY4x\nB30lMIOO5jzDHQWYvMQuUUcEH0A/agfCo/XvWRya78qG8MxWubnk6fAHg5OP\nBx0c\r\n=2oZa\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCEr+seND+syGmyF0qwFTt4Z6cHIfgM7kCjt9CEuGx2TAIgJRvJ6he+xZnADpwvQsi5i9ecIq+kcv1ftSPjRSYwc20="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.8.0-next.3_1617707693993_0.7116461818333761"},"_hasShrinkwrap":false},"0.7.3":{"name":"hardhat-deploy","version":"0.7.3","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"optionalDependencies":{"@ethersproject/hardware-wallets":"^5.0.14"},"peerDependencies":{"hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","@ethersproject/hardware-wallets":"^5.0.14"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"600a6f152c5cda648cd76480d4af1be893123587","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.3","_nodeVersion":"14.16.0","_npmVersion":"6.14.11","dist":{"integrity":"sha512-cJL1CHUgj4rDgARQ8AqAcP5pFcw2AL0wjbG2OQvPZ1i4d5ZNNzlNc0gOi2e1Po0HZhgEr+m9W9EsSyZRGz5VrA==","shasum":"f4dc119a6ddaa26859fdde8afd48ed863aab455c","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.3.tgz","fileCount":116,"unpackedSize":7164647,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgcC8WCRA9TVsSAnZWagAA7FEP/RBoKXLGWqK6zMvPX8nf\nvl7yi4Ay7vwxiOZYITIe9+Ijsvnd1ZJgNxIphdauw7xU5SV8zukI0AoRHd+U\nIPgnbBwQ1m39Lmw2+WFtqQIDJw9CnEA9cFxzjkNbPFcbfEji7lHaysQERi4J\nrVDclyTXTUUpLF0/cYjlqLCakQRXPil13YCo9ywrlo+5M7orMxb4qfaWFhdt\nBdSvn5JLPT3mDs1vqp2WzLCVfYikWZjyA5JwGWyyRaS8KqglBwbQ9B+t6q6Z\nZq5vfLQ2ldm9pSbW7MeOdgjlwPhtXSyp+nBIwdlzRrQaYxvMm9x2Qi821zCy\nEriZLd0CZw+vl/fA8kW+x+y0Fc+Etbb7mYgxD+hLo5q4K+nQnNOEvMbc3lsu\nJl2th3+pkz31iOM0U8Ft3R5zhdxveCJ3QQQNT2mh1XAGenVEmnDbhVFP2Cq/\ncGL8MwD6XbYrz2x4A1bml1CWrU9GTQeHFlC6ak0Oy4owaPEJd7qRdz3Smol9\nQZjp+R57+J32yjsMcUkYFZ8WxOW/3uagT2iuMfnbp083ifeVQpDrEDtHvzoO\nDDP/XtPjH47PSxV/1n1HdYUaq8y7b1LcG8Tt/G0F2MVVDceQ1kYZn0wfVs7P\no6HZnMAwvbJz4nTxwn9mbHXoSVowTOdqmmaE9FqsPF2bdr8ipOGiAXowmCov\nwZbE\r\n=NtWJ\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIHP3NLmNbGcb0DyhkEDn74OoTxKhMyC8x5/dIkIqCiRaAiBsskQYPvfqjRr0NhyqVL2B2040zBgYLo58bueIagHh2w=="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.3_1617964821859_0.24348861469587413"},"_hasShrinkwrap":false},"0.7.4":{"name":"hardhat-deploy","version":"0.7.4","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0","@ethersproject/hardware-wallets":"^5.0.14"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"f6af47ceadfa48df13d16ca93d2b026fc16ddb06","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.4","_nodeVersion":"14.16.0","_npmVersion":"6.14.11","dist":{"integrity":"sha512-i5Fdb+S7XpBSY+/j0HA09fxp7JPNO55vMfVmbvwx4y4w/TmDSxp74s/71JKGuwxVPZ8ke/gkWTsYjI1b56Zdgw==","shasum":"6736f4e67ea62eefb2eb9790117682e2efabe0d0","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.4.tgz","fileCount":116,"unpackedSize":7164688,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgcDXcCRA9TVsSAnZWagAA3jEP/18VLf4fXRQOfh6cKk7A\n62xPVAXh+QahA7/ehm4KTgbPmTh1wI8xZParboqx3VtZR0KzK/kzylgzNeke\nVMqDHEDbFzECFC4r6wRNwBo+J+sjWTNPTAYAfLhiKgm7avDAm9KFywHNdVPn\ngR0Vls5rbmO228Abdkh0zRt6bPWsbvMKqcfOO8P4Lub4+4A3x1tqEPsFdC9j\nBmj3PrL2jkFZFK7wX8AlvJ7R1QPa/d+aFwr1qKrVN8gLHmpfNBfvPapo5t1f\nyzwkosFAUgMc/qydjAP8yIkRQDJsmxC10A17wRkGbed4VDM+3FgO7sI/jfil\ny1LBFsV5qTGf9sI8iCeRNC4B62JBbHObDZWwKXbkLuTPmfhkyCo6CcD24kbM\nT8JzePeGEAywRQypEEm/gb3ms/LaN6GSmSI361QRVmNNHmpfcD2VQofenTjL\ne+eMezate47fVZVWhlYupRFpUznfQTxDw5vNSKPi8DP/0yihp5cq0URg0uNX\npUKSIVAAdOBI9QxWw7vNsMr7d/K/1MQ9MpGzaIst4bipkEyUFu2xAcBVZZfS\nj4O2tTc7SQqcmwRLrK7fchi0hKHg7lzej/9K1XbZFcUQvtT77zgld7R8rXQj\n7hegXvIl6IGnz5TPsIllkhZ92gT/XicELZ5v3ZQvtsb/LdLuDPSQ8A1InA8x\nSITv\r\n=i0kd\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIH0UWlMToUYL9/V3uPuj5UiKLH/cmjb4D4K/nNPFdF0LAiEA2MezQBXCjHm0YXLJZUfpPvjV1vxCjXLdFENbFF3wVXQ="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.4_1617966556088_0.3081420896975706"},"_hasShrinkwrap":false},"0.8.0-next.4":{"name":"hardhat-deploy","version":"0.8.0-next.4","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"hardhat":"^2.0.0","@ethersproject/hardware-wallets":"^5.0.14"},"dependencies":{"@ethersproject/abi":"^5.0.2","@ethersproject/abstract-signer":"^5.0.2","@ethersproject/address":"^5.0.2","@ethersproject/bignumber":"^5.0.5","@ethersproject/bytes":"^5.0.2","@ethersproject/contracts":"^5.0.2","@ethersproject/providers":"^5.0.5","@ethersproject/solidity":"^5.0.2","@ethersproject/transactions":"^5.0.2","@ethersproject/wallet":"^5.0.2","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"readme":"<h1> hardhat-deploy</h1>\n\n_A [Hardhat](https://hardhat.org) Plugin For Replicable Deployments And Easy Testing_\n\n- [What is it for ?](#what-is-it-for-)\n- [hardhat-deploy in a nutshell](#hardhat-deploy-in-a-nutshell)\n- [Installation](#installation)\n  - [npm install hardhat-deploy](#npm-install-hardhat-deploy)\n  - [TypeScript support](#typescript-support)\n  - [Migrating existing deployment to hardhat-deploy](#migrating-existing-deployment-to-hardhat-deploy)\n- [Hardhat Tasks Available/Updated](#hardhat-tasks-availableupdated)\n  - [1. hardhat deploy](#1-hardhat-deploy)\n    - [**Options**](#options)\n    - [**Flags**](#flags)\n  - [2. hardhat node](#2-hardhat-node)\n    - [**Options**](#options-1)\n    - [**Flags**](#flags-1)\n  - [3. hardhat test](#3-hardhat-test)\n  - [4. hardhat etherscan-verify](#4-hardhat-etherscan-verify)\n  - [5. hardhat sourcify](#5-hardhat-sourcify)\n    - [**Options**](#options-2)\n  - [6. hardhat export](#6-hardhat-export)\n    - [**Options**](#options-3)\n- [Hardhat Environment Extensions](#hardhat-environment-extensions)\n- [Configuration](#configuration)\n  - [**1. namedAccounts (ability to name addresses)**](#1-namedaccounts-ability-to-name-addresses)\n  - [**2. extra hardhat.config networks' options**](#2-extra-hardhatconfig-networks-options)\n  - [**3. extra hardhat.config paths' options**](#3-extra-hardhatconfig-paths-options)\n  - [Importing deployment from other projects (with truffle support)](#importing-deployment-from-other-projects-with-truffle-support)\n  - [Access to Artifacts (non-deployed contract code and abi)](#access-to-artifacts-non-deployed-contract-code-and-abi)\n- [How to Deploy Contracts](#how-to-deploy-contracts)\n  - [The `deploy` Task](#the-deploy-task)\n  - [Deploy Scripts](#deploy-scripts)\n  - [The `deployments` field](#the-deployments-field)\n    - [`deployments.deploy`](#deploymentsdeploy)\n- [Handling contract using libraries](#handling-contract-using-libraries)\n- [Exporting Deployments](#exporting-deployments)\n- [Deploying and Upgrading Proxies](#deploying-and-upgrading-proxies)\n- [Testing Deployed Contracts](#testing-deployed-contracts)\n  - [Creating Fixtures](#creating-fixtures)\n- [More Information On Hardhat Tasks](#more-information-on-hardhat-tasks)\n  - [**1. node task**](#1-node-task)\n  - [**2. test task**](#2-test-task)\n  - [**3. run task**](#3-run-task)\n  - [**4. console task**](#4-console-task)\n- [Deploy Scripts: Tags And Dependencies](#deploy-scripts-tags-and-dependencies)\n- [Builtin-In Support For Diamonds (EIP2535)](#builtin-in-support-for-diamonds-eip2535)\n- [Testing Deployed Contracts](#testing-deployed-contracts)\n  - [Creating Fixtures](#creating-fixtures)\n- [Deploy Scripts: Tags And Dependencies](#deploy-scripts-tags-and-dependencies)\n\n## What is it for ?\n\nThis [hardhat](https://hardhat.dev) plugin adds a mechanism to deploy contracts to any network, keeping track of them and replicating the same environment for testing.\n\nIt also adds a mechanism to associate names to addresses, so test and deployment scripts can be reconfigured by simply changing the address a name points to, allowing different configurations per network. This also results in much clearer tests and deployment scripts (no more `accounts[0]` in your code).\n\nThis plugin contains a lot more features too, all geared toward a better developer experience :\n\n- chain configuration export\n- listing deployed contracts' addresses and their abis (useful for webapps)\n- library linking at time of deployment.\n- deterministic deployment across networks.\n- support for specific deploy script per network (L1 vs L2 for example)\n- deployment dependency system (allowing you to only deploy what is needed).\n- deployment retrying (by saving pending tx): so you can feel confident when making a deployment that you can always recover.\n- deployments as test fixture using `evm_snapshot` to speed up testing.\n- ability to create your own test fixture that automatically benefits from `evm_snapshot`'s tests speed-up boost\n- combined with [hardhat-deploy-ethers](https://github.com/wighawag/hardhat-deploy-ethers) it has the ability to get ethers contract instance by name (like `await ethers.getContract(\"ContractName\")`).\n- importing artifact from external sources (like npm packages), including truffle support.\n- importing deployments from external sources (like npm packages), including truffle support.\n- ability to log information in `deploy` mode only (while in test the console remains clean).\n- contains helpers to read and execute transaction on deployed contract referring to them by name.\n- These helpers contains options to auto mine on dev network (to speed up test deployments).\n- save metadata of deployed contract so they can always be fully verified, via [sourcify](https://sourcify.dev) or [etherscan](https://etherscan.io).\n- ability to submit contract source to etherscan and sourcify for verification at any time. (Because **hardhat-deploy** will save all the necessary info, it can be executed at any time.)\n- support harhdat's fork feature so deployment can be accessed even when run through fork.\n- named accounts are automatically impersonnated too, so you can perform tx as if you had their private.\n- proxy deployment with ability to upgrade them transparently, only if code changes.\n- this include support for [openzeppelin](https://openzeppelin.com) transparent proxies\n- diamond deployment with facets, allowing you to focus on what the new version will be. It will generate the diamondCut necessary to reach the new state.\n- watch and deploy: **hardhat-deploy** can watch both your deploy script and contract code and redeploy on changes.\n- HCR (Hot Contract Replacement): the watch feature combined with proxy or diamond, gives you an experience akin to frontend Hot Module Replacement: once your contract changes, the deployment is executed and your contract retains the same address and same state, allowing you to tweak your contracts while debugging your front-end.\n\n## hardhat-deploy in a nutshell\n\nBefore going into the details, here is a very simple summary of the basic feature of **hardhat-deploy**.\n\n**hardhat-deploy** allows you to write [`deploy scripts`](#deploy-scripts) in the `deploy` folder. Each of these files that look as follows will be executed in turn when you execute the following task: `hardhat --network <networkName> deploy`\n\n```js\n// deploy/00_deploy_my_contract.js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('MyContract', {\n    from: deployer,\n    args: ['Hello'],\n    log: true,\n  });\n};\nmodule.exports.tags = ['MyContract'];\n```\n\nFurthermore you can also ensure these scripts are executed in test too by calling `await deployments.fixture(['MyContract'])` in your test.\nThis is optimized, so if multiple tests use the same contract, the deployment will be executed once and each test will start with the exact same state.\n\nThis is a huge benefit for testing since you are not required to replicate the deployment procedure in your tests. The tag feature (as seen in the script above) and [dependencies](#deploy-scripts-tags-and-dependencies) will also make your life easier when writing complex deployment procedures.\n\nYou can even group deploy scripts in different sub folder and ensure they are executed in their logical order.\n\nFurthermore hardhat-deploy can also support a multi-chain settings like L1, L2 with multiple deploy folder specific to each network.\n\nThere is a tutorial covering the basics here : https://github.com/wighawag/tutorial-hardhat-deploy\n\n## Installation\n\n### npm install hardhat-deploy\n\n```bash\nnpm install -D hardhat-deploy\n```\n\nAnd add the following statement to your `hardhat.config.js`:\n\n```js\nrequire('hardhat-deploy');\n```\n\nif you use `ethers.js` we recommend you also install `hardhat-deploy-ethers` which add extra features to access deployments as ethers contract.\n\nSince `hardhat-deploy-ethers` is a fork of `@nomiclabs/hardhat-ethers` and that other plugin might have an hardcoded dependency on `@nomiclabs/hardhat-etehrs` the best way to install `hardhat-deploy-ethers` and ensure compatibility is the following:\n\n```bash\nnpm install --save-dev  @nomiclabs/hardhat-ethers@npm:hardhat-deploy-ethers ethers\n```\n\nWhich means you then need to do `require(\"@nomiclabs/hardhat-ethers\")` instead of `require(\"hardhat-deploy-ethers\")` in your `hardhat.config.js` file.\n\nMore details on `hardhat-deploy-ethers` repo : https://github.com/wighawag/hardhat-deploy-ethers#readme\n\n### TypeScript support\n\nWith hardhat the tsconfig.json is optional.\n\nBut if you add folders to the `include` field in `tsconfig.json`, you ll also need to include `hardhat.config.ts` like :\n\n`include\": [\"./hardhat.config.ts\", \"./scripts\", \"./deploy\", \"./test\"]`\n\nfor deploy script (see below) you can write them this way to benefit from typing :\n\n```ts\nimport {HardhatRuntimeEnvironment} from 'hardhat/types';\nimport {DeployFunction} from 'hardhat-deploy/types';\n\nconst func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {\n  // code here\n};\nexport default func;\n```\n\nSee a template that uses **hardhat-deploy** here : https://github.com/wighawag/template-ethereum-contracts\n\nThis repo has also some examples branch that exemplify specific features, like the forking testing here : https://github.com/wighawag/template-ethereum-contracts/tree/examples/fork-test\n\n### Migrating existing deployment to hardhat-deploy\n\n(Only needed for existing project that already deployed contracts and has the deployment information available **(at minimum, address and abi)**)\n\nYou might want to switch your current deployment process to use **hardhat-deploy**. In that case you probably have some deployments saved elsewhere.\n\nIn order to port them to **hardhat-deploy**, you'll need to create one `.json` file per contract in the `deployments/<network>` folder (configurable via [paths config](#extra-paths-config)).\n\nThe network folder is simply the hardhat network name (as configured in hardhat.config.js) (accessible at runtime via `hre.network.name`).\nSuch folder need to have a file named `.chainId` containing the chainId as decimal.\n\nFor example for network named \"rinkeby\" (for the corresponding network) the file `deployments/rinkeby/.chainId` would be\n\n```\n4\n```\n\nNote, prior to hardhat 0.6 the chainId was appended to the folder name (expect for some known network name). This has changed and upgrading to 0.6 will require you to change the folder name and add the '.chainId' file.\n\nEach contract file must follow this type (as defined in [types.ts](types.ts)) :\n\n```ts\nexport interface Deployment {\n  address: Address;\n  abi: ABI;\n  receipt?: Receipt;\n  transactionHash?: string;\n  history?: Deployment[];\n  implementation?: string;\n  args?: any[];\n  linkedData?: any;\n  solcInputHash?: string;\n  metadata?: string;\n  bytecode?: string;\n  deployedBytecode?: string;\n  libraries?: Libraries;\n  userdoc?: any;\n  devdoc?: any;\n  methodIdentifiers?: any;\n  diamondCut?: FacetCut[];\n  facets?: Facet[];\n  storageLayout?: any;\n  gasEstimates?: any;\n}\n```\n\nAs you can see, only abi and address are mandatory. But having the other fields allow more feature. For example, metadata and args allow you to benefit from contract code verification.\n\nFor Receipt, the following type is expected:\n\n```ts\nexport type Receipt = {\n  from: string;\n  transactionHash: string;\n  blockHash: string;\n  blockNumber: number;\n  transactionIndex: number;\n  cumulativeGasUsed: string;\n  gasUsed: string;\n  contractAddress?: string;\n  to?: string;\n  logs?: Log[];\n  events?: any[];\n  logsBloom?: string;\n  byzantium?: boolean;\n  status?: number;\n  confirmations?: number;\n};\n```\n\nHere is an example:\n\nLet sey you have:\n\n- 2 Contract named Greeter and Registry deployed on rinkeby\n- 1 contract named Greeter on mainnet\n- 2 Contract named Greeter and Registry deployed on a network named rinkeby2\n\nYou would get the following folder structure:\n\n```\ndeployments/\n  mainnet/\n    .chainId\n    Greeter.json\n  rinkeby/\n    .chainId\n    Greeter.json\n    Registry.json\n  rinkeby2/\n    .chainId\n    Greeter.json\n    Registry.json\n```\n\nThe reason why **hardhat-deploy** save chainId in the `.chainId` file is both for\n\n- safety: so that if you were to change the network name to point to a different chain, it would not attempt to read the wrong folder and assume that a contract has been deployed while it has not.\n- ability to know the chainId without requring to be connected to a node (and so not dependent on hardhat.config.js settings). Useful for `export` task.\n\n---\n\n## Hardhat Tasks Available/Updated\n\nhardhat deploy add several task to hardhat. It also modify existing one, adding new options and new behavior. All of these are described here:\n\n---\n\n### 1. hardhat deploy\n\n---\n\nThis plugin adds the _deploy_ task to Hardhat.\n\nThis task will execute the scripts in the `deploy` folder and save the contract deployments to disk. These deployments are supposed to be saved for example in a git repository. This way they can be accessed later. But you are free to save them elsewhere and get them back via your mechanism of choice.\n\nWith the deployment saved, it allows you to deploy a contract only if changes were made.\n\nDeploy scripts (also called Deploy functions) can also perform aribtrary logic.\n\nFor further details on how to use it and write deploy script, see [section](#deploy-scripts) below.\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployments, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice (in wei) to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--reset`: This flag resets the deployments from scratch. Previously deployed contract are not considered and deleted from disk.\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n---\n\n### 2. hardhat node\n\n---\n\nThis plugin modify the _node_ task so that it also execute the deployment script before exposing the server http RPC interface\n\nIt add similar options than the `deploy` task :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n`--forkDeployments <networkName>`: defaults to `localhost`; this option allows you to specify the network to fetch the deployment from when running in fork mode. This is necessary as hardhat fork feature does not track the fork's network: <https://github.com/nomiclabs/hardhat/issues/1164>\n\n`--asNetwork <networkName`: default to `localhost` (or the value specified by `--forkDeployments` if any), this option allows you to specify the network name to be used for **hardhat-deploy** functionality, like which folder the resulting deployment should be saved to.\n\n#### **Flags**\n\n`--noReset`: This flag prevent the reseting of the existing deployments. This is usually not desired when running the `node` task as a network is created from scratch and previous deployemnt are irrelevant.\n\n`--show-accounts`: this flag will output the account private keys\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n`--no-deploy` that discard all other options to revert to normal `hardhat node` behavior without any deployment being performed.\n\nNote that the deployments are saved as if the network name is `localhost`. This is because `hardhat node` is expected to be used as localhost: You can for example execute `hardhat --network localhost console` after `node` is running. Doing `builder --network hardhat console` would indeed not do anything useful. It still take the configuration from `hardhat` in the hardhat.config.js file though.\n\n---\n\n### 3. hardhat test\n\n---\n\nThis plugin adds a flag argument `--deploy-fixture` to the _test_ task that runs the global deployments fixture before the tests and snapshots it. This will generaly speed up the tests.\n\n---\n\n### 4. hardhat etherscan-verify\n\n---\n\nThis plugin adds the _etherscan-verify_ task to Hardhat.\n\nThis task will submit the contract source and other info of all deployed contracts to allow etherscan to verify and record the sources.\n\nInstead of using the full solc input, this task will first attempt to send the minimal sources from the metadata.\nBut Etherscan sometime fails due to a bug in solidity compiler (<https://github.com/ethereum/solidity/issues/9573>). As such this task can fallback on full solc input (see option --solc-input). Note that if your contract was deployed with a previous version of **hardhat-deploy**, it might not contains the full information. The issue seems to be fully resolved since solc version 0.8.\n\nThis task will also attempt to automatically find the SPDX license in the source.\n\nTo execute that task, you need to specifiy the network to run against :\n\n```bash\nhardhat --network mainnet etherscan-verify --api-key <apikey>\n```\n\n#### **Options**\n\n`--api-key <api key>`: let you specify your etherscan api key. Alternatively, you can provide it via the env variable `ETHERSCAN_API_KEY`\n\n`--license <SPDX license id>`: SPDX license (useful if SPDX is not listed in the sources), need to be supported by etherscan: https://etherscan.io/contract-license-types\n\n`--force-license`: if set, will force the use of the license specified by --license option, ignoring the one in the source (useful for license not supported by etherscan)\n\n`--solc-input`: fallback on solc-input id needed (useful when etherscan fails on the minimum sources, see https://github.com/ethereum/solidity/issues/9573)\n\n---\n\n### 5. hardhat sourcify\n\n---\n\nThis plugin adds the _sourcify_ task to Hardhat.\n\nSimilar to `hardhat etherscan-verify` this task will submit the contract source and other info of all deployed contracts to sourcify.\n\n```bash\nhardhat --network mainnet sourcify\n```\n\nLater this task might instead pin the metadata to ipfs, so sourcify can automatically verify them.\n\n#### **Options**\n\n`--endpoint <endpoint>`: specify the sourcify endpoint, default to https://sourcify.dev/server/\n\n`--write-failing-metadata`: if set and the sourcify task fails to verify, the metadata file will be written to disk, so you can more easily figure out what has gone wrong.\n\n---\n\n### 6. hardhat export\n\n---\n\nThis plugin adds the _export_ task to Hardhat.\n\nThis task will export the contract deployed (saved in `deployments` folder) to a file with a simple format containing only contract addresses and abi, useful for web apps.\n\nOne of the following options need to be set for this task to have any effects :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\nThis last option has some limitations, when combined with the use of external deployments (see [Configuration](#configuration)). If such external deployments were using older version of **hardhat-deploy** or truffle, the chainId might be missing. In order for these to be exported, the hardhat network config need to explicity state the chainId in the `networks` config of `hardhat.config.js`.\n\n---\n\n---\n\n## Hardhat Environment Extensions\n\nThis plugin extends the Hardhat Runtime Environment by adding 4 fields:\n\n- `getNamedAccounts: () => Promise<{ [name: string]: string }>`: a function returning an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [Configuration](#configuration)).\n\n- `getUnnamedAccounts: () => Promise<string[]}>`: accounts which has no names, useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`: contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId(): Promise<string>`: offer an easy way to fetch the current chainId.\n\n---\n\n---\n\n## Configuration\n\n---\n\n### **1. namedAccounts (ability to name addresses)**\n\n---\n\nThis plugin extends the `HardhatConfig`'s object with an optional `namedAccounts` field.\n\n`namedAccounts` allows you to associate names to addresses and have them configured per chain.\nThis allows you to have meaningful names in your tests while the addresses match to multi sig in real network for example.\n\n```js\n{\n    namedAccounts: {\n        deployer: {\n            default: 0, // here this will by default take the first account as deployer\n            1: 0, // similarly on mainnet it will take the first account as deployer. Note though that depending on how hardhat network are configured, the account 0 on one network can be different than on another\n            4: '0xA296a3d5F026953e17F472B497eC29a5631FB51B', // but for rinkeby it will be a specific address\n            \"goerli\": '0x84b9514E013710b9dD0811c9Fe46b837a4A0d8E0', //it can also specify a specific netwotk name (specified in hardhat.config.js)\n        },\n        feeCollector:{\n            default: 1, // here this will by default take the second account as feeCollector (so in the test this will be a different account than the deployer)\n            1: '0xa5610E1f289DbDe94F3428A9df22E8B518f65751', // on the mainnet the feeCollector could be a multi sig\n            4: '0xa250ac77360d4e837a13628bC828a2aDf7BabfB3', // on rinkeby it could be another account\n        }\n    }\n}\n```\n\n<!-- You can also specify addresses with the `ledger://` prefix. In which case the account fetched will still be the corresponding address, but behind the scene, the transaction will be created via the hardware waller. Currently the feature is not working very well though and better support is needed. -->\n\n---\n\n### **2. extra hardhat.config networks' options**\n\n---\n\n**hardhat-deploy** add 4 new fields to `networks` configuration\n\n`live` : this is not used internally but is useful to perform action on a network whether it is a live network (rinkeby, mainnet, etc) or a temporary one (localhost, hardhat). The default is true (except for localhost and hardhat where the default is false).\n\n`saveDeployments`: this tell whether **hardhat-deploy** should save the deployments to disk or not. Default to true, except for the hardhat network.\n\n`tags`: network can have tags to represent them. The config is an array and at runtime the hre.network.tags is an object whose fields (the tags) are set to true.\n\nThis is useful to conidtionaly operate on network based on their use case.\n\nExample:\n\n```js\n{\n  networks: {\n    localhost: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"local\"]\n    },\n    hardhat: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"test\", \"local\"]\n    },\n    rinkeby: {\n      live: true,\n      saveDeployments: true,\n      tags: [\"staging\"]\n    }\n  }\n}\n```\n\n`deploy`: the deploy field override the paths.deploy option and let you define a set of folder containing the deploy scripts to be executed for this network.\n\nYou can thus have one network that will be executing L1 deployment and other L2 deployments, etc...\n\n---\n\n### **3. extra hardhat.config paths' options**\n\n---\n\nIt also adds fields to `HardhatConfig`'s `ProjectPaths` object.\n\nHere is an example showing the default values :\n\n```js\n{\n    paths: {\n        deploy: 'deploy',\n        deployments: 'deployments',\n        imports: 'imports'\n    }\n}\n```\n\nThe deploy folder is expected to contains the deploy script that are executed upon invocation of `hardhat deploy` or `hardhat node`.\nIt can also be an array of folder path.\n\nThe deployment folder will contains the resulting deployments (contract addresses along their abi, bytecode, metadata...). One folder per network and one file per contract.\n\nThe imports folder is expected to contains artifacts that were pre-compiled. Useful if you want to upgrade to a new solidity version but want to keep using previously compiled contracts. The artifact is the same format as normal hardhat artifact, so you can easily copy them over, before switching to a new compiler version.\n\n---\n\n### Importing deployment from other projects (with truffle support)\n\nIt also add the `external` field to `HardhatConfig`\n\nSuch fiels allows to specify paths for external artifacts or deployments.\n\nThe external object has 2 fields:\n\n```js\n{\n    external: {\n        contracts: [\n          {\n            artifacts: \"node_modules/@cartesi/arbitration/export/artifacts\",\n            deploy: \"node_modules/@cartesi/arbitration/export/deploy\"\n          },\n          {\n            artifacts: \"node_modules/someotherpackage/artifacts\",\n          }\n        ],\n        deployments: {\n          rinkeby: [\"node_modules/@cartesi/arbitration/build/contracts\"],\n        },\n    }\n}\n```\n\nThe contract field specify an array of object which itself have 2 fields.\n\n- artifacts: (mandatory) it is a path to an artifact folder. This support both hardhat and truffle artifacts.\n- deploy: (optional) it specifies a path to a folder where reside deploy script. The deploy script have only access to the artifact specified in the artifacts field. This allow project to share their deployment procedure. A boon for developer aiming at integrating it as they can get the contracts to be deployed for testing locally.\n\nThe deployments fields specify an object whose field name are the hardhat network and the value is an array of path to look for deployments. It supports both **hardhat-deploy** and truffle formats.\n\n---\n\n### Access to Artifacts (non-deployed contract code and abi)\n\nyou can access contract artifact via `getArtifact` function :\n\n```js\nconst {deployments} = require('hardhat');\nconst artifact = await deployments.getArtifact(artifactName);\n```\n\nWith the `hardhat-deploy-ethers` plugin you can get your ethers contract via :\n\n```js\nconst {deployments, ethers} = require('hardhat');\nconst factory = await ethers.getContractFactory(artifactName);\n```\n\nNote that the artifact file need to be either in `artifacts` folder that hardhat generate on compilation or in the `imports` folder where you can store contracts compiled elsewhere. They can also be present in the folder specified in `external.artifacts` see [Importing deployment from other projects](#importing-deployment-from-other-projects-truffle-support-too)\n\n---\n\n---\n\n## How to Deploy Contracts\n\n---\n\n### The `deploy` Task\n\n`hardhat --network <networkName> deploy [options and flags]`\n\nThis is a new task that the plugin adds. As the name suggests it deploys contracts.\nTo be exact it will look for files in the folder `deploy` or whatever was configured in `paths.deploy`, see [paths config](#extra-paths-config)\n\nIt will scan for files in alphabetical order and execute them in turn.\n\n- it will `require` each of these files and execute the exported function with the HRE as argument\n\nNote that running `hardhat deploy` without specifying a network will use the default network. If the default network is hardhat (the default's default) then nothing will happen as a result but this can be used to ensure the deployment is without issues.\n\nTo specified the network, you can use the builtin hardhat argument `--network <network name>` or set the env variable `HARDHAT_NETWORK`\n\n---\n\n### Deploy Scripts\n\nThe deploy scripts need to be of the following type :\n\n```js\nexport interface DeployFunction {\n  (env: HardhatRuntimeEnvironment): Promise<void | boolean>;\n  skip?: (env: HardhatRuntimeEnvironment) => Promise<boolean>;\n  tags?: string[];\n  dependencies?: string[];\n  runAtTheEnd?: boolean;\n  id?: string;\n}\n```\n\nThe skip function can be used to skip executing the script under whatever condition. It simply need to resolve a promise to true.\n\nThe tags is a list of string that when the _deploy_ task is executed with, the script will be executed (unless it skips). In other word if the deploy task is executed with a tag that does not belong to that script, that script will not be executed unless it is a dependency of a script that does get executed.\n\nThe dependencies is a list of tag that will be executed if that script is executed. So if the script is executed, every script whose tag match any of the dependency will be executed first.\n\nThe `runAtTheEnd` is a boolean that if set to true, will queue that script to be executed after all other scripts are executed.\n\nThese set of fields allow more flexibility to organize the scripts. You are not limited to alphabetical order.\n\nFinally the function can return true if it wishes to never be executed again. This can be usfeul to emulate migration scripts that are meant to be executed only once. Once such script return true (async), the `id` field is used so to track execution and if that field is not present when the script return true, it will fails.\n\nIn any case, as a general advice every deploy function should be idempotent. This is so they can always recover from failure or pending transaction.\n\nThis is why the `hre.deployments.deploy` function will by default only deploy if the contract code has changed, making it easier to write idempotent script.\n\nAn example of a deploy script :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  // the following will only deploy \"GenericMetaTxProcessor\" if the contract was never deployed or if the code changed since last deployment\n  await deploy('GenericMetaTxProcessor', {\n    from: deployer,\n    gasLimit: 4000000,\n    args: [],\n  });\n};\n```\n\nAs you can see the HRE passed in has 4 new fields :\n\n- `getNamedAccounts` is a function that returns a promise to an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [`namedAccounts`](#namedaccounts)).\n\n- `getUnnamedAccounts`: function that return a promise to an array of accounts (which were not used in `getNamedAccounts`), useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`, which contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId` which return a promise for the chainId\n\nThe deploynments field contains the `deploy` function taht allow you to deploy contract and save them. It contains a lot more functions though :\n\n---\n\n### The `deployments` field\n\nThe deployments field contains several helpers function to deploy contract but also execute transaction.\n\n```ts\nexport interface DeploymentsExtension {\n  deploy(name: string, options: DeployOptions): Promise<DeployResult>; // deploy a contract\n  diamond: {\n    // deploy diamond based contract (see section below)\n    deploy(name: string, options: DiamondOptions): Promise<DeployResult>;\n  };\n  deterministic( // return the determinsitic address as well as a function to deploy the contract, can pass the `salt` field in the option to use different salt\n    name: string,\n    options: Create2DeployOptions\n  ): Promise<{\n    address: Address;\n    deploy(): Promise<DeployResult>;\n  }>;\n  fetchIfDifferent( // return true if new compiled code is different than deployed contract\n    name: string,\n    options: DeployOptions\n  ): Promise<{differences: boolean; address?: string}>;\n  save(name: string, deployment: DeploymentSubmission): Promise<void>; // low level save of deployment\n  get(name: string): Promise<Deployment>; // fetch a deployment by name, throw if not existing\n  getOrNull(name: string): Promise<Deployment | null>; // fetch deployment by name, return null if not existing\n  getDeploymentsFromAddress(address: string): Promise<Deployment[]>;\n  all(): Promise<{[name: string]: Deployment}>; // return all deployments\n  getArtifact(name: string): Promise<Artifact>; // return a hardhat artifact (compiled contract without deployment)\n  getExtendedArtifact(name: string): Promise<ExtendedArtifact>; // return a extended artifact (with more info) (compiled contract without deployment)\n  run( // execute deployment scripts\n    tags?: string | string[],\n    options?: {\n      resetMemory?: boolean;\n      deletePreviousDeployments?: boolean;\n      writeDeploymentsToFiles?: boolean;\n      export?: string;\n      exportAll?: string;\n    }\n  ): Promise<{[name: string]: Deployment}>;\n  fixture( // execute deployment as fixture for test // use evm_snapshot to revert back\n    tags?: string | string[],\n    options?: {fallbackToGlobal?: boolean; keepExistingDeployments?: boolean}\n  ): Promise<{[name: string]: Deployment}>;\n  createFixture<T, O>( // execute a function as fixture using evm_snaphost to revert back each time\n    func: FixtureFunc<T, O>,\n    id?: string\n  ): (options?: O) => Promise<T>;\n  log(...args: any[]): void; // log data only ig log enabled (disabled in test fixture)\n\n  execute( // execute function call on contract\n    name: string,\n    options: TxOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<Receipt>;\n  rawTx(tx: SimpleTx): Promise<Receipt>; // execute a simple transaction\n  catchUnknownSigner( // you can wrap other function with this function and it will catch failure due to missing signer with the details of the tx to be executed\n    action: Promise<any> | (() => Promise<any>),\n    options?: {log?: boolean}\n  ): Promise<null | {\n    from: string;\n    to?: string;\n    value?: string;\n    data?: string;\n  }>;\n  read( // make a read-only call to a contract\n    name: string,\n    options: CallOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<any>;\n  read(name: string, methodName: string, ...args: any[]): Promise<any>;\n  // rawCall(to: Address, data: string): Promise<any>; // TODO ?\n}\n```\n\n---\n\n#### `deployments.deploy`\n\n---\n\nThe deploy function as mentioned allow you to deploy a contract and save it under a specific name.\n\nThe deploy function expect 2 parameters: one for the name and one for the options\n\nSee below the full list of fields that the option parameter allows and requires:\n\n```ts\nexport interface DeployOptions = {\n  from: string; // address (or private key) that will perform the transaction. you can use `getNamedAccounts` to retrived the address you want by name.\n  contract?: // this is an optional field. If not specified it defaults to the contract with the same name as the first parameter\n    | string // this field can be either a string for the name of the contract\n    | { // or abi and bytecode\n        abi: ABI;\n        bytecode: string;\n        deployedBytecode?: string;\n      };\n  args?: any[]; // the list of argument for the constructor (or the upgrade function in case of proxy)\n  skipIfAlreadyDeployed?: boolean; // if set it to true, will not attempt to deploy even if the contract deployed under the same name is different\n  log?: boolean; // if true, it will log the result of the deployment (tx hash, address and gas used)\n  linkedData?: any; // This allow to associate any JSON data to the deployment. Useful for merkle tree data for example\n  libraries?: { [libraryName: string]: Address }; // This let you associate libraries to the deployed contract\n  proxy?: boolean | string | ProxyOptions; // This options allow to consider your contract as a proxy (see below for more details)\n\n  // here some common tx options :\n  gasLimit?: string | number | BigNumber;\n  gasPrice?: string | BigNumber;\n  value?: string | BigNumber;\n  nonce?: string | number | BigNumber;\n\n  estimatedGasLimit?: string | number | BigNumber; // to speed up the estimation, it is possible to provide an upper gasLimit\n  estimateGasExtra?: string | number | BigNumber; // this option allow you to add a gas buffer on top of the estimation\n\n  autoMine?: boolean; // this force a evm_mine to be executed. this is useful to speed deployment on test network that allow to specify a block delay (ganache for example). This option basically skip the delay by force mining.\n  deterministicDeployment? boolean | string; // if true, it will deploy the contract at a deterministic address based on bytecode and constuctor arguments. The address will be the same across all network. It use create2 opcode for that, if it is a string, the string will be used as the salt.\n};\n```\n\n---\n\n---\n\n## Handling contract using libraries\n\nIn the deploy function, one of the `DeployOptions` that can be passed into the function is the `libraries` field.\n\nFirst, deploy the library using the `deploy` function, then when we deploy a contract that needs the the linked library, we can pass the deployed library name and address in as an argument to the `libraries` object.\n\n```js\nconst exampleLibrary = await deploy(\"ExampleLibary\", {\n    from: <deployer>\n});\n\n```\n\nExampleLibrary is now deployed to whatever network is in the context of the environment.\n\nFor example, if we are deploying on Rinkeby, this library will get deployed on rinkeby, and the `exampleLibrary` variable will be a deployment object that contains the abi as well as the deployed address for the contract.\n\nNow that the library is deployed, we can link it in our next deployed contract.\n\n```js\nconst example = await deploy(\"Example\", {\n    from: <deployer>\n    args: [\"This is an example string argument in the constructor for the 'Example' contract\"],\n    libraries: {\n        ExampleLibrary: exampleLibrary.address\n    }\n});\n\n```\n\nThis `libraries` object takes the name of the library, and its deployed address on the network. Multiple libraries can be passed into the `libraries` object.\n\n---\n\n---\n\n## Exporting Deployments\n\nApart from deployments saved in the `deployments` folder which contains all information available about the contract (compile time data + deployment data), `hardhat-deploy` allows you to export lightweight files.\n\nThese can be used for example to power your frontend with contract's address and abi.\n\nThis come into 2 flavors.\n\nThe first one is exported via the `--export <file>` option and follow the following format :\n\n```js\nexport interface Export {\n  chainId: string;\n  name: string;\n  contracts: {[name: string]: ContractExport};\n}\n```\n\nwhere name is the name of the network configuration chosen (see hardhat option `--network`)\n\nThe second one is exported via the `--export-all <file>` option and follow the following format :\n\n```js\nexport type MultiExport = {\n  [chainId: string]: {[name: string]: Export},\n};\n```\n\nAs you see the second format include the previous. While in most case you'll need the single export where your application will support only one network, there are case where your app would want to support multiple network at nonce. This second format allow for that.\n\nFurthermore as hardhat support multiple network configuration for the same network (rinkeby, mainnet...), the export-all format will contains each of them grouped by their chainId.\n\n---\n\n---\n\n## Deploying and Upgrading Proxies\n\nAs mentioned above, the deploy function can also deploy a contract through a proxy. It can be done without modification of the contract as long as it does not have a constructor (or constructor with zero arguments).\n\nThe default Proxy is both ERC-1967 and ERC-173 Compliant, but other proxy can be specified, like openzeppelin transparent proxies.\n\nCode for the default Proxy can be found [here](solc_0.7/proxy/EIP173Proxy.sol)\n\nTo perform such proxy deployment, you just need to invoke the deploy function with the following options : `{..., proxy: true}`\n\nSee example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: true,\n  });\n};\n```\n\nYou can also set it to `proxy: \"<upgradeMethodName>\"` in which case the function `<upgradeMethodName>` will be executed upon upgrade.\nthe `args` field will be then used for that function instead of the contructor. It is also possible to then have a constructor with the same arguments and have the proxy be disabled. It can be useful if you want to have your contract as upgradeable in a test network but be non-upgradeable on the mainnet.\n\nSee example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: 'postUpgrade',\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nThe proxy option can also be an object which can set the specific owner that the proxy is going to be managed by.\n\nSee example:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: {\n      owner: greeterOwner,\n      methodName: 'postUpgrade',\n    },\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nNote that for the second invokation, this deployment will fails to upgrade the proxy as the `from` which is `deployer` is not the same as the proxy's owner : `greeterOwner`\n\nTo make it work, you have to create a new script that have for `from` field: `greeterOwner`. If such value is a a multi sig or an address not registered as part of hardhat signers, the tx will not be executed but instead an error will be throw. That error can be caught up via deployments.catchUnknwonSigner function so you get the necessary tx details to execute it elsewhere.\n\nThe full proxy options is as follow:\n\n```ts\nexport interface ProxyOptions {\n  owner?: Address; // this set the owner of the proxy. further upgrade will need to be executed from that owner\n  methodName?: string; // method to be executed when the implementation is modified.\n  proxyContract?: string | ArtifactData; // default to \"EIP173Proxy\". See below for more details\n  viaAdminContract?: // allow to specify a contract that act as a middle man to perform upgrades. Useful and Recommended for Transparent Proxies\n  | string\n    | {\n        name: string;\n        artifact?: string | ArtifactData;\n      };\n}\n```\n\nThe `proxyContract` field allow you to specify your own Proxy contract. If it is a string, it will first attemp to get an artifact with that name. If not found it will fallback on the following if\n\nit matches:\n\n- `EIP173Proxy`: use the default Proxy that is EIP-173 compliant\n\n- `EIP173ProxyWithReceive`: Same as above except that the proxy contains a receive hook to accept empty ETH payment\n\n- `OpenZeppelinTransparentProxy`: Use Openzeppelin Transparent Proxy (slightly modified as openzeppelin's one hardcode the msg.sender as first owner, see code [here](solc_0.7\\openzeppelin\\proxy\\TransparentUpgradeableProxy.sol))\n  When this option is chosen, the `DefaultProxyAdmin` is also used as admin since Transparent Proxy kind of need an intermediarry contract for administration. This can be configired via the `viaAdminContract` option\n\n- `OptimizedTransparentProxy`: This contract is similar to above, except that it is optimized to not require storage read for the admin on every call.\n\n## Builtin-In Support For Diamonds (EIP2535)\n\nThe deployments field also expose the diamond field: `hre.deployments.diamond` that let you deploy [Diamonds](https://eips.ethereum.org/EIPS/eip-2535) in an easy way.\n\nInstead of specifying the facets to cut out or cut in, which the diamond contract expects, you specify the facets you want to end up having on the deployed contract.\n\n`diamond.deploy` expect the facet as names. The names represent contract to be deployed as facet. In future version you ll be able to specify deployed contract or artifact object as facet.\n\nTo deploy a contract with 3 facet you can do as follow :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: deployer,\n    owner: diamondAdmin,\n    facets: ['Facet1', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nif you then later execute the following script:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: diamondAdmin, // this need to be the diamondAdmin for upgrade\n    owner: diamondAdmin,\n    facets: ['NewFacet', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nThen the NewFacet will be deployed automatically if needed and then the diamondCut will cut Facet1 out and add NewFacet.\n\nNote that if the code for Facet2 and Facet3 changes, they will also be redeployed automatically and the diamondCuts will replace the existing facets with these new ones.\n\nNote that The Diamond contract's code is part of hardhat-deploy and contains 3 built-in facet that can be removed manually if desired.\nThese facets are used for ownership, diamondCut and diamond loupe.\n\nThe implementation is the [reference implementation by Nick Mudge](https://github.com/mudgen/diamond-3)\n\nLike normal proxies you can also execute a function at the time of an upgrade.\n\nThis is done by specifying the execute field in the diamond deploy options :\n\n```js\ndiamond.deploy('ADiamondContract', {\n  from: deployer,\n  owner: diamondAdmin,\n  facets: ['NewFacet', 'Facet2', 'Facet3'],\n  execute: {\n    methodName: 'postUpgrade',\n    args: ['one', 2, '0x3'],\n  },\n});\n```\n\nSince the diamond standard has no builtin mechanism to make the deployment of Diamond with function execution, the Diamond when deployed is actually deployed through a special contract, the `Diamantaire` (see code [here](solc_0.7/diamond/Diamantaire.sol)) that act as factory to build Diamond. It uses deterministic deployment for that so, it is transparently managed by hardhat-deploy. It also embed the implementation of the builtin facet, removing the need to have different instances of each live.\n\n<!-- The Diamantaire also support the deterministic deployment of Diamonds.\nAn extra field can be passed to the Diamond deployment options : `deterministicSalt`. It has to be a non-zero 32bytes string (in hex format).\nNote that if you want to deploy 2 diamonds with same owner, you'll need 2 different deterministicSalt for them to be 2 separate contracts. -->\n\n## Testing Deployed Contracts\n\nYou can continue using the usual test task :\n\n`hardhat test`\n\nTests can then use the `hre.deployments.fixture` function to run the deployment for the test and snapshot it so that tests don't need to perform all the deployments transaction every time, they simply reuse the snapshot for every test (this leverages `evm_snapshot` and `evm_revert` provided by both `hardhat` and `ganache`). You can for example set them in a `beaforeEach`.\n\nHere is an example of a test :\n\n```js\nconst {deployments} = require('hardhat');\n\ndescribe('Token', () => {\n  beforeEach(async () => {\n    await deployments.fixture();\n  });\n  it('testing 1 2 3', async function () {\n    const Token = await deployments.get('Token'); // Token is available because the fixture was executed\n    console.log(Token.address);\n    const ERC721BidSale = await deployments.get('ERC721BidSale');\n    console.log({ERC721BidSale});\n  });\n});\n```\n\nIf the deployment scripts are complex, the first test could take while (as the fixture need to execute the deployment) but then from the second test onward, the deployments are never re-executed, instead the fixture will do `evm_revert` and test will run far faster.\n\nTests can also leverage named accounts for clearer test. Combined with `hardhat-deploy-ethers` plugin, you can write succint test :\n\n```js\nconst {ethers, getNamedAccounts} = require('hardhat');\n\ndescribe('Token', () => {\n  beforeEach(async () => {\n    await deployments.fixture();\n  });\n  it('testing 1 2 3', async function () {\n    const {tokenOwner} = await getNamedAccounts();\n    const TokenContract = await ethers.getContract('Token', tokenOwner);\n    await TokenContract.mint(2).then((tx) => tx.wait());\n  });\n});\n```\n\n---\n\n### Creating Fixtures\n\nFurthermore, tests can easily create efficient fixture using `deployments.createFixture`\n\nSee example :\n\n```js\nconst setupTest = deployments.createFixture(async ({deployments, getNamedAccounts, ethers}, options) => {\n  await deployments.fixture(); // ensure you start from a fresh deployments\n  const { tokenOwner } = await getNamedAccounts();\n  const TokenContract = await ethers.getContract(\"Token\", tokenOwner);\n  await TokenContract.mint(10).then(tx => tx.wait()); //this mint is executed once and then `createFixture` will ensure it is snapshotted\n  return {\n    tokenOwner: {\n      address: tokenOwner,\n      TokenContract\n    }\n  };\n};\ndescribe(\"Token\", () => {\n  it(\"testing 1 2 3\", async function() {\n    const {tokenOwner} = await setupTest()\n    await tokenOwner.TokenContract.mint(2);\n  });\n});\n```\n\nWhile this example is trivial, some fixture can requires several transaction and the ability to snapshot them automatically speed up the tests greatly.\n\n---\n\n---\n\n## More Information On Hardhat Tasks\n\n---\n\n### **1. node task**\n\nas mentioned above, the node task is slighly modified and augmented with various flags and options\n\n`hardhat node`\n\nIn particulat it adds an argument `--export` that allows you to specify a destination file where the info about the contracts deployed is written.\nYour webapp can then access all contracts information.\n\n---\n\n### **2. test task**\n\n`hardhat test`\n\nthe test task is augmented with one flag argument `--deploy-fixture` that allows to run all deployments in a fixture snapshot before executing the tests. This can speed up the tests that use specific tags as the global fixture take precedence (unless specified).\n\nIn other word tests can use `deployments.fixture(<specific tag>)` where specific tag only deploys the minimal contracts for tests, while still benefiting from global deployment snapshot if used.\n\nIf a test needs the deployments to only include the specific deployment specified by the tag, it can use the following :\n\n```js\ndeployments.fixture('<specific tag>', {fallbackToGlobal: false});\n```\n\nDue to how snapshot/revert works in hardhat, this means that these tests will not benefit from the global fixture snapshot and will have to deploy their contracts as part of the fixture call. This is automatic but means that these tests will run slower.\n\n---\n\n### **3. run task**\n\n`hardhat --network <networkName> run <script>`\n\nThe run task act as before but thanks to the `hre.deployments` field it can access deployed contract :\n\n```js\nconst hre = require('hardhat');\nconst {deployments, getNamedAccounts} = hre;\n\n(async () => {\n  console.log(await deployments.all());\n  console.log({namedAccounts: await getNamedAccounts()});\n})();\n```\n\nYou can also run it directly from the command line as usual.\n\n`HARDHAT_NETWORK=rinkeby node <script>` is the equivalent except it does not load the hardhat environment twice (which the run task does)\n\n---\n\n### **4. console task**\n\n`hardhat console`\n\nThe same applies to the `console` task.\n\n---\n\n## Deploy Scripts: Tags And Dependencies\n\n---\n\nIt is possible to execute only specific parts of the deployments with `hardhat deploy --tags <tags>`\n\nTags represent what the deploy script acts on. In general it will be a single string value, the name of the contract it deploys or modifies.\n\nThen if another deploy script has such tag as a dependency, then when this latter deploy script has a specific tag and that tag is requested, the dependency will be executed first.\n\nHere is an example of two deploy scripts :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const deployResult = await deploy('Token', {\n    from: deployer,\n    args: ['hello', 100],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Token deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Token'];\n```\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const Token = await deployments.get('Token');\n  const deployResult = await deploy('Sale', {\n    from: deployer,\n    contract: 'ERC721BidSale',\n    args: [Token.address, 1, 3600],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Sale deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.dependencies = ['Token']; // this ensure the Token script above is executed first, so `deployments.get('Token')` succeeds\n```\n\nAs you can see the second one depends on the first. This is because the second script depends on a tag that the first script registers as using.\n\nWith that when `hardhat deploy --tags Sale` is executed\n\nthen both scripts will be run, ensuring Sale is ready.\n\nYou can also define the script to run after another script is run by setting `runAtTheEnd` to be true. For example:\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, execute, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer, admin} = namedAccounts;\n  await execute('Sale', {from: deployer}, 'setAdmin', admin);\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.runAtTheEnd = true;\n```\n\nTags can also be used in test with `deployments.fixture`. This allow you to test a subset of the deploy script.\n","readmeFilename":"README.md","gitHead":"0809a58781ec1550a08f37727a69561bfffe0de3","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.8.0-next.4","_nodeVersion":"14.16.0","_npmVersion":"6.14.11","dist":{"integrity":"sha512-4CLZ0/a9suB8muK+nIO+NPjFV3i3PA6P95qACbGtqaEjOOPdb050uYykvPIq+zCkpEVa5lwRnzPhw58crXVdzA==","shasum":"56d2ec45ef7243cc46e3b1788cf6b32cda810126","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.8.0-next.4.tgz","fileCount":116,"unpackedSize":7178837,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgc26MCRA9TVsSAnZWagAAykIQAI0zttcB3CP+EvPGJhhJ\nzRtX8OiKFspTwOtTyoWdET3NGrM0O7do8u5op7iFdUZQAdLeROlZS6ErVDPE\nS5Uc+wre0RK5QJwrJT8VTzbUED58uC+3AN+Mm+cVSwvkFPlX15YtK9XVhSao\n6rWTFYyf8OxYMBp0rWaWRkg4afoUgmrNR8uNZk968wBNj5ZEwzJ6AuH/2UoF\nfglZtKhQNt5G+i78cYObQk/q6deKKUofNbHpsSLjeB97GshgKOU7UjWjX0ry\nDC4D35zJAH5+50qeIEs3SinOD1nKeHDuKdonSlB2Zr0iYKpAB+D9Q4EqFyEw\n8HKb8ugA/pE1uqoDO5Q8tmdBWVXyi9e9MK1921rUe1MkHe8UCXZzvP3soQz5\nbT62S7spP4jIPONob2LP6NqzO06dO6keR5ErJ7469s/O4Ieu4VZkG7hAxR0+\nZG1BDTObMw4mwY8h3yJH/44GH2Dis68dMdoAxjFXNqWkeQfUfL6UO10aNByH\nPjaHt2xVLsKMQ7sV9osjjPccUFu+48sVq+iFXfD7wjmhuk1fc75sGFleL+UW\nzaXzPgAGP7ReAMZ8lhv8urgHz4qLsMQYddilmA1pJNV9K5AC+G8yw4TSclcs\nc9xD04ecqpSgFIjDTBsf4Zk63259ekaN15gnpccCx1Przb7AsLsx9vT4/Ivy\nWO7D\r\n=zCMW\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCICmRBTfByRp0TJKiIhU8DVfh9iZjBKkmqESKLzk6NXJ8AiEA2rF9dh+iZyP04GkLmKSEtxyENRaBiQ3x+e2uG8/kwhk="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.8.0-next.4_1618177676381_0.09393207933658942"},"_hasShrinkwrap":false},"0.7.5":{"name":"hardhat-deploy","version":"0.7.5","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.0","@ethersproject/abstract-signer":"^5.0.0","@ethersproject/address":"^5.0.0","@ethersproject/bignumber":"^5.0.0","@ethersproject/bytes":"^5.0.0","@ethersproject/contracts":"^5.0.0","@ethersproject/providers":"^5.0.0","@ethersproject/solidity":"^5.0.0","@ethersproject/transactions":"^5.0.0","@ethersproject/wallet":"^5.0.0","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"4d5b527e07a4742cf97f9648a6e1d2795edbfd22","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.5","_nodeVersion":"14.16.0","_npmVersion":"6.14.11","dist":{"integrity":"sha512-b+raIZBhrlw3lzkj7La8wyfczgxRsSWo8IHQM4STY4VUw0I/zjjeMm1naIvtGuebdrW/63ADLsucXZUZ8yVLkQ==","shasum":"d31edcca709e9a8314efeaecb9a35792c295bc77","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.5.tgz","fileCount":116,"unpackedSize":7165558,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgfB9iCRA9TVsSAnZWagAA3h4P/13MTYbUU/IKp/q6BO5s\nYrNsM7AeGpByMTLjc0qbPh0RAmMa+u5QWTZd1Bx/GFfhkTDcXdR9IBewx4Jf\n2v+m5TNZB60RDufnnudBo0GzWJJsM3Y7+fV3MNQBPXU6MHtEQkatX3o4J0vQ\nj0iF2Q468bkiwE3TEdRz3l1dstJRBEHfvy9ZmC8zFQy6rkRrZDUH7dw+5CzS\n0hxt70I5mk/BsWOUWca43Y4SawKoJMID3UrdR0fdhLC96No65tlmAqFunttQ\nipS4EbTE0JnS96EtDG7tt1QhbBb0eLoGmNrscVyn6I47bUBpjEaEoY5XQOHg\nMiZZaxMkPsIHJZfCIEzjzkAeLF1b/5HCZGp1JC+GHpRSnMNGO7FDzJNKsdV/\nOF31KNmSNaWdu9VKrGQbuBKUAEGpCm+sjFr7ngCpU1uA9Vc7r+R5yYNySG0S\nuIOIWELIKzDox43P+OvX4u/5ezHC8bfl81Qs/SEHPVwVamu7vsW4Ybtyfnkc\npQ+EboWL3Yc7Wffa2YI7X+7aVwzi5cBp3LUiW3Dy1VUJoywCAhX+0vxu/lQP\nY2ihKyhanhLGVxyGIXNK9CbTnv3mZsMFxHEnbIf72mdTrS+aNipCGUpO7pus\n4Sj/xpqiCwga8I3lPIr0+LQiBDao7eaYr0BGr1WOC8Uv7A9zxgOid4pGle+s\nx8ha\r\n=cPck\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIDnFq6S6LwiCfwQJ0rjmgLPYE4t5teGo+bZzq3ghGzCmAiEAoo+i/a4bE6jgWdDtwVGB8GmWbBIYRK3Fljh3iCcuaE0="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.5_1618747233623_0.19103620102992358"},"_hasShrinkwrap":false},"0.7.6":{"name":"hardhat-deploy","version":"0.7.6","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.0","@ethersproject/abstract-signer":"^5.0.0","@ethersproject/address":"^5.0.0","@ethersproject/bignumber":"^5.0.0","@ethersproject/bytes":"^5.0.0","@ethersproject/contracts":"^5.0.0","@ethersproject/providers":"^5.0.0","@ethersproject/solidity":"^5.0.0","@ethersproject/transactions":"^5.0.0","@ethersproject/wallet":"^5.0.0","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"cd90a99116aec07db010254657d4786bfb1d8d22","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.6","_nodeVersion":"14.16.1","_npmVersion":"6.14.12","dist":{"integrity":"sha512-oyhp9B1LvKpW6mTttDQ/gyxc+IpbMQi0Q76LcAlfygD+XRF0LUKTKEkPwYktfAruRrxe8Sap87Uma6a65TLR5A==","shasum":"66cafacfb202e8cb44dfc2f3194f2c33c08993b4","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.6.tgz","fileCount":116,"unpackedSize":7128343,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgoqZTCRA9TVsSAnZWagAA9joP/RbxUV9vuJ/2uQ/9KDZd\nbMCdhwhYavrhkjLOWW5Z3jR5ePreBG7HytzN7CBHjlHeenHapMhOptD6D5IJ\nRio2WwmS/nHzKKocXwRKiyI4D2fLIXa6JERKylCcy4jR43L2aqHjcJS/giA4\n59xxGwc8HmNIr1UIXnEdfpoHb78V7JqdyX+JEjqFY7V6s6ELTaabmizFYXBV\nLOtoTEFUWRc3mF4nqNbnxDneTL55lUOU3GF87lI1IZBZG2b1ENpzjwjvwSCK\nQsuKbpY/Lz8X+q8N4dWX9EwmaoBzJgJYEu8SGNupRMLoMkwHYixGHEioNzDT\nqpMI7ep9JYO2bqeXdPi7w2GyfW4Bn0EivGuISaksbtSGSa/zFPfuyFo7EloS\nIagF+x4l5dQDsTt58NCVBBg050X8Sv2sKLgrSUSc1mGvL3nIqS4HqOnNw80W\nNNVio81PzEKNUaCrmBFweDSdQS79pvXweUZkL2ChTRxSvQlfDJD+b5fpL8P1\nOD6YaW/MEAD4PfUb+y3SbQAvjJ1wtiQe4oEAAFs1g14bJoYDKorhBtlNkgxo\nKT1D3evuu0VIBUS533vMcCa1Viur3aFjJquQUn+lLqS/jbyo1ixF4Wek0Tzc\nRwOoUW5nxjTGVO3t/6L3OrTNmgpWnLO3rxgAra60SxkNBkvUXRaTPCZig2l5\nwD7L\r\n=L3ID\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCdqs84XDxsqr88+la3g+NsbADbRf5IX3XSYbRC+Z1YggIhAMVecVZq3bQzwYb3QaKg4hF0J6JCsyHI0So7rsPzz6jm"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.6_1621272146461_0.8909687195694909"},"_hasShrinkwrap":false},"0.7.7":{"name":"hardhat-deploy","version":"0.7.7","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.0","@ethersproject/abstract-signer":"^5.0.0","@ethersproject/address":"^5.0.0","@ethersproject/bignumber":"^5.0.0","@ethersproject/bytes":"^5.0.0","@ethersproject/contracts":"^5.0.0","@ethersproject/providers":"^5.0.0","@ethersproject/solidity":"^5.0.0","@ethersproject/transactions":"^5.0.0","@ethersproject/wallet":"^5.0.0","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"8d5eb281ac9041b7856d0551c06eaa70732c362e","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.7","_nodeVersion":"14.16.1","_npmVersion":"6.14.12","dist":{"integrity":"sha512-f4RzxnnUWmIUFpwCL54MSyyuLCWl/wAuUhuO1fd9VnHx2H4GzIz81g9Vi5xjxN/8OG2N4xBWr5jS7+klglICiQ==","shasum":"fd4b90f6dc89d77ce651719978c3cc9905df1d62","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.7.tgz","fileCount":124,"unpackedSize":7153836,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgpZ4pCRA9TVsSAnZWagAACwQP/2pSZ1dgjHD/1jpCK4S6\nsDBm+ENt6Uj+Lg8+8WFNCPugTEaPvI7lHWwAADje9I5A9NCnGPD1T7R1+r1B\nA0kpJ7Y+NRtlrGv6qZkcSq6Qmo0ZSG+DkhmDO12CUHjT6tfAUQlE6ZhjHwU2\nwK5C/0DtztgdeKyVdmKeGvT02zjpO5VQnGMhnZgg0rYGdpQNnHAgbhmDfD7R\nZi/4ISOXoeBQE7j7U0BUzThTTCN7Aeee2tIkbn+NRmAOyn6bnSIu1zl6G5Ry\ni6m/grqEr+FLngQWkQWLV4i0cVYmerHQgqV6LD88fJxog8Tw/I9EHuGL0Ouq\n7uD+J6f4EofoU8Q9BNEf6P1kq8xOe/X/gkNr+nKLRLSCPl0Mi8qy33DE0crb\nidZG9P76Yb3lmgJlsruT57LpzxfB4gzCtPS0YwPXebQyR2TkCzr3TNFbO9VZ\n+7rj0gz9kUzpyOaUSSvXmy2uphuXXJoqsJIUBnrZNAHHijKv69besHXKNisK\nN/DYPjE1NJdB1Nwdn/f2Rh7qAMEvlUm1rYEAx16u2qRZJopC19jgkj+2EdSn\ne22rWSQfSFVvMcDwuMNPLxEIwOuj2nt2JFMI+D+ntuGHPwyBAq6QzNljdsbv\npFi7ZIhEB/Qk0ciTMzKELG7ZHGQFkqJ27ua8rK474U6ghK6glf0PHyqF2pXv\nerkO\r\n=Gy4u\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDDrprh0srxxf0NodICwEoYz79uhtiX+6tiZPWrpiSbZwIhALXnObJmm4SVMURU5ThSzFPUGvSKdpG9xGi+Wm31Zq+V"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.7_1621466664554_0.6814217405881124"},"_hasShrinkwrap":false},"0.7.8":{"name":"hardhat-deploy","version":"0.7.8","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.0","@ethersproject/abstract-signer":"^5.0.0","@ethersproject/address":"^5.0.0","@ethersproject/bignumber":"^5.0.0","@ethersproject/bytes":"^5.0.0","@ethersproject/contracts":"^5.0.0","@ethersproject/providers":"^5.0.0","@ethersproject/solidity":"^5.0.0","@ethersproject/transactions":"^5.0.0","@ethersproject/wallet":"^5.0.0","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"e2524d95ea9fc999d01901d3bce2f536f6e0bf2f","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.8","_nodeVersion":"14.16.1","_npmVersion":"6.14.12","dist":{"integrity":"sha512-z+7WjZ0MSPScS71MvdN8QSIgJruLVao6VMshOlBMDrdvBjeREtbD+FE9wWhWq2sZNr+u//o9I4wPPx8Qe0J6Fw==","shasum":"476ebb17214a31b619ea807439254e00d8fd78ec","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.8.tgz","fileCount":124,"unpackedSize":7153907,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgp4vYCRA9TVsSAnZWagAA2T8QAJY6bGgSv+AmrT3ASrdH\ngllK7jGYBVNxq2I0kEjtuTI+n2Bxq8xCN+GVDDa9aOY6gyajo3mNb6THNVRc\n8DngzqTSOzuKhNcIGu6wfQznkFEEB2p5AozIr043lh9oHM0iY8MTTqU6n2uf\n2eAQ0rd+kwJryOWE1c8cykNgta2LevgM7d+yu5I9cA1zqOV8Tn4nsMhSSgQU\nmuaGeqV3tGtfgviECwSXmP4jx9ucvnMVVmv0PShZDlG2mbtKGl1SZ0quoSCi\nXYIB7myX5FhGg2DcsdWv9K3A+BuD4ScbDTRHFfY5jGrUBnhJRLyuq0DeX12L\n9NUWcGQC2+QiZfxpa8JrUFbRL+QyCpdbqnjQ2q//ZRlLuiCUG3reBpdUStIz\nmxM2HFdfASSqu2n3kqjkKH22qRcohXKNIbq1oIaXiOWlQ8CeKDaG8I6gZ+0u\ny5XmQbMygmqVITxco2dmNYBkN3ZwN3J1NkETlXuR2tFuHEdhhu/QXxbqC/hv\nSPXwXCdYOzHE88cHBosLE8LwYOvVgFkDSpHjATQrTEGCWf0C6qkWJY0xREu5\nw5HY0y4CzZ6or7CXRcADukA+MjgTCvJVLWpaxdOBPDsBd/GJJBhcFIV2hEU3\nptJKobsMlui+Hwf9YpocC7Z9v8i+L5zIxigC2/tu/10Yikz3ARUViT5edpS+\nAL/3\r\n=8mwd\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDSzYUB+Bl3NTB6RcCK7LUZxZUjNLd4hUADqQU5qwpq5AIhAIaD+WNdOmzr5T7JcLmZR10X+y2/qUvWGcZy4OkuAOEJ"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.8_1621593047624_0.33716478844308084"},"_hasShrinkwrap":false},"0.7.9":{"name":"hardhat-deploy","version":"0.7.9","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.0","@ethersproject/abstract-signer":"^5.0.0","@ethersproject/address":"^5.0.0","@ethersproject/bignumber":"^5.0.0","@ethersproject/bytes":"^5.0.0","@ethersproject/contracts":"^5.0.0","@ethersproject/providers":"^5.0.0","@ethersproject/solidity":"^5.0.0","@ethersproject/transactions":"^5.0.0","@ethersproject/wallet":"^5.0.0","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"e2524d95ea9fc999d01901d3bce2f536f6e0bf2f","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.9","_nodeVersion":"14.16.1","_npmVersion":"6.14.12","dist":{"integrity":"sha512-+8srf0vm5Y9SL2hR0UDUldwjHaXCl2S+TcbdeSyoZXacw7T930MOv3VIwZWru32rYc8bbGGsGSBMY8omafVlMw==","shasum":"67ed5408ac882ee7e70504ad344f59e2647da263","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.9.tgz","fileCount":124,"unpackedSize":7153949,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgp4wXCRA9TVsSAnZWagAA7dIP/2SXBvUaXd1A+4j8XS7v\nReeQ+RtHj5oGnKl6wj02j8WSPSS5ZkGGskV5Kpj38RbQ7jY3pVYGSGlPJZnH\nhO8RIWgLzwAm3i69RpDZSnG9AXBFVxNXq0fPVmGW+fU58SwcubziDr5ag0+o\nB6lDah3Ww5d3CB5XOD2iH4vOozM9LPg5X4ghneQUN9s0iw/NCdCIgTEhXO6+\nZrz7rNrwoLNwZtPgqwQIiwnXG+VDoUBu+MbSZ9dBrXAHUR4DqPGY71QMI1lZ\nOQpwWApMLsBEjIdlsKGf2f/kVKKLmBg5zT2BjtTRnbl6uVjHWojh88qTnDM0\ndhhPxP9NEloQrz76+Htv8aPcHPE9+nB2w5wDoZo5PGWdvAnCI2sOxMbjJ5/a\no9VhOKqB4F2Z5ROMFhvnicyE3SrJ3p0OseYp2+6SD8GIySdDurCEPLjnH62m\nT8wwohIxWYPVJ0n8YKeQS+qSi5I0kf6EqgrIpdHMXovFwrJ7BsqNtR6xzbDn\nvNOWhFMT0Ex0Wg3e8Ju2rPGKG1BlIGoRElksv288HmzQB0qu1bdR0+t3FGgy\nLY568Eu4rVxNLCxWChJSX9zzcwBGNjnVovoE6fTqY+XoRlT2PaQU3jweYc+o\nFKXD0FchLwpVF7OEhlOr3NKoS/ekbfYja4GDbhhu0oFAMe0uJGKCI8DaAucK\nfBJE\r\n=BfN2\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDOr3/L7gYwJhEpu/rAfjKvlMZb64Z0HIJO/KoB7DOCGQIhAO4O4c8zAX69/RXVfFg9Z4xbakKf9Nq3rT6/lIk+YR+v"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.9_1621593110840_0.40505326042407863"},"_hasShrinkwrap":false},"0.7.10":{"name":"hardhat-deploy","version":"0.7.10","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.0","@ethersproject/abstract-signer":"^5.0.0","@ethersproject/address":"^5.0.0","@ethersproject/bignumber":"^5.0.0","@ethersproject/bytes":"^5.0.0","@ethersproject/contracts":"^5.0.0","@ethersproject/providers":"^5.0.0","@ethersproject/solidity":"^5.0.0","@ethersproject/transactions":"^5.0.0","@ethersproject/wallet":"^5.0.0","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"c9cbc20b1d5aec868a9a48e47c87d9e6a90ed483","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.10","_nodeVersion":"14.16.1","_npmVersion":"6.14.12","dist":{"integrity":"sha512-+0oiEWy/FgKOEzRNhSWPqSjofVCwtkK3E5x916kbZ5SgFGOjWTFCrWbWUYjzc2GyZgNXuSuRn8mBowHSLF4sVg==","shasum":"2bc94bf36db5f39aa488c6c6569f07d5ca4b410a","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.10.tgz","fileCount":124,"unpackedSize":7155353,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgsCHSCRA9TVsSAnZWagAAa2cQAITwNfeQhF/UQV/3RiO+\nNiexr/lD66vZVvdNYjAFxkAMxi9GI87Rn6elMWYCIymCmH8JzuirDjQjZPoP\nxMvwOMqG4jedBqoF3lrt1WFb3XGGTRh6mY2A3VxsIia1X6xwU+mDX05XhXQx\n/N8LLFefyGvrzQIePvFn2COogBgIPHKzaXyxmRSGR0SClMPHu9MRbYR6HBHT\nNuBarL1aEYIChIQA3xjO+kc5toZbfRlWW73uttTQ8xTvSRS+qpJ2IRSGWdd4\n5a9IyXpXMbV/S37D4xmsJ+haDJxo8Fk/hQGWT6hXPmbedN9/WPFe7d4qFSJo\niafTs9hn/Z3d+xTFNFgx0kjbuDrfENniuQQYpUuSMLWVKJz5WEzq4fD6WG0G\nO1hMJ7/gKB72SgKm1hWNaE48ZfWC2oR+HziawpdYzrdA07tSj973awpaBnaR\nTD1hQYBmMiX5wejNvbAN7yX+KAoKmNYnbNtRLMP5Aef34ydd7e97sLtOvyB/\nLADUHaEhUJFTHEUwcOivFgDyuyMdynF4LVZhHm4LTGM6vLbzYLapShhtPg5c\n1vl3p8cHXAb17NjTqpUs6ekVcHJFf+r5ZoOQzzE0QfSlwwQAT9YXuFOUSKr1\nyu05/5p5M1jUu/dE1YKLan5wvNtC6xFD+c2OrD+oDDK5cICttmrx6uzgj2tZ\nYU2l\r\n=keBf\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCmTbNT7N27+MeRfWKZcH9wfbrkpWLUIlsRa9S7eB6o0QIgGfDi0Np5WbqNzn1RXX7/2BGyrJXZgN0ipe+QeT5xfSY="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.10_1622155729565_0.825887038828234"},"_hasShrinkwrap":false},"0.7.11":{"name":"hardhat-deploy","version":"0.7.11","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.0","@ethersproject/abstract-signer":"^5.0.0","@ethersproject/address":"^5.0.0","@ethersproject/bignumber":"^5.0.0","@ethersproject/bytes":"^5.0.0","@ethersproject/contracts":"^5.0.0","@ethersproject/providers":"^5.0.0","@ethersproject/solidity":"^5.0.0","@ethersproject/transactions":"^5.0.0","@ethersproject/wallet":"^5.0.0","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"e6a40ca43f9251309b5864a6368382d6715b108d","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.7.11","_nodeVersion":"14.16.1","_npmVersion":"6.14.12","dist":{"integrity":"sha512-ONLH3NH8Biuhky44KRFyaINVHM8JI4Ihy1TpntIRZUpIFHlz9h3gieq46H7iwdp6z3CqMsOCChF0riUF3CFpmQ==","shasum":"93f79dfbb529eeda24ac963e23a19064d536be2f","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.7.11.tgz","fileCount":124,"unpackedSize":7156283,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgwhXBCRA9TVsSAnZWagAA/6QP/RkJJjamFP5kPzMEyu93\nkkY0Rl26cFYwIZ0RHYl1uP4GxiUvRfsGF2bYumxgbc2uCDprpdI5j1I/Uf5t\njiTWUFmv9Zpk/EehqHFcH1So8UY008d7vNybBAomXcEzWuz/VcQPPtVu42/r\n6lYpnFg5ECxTjfz8mYmxaTZeW4b6Bx+miAzNndTaHrrg0GfhL9YefKr54WOy\n8PhtyhQsNi5bQJq3JtE71IF2xuwU3QgVMyCMMFa5CfrZhim5/6Z7iKUZ2pKR\nnk9dciO8oePn1bNV6JdLZrM7dTgA9KviZVdatTqTrA4ZUd3RuAtxjRwowa4m\nEq6JelHybQjSLzntvVMniIYmp8pNe9e1GxJtc4XyR5xZDRec+240AQGbu+7M\nyW2fPMuqNofv3nAvM+tw8AYOk2X8Vi/TAe8mL4LtyghRpaa17fqU95NItf5d\nGd+mCY7lC4khi8ykPQQKLTe96iTkvbrW/rz6AojG/d9Mu7aQM/ZX8GK/sCQS\nUx/pOm7nupnlRi8GlUA0Raf5nnvyj14cmUO+34HcOD5m3MFCYl6o10m4hwWM\nlxrO872MdegCauNb2ii6dd3RLqRfw76uIXf2xFJeSgPnORXlq/I+wv0kLsfe\nNZA2ZeuFojQxa9U9XU/pqgauCeCPTDjb0Zt0fC+5XR3Nl5G1ZDSmZnTHb9RN\n0Uv0\r\n=aFWD\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIERysYRv/TnsGEt2s9D2FLYT9eHE0G9GYCeVFEoN4F8+AiBLNe1GByc9sTSUHckZnbdEMO+zdNRQCpqoKaTArEzRLA=="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.7.11_1623332289712_0.9199336389861599"},"_hasShrinkwrap":false},"0.8.0-next.5":{"name":"hardhat-deploy","version":"0.8.0-next.5","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.0","@ethersproject/abstract-signer":"^5.0.0","@ethersproject/address":"^5.0.0","@ethersproject/bignumber":"^5.0.0","@ethersproject/bytes":"^5.0.0","@ethersproject/contracts":"^5.0.0","@ethersproject/providers":"^5.0.0","@ethersproject/solidity":"^5.0.0","@ethersproject/transactions":"^5.0.0","@ethersproject/wallet":"^5.0.0","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"readme":"<h1> hardhat-deploy</h1>\n\n_A [Hardhat](https://hardhat.org) Plugin For Replicable Deployments And Easy Testing_\n\n- [What is it for ?](#what-is-it-for-)\n- [hardhat-deploy in a nutshell](#hardhat-deploy-in-a-nutshell)\n- [Installation](#installation)\n  - [npm install hardhat-deploy](#npm-install-hardhat-deploy)\n  - [TypeScript support](#typescript-support)\n  - [Migrating existing deployment to hardhat-deploy](#migrating-existing-deployment-to-hardhat-deploy)\n- [Hardhat Tasks Available/Updated](#hardhat-tasks-availableupdated)\n  - [1. hardhat deploy](#1-hardhat-deploy)\n    - [**Options**](#options)\n    - [**Flags**](#flags)\n  - [2. hardhat node](#2-hardhat-node)\n    - [**Options**](#options-1)\n    - [**Flags**](#flags-1)\n  - [3. hardhat test](#3-hardhat-test)\n  - [4. hardhat etherscan-verify](#4-hardhat-etherscan-verify)\n  - [5. hardhat sourcify](#5-hardhat-sourcify)\n    - [**Options**](#options-2)\n  - [6. hardhat export](#6-hardhat-export)\n    - [**Options**](#options-3)\n- [Hardhat Environment Extensions](#hardhat-environment-extensions)\n- [Configuration](#configuration)\n  - [**1. namedAccounts (ability to name addresses)**](#1-namedaccounts-ability-to-name-addresses)\n  - [**2. extra hardhat.config networks' options**](#2-extra-hardhatconfig-networks-options)\n  - [**3. extra hardhat.config paths' options**](#3-extra-hardhatconfig-paths-options)\n  - [Importing deployment from other projects (with truffle support)](#importing-deployment-from-other-projects-with-truffle-support)\n  - [Access to Artifacts (non-deployed contract code and abi)](#access-to-artifacts-non-deployed-contract-code-and-abi)\n- [How to Deploy Contracts](#how-to-deploy-contracts)\n  - [The `deploy` Task](#the-deploy-task)\n  - [Deploy Scripts](#deploy-scripts)\n  - [The `deployments` field](#the-deployments-field)\n    - [`deployments.deploy`](#deploymentsdeploy)\n- [Handling contract using libraries](#handling-contract-using-libraries)\n- [Exporting Deployments](#exporting-deployments)\n- [Deploying and Upgrading Proxies](#deploying-and-upgrading-proxies)\n- [Testing Deployed Contracts](#testing-deployed-contracts)\n  - [Creating Fixtures](#creating-fixtures)\n- [More Information On Hardhat Tasks](#more-information-on-hardhat-tasks)\n  - [**1. node task**](#1-node-task)\n  - [**2. test task**](#2-test-task)\n  - [**3. run task**](#3-run-task)\n  - [**4. console task**](#4-console-task)\n- [Deploy Scripts: Tags And Dependencies](#deploy-scripts-tags-and-dependencies)\n- [Builtin-In Support For Diamonds (EIP2535)](#builtin-in-support-for-diamonds-eip2535)\n- [Testing Deployed Contracts](#testing-deployed-contracts)\n  - [Creating Fixtures](#creating-fixtures)\n- [Deploy Scripts: Tags And Dependencies](#deploy-scripts-tags-and-dependencies)\n\n## What is it for ?\n\nThis [hardhat](https://hardhat.dev) plugin adds a mechanism to deploy contracts to any network, keeping track of them and replicating the same environment for testing.\n\nIt also adds a mechanism to associate names to addresses, so test and deployment scripts can be reconfigured by simply changing the address a name points to, allowing different configurations per network. This also results in much clearer tests and deployment scripts (no more `accounts[0]` in your code).\n\nThis plugin contains a lot more features too, all geared toward a better developer experience :\n\n- chain configuration export\n- listing deployed contracts' addresses and their abis (useful for webapps)\n- library linking at time of deployment.\n- deterministic deployment across networks.\n- support for specific deploy script per network (L1 vs L2 for example)\n- deployment dependency system (allowing you to only deploy what is needed).\n- deployment retrying (by saving pending tx): so you can feel confident when making a deployment that you can always recover.\n- deployments as test fixture using `evm_snapshot` to speed up testing.\n- ability to create your own test fixture that automatically benefits from `evm_snapshot`'s tests speed-up boost\n- combined with [hardhat-deploy-ethers](https://github.com/wighawag/hardhat-deploy-ethers) it has the ability to get ethers contract instance by name (like `await ethers.getContract(\"ContractName\")`).\n- importing artifact from external sources (like npm packages), including truffle support.\n- importing deployments from external sources (like npm packages), including truffle support.\n- ability to log information in `deploy` mode only (while in test the console remains clean).\n- contains helpers to read and execute transaction on deployed contract referring to them by name.\n- These helpers contains options to auto mine on dev network (to speed up test deployments).\n- save metadata of deployed contract so they can always be fully verified, via [sourcify](https://sourcify.dev) or [etherscan](https://etherscan.io).\n- ability to submit contract source to etherscan and sourcify for verification at any time. (Because **hardhat-deploy** will save all the necessary info, it can be executed at any time.)\n- support harhdat's fork feature so deployment can be accessed even when run through fork.\n- named accounts are automatically impersonnated too, so you can perform tx as if you had their private.\n- proxy deployment with ability to upgrade them transparently, only if code changes.\n- this include support for [openzeppelin](https://openzeppelin.com) transparent proxies\n- diamond deployment with facets, allowing you to focus on what the new version will be. It will generate the diamondCut necessary to reach the new state.\n- watch and deploy: **hardhat-deploy** can watch both your deploy script and contract code and redeploy on changes.\n- HCR (Hot Contract Replacement): the watch feature combined with proxy or diamond, gives you an experience akin to frontend Hot Module Replacement: once your contract changes, the deployment is executed and your contract retains the same address and same state, allowing you to tweak your contracts while debugging your front-end.\n\n## hardhat-deploy in a nutshell\n\nBefore going into the details, here is a very simple summary of the basic feature of **hardhat-deploy**.\n\n**hardhat-deploy** allows you to write [`deploy scripts`](#deploy-scripts) in the `deploy` folder. Each of these files that look as follows will be executed in turn when you execute the following task: `hardhat --network <networkName> deploy`\n\n```js\n// deploy/00_deploy_my_contract.js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('MyContract', {\n    from: deployer,\n    args: ['Hello'],\n    log: true,\n  });\n};\nmodule.exports.tags = ['MyContract'];\n```\n\nFurthermore you can also ensure these scripts are executed in test too by calling `await deployments.fixture(['MyContract'])` in your test.\nThis is optimized, so if multiple tests use the same contract, the deployment will be executed once and each test will start with the exact same state.\n\nThis is a huge benefit for testing since you are not required to replicate the deployment procedure in your tests. The tag feature (as seen in the script above) and [dependencies](#deploy-scripts-tags-and-dependencies) will also make your life easier when writing complex deployment procedures.\n\nYou can even group deploy scripts in different sub folder and ensure they are executed in their logical order.\n\nFurthermore hardhat-deploy can also support a multi-chain settings like L1, L2 with multiple deploy folder specific to each network.\n\nThere is a tutorial covering the basics here : https://github.com/wighawag/tutorial-hardhat-deploy\n\n## Installation\n\n### npm install hardhat-deploy\n\n```bash\nnpm install -D hardhat-deploy\n```\n\nAnd add the following statement to your `hardhat.config.js`:\n\n```js\nrequire('hardhat-deploy');\n```\n\nif you use `ethers.js` we recommend you also install `hardhat-deploy-ethers` which add extra features to access deployments as ethers contract.\n\nSince `hardhat-deploy-ethers` is a fork of `@nomiclabs/hardhat-ethers` and that other plugin might have an hardcoded dependency on `@nomiclabs/hardhat-ethers` the best way to install `hardhat-deploy-ethers` and ensure compatibility is the following:\n\n```bash\nnpm install --save-dev  @nomiclabs/hardhat-ethers@npm:hardhat-deploy-ethers ethers\n```\n\nWhich means you then need to do `require(\"@nomiclabs/hardhat-ethers\")` instead of `require(\"hardhat-deploy-ethers\")` in your `hardhat.config.js` file.\n\nMore details on `hardhat-deploy-ethers` repo : https://github.com/wighawag/hardhat-deploy-ethers#readme\n\n### TypeScript support\n\nWith hardhat the tsconfig.json is optional.\n\nBut if you add folders to the `include` field in `tsconfig.json`, you ll also need to include `hardhat.config.ts` like :\n\n`include\": [\"./hardhat.config.ts\", \"./scripts\", \"./deploy\", \"./test\"]`\n\nfor deploy script (see below) you can write them this way to benefit from typing :\n\n```ts\nimport {HardhatRuntimeEnvironment} from 'hardhat/types';\nimport {DeployFunction} from 'hardhat-deploy/types';\n\nconst func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {\n  // code here\n};\nexport default func;\n```\n\nSee a template that uses **hardhat-deploy** here : https://github.com/wighawag/template-ethereum-contracts\n\nThis repo has also some examples branch that exemplify specific features, like the forking testing here : https://github.com/wighawag/template-ethereum-contracts/tree/examples/fork-test\n\n### Migrating existing deployment to hardhat-deploy\n\n(Only needed for existing project that already deployed contracts and has the deployment information available **(at minimum, address and abi)**)\n\nYou might want to switch your current deployment process to use **hardhat-deploy**. In that case you probably have some deployments saved elsewhere.\n\nIn order to port them to **hardhat-deploy**, you'll need to create one `.json` file per contract in the `deployments/<network>` folder (configurable via [paths config](#extra-paths-config)).\n\nThe network folder is simply the hardhat network name (as configured in hardhat.config.js) (accessible at runtime via `hre.network.name`).\nSuch folder need to have a file named `.chainId` containing the chainId as decimal.\n\nFor example for network named \"rinkeby\" (for the corresponding network) the file `deployments/rinkeby/.chainId` would be\n\n```\n4\n```\n\nNote, prior to hardhat 0.6 the chainId was appended to the folder name (expect for some known network name). This has changed and upgrading to 0.6 will require you to change the folder name and add the '.chainId' file.\n\nEach contract file must follow this type (as defined in [types.ts](types.ts)) :\n\n```ts\nexport interface Deployment {\n  address: Address;\n  abi: ABI;\n  receipt?: Receipt;\n  transactionHash?: string;\n  history?: Deployment[];\n  implementation?: string;\n  args?: any[];\n  linkedData?: any;\n  solcInputHash?: string;\n  metadata?: string;\n  bytecode?: string;\n  deployedBytecode?: string;\n  libraries?: Libraries;\n  userdoc?: any;\n  devdoc?: any;\n  methodIdentifiers?: any;\n  diamondCut?: FacetCut[];\n  facets?: Facet[];\n  storageLayout?: any;\n  gasEstimates?: any;\n}\n```\n\nAs you can see, only abi and address are mandatory. But having the other fields allow more feature. For example, metadata and args allow you to benefit from contract code verification.\n\nFor Receipt, the following type is expected:\n\n```ts\nexport type Receipt = {\n  from: string;\n  transactionHash: string;\n  blockHash: string;\n  blockNumber: number;\n  transactionIndex: number;\n  cumulativeGasUsed: string;\n  gasUsed: string;\n  contractAddress?: string;\n  to?: string;\n  logs?: Log[];\n  events?: any[];\n  logsBloom?: string;\n  byzantium?: boolean;\n  status?: number;\n  confirmations?: number;\n};\n```\n\nHere is an example:\n\nLet sey you have:\n\n- 2 Contract named Greeter and Registry deployed on rinkeby\n- 1 contract named Greeter on mainnet\n- 2 Contract named Greeter and Registry deployed on a network named rinkeby2\n\nYou would get the following folder structure:\n\n```\ndeployments/\n  mainnet/\n    .chainId\n    Greeter.json\n  rinkeby/\n    .chainId\n    Greeter.json\n    Registry.json\n  rinkeby2/\n    .chainId\n    Greeter.json\n    Registry.json\n```\n\nThe reason why **hardhat-deploy** save chainId in the `.chainId` file is both for\n\n- safety: so that if you were to change the network name to point to a different chain, it would not attempt to read the wrong folder and assume that a contract has been deployed while it has not.\n- ability to know the chainId without requring to be connected to a node (and so not dependent on hardhat.config.js settings). Useful for `export` task.\n\n---\n\n## Hardhat Tasks Available/Updated\n\nhardhat deploy add several task to hardhat. It also modify existing one, adding new options and new behavior. All of these are described here:\n\n---\n\n### 1. hardhat deploy\n\n---\n\nThis plugin adds the _deploy_ task to Hardhat.\n\nThis task will execute the scripts in the `deploy` folder and save the contract deployments to disk. These deployments are supposed to be saved for example in a git repository. This way they can be accessed later. But you are free to save them elsewhere and get them back via your mechanism of choice.\n\nWith the deployment saved, it allows you to deploy a contract only if changes were made.\n\nDeploy scripts (also called Deploy functions) can also perform aribtrary logic.\n\nFor further details on how to use it and write deploy script, see [section](#deploy-scripts) below.\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployments, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice (in wei) to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--reset`: This flag resets the deployments from scratch. Previously deployed contract are not considered and deleted from disk.\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n---\n\n### 2. hardhat node\n\n---\n\nThis plugin modify the _node_ task so that it also execute the deployment script before exposing the server http RPC interface\n\nIt add similar options than the `deploy` task :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n`--forkDeployments <networkName>`: defaults to `localhost`; this option allows you to specify the network to fetch the deployment from when running in fork mode. This is necessary as hardhat fork feature does not track the fork's network: <https://github.com/nomiclabs/hardhat/issues/1164>\n\n`--asNetwork <networkName`: default to `localhost` (or the value specified by `--forkDeployments` if any), this option allows you to specify the network name to be used for **hardhat-deploy** functionality, like which folder the resulting deployment should be saved to.\n\n#### **Flags**\n\n`--noReset`: This flag prevent the reseting of the existing deployments. This is usually not desired when running the `node` task as a network is created from scratch and previous deployemnt are irrelevant.\n\n`--show-accounts`: this flag will output the account private keys\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n`--no-deploy` that discard all other options to revert to normal `hardhat node` behavior without any deployment being performed.\n\nNote that the deployments are saved as if the network name is `localhost`. This is because `hardhat node` is expected to be used as localhost: You can for example execute `hardhat --network localhost console` after `node` is running. Doing `builder --network hardhat console` would indeed not do anything useful. It still take the configuration from `hardhat` in the hardhat.config.js file though.\n\n---\n\n### 3. hardhat test\n\n---\n\nThis plugin adds a flag argument `--deploy-fixture` to the _test_ task that runs the global deployments fixture before the tests and snapshots it. This will generaly speed up the tests.\n\n---\n\n### 4. hardhat etherscan-verify\n\n---\n\nThis plugin adds the _etherscan-verify_ task to Hardhat.\n\nThis task will submit the contract source and other info of all deployed contracts to allow etherscan to verify and record the sources.\n\nInstead of using the full solc input, this task will first attempt to send the minimal sources from the metadata.\nBut Etherscan sometime fails due to a bug in solidity compiler (<https://github.com/ethereum/solidity/issues/9573>). As such this task can fallback on full solc input (see option --solc-input). Note that if your contract was deployed with a previous version of **hardhat-deploy**, it might not contains the full information. The issue seems to be fully resolved since solc version 0.8.\n\nThis task will also attempt to automatically find the SPDX license in the source.\n\nTo execute that task, you need to specifiy the network to run against :\n\n```bash\nhardhat --network mainnet etherscan-verify --api-key <apikey>\n```\n\n#### **Options**\n\n`--api-key <api key>`: let you specify your etherscan api key. Alternatively, you can provide it via the env variable `ETHERSCAN_API_KEY`\n\n`--license <SPDX license id>`: SPDX license (useful if SPDX is not listed in the sources), need to be supported by etherscan: https://etherscan.io/contract-license-types\n\n`--force-license`: if set, will force the use of the license specified by --license option, ignoring the one in the source (useful for license not supported by etherscan)\n\n`--solc-input`: fallback on solc-input id needed (useful when etherscan fails on the minimum sources, see https://github.com/ethereum/solidity/issues/9573)\n\n`--sleep`: sleep 500ms between each verification, so API rate limit is not exceeded\n\n---\n\n### 5. hardhat sourcify\n\n---\n\nThis plugin adds the _sourcify_ task to Hardhat.\n\nSimilar to `hardhat etherscan-verify` this task will submit the contract source and other info of all deployed contracts to sourcify.\n\n```bash\nhardhat --network mainnet sourcify\n```\n\nLater this task might instead pin the metadata to ipfs, so sourcify can automatically verify them.\n\n#### **Options**\n\n`--endpoint <endpoint>`: specify the sourcify endpoint, default to https://sourcify.dev/server/\n\n`--write-failing-metadata`: if set and the sourcify task fails to verify, the metadata file will be written to disk, so you can more easily figure out what has gone wrong.\n\n---\n\n### 6. hardhat export\n\n---\n\nThis plugin adds the _export_ task to Hardhat.\n\nThis task will export the contract deployed (saved in `deployments` folder) to a file with a simple format containing only contract addresses and abi, useful for web apps.\n\nOne of the following options need to be set for this task to have any effects :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\nThis last option has some limitations, when combined with the use of external deployments (see [Configuration](#configuration)). If such external deployments were using older version of **hardhat-deploy** or truffle, the chainId might be missing. In order for these to be exported, the hardhat network config need to explicity state the chainId in the `networks` config of `hardhat.config.js`.\n\n---\n\n---\n\n## Hardhat Environment Extensions\n\nThis plugin extends the Hardhat Runtime Environment by adding 4 fields:\n\n- `getNamedAccounts: () => Promise<{ [name: string]: string }>`: a function returning an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [Configuration](#configuration)).\n\n- `getUnnamedAccounts: () => Promise<string[]}>`: accounts which has no names, useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`: contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId(): Promise<string>`: offer an easy way to fetch the current chainId.\n\n---\n\n---\n\n## Configuration\n\n---\n\n### **1. namedAccounts (ability to name addresses)**\n\n---\n\nThis plugin extends the `HardhatConfig`'s object with an optional `namedAccounts` field.\n\n`namedAccounts` allows you to associate names to addresses and have them configured per chain.\nThis allows you to have meaningful names in your tests while the addresses match to multi sig in real network for example.\n\n```js\n{\n    namedAccounts: {\n        deployer: {\n            default: 0, // here this will by default take the first account as deployer\n            1: 0, // similarly on mainnet it will take the first account as deployer. Note though that depending on how hardhat network are configured, the account 0 on one network can be different than on another\n            4: '0xA296a3d5F026953e17F472B497eC29a5631FB51B', // but for rinkeby it will be a specific address\n            \"goerli\": '0x84b9514E013710b9dD0811c9Fe46b837a4A0d8E0', //it can also specify a specific netwotk name (specified in hardhat.config.js)\n        },\n        feeCollector:{\n            default: 1, // here this will by default take the second account as feeCollector (so in the test this will be a different account than the deployer)\n            1: '0xa5610E1f289DbDe94F3428A9df22E8B518f65751', // on the mainnet the feeCollector could be a multi sig\n            4: '0xa250ac77360d4e837a13628bC828a2aDf7BabfB3', // on rinkeby it could be another account\n        }\n    }\n}\n```\n\n<!-- You can also specify addresses with the `ledger://` prefix. In which case the account fetched will still be the corresponding address, but behind the scene, the transaction will be created via the hardware waller. Currently the feature is not working very well though and better support is needed. -->\n\n---\n\n### **2. extra hardhat.config networks' options**\n\n---\n\n**hardhat-deploy** add 4 new fields to `networks` configuration\n\n`live` : this is not used internally but is useful to perform action on a network whether it is a live network (rinkeby, mainnet, etc) or a temporary one (localhost, hardhat). The default is true (except for localhost and hardhat where the default is false).\n\n`saveDeployments`: this tell whether **hardhat-deploy** should save the deployments to disk or not. Default to true, except for the hardhat network.\n\n`tags`: network can have tags to represent them. The config is an array and at runtime the hre.network.tags is an object whose fields (the tags) are set to true.\n\nThis is useful to conidtionaly operate on network based on their use case.\n\nExample:\n\n```js\n{\n  networks: {\n    localhost: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"local\"]\n    },\n    hardhat: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"test\", \"local\"]\n    },\n    rinkeby: {\n      live: true,\n      saveDeployments: true,\n      tags: [\"staging\"]\n    }\n  }\n}\n```\n\n`deploy`: the deploy field override the paths.deploy option and let you define a set of folder containing the deploy scripts to be executed for this network.\n\nYou can thus have one network that will be executing L1 deployment and other L2 deployments, etc...\n\n---\n\n### **3. extra hardhat.config paths' options**\n\n---\n\nIt also adds fields to `HardhatConfig`'s `ProjectPaths` object.\n\nHere is an example showing the default values :\n\n```js\n{\n    paths: {\n        deploy: 'deploy',\n        deployments: 'deployments',\n        imports: 'imports'\n    }\n}\n```\n\nThe deploy folder is expected to contains the deploy script that are executed upon invocation of `hardhat deploy` or `hardhat node`.\nIt can also be an array of folder path.\n\nThe deployment folder will contains the resulting deployments (contract addresses along their abi, bytecode, metadata...). One folder per network and one file per contract.\n\nThe imports folder is expected to contains artifacts that were pre-compiled. Useful if you want to upgrade to a new solidity version but want to keep using previously compiled contracts. The artifact is the same format as normal hardhat artifact, so you can easily copy them over, before switching to a new compiler version.\n\n---\n\n### Importing deployment from other projects (with truffle support)\n\nIt also add the `external` field to `HardhatConfig`\n\nSuch fiels allows to specify paths for external artifacts or deployments.\n\nThe external object has 2 fields:\n\n```js\n{\n    external: {\n        contracts: [\n          {\n            artifacts: \"node_modules/@cartesi/arbitration/export/artifacts\",\n            deploy: \"node_modules/@cartesi/arbitration/export/deploy\"\n          },\n          {\n            artifacts: \"node_modules/someotherpackage/artifacts\",\n          }\n        ],\n        deployments: {\n          rinkeby: [\"node_modules/@cartesi/arbitration/build/contracts\"],\n        },\n    }\n}\n```\n\nThe contract field specify an array of object which itself have 2 fields.\n\n- artifacts: (mandatory) it is a path to an artifact folder. This support both hardhat and truffle artifacts.\n- deploy: (optional) it specifies a path to a folder where reside deploy script. The deploy script have only access to the artifact specified in the artifacts field. This allow project to share their deployment procedure. A boon for developer aiming at integrating it as they can get the contracts to be deployed for testing locally.\n\nThe deployments fields specify an object whose field name are the hardhat network and the value is an array of path to look for deployments. It supports both **hardhat-deploy** and truffle formats.\n\n---\n\n### Access to Artifacts (non-deployed contract code and abi)\n\nyou can access contract artifact via `getArtifact` function :\n\n```js\nconst {deployments} = require('hardhat');\nconst artifact = await deployments.getArtifact(artifactName);\n```\n\nWith the `hardhat-deploy-ethers` plugin you can get your ethers contract via :\n\n```js\nconst {deployments, ethers} = require('hardhat');\nconst factory = await ethers.getContractFactory(artifactName);\n```\n\nNote that the artifact file need to be either in `artifacts` folder that hardhat generate on compilation or in the `imports` folder where you can store contracts compiled elsewhere. They can also be present in the folder specified in `external.artifacts` see [Importing deployment from other projects](#importing-deployment-from-other-projects-truffle-support-too)\n\n---\n\n---\n\n## How to Deploy Contracts\n\n---\n\n### The `deploy` Task\n\n`hardhat --network <networkName> deploy [options and flags]`\n\nThis is a new task that the plugin adds. As the name suggests it deploys contracts.\nTo be exact it will look for files in the folder `deploy` or whatever was configured in `paths.deploy`, see [paths config](#extra-paths-config)\n\nIt will scan for files in alphabetical order and execute them in turn.\n\n- it will `require` each of these files and execute the exported function with the HRE as argument\n\nNote that running `hardhat deploy` without specifying a network will use the default network. If the default network is hardhat (the default's default) then nothing will happen as a result but this can be used to ensure the deployment is without issues.\n\nTo specified the network, you can use the builtin hardhat argument `--network <network name>` or set the env variable `HARDHAT_NETWORK`\n\n---\n\n### Deploy Scripts\n\nThe deploy scripts need to be of the following type :\n\n```js\nexport interface DeployFunction {\n  (env: HardhatRuntimeEnvironment): Promise<void | boolean>;\n  skip?: (env: HardhatRuntimeEnvironment) => Promise<boolean>;\n  tags?: string[];\n  dependencies?: string[];\n  runAtTheEnd?: boolean;\n  id?: string;\n}\n```\n\nThe skip function can be used to skip executing the script under whatever condition. It simply need to resolve a promise to true.\n\nThe tags is a list of string that when the _deploy_ task is executed with, the script will be executed (unless it skips). In other word if the deploy task is executed with a tag that does not belong to that script, that script will not be executed unless it is a dependency of a script that does get executed.\n\nThe dependencies is a list of tag that will be executed if that script is executed. So if the script is executed, every script whose tag match any of the dependency will be executed first.\n\nThe `runAtTheEnd` is a boolean that if set to true, will queue that script to be executed after all other scripts are executed.\n\nThese set of fields allow more flexibility to organize the scripts. You are not limited to alphabetical order.\n\nFinally the function can return true if it wishes to never be executed again. This can be usfeul to emulate migration scripts that are meant to be executed only once. Once such script return true (async), the `id` field is used so to track execution and if that field is not present when the script return true, it will fails.\n\nIn any case, as a general advice every deploy function should be idempotent. This is so they can always recover from failure or pending transaction.\n\nThis is why the `hre.deployments.deploy` function will by default only deploy if the contract code has changed, making it easier to write idempotent script.\n\nAn example of a deploy script :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  // the following will only deploy \"GenericMetaTxProcessor\" if the contract was never deployed or if the code changed since last deployment\n  await deploy('GenericMetaTxProcessor', {\n    from: deployer,\n    gasLimit: 4000000,\n    args: [],\n  });\n};\n```\n\nAs you can see the HRE passed in has 4 new fields :\n\n- `getNamedAccounts` is a function that returns a promise to an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [`namedAccounts`](#namedaccounts)).\n\n- `getUnnamedAccounts`: function that return a promise to an array of accounts (which were not used in `getNamedAccounts`), useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`, which contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId` which return a promise for the chainId\n\nThe deploynments field contains the `deploy` function taht allow you to deploy contract and save them. It contains a lot more functions though :\n\n---\n\n### The `deployments` field\n\nThe deployments field contains several helpers function to deploy contract but also execute transaction.\n\n```ts\nexport interface DeploymentsExtension {\n  deploy(name: string, options: DeployOptions): Promise<DeployResult>; // deploy a contract\n  diamond: {\n    // deploy diamond based contract (see section below)\n    deploy(name: string, options: DiamondOptions): Promise<DeployResult>;\n  };\n  deterministic( // return the determinsitic address as well as a function to deploy the contract, can pass the `salt` field in the option to use different salt\n    name: string,\n    options: Create2DeployOptions\n  ): Promise<{\n    address: Address;\n    deploy(): Promise<DeployResult>;\n  }>;\n  fetchIfDifferent( // return true if new compiled code is different than deployed contract\n    name: string,\n    options: DeployOptions\n  ): Promise<{differences: boolean; address?: string}>;\n  save(name: string, deployment: DeploymentSubmission): Promise<void>; // low level save of deployment\n  get(name: string): Promise<Deployment>; // fetch a deployment by name, throw if not existing\n  getOrNull(name: string): Promise<Deployment | null>; // fetch deployment by name, return null if not existing\n  getDeploymentsFromAddress(address: string): Promise<Deployment[]>;\n  all(): Promise<{[name: string]: Deployment}>; // return all deployments\n  getArtifact(name: string): Promise<Artifact>; // return a hardhat artifact (compiled contract without deployment)\n  getExtendedArtifact(name: string): Promise<ExtendedArtifact>; // return a extended artifact (with more info) (compiled contract without deployment)\n  run( // execute deployment scripts\n    tags?: string | string[],\n    options?: {\n      resetMemory?: boolean;\n      deletePreviousDeployments?: boolean;\n      writeDeploymentsToFiles?: boolean;\n      export?: string;\n      exportAll?: string;\n    }\n  ): Promise<{[name: string]: Deployment}>;\n  fixture( // execute deployment as fixture for test // use evm_snapshot to revert back\n    tags?: string | string[],\n    options?: {fallbackToGlobal?: boolean; keepExistingDeployments?: boolean}\n  ): Promise<{[name: string]: Deployment}>;\n  createFixture<T, O>( // execute a function as fixture using evm_snaphost to revert back each time\n    func: FixtureFunc<T, O>,\n    id?: string\n  ): (options?: O) => Promise<T>;\n  log(...args: any[]): void; // log data only ig log enabled (disabled in test fixture)\n\n  execute( // execute function call on contract\n    name: string,\n    options: TxOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<Receipt>;\n  rawTx(tx: SimpleTx): Promise<Receipt>; // execute a simple transaction\n  catchUnknownSigner( // you can wrap other function with this function and it will catch failure due to missing signer with the details of the tx to be executed\n    action: Promise<any> | (() => Promise<any>),\n    options?: {log?: boolean}\n  ): Promise<null | {\n    from: string;\n    to?: string;\n    value?: string;\n    data?: string;\n  }>;\n  read( // make a read-only call to a contract\n    name: string,\n    options: CallOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<any>;\n  read(name: string, methodName: string, ...args: any[]): Promise<any>;\n  // rawCall(to: Address, data: string): Promise<any>; // TODO ?\n}\n```\n\n---\n\n#### `deployments.deploy`\n\n---\n\nThe deploy function as mentioned allow you to deploy a contract and save it under a specific name.\n\nThe deploy function expect 2 parameters: one for the name and one for the options\n\nSee below the full list of fields that the option parameter allows and requires:\n\n```ts\nexport interface DeployOptions = {\n  from: string; // address (or private key) that will perform the transaction. you can use `getNamedAccounts` to retrived the address you want by name.\n  contract?: // this is an optional field. If not specified it defaults to the contract with the same name as the first parameter\n    | string // this field can be either a string for the name of the contract\n    | { // or abi and bytecode\n        abi: ABI;\n        bytecode: string;\n        deployedBytecode?: string;\n      };\n  args?: any[]; // the list of argument for the constructor (or the upgrade function in case of proxy)\n  skipIfAlreadyDeployed?: boolean; // if set it to true, will not attempt to deploy even if the contract deployed under the same name is different\n  log?: boolean; // if true, it will log the result of the deployment (tx hash, address and gas used)\n  linkedData?: any; // This allow to associate any JSON data to the deployment. Useful for merkle tree data for example\n  libraries?: { [libraryName: string]: Address }; // This let you associate libraries to the deployed contract\n  proxy?: boolean | string | ProxyOptions; // This options allow to consider your contract as a proxy (see below for more details)\n\n  // here some common tx options :\n  gasLimit?: string | number | BigNumber;\n  gasPrice?: string | BigNumber;\n  value?: string | BigNumber;\n  nonce?: string | number | BigNumber;\n\n  estimatedGasLimit?: string | number | BigNumber; // to speed up the estimation, it is possible to provide an upper gasLimit\n  estimateGasExtra?: string | number | BigNumber; // this option allow you to add a gas buffer on top of the estimation\n\n  autoMine?: boolean; // this force a evm_mine to be executed. this is useful to speed deployment on test network that allow to specify a block delay (ganache for example). This option basically skip the delay by force mining.\n  deterministicDeployment? boolean | string; // if true, it will deploy the contract at a deterministic address based on bytecode and constuctor arguments. The address will be the same across all network. It use create2 opcode for that, if it is a string, the string will be used as the salt.\n};\n```\n\n---\n\n---\n\n## Handling contract using libraries\n\nIn the deploy function, one of the `DeployOptions` that can be passed into the function is the `libraries` field.\n\nFirst, deploy the library using the `deploy` function, then when we deploy a contract that needs the the linked library, we can pass the deployed library name and address in as an argument to the `libraries` object.\n\n```js\nconst exampleLibrary = await deploy(\"ExampleLibary\", {\n    from: <deployer>\n});\n\n```\n\nExampleLibrary is now deployed to whatever network is in the context of the environment.\n\nFor example, if we are deploying on Rinkeby, this library will get deployed on rinkeby, and the `exampleLibrary` variable will be a deployment object that contains the abi as well as the deployed address for the contract.\n\nNow that the library is deployed, we can link it in our next deployed contract.\n\n```js\nconst example = await deploy(\"Example\", {\n    from: <deployer>\n    args: [\"This is an example string argument in the constructor for the 'Example' contract\"],\n    libraries: {\n        ExampleLibrary: exampleLibrary.address\n    }\n});\n\n```\n\nThis `libraries` object takes the name of the library, and its deployed address on the network. Multiple libraries can be passed into the `libraries` object.\n\n---\n\n---\n\n## Exporting Deployments\n\nApart from deployments saved in the `deployments` folder which contains all information available about the contract (compile time data + deployment data), `hardhat-deploy` allows you to export lightweight files.\n\nThese can be used for example to power your frontend with contract's address and abi.\n\nThis come into 2 flavors.\n\nThe first one is exported via the `--export <file>` option and follow the following format :\n\n```js\nexport interface Export {\n  chainId: string;\n  name: string;\n  contracts: {[name: string]: ContractExport};\n}\n```\n\nwhere name is the name of the network configuration chosen (see hardhat option `--network`)\n\nThe second one is exported via the `--export-all <file>` option and follow the following format :\n\n```js\nexport type MultiExport = {\n  [chainId: string]: {[name: string]: Export},\n};\n```\n\nAs you see the second format include the previous. While in most case you'll need the single export where your application will support only one network, there are case where your app would want to support multiple network at nonce. This second format allow for that.\n\nFurthermore as hardhat support multiple network configuration for the same network (rinkeby, mainnet...), the export-all format will contains each of them grouped by their chainId.\n\n---\n\n---\n\n## Deploying and Upgrading Proxies\n\nAs mentioned above, the deploy function can also deploy a contract through a proxy. It can be done without modification of the contract as long as it does not have a constructor (or constructor with zero arguments).\n\nThe default Proxy is both ERC-1967 and ERC-173 Compliant, but other proxy can be specified, like openzeppelin transparent proxies.\n\nCode for the default Proxy can be found [here](solc_0.7/proxy/EIP173Proxy.sol)\n\nTo perform such proxy deployment, you just need to invoke the deploy function with the following options : `{..., proxy: true}`\n\nSee example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: true,\n  });\n};\n```\n\nYou can also set it to `proxy: \"<upgradeMethodName>\"` in which case the function `<upgradeMethodName>` will be executed upon upgrade.\nthe `args` field will be then used for that function instead of the contructor. It is also possible to then have a constructor with the same arguments and have the proxy be disabled. It can be useful if you want to have your contract as upgradeable in a test network but be non-upgradeable on the mainnet.\n\nSee example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: 'postUpgrade',\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nThe proxy option can also be an object which can set the specific owner that the proxy is going to be managed by.\n\nSee example:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: {\n      owner: greeterOwner,\n      methodName: 'postUpgrade',\n    },\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nNote that for the second invokation, this deployment will fails to upgrade the proxy as the `from` which is `deployer` is not the same as the proxy's owner : `greeterOwner`\n\nTo make it work, you have to create a new script that have for `from` field: `greeterOwner`. If such value is a a multi sig or an address not registered as part of hardhat signers, the tx will not be executed but instead an error will be throw. That error can be caught up via deployments.catchUnknwonSigner function so you get the necessary tx details to execute it elsewhere.\n\nThe full proxy options is as follow:\n\n```ts\nexport interface ProxyOptions {\n  owner?: Address; // this set the owner of the proxy. further upgrade will need to be executed from that owner\n  methodName?: string; // method to be executed when the implementation is modified.\n  proxyContract?: string | ArtifactData; // default to \"EIP173Proxy\". See below for more details\n  viaAdminContract?: // allow to specify a contract that act as a middle man to perform upgrades. Useful and Recommended for Transparent Proxies\n  | string\n    | {\n        name: string;\n        artifact?: string | ArtifactData;\n      };\n}\n```\n\nThe `proxyContract` field allow you to specify your own Proxy contract. If it is a string, it will first attemp to get an artifact with that name. If not found it will fallback on the following if\n\nit matches:\n\n- `EIP173Proxy`: use the default Proxy that is EIP-173 compliant\n\n- `EIP173ProxyWithReceive`: Same as above except that the proxy contains a receive hook to accept empty ETH payment\n\n- `OpenZeppelinTransparentProxy`: Use Openzeppelin Transparent Proxy (slightly modified as openzeppelin's one hardcode the msg.sender as first owner, see code [here](solc_0.7\\openzeppelin\\proxy\\TransparentUpgradeableProxy.sol))\n  When this option is chosen, the `DefaultProxyAdmin` is also used as admin since Transparent Proxy kind of need an intermediarry contract for administration. This can be configired via the `viaAdminContract` option\n\n- `OptimizedTransparentProxy`: This contract is similar to above, except that it is optimized to not require storage read for the admin on every call.\n\n## Builtin-In Support For Diamonds (EIP2535)\n\nThe deployments field also expose the diamond field: `hre.deployments.diamond` that let you deploy [Diamonds](https://eips.ethereum.org/EIPS/eip-2535) in an easy way.\n\nInstead of specifying the facets to cut out or cut in, which the diamond contract expects, you specify the facets you want to end up having on the deployed contract.\n\n`diamond.deploy` expect the facet as names. The names represent contract to be deployed as facet. In future version you ll be able to specify deployed contract or artifact object as facet.\n\nTo deploy a contract with 3 facet you can do as follow :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: deployer,\n    owner: diamondAdmin,\n    facets: ['Facet1', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nif you then later execute the following script:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: diamondAdmin, // this need to be the diamondAdmin for upgrade\n    owner: diamondAdmin,\n    facets: ['NewFacet', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nThen the NewFacet will be deployed automatically if needed and then the diamondCut will cut Facet1 out and add NewFacet.\n\nNote that if the code for Facet2 and Facet3 changes, they will also be redeployed automatically and the diamondCuts will replace the existing facets with these new ones.\n\nNote that The Diamond contract's code is part of hardhat-deploy and contains 3 built-in facet that can be removed manually if desired.\nThese facets are used for ownership, diamondCut and diamond loupe.\n\nThe implementation is the [reference implementation by Nick Mudge](https://github.com/mudgen/diamond-3)\n\nLike normal proxies you can also execute a function at the time of an upgrade.\n\nThis is done by specifying the execute field in the diamond deploy options :\n\n```js\ndiamond.deploy('ADiamondContract', {\n  from: deployer,\n  owner: diamondAdmin,\n  facets: ['NewFacet', 'Facet2', 'Facet3'],\n  execute: {\n    methodName: 'postUpgrade',\n    args: ['one', 2, '0x3'],\n  },\n});\n```\n\nSince the diamond standard has no builtin mechanism to make the deployment of Diamond with function execution, the Diamond when deployed is actually deployed through a special contract, the `Diamantaire` (see code [here](solc_0.7/diamond/Diamantaire.sol)) that act as factory to build Diamond. It uses deterministic deployment for that so, it is transparently managed by hardhat-deploy. It also embed the implementation of the builtin facet, removing the need to have different instances of each live.\n\n<!-- The Diamantaire also support the deterministic deployment of Diamonds.\nAn extra field can be passed to the Diamond deployment options : `deterministicSalt`. It has to be a non-zero 32bytes string (in hex format).\nNote that if you want to deploy 2 diamonds with same owner, you'll need 2 different deterministicSalt for them to be 2 separate contracts. -->\n\n## Testing Deployed Contracts\n\nYou can continue using the usual test task :\n\n`hardhat test`\n\nTests can then use the `hre.deployments.fixture` function to run the deployment for the test and snapshot it so that tests don't need to perform all the deployments transaction every time, they simply reuse the snapshot for every test (this leverages `evm_snapshot` and `evm_revert` provided by both `hardhat` and `ganache`). You can for example set them in a `beaforeEach`.\n\nHere is an example of a test :\n\n```js\nconst {deployments} = require('hardhat');\n\ndescribe('Token', () => {\n  beforeEach(async () => {\n    await deployments.fixture();\n  });\n  it('testing 1 2 3', async function () {\n    const Token = await deployments.get('Token'); // Token is available because the fixture was executed\n    console.log(Token.address);\n    const ERC721BidSale = await deployments.get('ERC721BidSale');\n    console.log({ERC721BidSale});\n  });\n});\n```\n\nIf the deployment scripts are complex, the first test could take while (as the fixture need to execute the deployment) but then from the second test onward, the deployments are never re-executed, instead the fixture will do `evm_revert` and test will run far faster.\n\nTests can also leverage named accounts for clearer test. Combined with `hardhat-deploy-ethers` plugin, you can write succint test :\n\n```js\nconst {ethers, getNamedAccounts} = require('hardhat');\n\ndescribe('Token', () => {\n  beforeEach(async () => {\n    await deployments.fixture();\n  });\n  it('testing 1 2 3', async function () {\n    const {tokenOwner} = await getNamedAccounts();\n    const TokenContract = await ethers.getContract('Token', tokenOwner);\n    await TokenContract.mint(2).then((tx) => tx.wait());\n  });\n});\n```\n\n---\n\n### Creating Fixtures\n\nFurthermore, tests can easily create efficient fixture using `deployments.createFixture`\n\nSee example :\n\n```js\nconst setupTest = deployments.createFixture(async ({deployments, getNamedAccounts, ethers}, options) => {\n  await deployments.fixture(); // ensure you start from a fresh deployments\n  const { tokenOwner } = await getNamedAccounts();\n  const TokenContract = await ethers.getContract(\"Token\", tokenOwner);\n  await TokenContract.mint(10).then(tx => tx.wait()); //this mint is executed once and then `createFixture` will ensure it is snapshotted\n  return {\n    tokenOwner: {\n      address: tokenOwner,\n      TokenContract\n    }\n  };\n};\ndescribe(\"Token\", () => {\n  it(\"testing 1 2 3\", async function() {\n    const {tokenOwner} = await setupTest()\n    await tokenOwner.TokenContract.mint(2);\n  });\n});\n```\n\nWhile this example is trivial, some fixture can requires several transaction and the ability to snapshot them automatically speed up the tests greatly.\n\n---\n\n---\n\n## More Information On Hardhat Tasks\n\n---\n\n### **1. node task**\n\nas mentioned above, the node task is slighly modified and augmented with various flags and options\n\n`hardhat node`\n\nIn particulat it adds an argument `--export` that allows you to specify a destination file where the info about the contracts deployed is written.\nYour webapp can then access all contracts information.\n\n---\n\n### **2. test task**\n\n`hardhat test`\n\nthe test task is augmented with one flag argument `--deploy-fixture` that allows to run all deployments in a fixture snapshot before executing the tests. This can speed up the tests that use specific tags as the global fixture take precedence (unless specified).\n\nIn other word tests can use `deployments.fixture(<specific tag>)` where specific tag only deploys the minimal contracts for tests, while still benefiting from global deployment snapshot if used.\n\nIf a test needs the deployments to only include the specific deployment specified by the tag, it can use the following :\n\n```js\ndeployments.fixture('<specific tag>', {fallbackToGlobal: false});\n```\n\nDue to how snapshot/revert works in hardhat, this means that these tests will not benefit from the global fixture snapshot and will have to deploy their contracts as part of the fixture call. This is automatic but means that these tests will run slower.\n\n---\n\n### **3. run task**\n\n`hardhat --network <networkName> run <script>`\n\nThe run task act as before but thanks to the `hre.deployments` field it can access deployed contract :\n\n```js\nconst hre = require('hardhat');\nconst {deployments, getNamedAccounts} = hre;\n\n(async () => {\n  console.log(await deployments.all());\n  console.log({namedAccounts: await getNamedAccounts()});\n})();\n```\n\nYou can also run it directly from the command line as usual.\n\n`HARDHAT_NETWORK=rinkeby node <script>` is the equivalent except it does not load the hardhat environment twice (which the run task does)\n\n---\n\n### **4. console task**\n\n`hardhat console`\n\nThe same applies to the `console` task.\n\n---\n\n## Deploy Scripts: Tags And Dependencies\n\n---\n\nIt is possible to execute only specific parts of the deployments with `hardhat deploy --tags <tags>`\n\nTags represent what the deploy script acts on. In general it will be a single string value, the name of the contract it deploys or modifies.\n\nThen if another deploy script has such tag as a dependency, then when this latter deploy script has a specific tag and that tag is requested, the dependency will be executed first.\n\nHere is an example of two deploy scripts :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const deployResult = await deploy('Token', {\n    from: deployer,\n    args: ['hello', 100],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Token deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Token'];\n```\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const Token = await deployments.get('Token');\n  const deployResult = await deploy('Sale', {\n    from: deployer,\n    contract: 'ERC721BidSale',\n    args: [Token.address, 1, 3600],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Sale deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.dependencies = ['Token']; // this ensure the Token script above is executed first, so `deployments.get('Token')` succeeds\n```\n\nAs you can see the second one depends on the first. This is because the second script depends on a tag that the first script registers as using.\n\nWith that when `hardhat deploy --tags Sale` is executed\n\nthen both scripts will be run, ensuring Sale is ready.\n\nYou can also define the script to run after another script is run by setting `runAtTheEnd` to be true. For example:\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, execute, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer, admin} = namedAccounts;\n  await execute('Sale', {from: deployer}, 'setAdmin', admin);\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.runAtTheEnd = true;\n```\n\nTags can also be used in test with `deployments.fixture`. This allow you to test a subset of the deploy script.\n","readmeFilename":"README.md","gitHead":"7ecec00c212cba66c88fdac3e77fe884548c99e9","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.8.0-next.5","_nodeVersion":"14.16.1","_npmVersion":"6.14.12","dist":{"integrity":"sha512-Sw443/i6ctRchN2HMuCZ1nPlBZiRRtN+2uSzQQzGVMLL6JQTgafx/xEbCGlwfGvIiHSNCDXyC1NHWUprQgREJA==","shasum":"5423e2e61c2ca736168cedab71c93429daac850d","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.8.0-next.5.tgz","fileCount":124,"unpackedSize":7170538,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgxGsHCRA9TVsSAnZWagAAP8gP/AtVWcMCBRvxaxVKc9GA\neTPjXtyayYap2KmpYoeH7EjV6Ohs6G38eSCce/rEC07bu/ssxuifFDJs/doI\nRBGaRFE2XnVXI+0yne4c9biqluqQKqcL6zO11bQtzUnYxkWBBPpPd5IIt2as\nm1gbMbanTdY0aX1wHr0bH2k7+t+Xdyq9K2xQqacjLZGIsVbHfBSjqoPDq6ya\n3k+rlv7LQSE4x8MUx9Ts9QWLjxbaZtl3gyObNYMSJHSL8kgoBOHiLymXzg8b\nQLuZeqgj0mTZAzzTgsQp+oWuB4yrry2w8kwUwLSahDGYB7Tydpz+RvrkS5nX\nXUfx2ItiKOs5rUKXlri38hyZPcBjXOF8UtEII20taHBsGhCN+kpChuEjxdDt\nqyj+S10/K3PRCfOr+8LaOUR75Of5n42QYsOHBUBCRosONwPN9a3i5qd0bMmU\ndyyaoeb6I2hsbNtCRJwyJJTzfxJ7iMeFfFWP4usA0vpErZkxHY0MqAV3Ok0I\nr3QY+89ppS84fFJOr67d88YcxaOTQLMtB2JoUceTuB0QJWX2zeDBRATBe+7M\nkzuo1xkOaUAQqu7iiL51NRFG8cMKzJJmJ/GJQ0gxkkshn2vTViNU4vOTxPL5\nJH73AHXdxuK1onbAtC3o1+/9K7sRIMjUCU00+NlKSOIM+wTzREiQqjXrJn3C\n6rNE\r\n=lIaS\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIF+qGllp4OQJAL1mD0aXhNxAPI3g7+qwuq/TyKFU77X8AiEAgRKGOImsA0aqvpLK8ys4JCyHmVuApx3aXVTlNZAKu2g="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.8.0-next.5_1623485190844_0.26537482417236835"},"_hasShrinkwrap":false},"0.8.0":{"name":"hardhat-deploy","version":"0.8.0","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.0","@ethersproject/abstract-signer":"^5.0.0","@ethersproject/address":"^5.0.0","@ethersproject/bignumber":"^5.0.0","@ethersproject/bytes":"^5.0.0","@ethersproject/contracts":"^5.0.0","@ethersproject/providers":"^5.0.0","@ethersproject/solidity":"^5.0.0","@ethersproject/transactions":"^5.0.0","@ethersproject/wallet":"^5.0.0","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"5547d16c434249ee59344f4be52e509a0732fcd0","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.8.0","_nodeVersion":"14.16.1","_npmVersion":"6.14.12","dist":{"integrity":"sha512-jmqvW/Udd3Xb0+G7jb9q409Z991Eah0EaK1v1b0DFbWV1oaTyo7Nyu+yAwI979OuDOKee/g0fnRtNTj/2ykzeA==","shasum":"514a97c7ec993e1d90237b05a283a364ffd922b3","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.8.0.tgz","fileCount":124,"unpackedSize":7178000,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgxGvRCRA9TVsSAnZWagAAknMQAINsfiw2NADHBuaLXE1/\n6vynRh2MgxG8jm7Fn5xG0gOZzhhrsImGs5Jmz65ktL5A1Pt8x3t+9bqXhAOY\nQD3RD7L+0hQQyRC1e1r3YGLcGF8BlSz7LTP6Cjnf3QxLrJNOe0kKZ0G/jh7R\n7P0Q8EGsK2KhS2RuokERSE4ihG43mPSjNcUWYVgB4Ir34S+ZZ8ECmywve57O\nCBh+NhKc/P1V1Hs3cV2bieoJbTIAmhz/kYta6UYpctB5hDIpo78UmHZi4id9\nG4mpwwqcYcy2GIB+dPJZ+/EVDN6t8DrXR5dhwfJQnXVoW0mTV/uix4b+QlZa\nJ6lTB6/XnLNHhsLPRr+u9qTV/tu95vyanP4CHU1/fBQuE5XIm4ACo2DXws70\nyMxoU4548Ufo5alPI/XSJS6JeStduhjBch18HBj+jsB6Bn05JF4k4ubhnaLW\nmwSymzCF9hYWMAyO8R0qBq5yqoUOsIvUPWt2TSpfiFzBzrbOZPCahwH3maPF\nvy/Fn2iIc76gIsFRkc8jlOzkt5FgLTC8arCdZDv9xUGikRKV3wG32hRSAeOt\n4gP9ajSKEbjWktavuy1H+fkldCncEV5klIAjYttIGyn0qs6ZcURul/8YOoMe\nYgfUws1yajlLJcrERMCN3+STNVOq3+vyRtoXsvvygS6I1Isc22uHpGbuDhST\naaLW\r\n=yJm+\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCGrdrqVVX5oFkUB4Sab1bCxi7dwNawjZ3thHGdYk2iKQIhAP1R0sAS7NFBwX3wjZKyVLAvL0QTj+baKTzlppGO0kxI"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.8.0_1623485392978_0.17754495933201242"},"_hasShrinkwrap":false},"0.8.1":{"name":"hardhat-deploy","version":"0.8.1","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.0","@ethersproject/abstract-signer":"^5.0.0","@ethersproject/address":"^5.0.0","@ethersproject/bignumber":"^5.0.0","@ethersproject/bytes":"^5.0.0","@ethersproject/contracts":"^5.0.0","@ethersproject/providers":"^5.0.0","@ethersproject/solidity":"^5.0.0","@ethersproject/transactions":"^5.0.0","@ethersproject/wallet":"^5.0.0","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"a5d0c1276d9c88116dfb468f79c2200e83c4da1a","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.8.1","_nodeVersion":"14.16.1","_npmVersion":"6.14.12","dist":{"integrity":"sha512-JaiXk4GiCqfsuQl1m3rrByxTbrQ/uIV852nFrPieI7PTN4WVcrT9wCxVWcvFQneuX74RBFGhsLWKkG7rYd9zgg==","shasum":"d6c4db94d83b787959f9934673336e84393b9795","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.8.1.tgz","fileCount":124,"unpackedSize":7181556,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgxPCNCRA9TVsSAnZWagAAtOYP/i+6SG+IdhCK3UtYyCdo\n5Uj4is6mzJEFvDHEMl1Swev51Ad3/P6J9EqKV8vHuArCM7AYST4RBAjZN2na\nMLCN9ozbkN0Y7EX5AGt6KD1eQp/V+tFytOKsKQEhrw55mxnGJhd/+Th5VyEC\nSAko1eYH2zUi2FcrHJtq57Y9Kn5qfGGlkm9Lkylu6loQAf++vdRel0uarQ3D\n7652c9hZkEJ+2fbWyADRkIRBgiSUV0mBakiuSy128nNJ+8k8M90nEaxYrrpc\nrI0AWNzsqnPrx/ifYhJMa5SckH0Ko1Ut5OBpiD5pVOjpPTAkGdY2uOe6qu+y\nrMl4MyfKvojywR9KQ1GUjZMfijrEoSu+n2RIhitg8fiLS6TkAXc27qIbeGDw\nea9qbibnFiscdDVFz4BDwErLPkgCtuKSWm+DJrQ+TKHtmDTxUdsaAd6WJpF/\n+xlDVT5jYTymnE0pGJIEGOvPeOmQJR19IKEN90kvgyvOXUIZZ3jVlkcSVJbw\nJQ2ug9MfrcUMrTac12ooM5uN5P29PhdQbhEc+lnonzPthWSXo2rMQlIEPHyN\nawnI2ILDjHBCEwrnFEP827gd3atV00bMWFD1DAa3MTq+nz09NfVo8PG3XXaz\nPEGzqdUdANAAR7pX5XyaOVWxkLIb+7R3Jz52rOdl2421aN5e4GoZ0VycLCH4\nswyW\r\n=dWoV\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCVfF4JWbt43BmVITI/33SaZU09pgzmNbd5kU2F5eGSDgIhAJV+ptM02j1GelIsWYiwiWow0sDHq2P3tQn20qdjYqqS"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.8.1_1623519373533_0.7537024279018845"},"_hasShrinkwrap":false},"0.8.2":{"name":"hardhat-deploy","version":"0.8.2","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.0","@ethersproject/abstract-signer":"^5.0.0","@ethersproject/address":"^5.0.0","@ethersproject/bignumber":"^5.0.0","@ethersproject/bytes":"^5.0.0","@ethersproject/contracts":"^5.0.0","@ethersproject/providers":"^5.0.0","@ethersproject/solidity":"^5.0.0","@ethersproject/transactions":"^5.0.0","@ethersproject/wallet":"^5.0.0","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"842e9c8744aada45474b24e465fdcbdbb4ce279f","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.8.2","_nodeVersion":"14.16.1","_npmVersion":"6.14.12","dist":{"integrity":"sha512-Ypf1JaFZTKQpfsFidbBSEZRZ6lyWuG+PZdRjH8dELk3V6pnjXgCIhGjIRSsXx4Sn/aXtxO/stqzZ1hDS229i3w==","shasum":"6754fd95b14c3573852d318c55d3299dfaa8efe0","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.8.2.tgz","fileCount":124,"unpackedSize":7185439,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgxRicCRA9TVsSAnZWagAA9/YQAJo4u7HvV5s6ZCglVqau\nul73G0+AxS3N9E/Ggs5BSnm01erp6wvqRltgO0hYkO3mYj0gJt6uewKz0ZGC\nelmnklPt7w9A6IwkEpVXKENtcLkjaawhx0/OfoU41dQyJyIYgEO3YpCVn3og\nMbuZNyW76lcRkD1aPEPXvRzEbVKkpt+P8Sk5W7ntp++IurnqHhY/LTVatikN\nJAMhJTYIaCnc656iKzKCZCf9PB/WnYPZwwn+x52bpsbhLOTpwDYRPbPqzpQb\neixBwk9PTw/V6xZYvdNd8tCXi2JHO7I9BPyu+I/o0jFCyVz1SVDfbJzDDYWy\nF7GNCWLfJ585cnU9PXe1c70U7qT56Wi5fouAeZjcaob5rFYKlrYPCAsg6Jgc\ngf6ctFHdM2UCT9vQT6lJnL5SLy+nEP4ZrN8h+v3Y37FGGbJM0bGvktsec02t\nwwN9o1OFUHpZvd3AEdMZanEZbx3SA8O+OVsCGey9uGpUZq3a1oO+REeYUdnp\nJL9Kk1YO/fYz7oHOSMGbkecZTVY/2DfPnw3idjs01yjbZfVdSM6/rxiwsgYq\n+CcFmjKoAUbHRsSMB4ED7ebcO6UKQcX4IGoJ5DcIJVlXPBcX0wfKlzT4sCfL\noqxvik4Xg8sV+/NAB8VGgV09CgSPyjLvOVZzPO5wv4bVCyGhzdQft6yDgpS4\nWqJG\r\n=vyyQ\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIGAlpv6v+fh9R7aYbf8xO3wozbk0Gg5JClIihZHNRoN6AiEAm5aZFXAgHDT1aPXJrIAYWQIlQMbZ4+wpsB1szE9WuAI="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.8.2_1623529628683_0.9194629942460986"},"_hasShrinkwrap":false},"0.8.3":{"name":"hardhat-deploy","version":"0.8.3","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.1.7","@types/debug":"^4.1.5","@types/fs-extra":"^5.0.4","@types/mocha":"^5.2.5","@types/node":"^8.10.38","@typescript-eslint/eslint-plugin":"^3.9.1","@typescript-eslint/parser":"^3.9.1","chai":"^4.2.0","dotenv":"^6.2.0","eslint":"^7.7.0","eslint-config-prettier":"^6.11.0","hardhat":"^2.0.0","mocha":"^5.2.0","prettier":"^2.0.5","prettier-plugin-solidity":"^1.0.0-alpha.56","solhint":"^3.3.1","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^8.1.0","typescript":"^3.4.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.0.0","@ethersproject/abstract-signer":"^5.0.0","@ethersproject/address":"^5.0.0","@ethersproject/bignumber":"^5.0.0","@ethersproject/bytes":"^5.0.0","@ethersproject/contracts":"^5.0.0","@ethersproject/providers":"^5.0.0","@ethersproject/solidity":"^5.0.0","@ethersproject/transactions":"^5.0.0","@ethersproject/wallet":"^5.0.0","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.0","chokidar":"^3.4.0","debug":"^4.1.1","enquirer":"^2.3.6","form-data":"^3.0.0","fs-extra":"^9.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"bc2831e85c9014204b4c2ffda0c238ddccc2ebbf","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.8.3","_nodeVersion":"14.16.1","_npmVersion":"6.14.12","dist":{"integrity":"sha512-GPDoNBMOgnr3fzsJCerM6+Bwn/18YtlHg9PW6XqXKuBxWSc5O3JneLr/ml+5gF/Sb+c5HA1C3oaB5iL1qzSdaQ==","shasum":"2fdb6f4054e833ba69cbdeb3ca20502eb5d79d64","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.8.3.tgz","fileCount":124,"unpackedSize":7207789,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgxaIxCRA9TVsSAnZWagAA0q8QAIPxlGcZRHhCmEUdXQJ5\nub8Ak30p3Ck3JGbF0KncsnnfokNxr8Lh0DvvuqOqRcSGI9+km2ZM+W2GZwI6\nxEaHej1SJ+Yp0BaRTkU3LvW48MxYwdFFQlMZWvNnpTw5ivzvhi/ZacuSrJZL\nTZBBUbdqeBwYHqNI27hB/RBKkwC0/76p0/cJVX0wp+UU6wUQq1BRkB5y3hYx\n+gbtI54lMo3LajrjvGntgcivJH1wTrc38kYljttaR1rYnKv3mrk4Xk7Baxgc\nl+ALXLB+LwLCpO7W0dHOUf6suipLiDrjZQfKHnrZ9v7IKfRYlYuso9db+NRs\nXi8NIbNQV2xTsgOs27zeTdhygn7EGebV3I4pTazaAI5fKKn3q/mCZz1S/fS1\nSlP3uTXtopHnY65fa2t+32bGlEqNxvqft1lO9qLyXzSVTi4GR+KWxXxtrfDW\nhB26YlLZNKFa0lKWgEdBQ6FdtpUuvpgZqUDfcL5WuP0dOZwlNTv1M/p5044J\nrzr3QRnyLNiFEYWy8U1UU985WwwtZY+gIyp/e4LBM0BF1r/ZBdnvjGlEBRZI\nf2lL+Edgue/wX+Ufmc5rjETF4vJFZGSrRtDdxX0OK8jyYXuM+TIoIGXAxctV\nMfKL9iMIP4tOgqk8Jezr8hu1Z0iiYX7JGpY2T7a/HGMofuVk4IQcSQD+EStW\nWJnn\r\n=3bHB\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIGlbsaWQ47o2voIm8qP+xT7VhIibgo2d03p7meOuVjhsAiB4QKijaeDSR3Lje1ZtiSHJtIEOiKa2w/rXiHTKdszE9Q=="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.8.3_1623564848918_0.7625827644497414"},"_hasShrinkwrap":false},"0.8.4":{"name":"hardhat-deploy","version":"0.8.4","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.18","@types/debug":"^4.1.5","@types/fs-extra":"^9.0.11","@types/mocha":"^8.2.2","@types/node":"^15.12.2","@typescript-eslint/eslint-plugin":"^4.26.1","@typescript-eslint/parser":"^4.26.1","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.28.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.3.3","mocha":"^9.0.0","prettier":"^2.3.1","prettier-plugin-solidity":"^1.0.0-beta.13","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.0.0","typescript":"^4.3.2"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.3.1","@ethersproject/abstract-signer":"^5.3.0","@ethersproject/address":"^5.3.0","@ethersproject/bignumber":"^5.3.0","@ethersproject/bytes":"^5.3.0","@ethersproject/contracts":"^5.3.0","@ethersproject/providers":"^5.3.1","@ethersproject/solidity":"^5.3.0","@ethersproject/transactions":"^5.3.0","@ethersproject/wallet":"^5.3.0","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.1","chokidar":"^3.4.0","debug":"^4.1.1","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"c873a281d456a5d8ee4cf04d4c10760a405dea1a","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.8.4","_nodeVersion":"14.16.1","_npmVersion":"6.14.12","dist":{"integrity":"sha512-GQr8hbY1ZWI7UqQPL2Mjdlz+LVFm8ki2QtAoKDTIpnEIv7DU3uU69T9a2aNj8dU9Ywa7CZIfQGgX5eNXI8GjkQ==","shasum":"a287a4eaae9bc1407986db49f261640060b8fb61","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.8.4.tgz","fileCount":124,"unpackedSize":7208463,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgxawFCRA9TVsSAnZWagAA61kP/if3hOJptOH0TFOLm3WQ\nBaKOjWr8VwVc6zzuanGRaVpJaWRBmOHqfEFHexEQxXVGOij9A7vsCn4x8LYu\nCVrd9hNPjXaXdQxYqP5pI87IEnVKa31jd2lomSWtSfPEieZ9IBJaKP2WKOi9\noiHH+s55Jh+y18yU7//IlifTDcNH5d+LBlw6NVaKLSkx8XW+710Wmr2t6vT3\nYZ4nxdvXkFD3qgtxBO+RLROxEtvgZemZl8Ep5kZZ33J/4KZrKiTiN2ZBMfHY\nKULcfYkPO8bqCRWLAJs64W7fJrO86opAKuCcLokTB7ztY684wa/3t/3GZJv4\nrgDG83q/OAWrkw8rBAwra+5xNpS+ySPIDQKeqa+lHA3mNZBEa1TtPUPRxlVv\nCXjvJ+bgzq9sRN+84+jTqRK/2ALYgM7F3wpL9Ar+GoJ2vcEbZYyHDa7QT9Qz\nxbaSNUdze8SAiaNFg+kAY7yuVHKrG9LDha5wQ1IQAztDecN9j6pgOdRQ1/r7\n9L/WRVMNHI66lzNmuQJbAOejHW2IaSlN8xYpJLsKkZKRBYavg4p2GoqK+cFH\nwyijhK2CXhcEJ3AN6zlZFpwr5GEnj6TY+fTLrUaFoIiJW2zeZyVqyCfoKnG1\nDEL7kN6UQ3EkXw5q98Mp+OAfKRYkfxq4m6RgzfQl/oVUz4pAcJNAESOCX9hR\nlKb6\r\n=12M+\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCICkGFFjK1DiVOleTnzkXdbd8gIbPb4x0GvWnUl08UHJOAiEAxbcUlUjZZrHXrf/k97FOaEPfBdPrKtzLzMvBUxJq2Qk="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.8.4_1623567364845_0.18952255588137157"},"_hasShrinkwrap":false},"0.8.5":{"name":"hardhat-deploy","version":"0.8.5","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.18","@types/debug":"^4.1.5","@types/fs-extra":"^9.0.11","@types/mocha":"^8.2.2","@types/node":"^15.12.2","@typescript-eslint/eslint-plugin":"^4.26.1","@typescript-eslint/parser":"^4.26.1","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.28.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.3.3","mocha":"^9.0.0","prettier":"^2.3.1","prettier-plugin-solidity":"^1.0.0-beta.13","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.0.0","typescript":"^4.3.2"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.3.1","@ethersproject/abstract-signer":"^5.3.0","@ethersproject/address":"^5.3.0","@ethersproject/bignumber":"^5.3.0","@ethersproject/bytes":"^5.3.0","@ethersproject/contracts":"^5.3.0","@ethersproject/providers":"^5.3.1","@ethersproject/solidity":"^5.3.0","@ethersproject/transactions":"^5.3.0","@ethersproject/wallet":"^5.3.0","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.1","chokidar":"^3.4.0","debug":"^4.1.1","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"8f1fbab9a39f2bcc8c64dc3943137c46f81743bc","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.8.5","_nodeVersion":"14.16.1","_npmVersion":"6.14.12","dist":{"integrity":"sha512-3tTGxZJW++XCeP1vEuEZpk8KdX63fSM/PeFyh2ldx7c9Eo7jGdP8Mtlut/UWdyopi1r+hj4vLpwqDjiYdt92gw==","shasum":"13004bb957f70409edd160df6891d7b7ad00391d","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.8.5.tgz","fileCount":124,"unpackedSize":7214530,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgxfF1CRA9TVsSAnZWagAAdmkQAIkRGwAl2VhdtvUDuPVn\nsziY/6VrgsO6EisqqFVJbTSeSv869gVarYhPqWDGuWrrzv5Kvci+6rJIWT80\nMzIb7V+vheUaF+B53Pf7gI+UUgwoXWuipgHPyN4qMZQ92f7AqqnbAYotkPz3\nulGSXB6JwUxPU7r0s1zQPzjOQ7cn9eVnz8Tf4ji0gAoTTX3m3QpkXcGqwKzB\n7xA6E6H6+HR+GoQplgD3UnXf4Ph/6Z0P4thDPRYuXzP+QtUXwFVuWDrClcgO\nRENKY+KTNEHT04d3DBl3uX2Cl9su8NJAFiJB0KE/O/GtJuoX8LavwptkAbY8\nTV+9FDZzJB5Dgjn1AybT9KZgRHnmvDKBmpZhlum6Ra47njuGyp5dL0XBe8Ux\nDvQwV+6PHPKVFeCVe/z2JsH0r7SIor7y/3Qc40lJ9BZBMitN/Z1LW+3MH9Pc\nwX93BszPTOAlYnWIjV+mDEk+zC4BAh6WwA+q2QN2sUZ7h6YreVLlYfFntjeR\nUKsJZErWOq2SesB2K5t0rYmrCc8aTsEuMCNnwP51h7GRvAi5UItdEGfko3bf\niz/UIOJSZqW1RgpNH2/1SUyemsCWM2092OXDp6PlbMAPt1ie30mDvpSCs81B\nM/U3IHuqp+qJO1a88OnCeRcDFrRbsNSY3lmZHMWv2gDJPynkJoo5UG/USXgs\nxy4J\r\n=qDYf\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIEupHVImCXNH5V34MNeCJ+OD+Q58/+ZVQmUOfIe636ZLAiB1EJHNClZQ6ThI7YKA4q1YG/6wgrx/sovO9Il8yvGIGw=="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.8.5_1623585141299_0.6806752067607762"},"_hasShrinkwrap":false},"0.8.6":{"name":"hardhat-deploy","version":"0.8.6","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.18","@types/debug":"^4.1.5","@types/fs-extra":"^9.0.11","@types/mocha":"^8.2.2","@types/node":"^15.12.2","@typescript-eslint/eslint-plugin":"^4.26.1","@typescript-eslint/parser":"^4.26.1","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.28.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.3.3","mocha":"^9.0.0","prettier":"^2.3.1","prettier-plugin-solidity":"^1.0.0-beta.13","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.0.0","typescript":"^4.3.2"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.3.1","@ethersproject/abstract-signer":"^5.3.0","@ethersproject/address":"^5.3.0","@ethersproject/bignumber":"^5.3.0","@ethersproject/bytes":"^5.3.0","@ethersproject/contracts":"^5.3.0","@ethersproject/providers":"^5.3.1","@ethersproject/solidity":"^5.3.0","@ethersproject/transactions":"^5.3.0","@ethersproject/wallet":"^5.3.0","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.1","chokidar":"^3.4.0","debug":"^4.1.1","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"e84e29387882fa92703599d0e59926e4ff0c01c3","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.8.6","_nodeVersion":"14.16.1","_npmVersion":"6.14.12","dist":{"integrity":"sha512-lw4k1SPVc3kG2jCSbxfnSqVxqh0E7xK9rB6HeJoWIvmy5Y6+Uuw0C3Lk0TObX02ewsTRF/5sWin7JHxbt6K8Mg==","shasum":"6f0e8684a66f0a130670e448bbd072bc512255be","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.8.6.tgz","fileCount":124,"unpackedSize":7207960,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgxkHoCRA9TVsSAnZWagAAi20P/RZyHEC5tgYU2F7/eBWW\nIuUKGH1LN5MSRgRmL2oa0MphzOT08Vhf7Ctdtt0MUiDCB3GPmypTMkNyxtt9\n35FL3CDnZ442fMHn3eCgdp7kwpP2nkKH5qU73azaJSuUdEwj5uoZg1eC6Dla\nKAnPbWqmeY7VYkPirFyf25L1qwsnwW9dvvuDc9PL9TgFWAUF9dhQE59QtHBZ\nroqaSFXR2yE+OiTNpnEr2sH8NAtHfsEVcF87G2/PNQJxOKEXMWAAEhx28EoG\n9W2i7ZunDVgnKSNRdSl+UNpNK/PL4UVcpdKhl7245RjIBXbNMdThKkaGTrhq\nK/17bWduePauViG3KyamUiZJcVcoYsm8mFp47R3VeR+RUVBUmawtY1/AB5ok\nJGDW0ywfwim28NjaJiNdnjV4I154u5tkNnL2srIaYAd75mfkmgjovdWsZcqM\n4d4yvVLo5utCB3xFwAms6qpx4FPtR20qd2dZ2M0FZZy/+7VQbmpSd1z4E4Ur\neAl/UDg/2mDvRAa6m3Wq/5Y61liDqM1GTRdYWPS+Qs+Q8RnoyAd+v5hGShHK\nfmeNFEl7/0aImkdIvcWfKPTnFaJv7JnA41RekGjnkN6AQ5JyW8lnDXTTVKo+\nVnJDXpWqx8alvlKwTtOoakzSHBQ2b594/LAwpqF+h3lCoDjL9/stuBoG0yzq\nybBr\r\n=hY4T\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDk6AOOpQYWLsN47t2sMSPrFkovkIONLiWAriMN3+6ZvwIgGNYUk/RUCM35doxj7e/QED00VTCqTRz4lHXANFlI4Zg="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.8.6_1623605735988_0.4213739355963537"},"_hasShrinkwrap":false},"0.8.7":{"name":"hardhat-deploy","version":"0.8.7","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.18","@types/debug":"^4.1.5","@types/fs-extra":"^9.0.11","@types/mocha":"^8.2.2","@types/node":"^15.12.2","@typescript-eslint/eslint-plugin":"^4.26.1","@typescript-eslint/parser":"^4.26.1","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.28.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.3.3","mocha":"^9.0.0","prettier":"^2.3.1","prettier-plugin-solidity":"^1.0.0-beta.13","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.0.0","typescript":"^4.3.2"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.3.1","@ethersproject/abstract-signer":"^5.3.0","@ethersproject/address":"^5.3.0","@ethersproject/bignumber":"^5.3.0","@ethersproject/bytes":"^5.3.0","@ethersproject/contracts":"^5.3.0","@ethersproject/providers":"^5.3.1","@ethersproject/solidity":"^5.3.0","@ethersproject/transactions":"^5.3.0","@ethersproject/wallet":"^5.3.0","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.1","chokidar":"^3.4.0","debug":"^4.1.1","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"9c0777b578f848f2cbb1bb1fd611e2bab9f6cbbf","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.8.7","_nodeVersion":"14.16.1","_npmVersion":"6.14.12","dist":{"integrity":"sha512-YEPfTQLeZnvgMyu/utzKK0CqXU9Ev1hKjWvn20Rv36NgcyCu48Imen5mFAx8FiQg4or8RBWLoyfzkltAIxQo7g==","shasum":"0d751502dcb4dc6932de991d0d30482f61d6c1a2","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.8.7.tgz","fileCount":124,"unpackedSize":7209770,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgzIVUCRA9TVsSAnZWagAAmPMP/1V6rAc/NJI/SUEYIK4S\nrUlD2l8BdC03bcBCugaYfl0ZS7p1ggLngSr8dL5Vf00vQxjTW11dBgLYVlZa\nYzT5fYN+/yC2LRVR1VJOftJuMHsPYqsfPN8hleQyJUvZxYvMGaM4pQ0yfSQU\n9Yl2Hlj6z7lDVSLpJ6mB6TwPeXXeF6yylNH56Gyq/h96SSO9kSs4iw/OVG8m\nGA8riMYT5y3dz5M4KWXmCs99+ByqK7jA1fpYdSbP+jTxYUiOA3tXgTX6CH/b\nNvlp2IAghCmdqm3XrU5rVpZFn+SSc1u9zEzbP+yWCHIU+3JMk+sezDcPd/C8\nYGuZKtH0KM9ZoCLV323FddU94TkGR+MKvYwrxOYQP1fERT0kB93Q5RMMo7VQ\nNG/6y1TGauS/SM60OZU8y0Ij0nMFRcd5edQaFlKoR+xb9uus5b4898umbAS2\n4gFpoYnHpKivPSJTxSJr9K/nE34rVGT2mxDURobQMArtvapH9wH5TPyMOCQx\nA6lmR2VCK3jImIy0EwQa7TKZDQCzdWEY2lPNtY//+v3nEhQr0NQhOZyXv+js\nO+Nm1YejVP5MdtZPq8+2ecfGyITc5MiMooqNnhYmBJ4TltKfmwxQXy1s7kMF\nhqbtvwDaJvf97/dPs8817ZgjPj2dO+q4iyAIepgHj8VD3uA+Vqttq1BWZfsr\nQiZj\r\n=oTEZ\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCICRlZtKdjip92LqgQULmjnXNKVLBm+DU7cCNYEqispfwAiEAxJTgZIbp+Otnib9skPr317iMQTAly+6F4QBdxF93xiw="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.8.7_1624016212072_0.5573438396286245"},"_hasShrinkwrap":false},"0.8.8":{"name":"hardhat-deploy","version":"0.8.8","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.18","@types/debug":"^4.1.5","@types/fs-extra":"^9.0.11","@types/mocha":"^8.2.2","@types/node":"^15.12.2","@typescript-eslint/eslint-plugin":"^4.26.1","@typescript-eslint/parser":"^4.26.1","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.28.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.3.3","mocha":"^9.0.0","prettier":"^2.3.1","prettier-plugin-solidity":"^1.0.0-beta.13","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.0.0","typescript":"^4.3.2"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.3.1","@ethersproject/abstract-signer":"^5.3.0","@ethersproject/address":"^5.3.0","@ethersproject/bignumber":"^5.3.0","@ethersproject/bytes":"^5.3.0","@ethersproject/contracts":"^5.3.0","@ethersproject/providers":"^5.3.1","@ethersproject/solidity":"^5.3.0","@ethersproject/transactions":"^5.3.0","@ethersproject/wallet":"^5.3.0","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.1","chokidar":"^3.4.0","debug":"^4.1.1","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"5ed527caf6d355ee6f62bce7d86f9d0c6c4e372b","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.8.8","_nodeVersion":"14.16.1","_npmVersion":"6.14.12","dist":{"integrity":"sha512-ffouHqv8ExehBthdltPMVYDIOFZba5utlrWbBFHYS8kLsMixA6/jcH8lbG4JyAIr2/PEaf9+h1oRQkDKsv8l6A==","shasum":"41a23bf3537789a85fda61c28dc8b6b42074a875","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.8.8.tgz","fileCount":124,"unpackedSize":7209381,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgzLnUCRA9TVsSAnZWagAAVOIP/07C2Sf5Ss1FOd9tud4U\nuChHL04enjIUPTMby7H5I5ET3kvixdtcbnQqvy3/e2Z2D+5ol0UJQOPdvsH4\nUobgDKY/nNE28W7fuZSI92MUTVelmtS3Okdtpybob7HoVVQ9pCF3VhxN0wS9\nawL3oGEjCI4Pg5ZvhP0U5oY0bBYXun7Mw/uFzWAfNxjgj5viviIM32YuHbil\nBV8LAszcUdQYvWytLwFyk/5ch9iW9tMbuVeLs2zAk+jqxlLGclyUtrsaYyJi\naKZF21gyj1M/MB+bm4u9UHa14kG0QCYUx8p9QB5KgOLyn8ajYe9c6D6zEqGE\nJBupZF2KmPTsYRT/UEEfF/GneUdh5Jl2spRiBjBezfnh4uIC7OT74TbNPxS7\nGABrDrE7j68WkTlo8+iKS/7+XD3IOQWBSMW6w8HfnZgIy5XnSuYFOIjDvJZv\neIraDCXp2XlQ9lhQnkx4ADoNJfdMRyQIcYwq/0aDJEz/PaNYbLAIH64x832D\n9FvgAr+Dwf388XN+2fcIwTg9nn2LOeXfmXStkQ1VZJcQxMQm4587f+OSQkfb\nGSjB9FTkHYnMUJ1EYh+RkOBVtEJZy7PAxh5MQowSZDBvb0PMLaAZr7NTLeUz\n4/Y5LBbAi7jQPTMOvS7rnffie2dWrrUDFliRl6lp+3RIVTZyUikKFtKIyl/4\nVe0T\r\n=TwFR\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIBEsAqygDOYwV4AFMGTgk0NffjUGk1wzx06Ax91S+eM0AiEAgaVuosDR1h/piYi0l1MrWif2RaiVHIj5YlZQHWFwqDI="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.8.8_1624029651790_0.7915404264911863"},"_hasShrinkwrap":false},"0.8.9":{"name":"hardhat-deploy","version":"0.8.9","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.18","@types/debug":"^4.1.5","@types/fs-extra":"^9.0.11","@types/mocha":"^8.2.2","@types/node":"^15.12.2","@typescript-eslint/eslint-plugin":"^4.26.1","@typescript-eslint/parser":"^4.26.1","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.28.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.3.3","mocha":"^9.0.0","prettier":"^2.3.1","prettier-plugin-solidity":"^1.0.0-beta.13","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.0.0","typescript":"^4.3.2"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.3.1","@ethersproject/abstract-signer":"^5.3.0","@ethersproject/address":"^5.3.0","@ethersproject/bignumber":"^5.3.0","@ethersproject/bytes":"^5.3.0","@ethersproject/contracts":"^5.3.0","@ethersproject/providers":"^5.3.1","@ethersproject/solidity":"^5.3.0","@ethersproject/transactions":"^5.3.0","@ethersproject/wallet":"^5.3.0","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.1","chokidar":"^3.4.0","debug":"^4.1.1","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"179403e2b1fc4d3f7281d6b38a439cc85a24551f","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.8.9","_nodeVersion":"14.16.1","_npmVersion":"6.14.12","dist":{"integrity":"sha512-hmn94K8b/ua7kTj/ECpCXaIqF/8Kfj1fI17ex1fxfvGS8RkZKvXaHaNU1ziX7vLaKZbcYHytKC9nL7PiRwXawQ==","shasum":"fa13f104a2aba85d6ce0043adbd683e0da026df9","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.8.9.tgz","fileCount":125,"unpackedSize":7572757,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJg1fOzCRA9TVsSAnZWagAAKKEQAJZRn2B5NkeFxbqToGaf\nMoBsrbDCUNyyz9uy3LYQlMnuoGPiaRAkA/nd74zobPqaW7eAouJreFcfDOWd\nUdz6Y92RnIOoW4LJm8tSLTUF3/RX1zSVHTC95wKuKiKjKm26bBnD6RBqq5Hr\nx3f9rRBDCVSs/T7N/1V/U4ZzbzHU3X8FnTWbR/wbs5j+eANzopLxo6mPvLej\nfAIOrU9oIOvZx0M8j5uak4nFsK+zJzsF2/9o7ES8mIGAY37CnEocUyEf+Q7M\nJhO1WM9H/eX1Lg79ioTq8hrNDtUI0R6wCcCSwWxkCSh8ghfQZ2BkSKiveuEp\nEXsbqguvgicRwd+HrN5OQsRMD+ZaqKcBadakYLnbx1QfyWTt3mLqfW1DWByS\ngJAhi5bUF+NCm/G9ArB/kRXAiGkwX/h87RXMDOzYhMtTIxXJNKjBntlf4oSY\nkwCEd8LvNQ4fNACYDQBsV+TwtweV1TKLcPEmxy57TR4mfFz1IuAXSbRIOAS/\n6/TamTAk9h4dC8znPDjnNs28XFQfNwBfdyNqVhEwcC4eHd89Pb+CDj7k21Kz\nF3i3iVJ9gI+UY9y2Bg1LMEt8HFlBmeJMFvfRsmWsPupchkcmPD/1BwmiuzBo\nUtiwqQ3BwExnxwS1EArVSzOa2yvyR+z6InCMPiqSh0hzev+XKMB83zBXvMTl\nQl5T\r\n=f1T2\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDBssXJ534F1r90MmFZOaHNev04uB/wIp4MSPnmWUl7gwIge9sAUyZpjNs/+yFmqok6b2KCnzeAo+aoQZcv3xdTb0k="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.8.9_1624634291059_0.8904384529277622"},"_hasShrinkwrap":false},"0.8.10":{"name":"hardhat-deploy","version":"0.8.10","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.18","@types/debug":"^4.1.5","@types/fs-extra":"^9.0.11","@types/mocha":"^8.2.2","@types/node":"^15.12.2","@typescript-eslint/eslint-plugin":"^4.26.1","@typescript-eslint/parser":"^4.26.1","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.28.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.3.3","mocha":"^9.0.0","prettier":"^2.3.1","prettier-plugin-solidity":"^1.0.0-beta.13","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.0.0","typescript":"^4.3.2"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.3.1","@ethersproject/abstract-signer":"^5.3.0","@ethersproject/address":"^5.3.0","@ethersproject/bignumber":"^5.3.0","@ethersproject/bytes":"^5.3.0","@ethersproject/contracts":"^5.3.0","@ethersproject/providers":"^5.3.1","@ethersproject/solidity":"^5.3.0","@ethersproject/transactions":"^5.3.0","@ethersproject/wallet":"^5.3.0","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.1","chokidar":"^3.4.0","debug":"^4.1.1","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"1a4ae4826a682e34e7ddda153e7c7b58d552e9a6","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.8.10","_nodeVersion":"14.16.1","_npmVersion":"6.14.12","dist":{"integrity":"sha512-IXFxJ7Qsqcs73fmFmJ7ImAlB78vpuhennaaZRdzw50cRHY+K/s3iYxHaV8hiITf1LCYxluaxU7oKY/AT/KzydA==","shasum":"3a13bd4d3d5220ceac74a7309563f45d5cf3d9ff","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.8.10.tgz","fileCount":125,"unpackedSize":7573062,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJg6URSCRA9TVsSAnZWagAAHG4P/2YUFtSzb8kH+wN0sV9H\noW8N+xfBLbvPclSEhoBexFGADRwaLbxBeKr/3P0ze8ceDoieJUUuMvgDcCQt\nq5te5HscM7aswtkAmxL9Nrqfe91rrg5j7sD0tPjyp7pSkpxu4fW7sO8xc3DH\nCY0ATiVVA54+eh4qKaS2Ea8OxuXkYJWjZ9J5vZUGhJ2mmbaqZaPubb7mK6Vl\ndB60pxX3MDPtBKyiAwDYbYl8olkgREMG9puUD10Q4hSFK0i7tl4Nnjkn7k5S\nwwsJ3fKhdrv2CBUfkq4yHMlYIGLPcabAlZN0O1XD2iNcyfpXFtAtEq8HZE16\nth12saTu1Ahlk9NRJVDWseowveyaVRam8uI45356zHD9+6bGc4RWV/zS4GU8\nVQ9NAzC5UOOCLrTyrNilPKWeTanCzoD/ZE+97nLoHMzgDWSD4T57gykJ1Lh1\nz1MLH240vom2vm0HOm7WKW8rkuFVoJnjZuUDPQ1kCI8/IjJ7UrWQrsc7Gyb1\nEocC6Gt7tW+pEkXgFPMoRjMeOGZ5Q4Gx5sORnDn++PtklfmdJ94A2cBSonz1\n85DZVGDkZ73bQggwEFojAnSjT8QahIfpWo3urhl38lQsyaKu9amYWOllk9Fl\n9Xp8aDJDN+iUogORvYdoyq6HcIHFlyeWEiIWz1uB/zxRwXOJ8OvhPVA74Hcc\noWPd\r\n=dQuV\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQD/RARlSP0bahnbnMjxYhEinT12ao3/DXv4sK8j3mKMTAIhAIXaPsTa2Ebr1JEwy4ERDOfc76zlGXWi62BJ0MAUCvCv"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.8.10_1625900113818_0.8147951161149902"},"_hasShrinkwrap":false},"0.8.11":{"name":"hardhat-deploy","version":"0.8.11","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.18","@types/debug":"^4.1.5","@types/fs-extra":"^9.0.11","@types/mocha":"^8.2.2","@types/node":"^15.12.2","@typescript-eslint/eslint-plugin":"^4.26.1","@typescript-eslint/parser":"^4.26.1","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.28.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.3.3","mocha":"^9.0.0","prettier":"^2.3.1","prettier-plugin-solidity":"^1.0.0-beta.13","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.0.0","typescript":"^4.3.2"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.3.1","@ethersproject/abstract-signer":"^5.3.0","@ethersproject/address":"^5.3.0","@ethersproject/bignumber":"^5.3.0","@ethersproject/bytes":"^5.3.0","@ethersproject/contracts":"^5.3.0","@ethersproject/providers":"^5.3.1","@ethersproject/solidity":"^5.3.0","@ethersproject/transactions":"^5.3.0","@ethersproject/wallet":"^5.3.0","@types/qs":"^6.9.4","axios":"^0.21.1","chalk":"^4.1.1","chokidar":"^3.4.0","debug":"^4.1.1","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"f5bad80ced4555f50c857f0420803189a14cc65d","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.8.11","_nodeVersion":"14.16.1","_npmVersion":"6.14.12","dist":{"integrity":"sha512-PJIYckR9lYvGMHxaIb8esvZw9k+gW2xPCUYf4XJTQ3f1fLTXhA86AOhPQsfyBr+MY11/D+UUerIP88tl+PW2+g==","shasum":"faa20def76f031101db81c5b71d7388e0475b794","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.8.11.tgz","fileCount":125,"unpackedSize":7573465,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJg6UevCRA9TVsSAnZWagAAqr8QAI3cYZn3D+ZwldjEOkSV\nhIem4cwZmtiTpeWBs/djyRO8Ky8vzB6SeuvO/+jplH4g0fvywoGUqArrgPX+\nKLvNtLNesOsLJ0lahzReQo0usvXIXxz2DbqrvYZbJuJ08a8xJC/wpRlK4/aR\n35ZNv7LCnba03xQekZVrQslOPlltuXU//y+STcY+gOF3iA+4s2akOqMT8/lF\nzyI2GTJ1nqSC78i6sFBwlwXdbrQLmg6KYkXmRbmGakX1A0Ps49oFkTQ7Wfr1\nc84j7WbheI3vQVyGCjwFagHtnwJtZWuOrta8okUePKbG4WC/omin9KXL/KF1\nSl2411FVV4tSSqRR1u8ITzPD+TD684eJokY/leRHjyKUe0pMMBJrmPZGYDr1\n3Fsl3j6eEqaY0OWt68VnJ6MDNcKfPmZRfYuztnJMgSsD/33q9+g7xFGWL9+m\nYdybnvqaFBltEJNqf8I1LeR5cB5uS8hkMOzEtk5UtEQeL2zjqC9onBPDiS2A\nMla2E6xk5wGSGiOxXJkbLXd855ROwzhttF8HbQXJ3911wkVMAib3rl7f8i+p\nSo/goDNKvFKCtjYGT0KNCXkg/EMDfFNKk3uInU4dbpJrNNjaN/Cw0KjtLU6V\nka+ktpVCj9ZJRfvGeSrBP9UU1Ma0wsS+mQPDkS0we5zJoI6EeqKYNFsiYArL\n6JgW\r\n=gStG\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIAWyeUoLk2OTyM+zAC2r0CLNIb+rkT5T8LLIlmNezigyAiEA00Yf8R0a9sLpqU3IQmdbo9PYzD0PtIH6WJItSOPrdQA="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.8.11_1625900975113_0.4582659614795248"},"_hasShrinkwrap":false},"0.9.0-next.0":{"name":"hardhat-deploy","version":"0.9.0-next.0","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.1","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"readme":"<h1> hardhat-deploy</h1>\n\n_A [Hardhat](https://hardhat.org) Plugin For Replicable Deployments And Easy Testing_\n\n> **A complete dev template using hardhat-deploy is available here** : https://github.com/wighawag/template-ethereum-contracts\n> It also contains various branches examplifying the capability of hardhat-deploy. Check it out.\n\n- [What is it for ?](#what-is-it-for-)\n- [hardhat-deploy in a nutshell](#hardhat-deploy-in-a-nutshell)\n- [Installation](#installation)\n  - [npm install hardhat-deploy](#npm-install-hardhat-deploy)\n  - [TypeScript support](#typescript-support)\n  - [Migrating existing deployment to hardhat-deploy](#migrating-existing-deployment-to-hardhat-deploy)\n- [Hardhat Tasks Available/Updated](#hardhat-tasks-availableupdated)\n  - [1. hardhat deploy](#1-hardhat-deploy)\n    - [**Options**](#options)\n    - [**Flags**](#flags)\n  - [2. hardhat node](#2-hardhat-node)\n    - [**Options**](#options-1)\n    - [**Flags**](#flags-1)\n  - [3. hardhat test](#3-hardhat-test)\n  - [4. hardhat etherscan-verify](#4-hardhat-etherscan-verify)\n    - [**Options**](#options-2)\n  - [5. hardhat sourcify](#5-hardhat-sourcify)\n    - [**Options**](#options-3)\n  - [6. hardhat export](#6-hardhat-export)\n    - [**Options**](#options-4)\n- [Hardhat Environment Extensions](#hardhat-environment-extensions)\n- [Configuration](#configuration)\n  - [**1. namedAccounts (ability to name addresses)**](#1-namedaccounts-ability-to-name-addresses)\n  - [**2. extra hardhat.config networks' options**](#2-extra-hardhatconfig-networks-options)\n    - [`live`](#live)\n    - [`saveDeployments`](#savedeployments)\n    - [`tags`](#tags)\n    - [`deploy`](#deploy)\n    - [`companionNetworks`](#companionnetworks)\n  - [**3. extra hardhat.config paths' options**](#3-extra-hardhatconfig-paths-options)\n  - [Importing deployment from other projects (with truffle support)](#importing-deployment-from-other-projects-with-truffle-support)\n  - [Access to Artifacts (non-deployed contract code and abi)](#access-to-artifacts-non-deployed-contract-code-and-abi)\n- [How to Deploy Contracts](#how-to-deploy-contracts)\n  - [The `deploy` Task](#the-deploy-task)\n  - [Deploy Scripts](#deploy-scripts)\n    - [An example of a deploy script :](#an-example-of-a-deploy-script-)\n  - [The `deployments` field](#the-deployments-field)\n    - [`deployments.deploy(<name>, options)`](#deploymentsdeployname-options)\n- [Handling contract using libraries](#handling-contract-using-libraries)\n- [Exporting Deployments](#exporting-deployments)\n- [Deploying and Upgrading Proxies](#deploying-and-upgrading-proxies)\n- [Builtin-In Support For Diamonds (EIP2535)](#builtin-in-support-for-diamonds-eip2535)\n- [Testing Deployed Contracts](#testing-deployed-contracts)\n  - [Creating Fixtures](#creating-fixtures)\n- [More Information On Hardhat Tasks](#more-information-on-hardhat-tasks)\n  - [**1. node task**](#1-node-task)\n  - [**2. test task**](#2-test-task)\n  - [**3. run task**](#3-run-task)\n  - [**4. console task**](#4-console-task)\n- [Deploy Scripts: Tags And Dependencies](#deploy-scripts-tags-and-dependencies)\n\n## What is it for ?\n\nThis [hardhat](https://hardhat.org) plugin adds a mechanism to deploy contracts to any network, keeping track of them and replicating the same environment for testing.\n\nIt also adds a mechanism to associate names to addresses, so test and deployment scripts can be reconfigured by simply changing the address a name points to, allowing different configurations per network. This also results in much clearer tests and deployment scripts (no more `accounts[0]` in your code).\n\nThis plugin contains a lot more features too, all geared toward a better developer experience :\n\n- chain configuration export\n- listing deployed contracts' addresses and their abis (useful for webapps)\n- library linking at time of deployment.\n- deterministic deployment across networks.\n- support for specific deploy script per network (L1 vs L2 for example)\n- ability to access deployment from \"companion\" networks\n- deployment dependency system (allowing you to only deploy what is needed).\n- deployment retrying (by saving pending tx): so you can feel confident when making a deployment that you can always recover.\n- deployments as test fixture using `evm_snapshot` to speed up testing.\n- ability to create your own test fixture that automatically benefits from `evm_snapshot`'s tests speed-up boost\n- combined with [hardhat-deploy-ethers](https://github.com/wighawag/hardhat-deploy-ethers) it has the ability to get ethers contract instance by name (like `await ethers.getContract(\"ContractName\")`).\n- importing artifact from external sources (like npm packages), including [truffle](https://www.trufflesuite.com/truffle) support.\n- importing deployments from external sources (like npm packages)\n- ability to log information in `deploy` mode only (while in test the console remains clean).\n- contains helpers to read and execute transaction on deployed contract referring to them by name.\n- These helpers contains options to auto mine on dev network (to speed up test deployments).\n- save metadata of deployed contract so they can always be fully verified, via [sourcify](https://sourcify.dev) or [etherscan](https://etherscan.io).\n- ability to submit contract source to etherscan and sourcify for verification at any time. (Because **hardhat-deploy** will save all the necessary info, it can be executed at any time.)\n- support harhdat's fork feature so deployment can be accessed even when run through fork.\n- named accounts are automatically impersonnated too, so you can perform tx as if you had their private key.\n- proxy deployment with ability to upgrade them transparently, only if code changes.\n- this include support for [openzeppelin](https://openzeppelin.com) transparent proxies\n- diamond deployment with facets, allowing you to focus on what the new version will be. It will generate the diamondCut necessary to reach the new state.\n- watch and deploy: **hardhat-deploy** can watch both your deploy script and contract code and redeploy on changes.\n- HCR (Hot Contract Replacement): the watch feature combined with proxy or diamond, gives you an experience akin to frontend Hot Module Replacement: once your contract changes, the deployment is executed and your contract retains the same address and same state, allowing you to tweak your contracts while debugging your front-end.\n\n## hardhat-deploy in a nutshell\n\nBefore going into the details, here is a very simple summary of the basic feature of **hardhat-deploy**.\n\n**hardhat-deploy** allows you to write [`deploy scripts`](#deploy-scripts) in the `deploy` folder. Each of these files that look as follows will be executed in turn when you execute the following task: `hardhat --network <networkName> deploy`\n\n```js\n// deploy/00_deploy_my_contract.js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('MyContract', {\n    from: deployer,\n    args: ['Hello'],\n    log: true,\n  });\n};\nmodule.exports.tags = ['MyContract'];\n```\n\nFurthermore you can also ensure these scripts are executed in test too by calling `await deployments.fixture(['MyContract'])` in your test.\nThis is optimized, so if multiple tests use the same contract, the deployment will be executed once and each test will start with the exact same state.\n\nThis is a huge benefit for testing since you are not required to replicate the deployment procedure in your tests. The tag feature (as seen in the script above) and [dependencies](#deploy-scripts-tags-and-dependencies) will also make your life easier when writing complex deployment procedures.\n\nYou can even group deploy scripts in different sub folder and ensure they are executed in their logical order.\n\nFurthermore hardhat-deploy can also support a multi-chain settings like L1, L2 with multiple deploy folder specific to each network.\n\n**All of this can also be bundled in a npm package so user of hardhat-deploy can reuse your deployment procedure and get started integrating with your project locally.**\n\nThere is a tutorial covering the basics here : https://github.com/wighawag/tutorial-hardhat-deploy\n\n## Installation\n\n### npm install hardhat-deploy\n\n```bash\nnpm install -D hardhat-deploy\n```\n\nAnd add the following statement to your `hardhat.config.js`:\n\n```js\nrequire('hardhat-deploy');\n```\n\nif you use `ethers.js` we recommend you also install `hardhat-deploy-ethers` which add extra features to access deployments as ethers contract.\n\nSince `hardhat-deploy-ethers` is a fork of `@nomiclabs/hardhat-ethers` and that other plugin might have an hardcoded dependency on `@nomiclabs/hardhat-ethers` the best way to install `hardhat-deploy-ethers` and ensure compatibility is the following:\n\n```bash\nnpm install --save-dev  @nomiclabs/hardhat-ethers@npm:hardhat-deploy-ethers ethers\n```\n\nWhich means you then need to do `require(\"@nomiclabs/hardhat-ethers\")` instead of `require(\"hardhat-deploy-ethers\")` in your `hardhat.config.js` file.\n\nMore details on `hardhat-deploy-ethers` repo : https://github.com/wighawag/hardhat-deploy-ethers#readme\n\n### TypeScript support\n\nWith hardhat the tsconfig.json is optional.\n\nBut if you add folders to the `include` field in `tsconfig.json`, you ll also need to include `hardhat.config.ts` like :\n\n`include\": [\"./hardhat.config.ts\", \"./scripts\", \"./deploy\", \"./test\"]`\n\nfor deploy script (see below) you can write them this way to benefit from typing :\n\n```ts\nimport {HardhatRuntimeEnvironment} from 'hardhat/types';\nimport {DeployFunction} from 'hardhat-deploy/types';\n\nconst func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {\n  // code here\n};\nexport default func;\n```\n\nSee a template that uses **hardhat-deploy** here : https://github.com/wighawag/template-ethereum-contracts\n\nThis repo has also some examples branch that exemplify specific features, like the forking testing here : https://github.com/wighawag/template-ethereum-contracts/tree/examples/fork-test\n\n### Migrating existing deployment to hardhat-deploy\n\n> Only needed for existing project that already deployed contracts and has the deployment information available **(at minimum, address and abi)**\n\nYou might want to switch your current deployment process to use **hardhat-deploy**. In that case you probably have some deployments saved elsewhere.\n\nIn order to port them to **hardhat-deploy**, you'll need to create one `.json` file per contract in the `deployments/<network>` folder (configurable via [paths config](#extra-paths-config)).\n\nThe network folder is simply the hardhat network name (as configured in hardhat.config.js) (accessible at runtime via `hre.network.name`).\nSuch folder need to have a file named `.chainId` containing the chainId as decimal.\n\nFor example for network named \"rinkeby\" (for the corresponding network) the file `deployments/rinkeby/.chainId` would be\n\n```\n4\n```\n\nNote, prior to hardhat 0.6 the chainId was appended to the folder name (expect for some known network name). This has changed and upgrading to 0.6 will require you to change the folder name and add the '.chainId' file.\n\nEach contract file must follow this type (as defined in [types.ts](types.ts)) :\n\n```ts\nexport interface Deployment {\n  address: Address;\n  abi: ABI;\n  receipt?: Receipt;\n  transactionHash?: string;\n  history?: Deployment[];\n  implementation?: string;\n  args?: any[];\n  linkedData?: any;\n  solcInputHash?: string;\n  metadata?: string;\n  bytecode?: string;\n  deployedBytecode?: string;\n  libraries?: Libraries;\n  userdoc?: any;\n  devdoc?: any;\n  methodIdentifiers?: any;\n  diamondCut?: FacetCut[];\n  facets?: Facet[];\n  storageLayout?: any;\n  gasEstimates?: any;\n}\n```\n\nAs you can see, only abi and address are mandatory. But having the other fields allow more feature. For example, metadata and args allow you to benefit from contract code verification.\n\nFor Receipt, the following type is expected:\n\n```ts\nexport type Receipt = {\n  from: string;\n  transactionHash: string;\n  blockHash: string;\n  blockNumber: number;\n  transactionIndex: number;\n  cumulativeGasUsed: string;\n  gasUsed: string;\n  contractAddress?: string;\n  to?: string;\n  logs?: Log[];\n  events?: any[];\n  logsBloom?: string;\n  byzantium?: boolean;\n  status?: number;\n  confirmations?: number;\n};\n```\n\nHere is an example:\n\nLet sey you have:\n\n- 2 Contract named Greeter and Registry deployed on rinkeby\n- 1 contract named Greeter on mainnet\n- 2 Contract named Greeter and Registry deployed on a network named rinkeby2\n\nYou would get the following folder structure:\n\n```\ndeployments/\n  mainnet/\n    .chainId\n    Greeter.json\n  rinkeby/\n    .chainId\n    Greeter.json\n    Registry.json\n  rinkeby2/\n    .chainId\n    Greeter.json\n    Registry.json\n```\n\nThe reason why **hardhat-deploy** save chainId in the `.chainId` file is both for\n\n- safety: so that if you were to change the network name to point to a different chain, it would not attempt to read the wrong folder and assume that a contract has been deployed while it has not.\n- ability to know the chainId without requring to be connected to a node (and so not dependent on hardhat.config.js settings). Useful for `export` task.\n\n---\n\n## Hardhat Tasks Available/Updated\n\nhardhat deploy add several task to hardhat. It also modify existing one, adding new options and new behavior. All of these are described here:\n\n---\n\n### 1. hardhat deploy\n\n---\n\nThis plugin adds the _deploy_ task to Hardhat.\n\nThis task will execute the scripts in the `deploy` folder and save the contract deployments to disk. These deployments are supposed to be saved for example in a git repository. This way they can be accessed later. But you are free to save them elsewhere and get them back via your mechanism of choice.\n\nWith the deployment saved, it allows you to deploy a contract only if changes were made.\n\nDeploy scripts (also called Deploy functions) can also perform aribtrary logic.\n\nFor further details on how to use it and write deploy script, see [section](#deploy-scripts) below.\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployments, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice (in wei) to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--reset`: This flag resets the deployments from scratch. Previously deployed contract are not considered and deleted from disk.\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n---\n\n### 2. hardhat node\n\n---\n\nThis plugin modify the _node_ task so that it also execute the deployment script before exposing the server http RPC interface\n\nIt add similar options than the `deploy` task :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--no-reset`: This flag prevent the reseting of the existing deployments. This is usually not desired when running the `node` task as a network is created from scratch and previous deployemnt are irrelevant.\n\n`--show-accounts`: this flag will output the account private keys\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n`--no-deploy` that discard all other options to revert to normal `hardhat node` behavior without any deployment being performed.\n\n> :warning: Note that the deployments are saved as if the network name is `localhost`. This is because `hardhat node` is expected to be used as localhost: You can for example execute `hardhat --network localhost console` after `node` is running. Doing `hardhat --network hardhat console` would indeed not do anything useful. It still take the configuration from `hardhat` in the hardhat.config.js file though.\n\n---\n\n### 3. hardhat test\n\n---\n\nThis plugin adds a flag argument `--deploy-fixture` to the _test_ task which if enabled will run the global deployments fixture before the tests and snapshots it. This will generaly speed up the tests as further test will be able to revert back to the full deployment.\n\n> :warning: Note though that if your test behave differently whether that option is on or not, this most likely mean that your deploy scripts' tags and dependencies are not configured correctly. This is because the global fixture will ensure all contract are deployed while test will usually (for efficiency) ask for a particular tag.\n\n---\n\n### 4. hardhat etherscan-verify\n\n---\n\nThis plugin adds the _etherscan-verify_ task to Hardhat.\n\nThis task will submit the contract source and other info of all deployed contracts to allow etherscan to verify and record the sources.\n\nInstead of using the full solc input, this task will first attempt to send the minimal sources from the metadata.\nBut Etherscan sometime fails due to a bug in solidity compiler (<https://github.com/ethereum/solidity/issues/9573>). As such this task can fallback on full solc input (see option --solc-input). Note that if your contract was deployed with a previous version of **hardhat-deploy**, it might not contains the full information. The issue seems to be fully resolved since solc version 0.8.\n\nThis task will also attempt to automatically find the SPDX license in the source.\n\nTo execute that task, you need to specifiy the network to run against :\n\n```bash\nhardhat --network mainnet etherscan-verify --api-key <apikey>\n```\n\n#### **Options**\n\n`--api-key <api key>`: let you specify your etherscan api key. Alternatively, you can provide it via the env variable `ETHERSCAN_API_KEY` or through the hardhat.config.ts etherscan field:\n\n```js\n{\n  ...\n  etherscan: {\n    apiKey: '<API key>'\n  }\n}\n```\n\n`--license <SPDX license id>`: SPDX license (useful if SPDX is not listed in the sources), need to be supported by etherscan: https://etherscan.io/contract-license-types\n\n`--force-license`: if set, will force the use of the license specified by --license option, ignoring the one in the source (useful for license not supported by etherscan)\n\n`--solc-input`: fallback on solc-input id needed (useful when etherscan fails on the minimum sources, see https://github.com/ethereum/solidity/issues/9573)\n\n`--sleep`: sleep 500ms between each verification, so API rate limit is not exceeded\n\n---\n\n### 5. hardhat sourcify\n\n---\n\nThis plugin adds the _sourcify_ task to Hardhat.\n\nSimilar to `hardhat etherscan-verify` this task will submit the contract source and other info of all deployed contracts to sourcify.\n\n```bash\nhardhat --network mainnet sourcify\n```\n\nLater this task might instead pin the metadata to ipfs, so sourcify can automatically verify them.\n\n#### **Options**\n\n`--endpoint <endpoint>`: specify the sourcify endpoint, default to https://sourcify.dev/server/\n\n`--write-failing-metadata`: if set and the sourcify task fails to verify, the metadata file will be written to disk, so you can more easily figure out what has gone wrong.\n\n---\n\n### 6. hardhat export\n\n---\n\nThis plugin adds the _export_ task to Hardhat.\n\nThis task will export the contract deployed (saved in `deployments` folder) to a file with a simple format containing only contract addresses and abi, useful for web apps.\n\nOne of the following options need to be set for this task to have any effects :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\nThis last option has some limitations, when combined with the use of external deployments (see [Configuration](#configuration)). If such external deployments were using older version of **hardhat-deploy** or truffle, the chainId might be missing. In order for these to be exported, the hardhat network config need to explicity state the chainId in the `networks` config of `hardhat.config.js`.\n\n---\n\n---\n\n## Hardhat Environment Extensions\n\nThis plugin extends the Hardhat Runtime Environment by adding 4 fields:\n\n- `getNamedAccounts: () => Promise<{ [name: string]: string }>`: a function returning an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [Configuration](#configuration)).\n\n- `getUnnamedAccounts: () => Promise<string[]}>`: accounts which has no names, useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`: contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId(): Promise<string>`: offer an easy way to fetch the current chainId.\n\n---\n\n---\n\n## Configuration\n\n---\n\n### **1. namedAccounts (ability to name addresses)**\n\n---\n\nThis plugin extends the `HardhatConfig`'s object with an optional `namedAccounts` field.\n\n`namedAccounts` allows you to associate names to addresses and have them configured per chain.\nThis allows you to have meaningful names in your tests while the addresses match to multi sig in real network for example.\n\n```js\n{\n    namedAccounts: {\n        deployer: {\n            default: 0, // here this will by default take the first account as deployer\n            1: 0, // similarly on mainnet it will take the first account as deployer. Note though that depending on how hardhat network are configured, the account 0 on one network can be different than on another\n            4: '0xA296a3d5F026953e17F472B497eC29a5631FB51B', // but for rinkeby it will be a specific address\n            \"goerli\": '0x84b9514E013710b9dD0811c9Fe46b837a4A0d8E0', //it can also specify a specific netwotk name (specified in hardhat.config.js)\n        },\n        feeCollector:{\n            default: 1, // here this will by default take the second account as feeCollector (so in the test this will be a different account than the deployer)\n            1: '0xa5610E1f289DbDe94F3428A9df22E8B518f65751', // on the mainnet the feeCollector could be a multi sig\n            4: '0xa250ac77360d4e837a13628bC828a2aDf7BabfB3', // on rinkeby it could be another account\n        }\n    }\n}\n```\n\n<!-- You can also specify addresses with the `ledger://` prefix. In which case the account fetched will still be the corresponding address, but behind the scene, the transaction will be created via the hardware waller. Currently the feature is not working very well though and better support is needed. -->\n\n---\n\n### **2. extra hardhat.config networks' options**\n\n---\n\n**hardhat-deploy** add 5 new fields to `networks` configuration\n\n#### `live`\n\nthis is not used internally but is useful to perform action on a network whether it is a live network (rinkeby, mainnet, etc) or a temporary one (localhost, hardhat). The default is true (except for localhost and hardhat where the default is false).\n\n#### `saveDeployments`\n\nthis tell whether **hardhat-deploy** should save the deployments to disk or not. Default to true, except for the hardhat network.\n\n#### `tags`\n\nnetwork can have tags to represent them. The config is an array and at runtime the hre.network.tags is an object whose fields (the tags) are set to true.\n\nThis is useful to conidtionaly operate on network based on their use case.\n\nExample:\n\n```js\n{\n  networks: {\n    localhost: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"local\"]\n    },\n    hardhat: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"test\", \"local\"]\n    },\n    rinkeby: {\n      live: true,\n      saveDeployments: true,\n      tags: [\"staging\"]\n    }\n  }\n}\n```\n\n#### `deploy`\n\nthe deploy field override the paths.deploy option and let you define a set of folder containing the deploy scripts to be executed for this network.\n\nYou can thus have one network that will be executing L1 deployment and other L2 deployments, etc...\n\nYou could also have a folder that deploy contracts that are live on mainnet but that you need to replicate for your test or local network.\n\n#### `companionNetworks`\n\nthe companionNetworks field is an object whose key is any name you desire and the value is the name of a network that will be accessible inside the deploy script. For example:\n\n```js\n{\n  ...\n  networks: {\n    optimism: {\n      url: 'http://127.0.0.1:8545',\n      ovm: true,\n      companionNetworks: {\n        l1: 'localhost',\n      },\n    }\n  }\n  ...\n}\n```\n\nBy using name you can have the same deploy script used in different set of network.\n\nFor your test you could have the companion networks pointing to the same hardhat network, for test deployment, you could have rinkeby acting like your l2 while goerli act as your l1.\n\nAn example repo that show case a multi-network setup with optimism can be found here : https://github.com/wighawag/template-ethereum-contracts/tree/examples/optimism\n\ndeploy script can then access the network and its deployment as follow :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  const OVM_L1ERC20Gateway = await hre.companionNetworks['l1'].deployments.get(\n    'OVM_L1ERC20Gateway'\n  ); // layer 1\n\n  await execute(\n    'SimpleERC20_OVM',\n    {from: deployer, log: true},\n    'init',\n    OVM_L1ERC20Gateway.address\n  );\n};\n```\n\n---\n\n### **3. extra hardhat.config paths' options**\n\n---\n\n`hardhat-deploy` also adds fields to `HardhatConfig`'s `ProjectPaths` object.\n\nHere is an example showing the default values :\n\n```js\n{\n    paths: {\n        deploy: 'deploy',\n        deployments: 'deployments',\n        imports: 'imports'\n    }\n}\n```\n\nThe `deploy` folder is expected to contains the deploy script that are executed upon invocation of `hardhat deploy` or `hardhat node`.\nIt can also be an array of folder path.\n\nThe `deployments` folder will contains the resulting deployments (contract addresses along their abi, bytecode, metadata...). One folder per network and one file per contract.\n\nThe `imports` folder is expected to contains artifacts that were pre-compiled. Useful if you want to upgrade to a new solidity version but want to keep using previously compiled contracts. The artifact is the same format as normal hardhat artifact, so you can easily copy them over, before switching to a new compiler version.\n\n> This is less useful now that hardhat support multiple solidity compiler at once.\n\n---\n\n### Importing deployment from other projects (with truffle support)\n\n`hardhat-deploy` also add the `external` field to `HardhatConfig`\n\nSuch field allows to specify paths for external artifacts or **deployments**.\n\nThe external object has 2 fields:\n\n```js\n{\n    external: {\n        contracts: [\n          {\n            artifacts: \"node_modules/@cartesi/arbitration/export/artifacts\",\n            deploy: \"node_modules/@cartesi/arbitration/export/deploy\"\n          },\n          {\n            artifacts: \"node_modules/someotherpackage/artifacts\",\n          }\n        ],\n        deployments: {\n          rinkeby: [\"node_modules/@cartesi/arbitration/build/contracts\"],\n        },\n    }\n}\n```\n\nThe `contracts` field specify an array of object which itself have 2 fields.\n\n- `artifacts`: (mandatory) it is a path to an artifact folder. This support both hardhat and truffle artifacts.\n- `deploy`: (optional) it specifies a path to a folder where reside deploy script. The deploy scripts have only access to the artifact specified in the artifacts field. This allow project to share their deployment procedure. A boon for developer aiming at integrating it as they can get the contracts to be deployed for testing locally.\n\nThe `deployments` fields specify an object whose field nasme are the hardhat network and the value is an array of path to look for deployments. It supports both **hardhat-deploy** and truffle formats.\n\n---\n\n### Access to Artifacts (non-deployed contract code and abi)\n\nArtifacts in hardhat terminology represent a compiled contract (not yet deployed) with at least its bytecode and abi.\n\n`hardhat-deploy` gives can access to these artifact via the `deployments.getArtifact` function :\n\n```js\nconst {deployments} = require('hardhat');\nconst artifact = await deployments.getArtifact(artifactName);\n```\n\nWith the `hardhat-deploy-ethers` plugin you can get an artifact as an ethers contract factory, ready to be deployed, via the following:\n\n```js\nconst {deployments, ethers} = require('hardhat');\nconst factory = await ethers.getContractFactory(artifactName);\n```\n\n> Note that the artifact's files need to be either in `artifacts` folder that hardhat generate on compilation or in the `imports` folder where you can store contracts compiled elsewhere. They can also be present in the folder specified in `external.artifacts` see [Importing deployment from other projects](#importing-deployment-from-other-projects-with-truffle-support)\n\n---\n\n---\n\n## How to Deploy Contracts\n\n---\n\n### The `deploy` Task\n\n`hardhat --network <networkName> deploy [options and flags]`\n\nThis is a new task that the `hardhat-deploy` adds. As the name suggests it deploys contracts.\nTo be exact it will look for files in the folder `deploy` or whatever was configured in `paths.deploy`, see [paths config](#extra-paths-config)\n\nIt will scan for files in alphabetical order and execute them in turn.\n\n- it will `require` each of these files and execute the exported function with the HRE as argument\n\nTo specify the network, you can use the builtin hardhat argument `--network <network name>` or set the env variable `HARDHAT_NETWORK`\n\n> :warning: Note that running `hardhat deploy` without specifying a network will use the default network. If the default network is hardhat (the default's default) then nothing will happen as a result as everything happens in memory, but this can be used to ensure the deployment is without issues.\n\n---\n\n### Deploy Scripts\n\nThe deploy scripts need to be of the following type :\n\n```ts\nexport interface DeployFunction {\n  (env: HardhatRuntimeEnvironment): Promise<void | boolean>;\n  skip?: (env: HardhatRuntimeEnvironment) => Promise<boolean>;\n  tags?: string[];\n  dependencies?: string[];\n  runAtTheEnd?: boolean;\n  id?: string;\n}\n```\n\nThe skip function can be used to skip executing the script under whatever condition. It simply need to resolve a promise to true.\n\nThe tags is a list of string that when the _deploy_ task is executed with, the script will be executed (unless it skips). In other word if the deploy task is executed with a tag that does not belong to that script, that script will not be executed unless it is a dependency of a script that does get executed.\n\nThe dependencies is a list of tag that will be executed if that script is executed. So if the script is executed, every script whose tag match any of the dependencies will be executed first.\n\nThe `runAtTheEnd` is a boolean that if set to true, will queue that script to be executed after all other scripts are executed.\n\nThese set of fields allow more flexibility to organize the scripts. You are not limited to alphabetical order and you can even organise deploy script in sub folders.\n\nFinally the function can return true if it wishes to never be executed again. This can be usfeul to emulate migration scripts that are meant to be executed only once. Once such script return true (async), the `id` field is used to track execution and if that field is not present when the script return true, it will fails.\n\nIn other words, if you want a particular deploy script to run only once, it needs to both return true (async) and have an `id` set.\n\nIn any case, as a general advice every deploy function should be idempotent. This is so they can always recover from failure or pending transaction. This is what underpin most of hardhat-deploy philosophy.\n\nThis is why the `hre.deployments.deploy` function will by default only deploy if the contract code has changed, making it easier to write idempotent script.\n\n#### An example of a deploy script :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  // the following will only deploy \"GenericMetaTxProcessor\" if the contract was never deployed or if the code changed since last deployment\n  await deploy('GenericMetaTxProcessor', {\n    from: deployer,\n    gasLimit: 4000000,\n    args: [],\n  });\n};\n```\n\nAs you can see the HRE passed in has 4 new fields :\n\n- `getNamedAccounts` is a function that returns a promise to an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [`namedAccounts`](#namedaccounts)).\n\n- `getUnnamedAccounts` is a function that return a promise to an array of accounts which were not named (see [`namedAccounts`](#namedaccounts)). It is useful for tests where you want to be sure that the account has no speicifc role in the system (no token given, no admin access, etc...).\n\n- `getChainId` is a function which return a promise for the chainId, as convenience\n\n- `deployments` is an object which contains functions to access past deployments or to save new ones, as well as helpers functions.\n\nThat latter field contains for example the `deploy` function that allows you to deploy contract and save them. It contains a lot more functions though :\n\n---\n\n### The `deployments` field\n\nThe deployments field contains several helpers function to deploy contract but also execute transaction.\n\n```ts\nexport interface DeploymentsExtension {\n  deploy(name: string, options: DeployOptions): Promise<DeployResult>; // deploy a contract\n  diamond: {\n    // deploy diamond based contract (see section below)\n    deploy(name: string, options: DiamondOptions): Promise<DeployResult>;\n  };\n  deterministic( // return the determinsitic address as well as a function to deploy the contract, can pass the `salt` field in the option to use different salt\n    name: string,\n    options: Create2DeployOptions\n  ): Promise<{\n    address: Address;\n    deploy(): Promise<DeployResult>;\n  }>;\n  fetchIfDifferent( // return true if new compiled code is different than deployed contract\n    name: string,\n    options: DeployOptions\n  ): Promise<{differences: boolean; address?: string}>;\n  save(name: string, deployment: DeploymentSubmission): Promise<void>; // low level save of deployment\n  get(name: string): Promise<Deployment>; // fetch a deployment by name, throw if not existing\n  getOrNull(name: string): Promise<Deployment | null>; // fetch deployment by name, return null if not existing\n  getDeploymentsFromAddress(address: string): Promise<Deployment[]>;\n  all(): Promise<{[name: string]: Deployment}>; // return all deployments\n  getArtifact(name: string): Promise<Artifact>; // return a hardhat artifact (compiled contract without deployment)\n  getExtendedArtifact(name: string): Promise<ExtendedArtifact>; // return a extended artifact (with more info) (compiled contract without deployment)\n  run( // execute deployment scripts\n    tags?: string | string[],\n    options?: {\n      resetMemory?: boolean;\n      deletePreviousDeployments?: boolean;\n      writeDeploymentsToFiles?: boolean;\n      export?: string;\n      exportAll?: string;\n    }\n  ): Promise<{[name: string]: Deployment}>;\n  fixture( // execute deployment as fixture for test // use evm_snapshot to revert back\n    tags?: string | string[],\n    options?: {fallbackToGlobal?: boolean; keepExistingDeployments?: boolean}\n  ): Promise<{[name: string]: Deployment}>;\n  createFixture<T, O>( // execute a function as fixture using evm_snaphost to revert back each time\n    func: FixtureFunc<T, O>,\n    id?: string\n  ): (options?: O) => Promise<T>;\n  log(...args: any[]): void; // log data only ig log enabled (disabled in test fixture)\n\n  execute( // execute function call on contract\n    name: string,\n    options: TxOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<Receipt>;\n  rawTx(tx: SimpleTx): Promise<Receipt>; // execute a simple transaction\n  catchUnknownSigner( // you can wrap other function with this function and it will catch failure due to missing signer with the details of the tx to be executed\n    action: Promise<any> | (() => Promise<any>),\n    options?: {log?: boolean}\n  ): Promise<null | {\n    from: string;\n    to?: string;\n    value?: string;\n    data?: string;\n  }>;\n  read( // make a read-only call to a contract\n    name: string,\n    options: CallOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<any>;\n  read(name: string, methodName: string, ...args: any[]): Promise<any>;\n  // rawCall(to: Address, data: string): Promise<any>; // TODO ?\n}\n```\n\n---\n\n#### `deployments.deploy(<name>, options)`\n\n---\n\nThe `deploy` function, as mentioned above, allows you to deploy a contract and save it under a specific name.\n\nThe deploy function expect 2 parameters: one for the name and one for the options\n\nSee below the full list of fields that the option parameter allows and requires:\n\n```ts\nexport interface DeployOptions = {\n  from: string; // address (or private key) that will perform the transaction. you can use `getNamedAccounts` to retrived the address you want by name.\n  contract?: // this is an optional field. If not specified it defaults to the contract with the same name as the first parameter\n    | string // this field can be either a string for the name of the contract\n    | { // or abi and bytecode\n        abi: ABI;\n        bytecode: string;\n        deployedBytecode?: string;\n      };\n  args?: any[]; // the list of argument for the constructor (or the upgrade function in case of proxy)\n  skipIfAlreadyDeployed?: boolean; // if set it to true, will not attempt to deploy even if the contract deployed under the same name is different\n  log?: boolean; // if true, it will log the result of the deployment (tx hash, address and gas used)\n  linkedData?: any; // This allow to associate any JSON data to the deployment. Useful for merkle tree data for example\n  libraries?: { [libraryName: string]: Address }; // This let you associate libraries to the deployed contract\n  proxy?: boolean | string | ProxyOptions; // This options allow to consider your contract as a proxy (see below for more details)\n\n  // here some common tx options :\n  gasLimit?: string | number | BigNumber;\n  gasPrice?: string | BigNumber;\n  value?: string | BigNumber;\n  nonce?: string | number | BigNumber;\n\n  estimatedGasLimit?: string | number | BigNumber; // to speed up the estimation, it is possible to provide an upper gasLimit\n  estimateGasExtra?: string | number | BigNumber; // this option allow you to add a gas buffer on top of the estimation\n\n  autoMine?: boolean; // this force a evm_mine to be executed. this is useful to speed deployment on test network that allow to specify a block delay (ganache for example). This option basically skip the delay by force mining.\n  deterministicDeployment? boolean | string; // if true, it will deploy the contract at a deterministic address based on bytecode and constuctor arguments. The address will be the same across all network. It use create2 opcode for that, if it is a string, the string will be used as the salt.\n};\n```\n\n---\n\n---\n\n## Handling contract using libraries\n\nIn the deploy function, one of the `DeployOptions` field is the `libraries` field. It allows you to associate external contract as libraries at the time of deployment.\n\nFirst, you have deploy the library using the `deploy` function, then when we deploy a contract that needs the linked library, we can pass the deployed library name and address in as an argument to the `libraries` object.\n\nFirst step: deploy the library:\n\n```js\nconst exampleLibrary = await deploy(\"ExampleLibary\", {\n    from: <deployer>\n});\n\n```\n\nExampleLibrary is now deployed to whatever network was chosen (`hardhat deploy --network <networkName>`)\n\nFor example, if we are deploying on Rinkeby, this library will get deployed on rinkeby, and the `exampleLibrary` variable will be a deployment object that contains the abi as well as the deployed address for the contract.\n\nNow that the library is deployed, we can link it in our next deployed contract.\n\n```js\nconst example = await deploy(\"Example\", {\n    from: <deployer>\n    args: [\"example string argument for the 'Example' contract constructor\"],\n    libraries: {\n        ExampleLibrary: exampleLibrary.address\n    }\n});\n\n```\n\nThis `libraries` object takes the name of the library, and its deployed address on the network. Multiple libraries can be passed into the `libraries` object.\n\n---\n\n---\n\n## Exporting Deployments\n\nApart from deployments saved in the `deployments` folder which contains all information available about the contract (compile time data + deployment data), `hardhat-deploy` allows you to export lightweight files.\n\nThese can be used for example to power your frontend with contract's address and abi.\n\nThis come into 2 flavors.\n\nThe first one is exported via the `--export <file>` option and follow the following format :\n\n```ts\nexport interface Export {\n  chainId: string;\n  name: string;\n  contracts: {[name: string]: ContractExport};\n}\n```\n\nwhere name is the name of the network configuration chosen (see hardhat option `--network`)\n\nThe second one is exported via the `--export-all <file>` option and follow the following format :\n\n```ts\nexport type MultiExport = {\n  [chainId: string]: {[name: string]: Export};\n};\n```\n\nAs you see the second format include the previous. While in most case you'll need the single export where your application will support only one network, there are case where your app would want to support multiple networks at nonce. This second format allow for that.\n\nFurthermore as hardhat support multiple network configuration for the same network (rinkeby, mainnet...), the export-all format will contains each of them grouped by their chainId.\n\n---\n\n---\n\n## Deploying and Upgrading Proxies\n\nAs mentioned above, the deploy function can also deploy a contract through a proxy. It can be done without modification of the contract as long as its number of constructor arguments matches the proxy initialization/update function.\n\nThe default Proxy is both ERC-1967 and ERC-173 Compliant, but other proxy can be specified, like openzeppelin transparent proxies.\n\nCode for the default Proxy can be found [here](solc_0.7/proxy/EIP173Proxy.sol).\n\nTo perform such proxy deployment, you just need to invoke the deploy function with the following options : `{..., proxy: true}`\n\nSee example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: true,\n  });\n};\n```\n\nYou can also set it to `proxy: \"<upgradeMethodName>\"` in which case the function `<upgradeMethodName>` will be executed upon upgrade.\nthe `args` field will be then used for that function instead of the contructor. It is also possible to then have a constructor with the same arguments and have the proxy be disabled. It can be useful if you want to have your contract as upgradeable in a test network but be non-upgradeable on the mainnet.\n\nSee example :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  network,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: network.live ? false : 'postUpgrade',\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nThe proxy option can also be an object which can set the specific owner that the proxy is going to be managed by.\n\nSee example:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: {\n      owner: greeterOwner,\n      methodName: 'postUpgrade',\n    },\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nNote that for the second invokation, this deployment will not be executed from the specified `from: deployer` as otherwise these tx will always fails. It will instead be automatically executed from the proxy's current owner (in that case : `greeterOwner`)\n\nNow, it is likely you do not want to locally handle the private key / mnemonic of the account that manage the proxy or it could even be that the `greeterOwner` in question is a multi sig. As such that second invocation will throw an error as it cannot find a local signer for it.\n\nThe error will output the necessary information to upgrade the contract but `hardhat-deploy` comes also with a utility function for such case: `deployments.catchUnknwonSigner` which will catch the error and output to the console the necessary information while continuing to next step.\n\nHere is the full example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy, catchUnknownSigner} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await catchUnknownSigner(\n    deploy('Greeter', {\n      from: deployer,\n      proxy: {\n        owner: greeterOwner,\n        methodName: 'postUpgrade',\n      },\n      args: ['arg1', 2, 3],\n    })\n  );\n  // you could pause the deployment here and wait for input to continue\n};\n```\n\nThe full proxy options is as follow:\n\n```ts\ntype ProxyOptionsBase = {\n  owner?: Address; // this set the owner of the proxy. further upgrade will need to be executed from that owner\n  upgradeIndex?: number; // allow you to breakdown your upgrades into separate deploy scriot, each with their own index. A deploy call with a specific upgradeIndex will be executed only once, only if the current upgradeIndex is one less.\n  proxyContract?: // default to \"EIP173Proxy\". See below for more details\n  string | ArtifactData;\n  viaAdminContract?: // allow to specify a contract that act as a middle man to perform upgrades. Useful and Recommended for Transparent Proxies\n  | string\n    | {\n        name: string;\n        artifact?: string | ArtifactData;\n      };\n};\n\nexport type ProxyOptions =\n  | (ProxyOptionsBase & {\n      methodName?: string; // method to be executed when the proxy is deployed for the first time or when the implementation is modified. Use the deployOptions args field for arguments\n    })\n  | (ProxyOptionsBase & {\n      execute?:\n        | {\n            methodName: string; // method to be executed when the proxy is deployed for the first time or when the implementation is modified.\n            args: any[];\n          }\n        | {\n            init: {\n              methodName: string; // method to be executed when the proxy is deployed\n              args: any[];\n            };\n            onUpgrade?: {\n              methodName: string; // method to be executed when the proxy is upgraded (not first deployment)\n              args: any[];\n            };\n          };\n    });\n```\n\nThe `proxyContract` field allow you to specify your own Proxy contract. If it is a string, it will first attempt to get an artifact with that name. If not found it will fallback on the following if\n\nit matches:\n\n- `EIP173Proxy`: use the default Proxy that is EIP-173 compliant\n\n- `EIP173ProxyWithReceive`: Same as above except that the proxy contains a receive hook to accept empty ETH payment.\n\n- `OpenZeppelinTransparentProxy`: Use Openzeppelin Transparent Proxy (slightly modified as openzeppelin's one hardcode the msg.sender as first owner, see code [here](solc_0.7\\openzeppelin\\proxy\\TransparentUpgradeableProxy.sol))\n  When this option is chosen, the `DefaultProxyAdmin` is also used as admin since Transparent Proxy kind of need an intermediarry contract for administration. This can be configured via the `viaAdminContract` option\n\n- `OptimizedTransparentProxy`: This contract is similar to above, except that it is optimized to not require storage read for the admin on every call.\n\n## Builtin-In Support For Diamonds (EIP2535)\n\nThe deployments field also expose the diamond field: `hre.deployments.diamond` that let you deploy [Diamonds](https://eips.ethereum.org/EIPS/eip-2535) in an easy way.\n\nInstead of specifying the facets to cut out or cut in, which the diamond contract expects, you specify the facets you want to end up having on the deployed contract.\n\n`diamond.deploy` expect the facet as names. The names represent contract to be deployed as facet. In future version you ll be able to specify deployed contract or artifact object as facet.\n\nTo deploy a contract with 3 facet you can do as follow :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: deployer,\n    owner: diamondAdmin,\n    facets: ['Facet1', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nif you then later execute the following script:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: diamondAdmin, // this need to be the diamondAdmin for upgrade\n    owner: diamondAdmin,\n    facets: ['NewFacet', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nThen the NewFacet will be deployed automatically if needed and then the diamondCut will cut Facet1 out and add NewFacet.\n\nNote that if the code for Facet2 and Facet3 changes, they will also be redeployed automatically and the diamondCuts will replace the existing facets with these new ones.\n\nNote that The Diamond contract's code is part of `hardhat-deploy` and contains 3 built-in facet that can be removed manually if desired.\nThese facets are used for ownership, diamondCut and diamond loupe.\n\nThe implementation is the [reference implementation by Nick Mudge](https://github.com/mudgen/diamond-3)\n\nLike normal proxies you can also execute a function at the time of an upgrade.\n\nThis is done by specifying the execute field in the diamond deploy options :\n\n```js\ndiamond.deploy('ADiamondContract', {\n  from: deployer,\n  owner: diamondAdmin,\n  facets: ['NewFacet', 'Facet2', 'Facet3'],\n  execute: {\n    methodName: 'postUpgrade',\n    args: ['one', 2, '0x3'],\n  },\n});\n```\n\nSince the diamond standard has no builtin mechanism to make the deployment of Diamond with function execution, the Diamond when deployed is actually deployed through a special contract, the `Diamantaire` (see code [here](solc_0.7/diamond/Diamantaire.sol)) that act as factory to build Diamond. It uses deterministic deployment for that so, it is transparently managed by `hardhat-deploy`. It also embed the implementation of the builtin facet, removing the need to have different instances of each live.\n\n<!-- The Diamantaire also support the deterministic deployment of Diamonds.\nAn extra field can be passed to the Diamond deployment options : `deterministicSalt`. It has to be a non-zero 32bytes string (in hex format).\nNote that if you want to deploy 2 diamonds with same owner, you'll need 2 different deterministicSalt for them to be 2 separate contracts. -->\n\n## Testing Deployed Contracts\n\nYou can continue using the usual test task :\n\n`hardhat test`\n\nTests can then use the `hre.deployments.fixture` function to run the deployment for the test and snapshot it so that tests don't need to perform all the deployments transaction every time, they simply reuse the snapshot for every test (this leverages `evm_snapshot` and `evm_revert` provided by both `hardhat` and `ganache`). You can for example set them in a `beaforeEach`.\n\nHere is an example of a test :\n\n```js\nconst {deployments} = require('hardhat');\n\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    await deployments.fixture(['Token']);\n    const Token = await deployments.get('Token'); // Token is available because the fixture was executed\n    console.log(Token.address);\n    const ERC721BidSale = await deployments.get('ERC721BidSale');\n    console.log({ERC721BidSale});\n  });\n});\n```\n\nTests can also leverage named accounts for clearer test. Combined with `hardhat-deploy-ethers` plugin, you can write succint test :\n\n```js\nconst {ethers, getNamedAccounts} = require('hardhat');\n\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    await deployments.fixture(['Token']);\n    const {tokenOwner} = await getNamedAccounts();\n    const TokenContract = await ethers.getContract('Token', tokenOwner);\n    await TokenContract.mint(2).then((tx) => tx.wait());\n  });\n});\n```\n\n---\n\n### Creating Fixtures\n\nFurthermore, tests can easily create efficient fixture using `deployments.createFixture`\n\nSee example :\n\n```js\nconst setupTest = deployments.createFixture(async ({deployments, getNamedAccounts, ethers}, options) => {\n  await deployments.fixture(); // ensure you start from a fresh deployments\n  const { tokenOwner } = await getNamedAccounts();\n  const TokenContract = await ethers.getContract(\"Token\", tokenOwner);\n  await TokenContract.mint(10).then(tx => tx.wait()); //this mint is executed once and then `createFixture` will ensure it is snapshotted\n  return {\n    tokenOwner: {\n      address: tokenOwner,\n      TokenContract\n    }\n  };\n};\ndescribe(\"Token\", () => {\n  it(\"testing 1 2 3\", async function() {\n    const {tokenOwner} = await setupTest()\n    await tokenOwner.TokenContract.mint(2);\n  });\n});\n```\n\nWhile this example is trivial, some fixture can requires several transaction and the ability to snapshot them automatically speed up the tests greatly.\n\n---\n\n---\n\n## More Information On Hardhat Tasks\n\n---\n\n### **1. node task**\n\nas mentioned above, the node task is slighly modified and augmented with various flags and options\n\n`hardhat node`\n\nIn particular it adds an argument `--export` that allows you to specify a destination file where the info about the contracts deployed is written.\nYour webapp can then access all contracts information.\n\n---\n\n### **2. test task**\n\n`hardhat test`\n\nthe test task is augmented with one flag argument `--deploy-fixture` that allows to run all deployments in a fixture snapshot before executing the tests. This can speed up the tests that use specific tags as the global fixture take precedence (unless specified).\n\nIn other word tests can use `deployments.fixture(<specific tag>)` where specific tag only deploys the minimal contracts for tests, while still benefiting from global deployment snapshot if used.\n\nIf a test needs the deployments to only include the specific deployment specified by the tag, it can use the following :\n\n```js\ndeployments.fixture('<specific tag>', {fallbackToGlobal: false});\n```\n\nDue to how snapshot/revert works in hardhat, this means that these tests will not benefit from the global fixture snapshot and will have to deploy their contracts as part of the fixture call. This is automatic but means that these tests will run slower.\n\n---\n\n### **3. run task**\n\n`hardhat --network <networkName> run <script>`\n\nThe run task act as before but thanks to the `hre.deployments` field it can access deployed contract :\n\n```js\nconst hre = require('hardhat');\nconst {deployments, getNamedAccounts} = hre;\n\n(async () => {\n  console.log(await deployments.all());\n  console.log({namedAccounts: await getNamedAccounts()});\n})();\n```\n\nYou can also run it directly from the command line as usual.\n\n`HARDHAT_NETWORK=rinkeby node <script>` is the equivalent except it does not load the hardhat environment twice (which the run task does)\n\n---\n\n### **4. console task**\n\n`hardhat console`\n\nThe same applies to the `console` task.\n\n---\n\n## Deploy Scripts: Tags And Dependencies\n\n---\n\nIt is possible to execute only specific parts of the deployments with `hardhat deploy --tags <tags>`\n\nTags represent what the deploy script acts on. In general it will be a single string value, the name of the contract it deploys or modifies.\n\nThen if another deploy script has such tag as a dependency, then when this latter deploy script has a specific tag and that tag is requested, the dependency will be executed first.\n\nHere is an example of two deploy scripts :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const deployResult = await deploy('Token', {\n    from: deployer,\n    args: ['hello', 100],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Token deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Token'];\n```\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const Token = await deployments.get('Token');\n  const deployResult = await deploy('Sale', {\n    from: deployer,\n    contract: 'ERC721BidSale',\n    args: [Token.address, 1, 3600],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Sale deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.dependencies = ['Token']; // this ensure the Token script above is executed first, so `deployments.get('Token')` succeeds\n```\n\nAs you can see the second one depends on the first. This is because the second script depends on a tag that the first script registers as using.\n\nWith that when `hardhat deploy --tags Sale` is executed\n\nthen both scripts will be run, ensuring Sale is ready.\n\nYou can also define the script to run after another script is run by setting `runAtTheEnd` to be true. For example:\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, execute, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer, admin} = namedAccounts;\n  await execute('Sale', {from: deployer}, 'setAdmin', admin);\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.runAtTheEnd = true;\n```\n\nTags can also be used in test with `deployments.fixture`. This allow you to test a subset of the deploy script.\n","readmeFilename":"README.md","gitHead":"f96f725a9f5ac46493a7cc18e95f1fb6258f48c2","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.9.0-next.0","_nodeVersion":"14.16.1","_npmVersion":"6.14.12","dist":{"integrity":"sha512-RRY4ghXswejqredNel5EU9wtuQhmwNLI8KTXS/q4UKeeS8BmKaBEhPNj3uq/mFiuBNYKQbsqRazABkpVi2NDJg==","shasum":"ce5a1331529410268b532cdf3a2fac16400fdc50","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.9.0-next.0.tgz","fileCount":125,"unpackedSize":7584521,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhIMp8CRA9TVsSAnZWagAA9TIQAJOG1B8pgunwWB50Cswz\n2VxBpi+z7y2gi3nC67oQzmJC43W4zyB8GIuV3RgJ9OWZ0m3bszpSdpYHliu8\npeRB1tk3ROXt29SYQanqsScy6u86hn8zDzSdQ0LsvZC1+A/OQB3l1CfaxIWL\noB9sAxvmrycdazQznAhGp1VOaPlS1BO2U13jfwb/55m0CPc9Kow1aLfvIFL2\nqpkBGpQx4li4WBOHd4UURSQt8O/rd2fgLfufOS2vkX1h9KIOnTg/m9wKYtl/\nsjW4lQ+UhdEn+GFnfVA3bcDsYkYXs1xdwVT5HUoUnD/rqhd94o4+DqaK21fZ\nznBADDbwDxYSTbZzKhOxJGNjva9O+zpossrjeccF0uzl0Xtak7NEbzlzuCex\nKR3e+r/bQilhDgiAiKk93fdUAn/yxkENwtx/GifCG8CXuCBWNBqTPcZFTAW7\nD6O4cpE3AmS0moEuZT1hpcLdmX2/W8N9hL0yOVSAZXfMAE99MXcH9V/hZx9M\nKhr/WeEgPbYYmcmEjGBhOp4UncZPUzw/e7ihBlQgoVXFlyPp6FERCv93NCgg\n7CDzJx1+1kUOyrIr26UYHjD+NA2+Z+tPKFcU3j4la1wSrt85izD3Ci0jhShE\n2ZoabVIIFHqRy324IhVepHudR9SJSIj5rL5cigahVCvgiUGKWYlAMxpPS9kQ\nieWU\r\n=JcUI\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCmCmSPzWTucISN4o3+uIkXnqtulpZHEcyXExyNFnVdygIhAMcDqc+IAcAawvviiRN6l5FXjcnEDlt5NUwoSpweKpvg"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.9.0-next.0_1629538939627_0.5632336260086239"},"_hasShrinkwrap":false},"0.9.0":{"name":"hardhat-deploy","version":"0.9.0","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.1","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"f96f725a9f5ac46493a7cc18e95f1fb6258f48c2","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.9.0","_nodeVersion":"14.16.1","_npmVersion":"6.14.12","dist":{"integrity":"sha512-opAolAR0WiUkMfZU0RljqwxXyrNjefx4eHn+sARXLPUfaUJWx/kjaaUUWw9Vz6Qlvi1pQfENDfYwGaWjnDJImw==","shasum":"83480e1834ecf41d4a63017ab1aecfc586476ba5","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.9.0.tgz","fileCount":125,"unpackedSize":7584564,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhJKSiCRA9TVsSAnZWagAAiTwQAIHAXZwAG16hcRcob8Yc\nj0ZS5Qus7Dt9k94LpqTQ3GqUEjri7ZcNO5r1BV/+rEjw5EOuQb9vwl/YR6/9\n1sjT/JdZNqlX937qjjvBwLIBKqzFMwqUpMtxMN+nkH9Qpw5IU+f+io0/9+23\nafGQa7DCNIkpxrA/RKX76PwiIGgA2Pk4peezZh+iqUiVOHne+7GkYq4sxyFM\n4Tp5GSVtnX3w9lvxxeBTWXLocNrV8bWKOEwpReztrJ2AAnnm9ZeX3PrjmmQo\nh2I0lrBpoEONPTZSXRmGzFlYwPWjmF5Bd01jhW+bLyDh9z0EPWD7egiFU10X\n8R56+9kx8F534Jd4MjcPnO98vC8ghUefw7d8YCLyA33Hbud/Xb/23Ds9/Crr\n5l8PIuDtRtKHTMzKEDLtfF+PQ2P4F+azQQs4toLOL7B9YPoEHjTtimuNVolM\n3aKOYwdHpR8MbZlTM8kUPRGh8PXtogs5RlyhiFvSFUu1+q5oFhuUDLB+JvA+\nMMURLcibCu7eOn9EsIIMfLRXURQ5SHBftfvux5diExEqUpZ9j2LA6KnXd2iZ\nkRyqO6J8uWNyzgtqkolVuPhXQuzPtXI73q3ThlA+4DDMWrTKaE1napTfbY++\ndD8F2Z2cDoeLVYzSbculGzm8xXdgv237Umr9OPfSX5YFLE1BCd930Oj4U2oc\nWmSQ\r\n=2Sd7\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIHEpewA8grWAUN2gbflcpP6GzdSyuOLJctFLun1cT4zxAiEAqU8lmQN42yCcEh6uAo8f71ohqICQ1SNDrAcPTpHytWM="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.9.0_1629791394500_0.4273815639484493"},"_hasShrinkwrap":false},"0.9.1":{"name":"hardhat-deploy","version":"0.9.1","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.1","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"61ad90a8b26eba3c82aa5d0b49bf672a93dcde9f","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.9.1","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-GUrLlsBKZqWJ2isFDnpnlnyLuIDqES7mEFGm4P7GutG2jeBebvTg2wCNh3RTW/rpHUtU66yCZXfy+LeD0QXFbg==","shasum":"878bb10ef1bfcfee892477c2133295a250721672","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.9.1.tgz","fileCount":125,"unpackedSize":7593360,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhM3wWCRA9TVsSAnZWagAA7GEP/i/hBV0nPJ4/xD2K7pKD\nieqlRrzaOz+eqvnOt1X6vdOd94tQLwBmVSCmSQBdTxhc9kmXZaqx8P56DYXn\nQBRNbiel2qqFJgUeD9rwjHqoTY/jX07xbCYHo72TdekmdsLEfs0wso8U3/SA\n/qYx+yDc6dU9CEAesbIE3SjHbqQU5xNEHKWmdFMXqVnyFb7/p63CmbiT7B2O\nYNk+FWda+wvgTO8mPxkv8CSWyObOQxaKseUZBEj6NrJPm9zihEdF9BuV623G\nEeVy5fiAsgC33j61BiD5AGOMYjCMAdlHLz6dLjKxNmmcZvmZMJTbvQrHuqTo\nT1gZCrchQN7bxmWaJNyG1KS/QyY3OwjJvU4jsf0pLYx/YuTwzU1Zc4E6luWt\nQCJuz6Xd4YKTnXGKNA1dy+Pt2/2L247D+dkTdWzB+TEsKxJRQNT3WjrE2nht\nrAPdbZwlHRKGL+qyOp1t8WkYvk2iYA/xmNc7MVFjRo/dxPxtpNjoiaTS1ne+\ndivppbf/a2uu2e/udGBLP/LXaDa/Edx4T00I0xpiXre9vnUsyeUMNcgmIA0d\n+6O+Kee8wDamhouIc8haRq3n0J9yG2EGKg7bz7X3q8Cifd9EiwV88Eks5K3p\nfmGooBI8F0Ng/IfB9+fruPkltcSZkKNLSjEgrq1fkqiKPxxaVVjEREiHkp+N\n4BML\r\n=Fk19\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCYZB+ogD0jLyz2TyDrH6JPZ8Lst4EdLjO4MCLnKfxClgIgDsV+8rMhD8FxScLfhSLgM+YJpecRsmrxRr6Yg8EnOU0="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.9.1_1630764053797_0.843739316862655"},"_hasShrinkwrap":false},"0.9.2":{"name":"hardhat-deploy","version":"0.9.2","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.1","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"8c76e7f942010d09b3607650042007f935401633","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.9.2","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-JV7ilajpkVsW2ZQSILvQ6QQpOxsOhl15sJ+Yk0Lg1nvOG8FRlsnsnVVcx0QPpiMviea+r0nKUwo6d6U9ISFTAQ==","shasum":"5c26707a5ea65e0dac877d99cce81a14f44434ac","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.9.2.tgz","fileCount":125,"unpackedSize":7606630,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIGTIie6C7USh2w/Yu4+0/UxZWDiD8Tnb3tjZ2oOovqD8AiASDDLgjhpth5zj9Kc8RulKQ0pDrzam7LF2jlijC1MYWg=="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.9.2_1632771061172_0.8578793606328361"},"_hasShrinkwrap":false},"0.9.3":{"name":"hardhat-deploy","version":"0.9.3","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.1","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"f7f84c3f4f36979ebe9506eb6128827e6beaf380","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.9.3","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-0sxxQoxcA1+LSVmmLwp9empK4Pz5tjr92JvfcobojBz35DSpp0o3f0f/tXocYWaGbOrms3eQJ8OX5WVsmcnN4Q==","shasum":"cf9a7806c0a86a6f7e9352fc558b26c079983496","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.9.3.tgz","fileCount":125,"unpackedSize":7619215,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCurcI4MapRQ+Sc+H3CwR/bGhcpZz61Tej/Vva4pDn7cgIgCJLNBk+QHzshzY7fzDoBxR1SQchHd+jyEqJ1La8un54="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.9.3_1633269806028_0.8703817134369438"},"_hasShrinkwrap":false},"0.9.4":{"name":"hardhat-deploy","version":"0.9.4","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.1","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"2e6004ab08bb3d095df4e7aa6cfe91b2b76055ef","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.9.4","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-0Zr8R5SAq6oK/gi170yCDqPTvKNPHdlm6wQe3ZQg/uiIDZxofpRM2frQVPUFlgdI2yUXtVcGBiPcC2r2fEockw==","shasum":"8039b6283e8adc8bc908a3af8079f0d4c9850387","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.9.4.tgz","fileCount":125,"unpackedSize":7619799,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCewcmDwnu1vzp/PF0dXmkG60LcijCBS9Yn8N3Dx/zwJAIhANX0+JImBuVWUWn6HApulVdUIsjm+zDz6YAkmV1xfO3N"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.9.4_1634374703696_0.11867601488043045"},"_hasShrinkwrap":false},"0.9.5":{"name":"hardhat-deploy","version":"0.9.5","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.1","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"355650ae5af911d579965f9fb1c48a883a30a153","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.9.5","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-y0ckqSesN3X75OPi7s9ssOF1X0jLhTqllrMlssMCExNh9TODtEAWirSbma1CV2+Xl/BFxlkjiNwL3su6mINXGA==","shasum":"0d20c0270ea3dd6e49f2cd4e30e60948ef66d944","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.9.5.tgz","fileCount":125,"unpackedSize":7620071,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIGBUk5p2HGXKeetkCMu5yAf0ZsW7gr1im0R/0MpGSxN6AiEA9H07Elyq2OUlz/qFErOl8GeCpG8Xrdjs7ET991UHahI="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.9.5_1636374104437_0.40452233370615276"},"_hasShrinkwrap":false},"0.9.6":{"name":"hardhat-deploy","version":"0.9.6","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.1","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"d5988f28c7dd2a7adf89607d74faa523eb32535e","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.9.6","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-4yaG+RSpZhrqIzOrbesObZS0UTB8iKyG9PdGSAYjeiteG24y5AX9Cx5ex0cmOsdfJ2B9Bl7Si/lXTHNXZeC3TQ==","shasum":"edb904b2bb897560d48016c5a66f314eb3ef8de6","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.9.6.tgz","fileCount":125,"unpackedSize":7621903,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDvbyARANrq3H99sL8cH6tHtlhSmHMdPdU0DgP/xi8tiAIgVp11LIhNnOydsJgszMY7wZIAtXwuiHLD7kxJQJV4e+k="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.9.6_1636558911154_0.6963317929727371"},"_hasShrinkwrap":false},"0.9.7":{"name":"hardhat-deploy","version":"0.9.7","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.1","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"d95627532548cc9c6904248329aa068365b2c2fe","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.9.7","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-vCAHi3rRthXxEWRR66pl3Z4odRn7I5nG49l+VMcwub6oopHJN//MWrgVN9MxIlx7AeIb845h2ZYiOOYwMeCO2g==","shasum":"b18c8bd712671c1112677efc9db042223ec8e4f3","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.9.7.tgz","fileCount":125,"unpackedSize":7626581,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCBkiwO+QfCDsfgUpYbxJbyoBxuyQ0+3ai+3j6t6p+XFgIhAIn7a0xcJOCKerQKtt4Sc9ncvbZpYmNBTBGe4HqgxMKY"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.9.7_1636797213409_0.8679511576486341"},"_hasShrinkwrap":false},"0.9.8":{"name":"hardhat-deploy","version":"0.9.8","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.1","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"c8cf6cb14fd163bea400fc94608f460a7a2c63d0","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.9.8","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-f7s3mG4wHnZuQWR+W4QVnPIE0OshgBrf19gvqRBqMbH9cDw4IxBXKWYSVTPXHXNITjwE3CA9Rqx+52Ee1ovtAA==","shasum":"197375e043ff2b06e7879c4119f801bdd11a493b","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.9.8.tgz","fileCount":125,"unpackedSize":7631263,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQD+y7dhn4lD7gIqKLW21Y41ax9uzPDbL8QuYcsnvGXMnAIhAJ1+WZ8pM8qs59UZdhk/QbjsvrRXc9EEm8+1ZhqS5iEk"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.9.8_1636797773675_0.35239883623367163"},"_hasShrinkwrap":false},"0.9.9":{"name":"hardhat-deploy","version":"0.9.9","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.1","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"df59005b68a829729ec39b3888929a02bd172867","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.9.9","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-VLGZ22KTrhdwIFQ0aUoTKuODHtZebK9WBTIx3j61IAXrkEjvQVfdO8zfFiieMXRwm31Au0bDlQtJ8F5GihnWvw==","shasum":"9d39f64ce85d8cc0ee6f24a72cce9dae784b24bf","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.9.9.tgz","fileCount":125,"unpackedSize":7633051,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhmm26CRA9TVsSAnZWagAAsYoP/Al2Nppw+MGnudhROwtq\nc4FELH15noNGIxtQ4+V/kkfviJ6lbVlkhmHw4I4PHpQ9p2IUlh7DmtH0FPkd\nvF/aOEP5ZqjGoelz1jNWTU9t+rGhnWJFHOqqYZqEVQHlJTLat2I50AYwzjRR\nP/8Z45RdEB2Y8ng0i9c1+x+NDIi7nVSWwVt2z26tIbe9nC22JwV56nPfM7i8\nAVDJntNLn0yoY2KN4UDO4SHAUU3EbS8OL23M+AeU99NrdCOVcaoG0C3OZi5+\nGyEGK69Dft2qjDY9N6F1UKjN6/0eN4NPxpVe5EIOXmiNUwmFfTEj2QU0Zpcd\nI/Wz9B02zYRG/S53RL5d9F7vquOnaOw+Shv0v3+kSI7NCcdvljo8MIUDqVWY\nsD0XD9Bn+r6sy4ICr1cXjeklSEKZ5/pa1kUFd3MolR9xYum7LLbZ08iyHydD\nb0xfz4qJsjPMy3m8KpXiMP7NshJZ1/+SOEIIKQWiIx5OggtQTcgE15qarICt\nyFgfO8XXx9JPwNA+AMKsiz/L2o7xsFzlxw1qY5CmUjwwY3D2VXHh3NigJxQa\n4764S/9jlKORo6CPOQRtyf94chlCtGfmS6FOojrq4zVKjxIMMi/LPoARUyLt\ncHq8PTuEyKX6C3y0mC0W4Khxyhz7VARndVPOoh706iMkzsWxkLsudYWLLikZ\nNEpX\r\n=2ClL\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCNUovpJdPSKQhJqHVHDENw9ioAx0hh7hR88cwYD5SjlgIgaVchTH05QjCTF0NnJ8mtdIjHiEBI5I19pz9HLw4scB0="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.9.9_1637510586472_0.1209670205143285"},"_hasShrinkwrap":false},"0.9.10":{"name":"hardhat-deploy","version":"0.9.10","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.1","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"3cd25e33a06fd4096c2537384f6438f6cb1303f1","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.9.10","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-Cu9uwpnvfk+pFuspcie6PVxxV/DOIpNGyBuffKayBAtrKHqU/wkKqiw+q8iR5eND+F63JXFmLlt2v8SMea7odQ==","shasum":"b2346421624dceba73dc51483ca4c4b25b17a4da","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.9.10.tgz","fileCount":125,"unpackedSize":7633279,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhmm5oCRA9TVsSAnZWagAArWgP/2azFm5V3aQKx8lifw4A\naZc30CMFdiRd3K/xLAaoYqgLctXagjPkXzQ3oq7laQZeaG1G58yGxjI6oOGc\nZ1sXYyxPUGHmAeIgrTdXOWz2iEd9VciQScMisRLbym6oo0NJXU5e7S/a76Z6\nw/te54UPaA4Udksh05cXASA5KEKrciq7W4rq/8376i8ztJ7yeSCTA27WYgUG\nHQp0/1VHFsz/vAeU1WTaAbfk/y/RUEu0amKmcj10Wd2HAufqayBTFQYBRTfi\nkahbSjFofkOO9tG1VddMVPShKGbZBVjPfiic6XKOOjVmXGn2b0MxUN/BMh49\nDlaPwA5k3w58OhV4tZQ8WAmFP9K5JX3XDAv+ciQ5C8YxTwrw96+oXSAaqJdk\n+NehIeYV6YVRWlN6raHJXg+zxtjr4TcAm41lFlqNsPGvOR1LuUZhNQ8WLIkh\nlaO9LX/wUu8I+agGuwDuiHWybK6EkIC2QKQ/0GNdiA1gSudwb5L7x+o3Zef3\nLEe5qqHe+X4ArWkFbPNNsdmDM/NG1XbcrJGW/NQ8wnPg92icWERJfcMjBY6B\noUKjSL+k+TMa0SehF6p3s6G7ch6WOhtgYGE6bRhuHPkBp6yFCFSuRyY3OaDJ\nYInXYSPdjVU1hIQlH5NsKkhvIO3YC0X3iv8XrFFuo6k48opYiI06Dywrz8x5\nCQSR\r\n=UTnQ\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIHI4sNsezfeodnT5skTXoyNODqsji6v/Stqjm6yiNhwrAiBucrSsiG7feY3xDvcrAtJ0i8xvSuqSg0C4RVOvRd1yRw=="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.9.10_1637510760404_0.45613076727973123"},"_hasShrinkwrap":false},"0.9.11":{"name":"hardhat-deploy","version":"0.9.11","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.1","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"721a9f2daadd91a49caec508efc108c491a8e0dd","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.9.11","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-GQyvtNKXAC35H0J+OlTl5UkOEA5WBfpVe/8ca0KXxfPrr/hiBvTpUNK460gNVgHTBkRJKWEHbdVSgXEha4y+8g==","shasum":"2811f49767e27427b798908df978b2d5abf6e511","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.9.11.tgz","fileCount":125,"unpackedSize":7633842,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhnzkuCRA9TVsSAnZWagAAYBoP/0heOc2T3sdnX8iIL0Kz\nlATLOBjQchd00zAHh7XibKIPT9EUZ5586L6CaBd4WKe4Rw5jcvquoamcSRwg\n3+ix9+3S4l+98MD9e4jXrcj8sT4CXO3YkT1hM++iO4eR9GGkDJMnYVH43grL\nAfFx+YvoL9lFRryJcJYmVPC0rfSE9Im2qhrLutb+gatF4rZ6Epbls20KL/eO\nvw3MnaIsJa0ZYiSf2NDDDWjbrFCYBc0fY2JTCacbxBH1d+c/Kqa8fHPW3J+M\nqq0Z/KyQOYEdpZv8g4iAHdQoV9q4oFpQWKFLPT4OnVE4diCV5cQwJYrm/Hen\n31Nwt6qiMzDybMiUMUKf9W/mAcl3Js7YGy4Z0CXFDQ7tFuDMqSdmf6EPmPde\nF/J3Rl9Z/AMHB28EKQ1L6ppqNyzzCIGTl3BFy4j/5B9wgbJfKevDS4OfKLB7\nJf1WdgnndbFq60tsQuFveuJ6AKQWyel1bh3JocXz+GmIJlGvaX7hoF/dix/m\nqRYeBPys+gzpr9sXA1hgvmMgFsPtzkQUrpq+3V+ef6XoXeIFX+Ou9fy6Pu7D\njSYO3sVT8YZaDn5/wiiiYa/P9uuExnszLW8I164z4v3P+f15aCrpyGfUwmQv\nleUTGBmBmSHQUh/ag4FG4KM4rIM1hz3I6aWRswC8XZp3HuMDpgSn+IfPwudo\nYikw\r\n=/dL2\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDyKyQAuLWFbolUnGvCpZ0r3w3hi1s7K+swE85ius7TsQIhAMOWGHEMGa3h8G9ntvLBA+xoR0lVZL6gc/GDe1YhlF8v"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.9.11_1637824814316_0.2668170104136227"},"_hasShrinkwrap":false},"0.9.12":{"name":"hardhat-deploy","version":"0.9.12","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.1","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"27ea7f8e4ac835edbf5f39220697d40f7c6f4d25","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.9.12","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-qfOXYB2laNPkL2JHkpMUIXHa3xdmIY6Pf04SvHO0M/pEU8/i1Bji1BHdlaf5PMu9r9ab5ooaeNbu+qeRU6yGBA==","shasum":"860fc1ff41554422e9a56fe3f94fed6d92a8fa6d","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.9.12.tgz","fileCount":125,"unpackedSize":7633831,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhnzqkCRA9TVsSAnZWagAAANoP/0v5N0fhIqp12YjnqtSc\nIdCw+EzQxh6zFYPvOYVz5zIdrDS1MTiBP8EcDHFXxB/Z3MumdGAU3UvTXeuE\nqIwvNGxDHeK5+8c+S7uKH6dffxMrrOlIF3C+Hu7S1liVXk1biu87z8QaxwCn\nTt+aZnmscUJqZk/kRulZBY6pP3W0RE6OC0vrMIfiq04iT4XoSOvCpp+x7A3y\nAFU9lROfjtktqnqgnJrj/wbTZHTBSqIveZAWMf3yIaa4y7+lgg+XKPjNDGdD\ntatZepmV0JCkIF1ar0qAbYL0oNMGi2dZ9x69CdLHgBv85pWo2jBztobeZFoS\n02WRLI8Bsdw5ppSPe7FdJwFnf+DGXTX6Hfa7F8EDvcuTHL4s52SZjy+QLh8H\nlwcwJnUE5iXm65zG0evBAnZBT7z8Zu/tU+OI2bmD/nzwzI2svzuTDH6eqEhQ\n5EocQxqKsPS4qwifHYTiZOnjBY16Xjn3udd485tnKx7duzc7oeSgalhir8OS\n40HQ25tud1ZMCDb31/YnZ7gBQVzh5RiZiy3f5punsxSOexiOqMRxrSdoMC7X\n81KQJEyHFJosyJoknDyboivFRY5QLIg6dgikzeQrF/M/T/mIjX846YyrEK5Q\nfAhXJRUpi6kx5ljzRXIbMlJcPlicDdh6F64OQRrLmqq0auZBFQLuQTj52YLG\nplsI\r\n=29rA\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCYAyffnuxRiHiGysjT/ssFhv3CMYfRb7nuECupxlZ4kwIhAL03Er7XV5JODUfvJwG0VmAFxfiy/M+TSbXc4kf270s5"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.9.12_1637825188025_0.06117250270637742"},"_hasShrinkwrap":false},"0.9.13":{"name":"hardhat-deploy","version":"0.9.13","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.1","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"71b6672af051052b15adb4b3373b385fbf21c318","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.9.13","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-PykQToEUwAi2dq5Lzz/Qayqka1EfbZUjD0guNsYyWhQetW5j3tpP8sM4HWjkWvqvpX6T+P843iTGYiHBdgsd5Q==","shasum":"60015052f546559e7dc2921012c48d580703df67","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.9.13.tgz","fileCount":125,"unpackedSize":7636271,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJho7ekCRA9TVsSAnZWagAAX1QP/3V0ByjRXCeuGefC4Ibq\nxIpmKRzwZUwpqiNcQxChccf/IreXKsyz3AyREhW9x7Y3IgtTEMfXAeSkSCXF\nX4DmTibnl0EcCkNqNenRxmEGn0yqXTszYGTNEaYUJHvTwlO/sbDao79DL92d\ngWA27dMB8sib1ku+lFe0ZGF6rpxTbdbrljjptaXt5b5rjAPATsPQ6hG4EbU3\n+gqDOMq3mHYIMzcHxI/m5G2JDw1KEA2ZggThQ68w6eXzmnN6C7NJN+CH13zU\nIQgjDLMHiC3hwKRMJYuBuXdpX0XFyb63BPTqyNbA+M3e43KRX0+sPPg6vhuZ\n64tOje1/XTN2nmmGQPGM9RXM+/uc7xFy1e9wTzyt6/GBgXqOy23xr2LL9ScN\n+9BY3G2G92+dUxFnAFjRWxZ5tUi9AknIcOrl+uE46lV7m4az2fBJEfeQUMzr\nwfT6gVm+TqqL/4Z9h9aYdOCFMC91DtRtXY63QvZg29pch1EvttjMLAEpxJJU\nJvBhmRvrdsgaDkTfRRoxOWBxSR4hA5x27t+985X7Myuc5tuLhYMbO/UQmEfC\nBfwgLIG5wAAQqX7JlGBAbc6Go9eprvzUtetyCob4pPrjXlqF+Wff5tWcAvfO\nAZcGD3Rv/oCWUnGF9o+j9OzhA8pMpntzxBtoDIEge0quZwyNY3IttmEZHh7E\n74mv\r\n=zTSk\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDU+JGG2dwrZJkD17YJVGVWcmAebjJZx3TqBAjIQxDJpwIhAPAxlgMZxp9mafOQS3IybuEAfBOl0dqhbY2NKi8ZBPlh"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.9.13_1638119331789_0.5014124729439873"},"_hasShrinkwrap":false},"0.9.14":{"name":"hardhat-deploy","version":"0.9.14","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.1","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"919d977f62ed05c11a3102d32c124441e0ffc3a3","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.9.14","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-mCwXeXdqtrQN8dL1gOnoGUh0z9Jylfsh56UNVZJC0c8AhjlwjLPgGE3pzNmMuyy88pj9OX4qo53X57bW2W7NJQ==","shasum":"88c07497efd14cfca6f9fed1574f0bad65f0a8a0","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.9.14.tgz","fileCount":125,"unpackedSize":7636763,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhpARxCRA9TVsSAnZWagAAoekP/2YNiKvsXpl/56pVC9Wp\nYw0MC5IWMARwcmLfUlC8qugKS1U/W296xluA6/3CVbl5z1poHWoxCJbnBrdf\nSQBkFYf8Qu+6mF4Ssx/DcIjmsqgZ49eOOWA1JhSq8uAXItqDybGUFr5o3IyY\n7SKVUyaOtESenib3jaZlkVLkcs9q8OVbRntbIExt6XnmSXrQJLN4suG/FF4B\nd9fGX4YN2HjSW2uZ5ij2TwC+Ux1Jxu+6co8lH7RHneHoxJod/gfNvqcvnMzp\nIaZunixVtB0tvJgPF9Pb/tFdzD6yj0K2qvg3S7Iw74sUIAqrdjyvI2dOUgDZ\n6GA6Xz9DBAC8d0ccX6ncYkqxonKj3rzVoeeWb4AVsC6Kinl1aJJnD27gUKSt\nplPtynhQ4+t6DC90eaJL39wvHq8+5fK1b69xL/TDEjwlGfRlFMQsh49g69TE\n2ee8ANrqUgNMDKr9r5tg6Zk6AEZ4//y21WPJfyR7I9e3GlyC3TL0T4DvdlWv\nA8GoIAktQneeKbHSMmYjG/jdcYWdDUqds7UdedPIQT9y3+8xBt4h/jFXhxCb\nDzRTaoJrtc8xoOEZip1HEgmvSWR5h4GOgP0RQtzK61wUDOCrJSBfnzmubkAP\na66b+aQb3IXCmzwn4iqmtB4AWalQ0roSqryOmXgYVNjsKLmZaBCfkwmx5iHI\nlF/j\r\n=3ApQ\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDT5St88aLYyIXKt2BH7BqhStdH14WsgBeip+azW3ibYgIgTlk6B9pYdD9IHAivb/hWrmLMSs5a8ij9Tcx14GLakJk="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.9.14_1638138993376_0.4246127893324596"},"_hasShrinkwrap":false},"0.9.15":{"name":"hardhat-deploy","version":"0.9.15","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.1","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"7e75d84269609876b669aac17bec5d3b84042ef7","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.9.15","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-j2qnMHW+7FiUNqsR6D9FKdoaoI4p+TOXdm2KABh0Kd0FPMBrD6wjP+HNp5g2xpLIOosBa6nR/Qyc8mQ1N9aNlg==","shasum":"978cfe1aec7eb1ebe05b2f57f5e72cdb2518eaf0","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.9.15.tgz","fileCount":125,"unpackedSize":7641553,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhxag0CRA9TVsSAnZWagAARuMP/1bAu3lDz/f4IX19B1Ut\ns5UCoU2Kwtsh4FoaRldsFPQOceMWUcXgD+AXrts3qwhO8fOMcLh4Re9WW0FN\nIDuSh7PNGlL8YJJJ4YzcQXv6Mt3uVi3btueF7yumWo/7TQ0GWeqkiIN08TyP\nehsRw7+mFKIooU0zaDl4SU3M7CtkO6/mbuItV4qPFW8k4g3NefiLShUkeE7l\nktZO/tU+wgQQtFV7MkRqxg8JcS23Kc+oZotBdM328UJdgZXahzr8y1MsC4Lc\nHXeXZo2ZOsDHVNIVqbQ2mZgiBeqYdxHFMuBGKCPisdqFGneLDLTUX4tTYFQS\nrt3VzurRPyCbhKlaAyHFyhSw0GrguQKu7q+pQwFLYtMuzcvAT43nZ25Rappq\ndXe7R00GzSSeFqSuBVhRZgV9YZF/VKMmLTcBylndbCZzuazYKpJSo8sAEMg7\nr5lcJmMjpE/MXxUFL1EYH5mFZppXFasrTF7QNqZS5PqsnxZF/W5VUKPCiv9D\nIp0z7SsMDgfhlUqOdveIUzeQSskjvAbwKWrZLr7o6l58q3Etm8FLZYvoRrLo\ng6aX0TyoElpRRBAtvXIr4jB8d4SjAPZoivbMk4j1lb/XG6unPSuNZXEP2b9M\ncITN6ASBjT4B/T2DnFuOHktg1EyMjpEeQp5uekbuRrvZrAPnZpsQHJh7ouoR\nQ+dx\r\n=cf0J\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDbKomMtB3CA6WHoJzItLH3UAn8aMYUCl7liK8XMo811gIgZchUxFH8PU8dfhfsnon1ENyKfLz2Z8VTnZQqWVlpXYA="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.9.15_1640343604030_0.09267032761764882"},"_hasShrinkwrap":false},"0.9.16":{"name":"hardhat-deploy","version":"0.9.16","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.1","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"19e0fa4c30963b8e4190b6bb6a15be186026d7e6","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.9.16","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-SS2oTDpXA7fm/AGVjl/89CG4rg9SxtrB/5TjtHl4KEAeRgtngb2xYACXjzudzVRVBOZ0JwKiz4yPfhr2lX+JTw==","shasum":"cdbeea435d4e0c0673f40c6bd19b189eb49b3ddd","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.9.16.tgz","fileCount":125,"unpackedSize":7643643,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhxasWCRA9TVsSAnZWagAARIcP/2rg60073DgdKvyx/Z87\n2ylnZqfZ8k7QnJEOQl4FQERO83MBCfpjtCqLmN0tlvhe/XnekOrGRwqFfJmX\nFCeuzr4TlVOv6DnReOOkHVNA5WR9CaROjNOIQMd/GU5nYUtCfVkv6ZDkr+MD\nU48UA7kT0NtvweVxXs1tv7/Z0aCFSgnKzcQ7S1qCjbgiY9v7ZZqlgzj7F5SF\nismnRBH2Ia/QjswdnaggAGvM86ZmKtLIKTQrfv+kIPItO2pdTTr9sE0BQG+8\npFgk6lHz6/LSg2Ny5Kc2afyacYENinKwjmnWeSvq1rWk0SyZK1xSWBZ24VX8\nXdhe1kxV0CaN8hJqA8bBTTA+mK3f7xROhb/PrCEPxm69L0CJ5eqQzHMHVfeI\nqNcvb0VsTUWmUkjNk+Kzf1WoJ4n6bWwtx5M3oEoZpHWkAVzGWK9ZfC1+L2et\ngBCRApTRkQ9S1jkPJs7iXUPkRrWvMyVdPLmgiVP5daePu5AyZ22mpfaXDiHO\nN9Jb8ZOTVzWBc7McDpAd06I0gwglW1vqaeDnCd4E9f9SshukL2SfiHZQLJTq\n3DP8DTjF0qC2NpA09aB0BIDd7MKJdZysmrnT79zsLrm4Wdcjl3qHLFxAxV1o\n/ME/Z2CLCKC7CofXq0JKsFmWGQ3odu3tAzxPjgKwvLd7c8k+zaCbvv0kXdGK\nyvSz\r\n=9zCY\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIFdB5B7alOnvWFnA2f76Qhl8NV1rm9CGlcY4sIkztzvFAiEAuKJLifMUsWFNdkGJVF7zsVaFgeAA1jqN3P9hcg2inM0="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.9.16_1640344342519_0.11442295908330058"},"_hasShrinkwrap":false},"0.9.17":{"name":"hardhat-deploy","version":"0.9.17","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.1","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"5da9825948e0e7bdd1f4a9b23dbccd98de15ed64","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.9.17","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-VWQSF+2LqkkS53qG/uo8vIsHlotS5idUjCWpbHLTue51duiAGWtVVLmpwK1ISUCk/o7Ixr0r96AEzUOc/0hXRg==","shasum":"9e4adfa829004edb0265ff53fcbbbd18160d6b33","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.9.17.tgz","fileCount":125,"unpackedSize":7646081,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhxayqCRA9TVsSAnZWagAAFWcP/0PJlNc7r12ZgE+Sural\nMs6AguaQEB7tCxQCYTGa0eWlGdQss6LKgglTpOIJ4FAJp9ALsXY6g1MFeTrX\n/QjsqPcD074ININjB0xTKyBMK/yP7rRhhVX1d+9/deS/jR3oTEq/H+hG4boT\n8HEeSmUOD6he1AO08SD2AIMdaG4fphq76kaeeS2yccC3U5HfA4hY1iHUftxW\n2eheeGaHmJ2pXB/uiYeZJPoNO3p0PwfMyM6oX6uWkeUQSrxby44XY2qO0uDr\ncX7CCRxzxtPFjCKetoM9qaB6LrICL6bJ2qxM7tCJQhhs72aIx0F18B+2H/J1\nfli9mhoWl4GPyCnhkSXItgTKkfULZq3AOCOAxHtnQzpL5CGzjx435OnPc5D6\nt/FnuW/xPLCWmJ1wFQLWcvJEUhgADlG9oo301MROOB8HFVOySz3EpmTWrEww\nmXU3g/InCqLTN1DQeVOcdO2XFD4i/kHJ1FiQoWiRh5yd1PzDlwx8GXsJbVtB\nhC6w2xhC/3fEuCESf0fV74AVwH9d2BKTyA17DaD7FIUtna6cqoQtY9h8TQes\n7SsHexsy0LuB4u8UnAXJ+aR5nqkeZ6LLhhjY17yLbyLLPryykKIUYk74nHaj\nxI/8TrOZK4Hode5RDNDn8mnlRbWrDba7DQYoFsHePJiJ1fWFApWzmg4TPpvm\nZGcv\r\n=e/y0\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIC/CUwXTDLgzSbkH91vfd+kSGelgHpt97tXyN0ytylCbAiEA9ziNZrRkzJLZe7YSYgSHyEWQIT3t0Lb5M2e4+f1qrdY="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.9.17_1640344746111_0.27722850957344636"},"_hasShrinkwrap":false},"0.9.18":{"name":"hardhat-deploy","version":"0.9.18","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.1","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"910c44be52d1f5e22fe3b1320a809095a3f4afda","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.9.18","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-pSmAe8im+s6V7i1w7u6AeX9fhLZgX8nBCQO6CJ8aym6b1aLIJdI4fhsyk6DAafCyQH/nHGWaPMthCv4BqNrTiA==","shasum":"9fe18fc283af3a2fd7b00d8022cf2ea9db178d66","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.9.18.tgz","fileCount":125,"unpackedSize":7647545,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhxdp6CRA9TVsSAnZWagAAz5IP/RGtbl+tXca9tkoWIEpt\nHrwwXUrMPM6pxIkDA6i54KbAqB4gyrx2rEPWNhc+wUlSEK1nK6+1Kn4YzJNI\ngvV33KNbDaxP1I+xXvowzkwVlBT6iBKpghebdoJI/3QHlvSc1tYV0X9eDCYZ\nkXq9LvXXBl4VhCzptmHIORr726mSep474PM7GLV3JmMK9AqVTphv/3d2Rhux\njVp+eEvi0ziYhukh0qO2sJ5vghMoHGBgg9RvCopLsA49C6k0OkvQmShzkjYP\nDnF0JHuvoa9M1FUB++8T6tEmu66ciZOiozWj0yYfntFjRmG5EUD5pcoFy622\nsA5N2u52TebpdIvvmLOnqPb70OTWJNhuYRkwi2mHc+igp0zJH1Kq0bNsqgEF\nejbqinIc1V85fgac5rdREmE9t/ZJbu0V9K0sJ6G1RtXLxusW9if0qnri2gpM\nxOgzCrHmOIO+zndanVF8JkPwRAT/GcpLnL4C++w5g7xP3Wosp61MN8X/jn/c\n4+EfMlVOJM13OX08wCF9oUvuILW50nkzYhLe3IWAO7iAlzlwCKCta2rg8JOX\nVsgXxX7ZZLEk4KZpJS4Ofb3gukiycxX6/ydy+VObfr0KjeuGGuywFyLowaFB\nCbjpN4XpULtOVJAhOOuaFuinaABlfG0STP9eYgMRYUTYFk01CXCoHqJza1RY\nCuC/\r\n=XrHe\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIFHJmV+VozhYL4gatl/3OfXNneIZT2lhW1wPb4Oycd7HAiEAz7HElX4N2xycz0lnHmdsVBlMCi3wlMTFErVh72TEB4g="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.9.18_1640356474145_0.09948166339550157"},"_hasShrinkwrap":false},"0.9.19":{"name":"hardhat-deploy","version":"0.9.19","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.1","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"1d7e644d128b4b53fa2c272a2c230e45c0207004","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.9.19","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-yfI3ccGOGVu4U2gjW1GEqMahTqPa06vDOc9FAi5z9c8vuwvUtL5lBsfHJxeKoE5wsJuu1okKHnCTRnQrr22b/g==","shasum":"68cd43500410807f5680779e24d98b98e5de6136","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.9.19.tgz","fileCount":125,"unpackedSize":7646947,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhxmGSCRA9TVsSAnZWagAArOMQAIsrX6P0aOkZ0C+il47c\n2EoH2zg/M8OJ293T6sEJgVqHiqrmO94Ucp6kn5F7+FSTtOeFzJeoAQsUCcRe\nSyPJ77JBeIKsTFuVHIRE7tPs9GgJGi1tqn3l5RZzNLwsoC4LCip5wkCZrqJ7\njKSHKa/F0xSlhmEH31m7jBJO4GNl6U7A2mqI2Mzr5fcSv5RVr9R3ZEC9dsXS\nfqBzjRCCnu60tjBf/mx7jDSeKPW+19tRd0EYGaJVTVE+Lo59Jp3/DB8NgH4k\nfX+c/xYsVKfTcOTmCrw/IkU1EQsSNAHutBCVwoHkQ970C375oLX4j5u+l2Ox\n7+NWq3mmJUPVImRMGLQyUTWoBfzJZgFdZp9BWk2LP9Jxs4ZZ8OPGJ4eZZABS\nqJX+FjyywJnPmDtmBXfNUr3AvziLiwT/fmOdroWVemHLRyxd891d2pTGWHJv\n/m5kszNji/ij3a1340csLcYgF+U9xlPw953PSses1ucgW8OolGzFdQLPhwJq\nOgI675MsQfhdRLOqJYVkEaPJTxj1tzPz2m2Ct4W01DMuyC1M1eOBgSzhISGF\n5gRE7Oc7ivObsXCEYiV1kQlqMLZ0XnKD/iIER1Hq+3N0+ifCnUvtF/sDFUub\nkwYobMiybzUPrwzD0HskdyuR7Ks3DHNFivKucuro8Vv0S7u+++kgWT8CWszv\nj8Sw\r\n=Aoka\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIFMpl1Fdl1HsdCi+STQbjTeqbgyJFIEkexgfyguHK6OTAiAQ0yKPndB2ZNY7RrkB7sNLQ8aolCcUXt1xMrUyloCnfw=="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.9.19_1640391058784_0.19073322668272796"},"_hasShrinkwrap":false},"0.9.20":{"name":"hardhat-deploy","version":"0.9.20","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.1","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.0.0"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"909ff88b10ecaf78955d5c48981ca30c75adea3b","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.9.20","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-8mAm+GK13LozGRJmtSSWvVnsXj7S9dHeArUBtL11cbpID3CRrtQHZ6Wg1tQZCjx2XlpEVG/iecOOvU893kcqSg==","shasum":"d90d5a0f92c27c386c5719fa8e1cd434cfe17764","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.9.20.tgz","fileCount":125,"unpackedSize":7647834,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhyEqeCRA9TVsSAnZWagAAo50P/Ag3bOnrTgfHVSErAbJZ\nAcI5bBSr2ltTH4flMGEn2qIJzr4C6lrX+JtiCK1izea1+zfqAGLB2d2ubF5u\neAhKNVfmWwXEbk3n7ic90Wr0nY/VGnC8MCxG+HdNbnaOL+H9QFpXxfDcJZRs\nyYeUnBmx3RiMYa/Ny//13Qkgal1cPijA3C05aDZUiR6wFu0Lb4DwKDiAWizL\n95Uf8l/0Sawke4e1hyWZIkGdj7dwYvylMuI689tbEmad7k+CCf7nYwlGS3Gi\n27sosTXMHPAHI/QXB9K8wvuzkCd3veNndjPCH03iafRfbPC0kw00aS7dcbYW\n1Ndq4LI74D4GZGrsN8/gL/aGGdPHH86W7n5jLrs5rh+OLI5b4Gu75J3re028\nSq0z2ge47AkIWoM51sV4D8UIp9OU7hxQ91Wn/VXy79PTf8AKRQZhRJp2bqAb\nyOOYvv5Wt1yJ5clPoWtvnUojSqbnKWtzUOvKDQoW0ev18LpPkKfwJiBqqmTp\nq7HIBaqbckav4i86yLXmGUomzYZ+NApRPo+3ZRIFR3yj+eYgqonrv6T28/B3\n51urFnUlN+J7Xf1GIAdDv3QQb24mdZwNBNt/BPQdQPven68Yd2MpaysbrBGd\nlC/SNr22TjpUpapdJo+pZditW1M7aTeYr+HD0id79rQYAFKvL8JkNaSbVdQn\nNRIn\r\n=QKDA\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCpwzlsUH+PI0VlbEwrnAjj0Ggb9B/L/PVdKB4mGBmcXQIgEluHPS2AR0UfrTgMy5G7FNNTtKuuM8M/ISm0bjXCziw="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.9.20_1640516254465_0.7388935024668251"},"_hasShrinkwrap":false},"0.9.21":{"name":"hardhat-deploy","version":"0.9.21","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.8","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.6.8"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"917fcf0196c4590bba2ea062fc4ee39b3f6163a8","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.9.21","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-ETgIlt0SDpjnhnKJyDDxp7vNtiaz5DTRkiDjNvHUCsVmB2RYwk/4BlaD7wvCndeRSpybJ8f8qmjW8VFFb5sLiA==","shasum":"e56610e0e333264c189a425d0a754d88941787df","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.9.21.tgz","fileCount":125,"unpackedSize":7646463,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhyEyICRA9TVsSAnZWagAAR4MP/3y4oJaxuKGiVPrHFRJM\nV7bGG69I8gy4YObp5c+pCQdAELGASRS5JiMbaNNqGOdaHGkZW8ivz0s/6xnW\ntWXrhNEpt6RRur0c0mMHwfa0emHWeSOFWDGkqHbkyqP7BkEThUEj1xy9oK26\nyQ1twStYpV2Ctpw55d61chmmGxDOcadg4Ka6C6zI0R3bwDFtiK0YRZxXvXsa\n9rxY29QgASrwBsIOdFg7v+05bx5mtahtrNvAeLSeoq4ux4Q1cINMpJ7niB3J\nIulIJUbanAEi8o94Jl3II8imWJGK8s2XNwgesWqXBZjKf2rLBlseLMnPCeIs\n59vDfELQlH2OX7pDUZ9TWHOeFXPWbbeSDOF14A6S5kGj0bp7kJXvQ6zXFMyj\n+gZxHMD0hkSh391F/T6SO8Jgv9LWZ4HWoEW5UJyMPl4zp+n6+Ptcj4Dn2tf0\nnMYKUVgJprxAJRZl37okwQBqMb2KEBvX5IinYuefgpx6dCvcaHjFKkWfxSDS\nd2Bva3lQRR9xGmFR5BqeNXxRVknqhKxOD/hqJlDpjP/CNniq+P9gYkd6h2RC\n/qy66A78FckPEcRpFLqySuTPFGSZWwlVF8F9E6aOqlK/gBcSqxfHkMoZ74vf\nljE4vXzrIKcbPUicCQRx5LLVhT8VWRpsVyO0ldgXaYtOQLYmOlLszvgQfFsa\nZau6\r\n=F4OU\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDPTl+ac942y2H1WDeMUlnFXNrn73zz1WsNM8d6fk1wMgIhAO6kzBqUXc/Z40VbvhHxDNg9xfxRgS3twq5VdPHzrqPX"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.9.21_1640516743901_0.47575391334541806"},"_hasShrinkwrap":false},"0.9.22":{"name":"hardhat-deploy","version":"0.9.22","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.8","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.6.8"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"ffcaa06c9f372237c47b7716161bed68a8bf08c2","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.9.22","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-qaQIRIn6oAHew4PRX8TttMQWwccydNxhy9x/dSX3e5Xg9xmSokvKnNNCoMs8jdwxl2/PED0HxUBbWJtfw9XFXw==","shasum":"d2d540e608ca6dc942a42622c9df26e1a1bc4a27","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.9.22.tgz","fileCount":125,"unpackedSize":7646929,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhyE5SCRA9TVsSAnZWagAApggP/3JjrWc6b0hCThKxXZCP\nSBuKD9bzrXm5pbYtqm4GYh3+CAZo686sg5KM+wEHm9pXaoIfR/VKCEXbJPL0\n96Hg5zJmVr44eAzAveNsmzChJsy4vMHkSfb5ZSWl3vtquriS25/RT98G50oR\nDzD6SB7Uq+EyiPEA/9ugIVwfRjsXDTA4v8WGvlHlaA84OnWr9RF1mkoMc8Sy\ngZRlfU08VortnzhTZHSaCAMMHnA1TQgMswGv2RMz8oW+4ZE/fN3XISfmBimv\nI+riIFVDFRCyNVyiOVwqw2bRD6Q4qc4L0KcSE9Odttx+1TpZI6nX+7dr/Tmp\nCIsB8y3ucqTF9M9Ng0ye1MtF69P0sYGwNJ0hJA4fp4w4ZyPJkMqNI1jG/O0v\n8M6TqzkijTBK3F5iGB5pruSckY1vEFYX/xnreR9AUqSmyOt2PUkJel3dA+0s\nPf5ha0mAWDIgyolK98JBKhqf2Q/2u5PYMNbA+AqU0BU8RHmndLHx6pV3CapN\nzlfxnGf+GslyBssRilQsj/RE+xROno4zAzMTPPVTcEFxGr503PGQyTkszBBI\nCWCDa1fEP2vlaUvz6+9ojkESR8on7WT61FWmS75EfapkEjpA7A86J8WzFOuX\nuUCWElGRcJv4c1Hvk+49rwdDk+ckiwaEoUQDQuQt2oHJro0bA422WrEJlvPg\nidPn\r\n=N83r\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDmctmYJTnULYOlIPOBu2OTyN+6krHaKShEydabeihgxwIhAMS75/nAuE6taVpMENCRI0YX0Ue2izwrRkFZq+TGeCtG"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.9.22_1640517202109_0.02723545747574696"},"_hasShrinkwrap":false},"0.9.23":{"name":"hardhat-deploy","version":"0.9.23","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.8","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.6.8"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"3844a03b00ff6a318f6668ca9b59e82714f7c178","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.9.23","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-2u4n7jGRaChRF7RbzuyiK5MaKRTCmHGVyuNrTPUJ82ucCYITxgaE8hhQIsH7O0hOdrbY0qaoUzk8fVselkaujw==","shasum":"307fdb0044912e10cb4f38206f1f3f5c8d8d41ec","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.9.23.tgz","fileCount":125,"unpackedSize":7650271,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhzby0CRA9TVsSAnZWagAAdfsP+QBhyir9VIBZvEKxPHyw\n9B8vUn9Jn5FGTeJf1PvokM85srWuz96DSbASXFrlOALnyESOvZGpjhZuJZt2\nAT2aOeBLbxAQ72xLOoUVGqyzEoX1lTWZe9IMEzukcniiWYbSu++EWdZNMI1U\nhPmVN+yxh9TB+tENshEb1VBJ2YO06vO/OCzDMmDuhyIZe15wopFx7qmz3Azm\n7F5Dc8Vybivvew+u0MGNqeUOnXfORbj8gSMtkLnYPVPL/5vYafCiAefIREUw\n1ZBQnTbqSqBKZ/HSSNlXKOFFzbiA+r7Y0EVGu6+OKeUu3RnTlNPiXCxNG78t\n4xGSkKZ/wYXQPJE0qVKkXdc89puwrgm3NOLSCVOK/4kaxIGsjPHhN3pExBim\nvO/U0tHLf23zFnxu0x52NiQeDkFo7pKVb+Ifn6XM8syty/nAb5TDrHjCXM6m\nt/kclXjYjJma/NhW4aXasUbIyVdFBA6QTHFLirdMcJuJPrWUIRfYQESt2nwA\nwrKwlVsrN4Bz1aaCbE90OHmHUr0ubWW4PCBgikgzl/TkzEd30DOUN8f0XV1B\nGGWlv1XKkMHTw2omQQtzlIhFXvKWBreETHtej5xdu5oRU9lT1gaNFaiYFMF/\nCkzmvYsUeHNUyJ4EJ9YX6qwXUmJhT+o4Z+SMemI25Wy+GkO6NjG+UiMJrSXU\nb+F+\r\n=z9bm\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDZ9v4zoJKMbJYB1/dUKRuRk4xCb3y0R1/59JSg4kVfcAIhAJAf7jGpMerwmK3iQzTLB7lxQBKRcKQDTX0tJOKXKPiz"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.9.23_1640873140025_0.2858158143960081"},"_hasShrinkwrap":false},"0.9.24":{"name":"hardhat-deploy","version":"0.9.24","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.8","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.6.8"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"6080f5195ffec34691629ca7a01020c3ef81cee3","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.9.24","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-fIIg6Wt7lV8h+6c6dFnINUKcJ/5Wfe5GYDaDsGGPqaK2b71DaeFHjsWRL+2ozaHkMZjdyYBOweY09wRu/KM1Qw==","shasum":"0e0ca589dbeb9682c5b43e935246390cc5d6fb14","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.9.24.tgz","fileCount":125,"unpackedSize":7651252,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJh0xuGCRA9TVsSAnZWagAAUr4P/3GBsL07pJcbvtOutugo\njVC1qvjdZgw3nTRiDHlpO5kkCWHRWc37zqMvrQ21lItTpeYbL2Q6oDzp/tuV\nzQINst5Wr1CoikRhd0lAoGTABS7wypS4MQysdZgj8J586qhS2Kx+U+5L2F0r\nQkOCH/9j7dshv8rZvR2gnH5GA6o6RZuSv5M6VlPO6Wk+86PRpEJgl1zgq0qA\njCSRCfXoOGi/g7WsfxKlDfLntuS5aBs15LwlGjt65etG24jPxwzN/U6kxmPB\no/z2x3sLUtJAoDC7HFKOKIDIwr/RPEnc2yo3+SGSyqNg7s7Tfd/Dwox6JMjr\niUMJdviSnrZso4Mbr6tUGLlFMSHG+2p7wckJBrkO3o0EGP6KdT2RZ/F2AMin\nus9WuB/nllZSpo7eZRnfkzsV+NFbrtD5bgvZYyQC/s9lyfvGWgP5755ByQFv\na5yPHNfpKnMNB3vvdmlwvWzMrPhDMMjTQlGx2l3rpHt3zc4W/H+2AXlWpjV5\nP5beq1qKTQSEQjUnR59wbfbz9L1A5kLpn2TagBYg8gnAGkTPAmo6y9C+ik+6\nFX2xTzexnqkq3Kwy9knio7/4qJp9LO/V0vbC55QGOS+xgt/VvYE4RNlgis3U\nGSZwe9Hcnu4hPem7R8p/Sf8HxFms00qhX67rgf+FhO4UuR2+sG6EEuFREs0H\nV+av\r\n=0Hrq\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCEWgIZ+bOz5Ax3KjzZX79058whl3kSc0wTl5Yv9wfP5QIhAPY8ZrkIu/9eVleSGJZyxLb1Ew19YYKU2aw3cvUdk1oN"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.9.24_1641225094470_0.9599285181190482"},"_hasShrinkwrap":false},"0.9.25":{"name":"hardhat-deploy","version":"0.9.25","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.8","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.6.8"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"fa45d80d499b9841e14eb345d7093980d12603a4","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.9.25","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-be79CxwAG3sOysdbBQNKbKSCOpgs1B892gsP28jjzE8FW25uBILvXbkbr6nEBrehKyX8iVmMkN0zUg4JEYk4bQ==","shasum":"3ab8b98c729066779051f75de0e76a829254a10a","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.9.25.tgz","fileCount":125,"unpackedSize":7656343,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJh6TaeCRA9TVsSAnZWagAAL48QAIFNYlv/Aw/WjfheV4B9\ndsKz+G2/aG+Jp6Wb3iV3T33KD48Mhw9jMsuMnhlRoYsfup+kP0HCqYYqrWfY\nIBFHjEzXhUfmWBWEygo5X9Zxyl4SQKcu61VQuetA5nn1nA7jHSKUuvDafTEu\nDReg8hDV/vgdqtKk/k7alvbjt0JQyEaPdE3RE4tRFyBXskWBDXmTNKFKQ8HN\nL+mNalhtoeAPk9JXMF9AVTl3/v+So/wL8Kc4/D7eUcpqxESi80qWqtYiApyc\nf42VOZSybDvFGtOYnrYAK77s/q76bpv7mlg0U3LFLSxLCmHhxiOuWdyUehCj\neilOk8wcr5SXVvLfVZ697qmNMMIhjfRWGAPT0v2Vurrxyg57gOCcjABdGq8z\n4FR7xRVBnuhK8YFAddoi15IA0ZKUZQfcbzSjhGsQiAdBiUMaxXbKs4slBWXz\nkBLG57wGVATxCxLUx1OhHFmEg3DLcfXHO4o8Ndfh49THdQ4jkgpAAFeqKCJl\nakDGorSIJATqqgqLwCqmh3xmWEwM6aFZD7ThRgcScx1Utl7LQSRwBeeDjDfb\n3AMwMT0d5nXjn5T7BMR8XhdFG4nKL+J60gviDHfuFpjqJQsU2I5j+UJf0Bti\nbnKrkf+ZfymAeaycOd+xRj7FAjZ6joP65EnsIoN8fhk87erXmYoYt36mQUHV\nfSq7\r\n=6T9s\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIDKdEyQ9hwSawwgKhgcW0El32X341B1lfi+DnVNWdCJuAiEAne/cgHbFlmWM7pSCLNGlLqIrR0b2KPWWHZFL/JqJfn4="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.9.25_1642673821853_0.19545035116356124"},"_hasShrinkwrap":false},"0.9.26":{"name":"hardhat-deploy","version":"0.9.26","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.8","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.6.8"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"486f8231edb6e5b813b4a67be4ab5d7ff0fbb22e","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.9.26","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-hQsftZrmPkel8NrcVqHsJaXMv9xCVIaJdzn8TFa8Ow+nuvkt2NvIjsC1aN02SAL2nTI1Na3H1vfubWHSTbN2gA==","shasum":"84b85dbf67f317c8eca8b7cfeab27c051be6f023","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.9.26.tgz","fileCount":128,"unpackedSize":7658482,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJh6UaYCRA9TVsSAnZWagAAjcsP/06Bn4OLFZb/TSSpNd9w\nj4IRocDbqhHeHo2/D+H8Zjq+yUbsL8jKDVVRQpM2ENEVhfC0TLieasKvYCBA\n/MeAFxUWYPv7AvRL1V71Ao+NqBv1s60yAwhc9M7Dfk6cfyHdRVkA+xff3/Ms\nCDiDM5plWwznZnmgK/cveL/8KfMhP1ON+ltWvx2fWoF7/yPue4+fxDhswKDG\nM3DUG20NfUUs6VoJDf9cvAAIp9exe4VKVKkscibqkgHZr/4MqrZK/zAnPQDd\nmXQsP9TcMk+OwY0ugDExkYYUokbhvKfkRZixAYqL2D27HoCRWf8/A7mpqk0A\nFglKLWLfLhtR7UhyCd0vRb93jUT+qJObCdX5MKUaatkqBQsm1TncDlh2mZAT\nzwveXApZctGOEjqDQ+bZPr/HhWpe6ZnnY1xKhII52LJM7qpVqz/5JSiIGBMb\n4pqydFNAS1onERwUryw5oz7wc6wl5tt8/nFiusp6fBG/FeXKJPaAmUMiHTz4\nmums0h3UbobHjpa3/sgE27OJgGmKPcreH/30PGjC1Nys5oxm/vn+KK2RpkwO\nh92wtLHRubdIJQKxuUDVptglmqlBwMAxQHms65fAdATcnIt+cHlh8CbYEy7M\n+uJpSIyXw7sb6niTaBmcRoFUCrDy+1YRKP9YpkOZ7rDZ/hQCR4CkbjPmGk/g\nRddF\r\n=y854\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCt5h9e7bUBV/ycsufLSmMp2DrKW2tTbagbugDCqxg6+gIgFrHGtWXSnp0Sg4YXQE5Ab38xY4cWBGgmS4VLPw76gVI="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.9.26_1642677912572_0.5302241288668841"},"_hasShrinkwrap":false},"0.9.27":{"name":"hardhat-deploy","version":"0.9.27","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.8","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.6.8"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"19b4ef8f9b1423ade4c318178d356f1747cadf63","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.9.27","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-zItDvYRUkJCc3SPO6XNRNUteIZXIijOcIXE1JHfnCCbHjPXmXSQdmkIUUAsmn2zMZjo34pdJ57aisfm7If9w3g==","shasum":"94823079a059d84732b4860f3e6cf4d2199a327d","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.9.27.tgz","fileCount":128,"unpackedSize":7658771,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJh6vspCRA9TVsSAnZWagAA4DcP/j6GLuHm6hqHlAQZQEI0\nPUTNqvK8SgTVfpDPRwft+7vJxylFQEDuO+FjCKKRwUnhJCC1TdnBJJVTqHQp\n6hJt95ppvpcwhO1BhOpQKc1U7FmKKAn2dtrz2RtmMOA2S/hz8CxienKGpuyW\nwBHoWGCKyUf4gdsCgQn12rES3UwXAcNC3pGza5aOBYr0D0UJpFWLrFbpEXZA\nxt/OQfTAfPj2euKAUHpxrybBD8n1POUFwyPgowIpxxuitLrpZzT9hdPfrA3y\nCKtXr/gsytuGNwLPurUs/7gjwG418q77Rztcx+BNkTo3ujF2MbkvNHi9WkjM\nbmXVdmZ/BCx96+7HrIgWFso8BmvHtFX8RWzsRQRUvx7EUsktoqit1HDGj2Q4\nW+7P9wYZfW79HqrluaVeF+c5CsobqIO2zNNMraoW5YPRE7u37AuJeGmET3GU\nNt8dnXjVKXczZ0SCTPwoYSz8dT/tl3UIKzmRqwNxwSPg0M1lt/XLZaMECfiD\nwh8nXUF4cd56gT203qDCBFDoLsoTBR7t5y5n7fg9xWk/cY0UtzQBpWbs1F2w\nSogC5IXdIjzxHHtEt6trhVyKsyhbsrzsTfFb+oLPiFTz7Kh0Rez8H1oVCpB8\nz6gaETXNPocNoEy8Pl6O2JZtT643sDhZcq0jhdFWteBJ2NyPjNaOjJPxqpiU\nqy/8\r\n=9aG9\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIEGiOwXEqAFYKH267vFGbDtfL7o9FksIOlj6iv9MgFdlAiEAqRSyVVx93VeSds4NiFqw0sf+2A7TZeMmSUiMg0zNLSI="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.9.27_1642789672898_0.135921089995656"},"_hasShrinkwrap":false},"0.9.28":{"name":"hardhat-deploy","version":"0.9.28","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.8","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.6.8"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"7bcb41ec6af2202efc413517d4bde2a52b53ce88","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.9.28","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-YwNGxjXEkbMdq6UNuarQE+jd/lvl+I0ik+JNIpnlOWtTpllORBO/khOV1aHHxSpVXXW/j+CNhHx09QOlxSmP3g==","shasum":"d9b06f788db4e154639f524fa30d75883fbff5c6","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.9.28.tgz","fileCount":128,"unpackedSize":7659653,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJh7pohCRA9TVsSAnZWagAAeHwP/3Rjh9Dvbq5TmGX7u+U5\nTTKHuYfq2Mk5zTYM6jLqjLyjW1wZHnWetGPcvjIrlTmbzsCq+M35BcJISsXX\nD1Ggyq3apUuDWDlq7KmYIETGX70i9XldKe6qADCUvmF5ZvMiai8xWQ045Un5\n/rJXq2NpWz5pavZlR+P/KPVKfesv+lDa+fQOj22VBBlg/0YEYK9zgRzbf2ma\ngYbSyfDFEfQOOmSSN+q8lqBTuZzaCtQKPP4L/T6QQTw3/b2rlGwR1akXpOg/\n+Ybyndg1STz8uaGbvTVSZq0oaEO7UO+teLrJZDyZU93drkJxymVGzsn5eKfq\nuToG9sBFfq44n5MtASW+Py0wsAopcQ7avecykHpsxgBUxOlFaioyX/8o+P06\nSvlnflOPkJps7GjBWS6Pm69/vqu03IjRQJdFgXixhPLiUp1gw1nCg0pgR/f1\nYPwD32C8dV1KNyHVZ9P3H0Ihmxq0s5AeBxsWGXEAWs5YMDVxNHEJlLvmV/t8\nYrtvPaNFsW4Blyyy994murPl4tQbFeeT8mgDuYaK0plYvYz9wUbJ0CeCavhD\nQL3oBSDy1QCMtn93hWsaeG7SM+uo+63UcfrkS3ocQt6TQxZpjQbAb/1uMSV0\nSP9snLjUeNAKVJyDFbEEUMOhtPrb5mBnX9ULAR93Wa2W+xPebwzkI0onJgZ0\nnHhX\r\n=DONb\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIEBoRxOcIJp/3HiBQ/QjPAGau1hlwydi4CMF/GsfD2OCAiBq7PkhyIw0tOlXZ4Mpj5K9kmTZid8yFkWF3nF51M5GXw=="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.9.28_1643026977457_0.2913519361481418"},"_hasShrinkwrap":false},"0.9.29":{"name":"hardhat-deploy","version":"0.9.29","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.8","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.6.8"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"d7c6d0bf0890b7677af25f00fb1026c06e4da751","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.9.29","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-8tIGszPFmOaXtyloCbASiZPvoAgLNGGL/Ubys3YW/oj4dvoPa8G6YDyaOCdsAhsENZ+QgR280NFSG9JdN7SU9Q==","shasum":"b1177d4f3077f335ad3f50c55825d9417ec75968","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.9.29.tgz","fileCount":128,"unpackedSize":7661971,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJh8vHhCRA9TVsSAnZWagAA4xIP/0RVEZtLpUcUebABucrC\ny2lnjI5a2rZGQCM+IEE6Uy1/UBxRVvRjMHP87A1nqalVpSRMKzyqKOjKXDMg\nH4/gQeTH4ihzhTvfVahW+0Ti2RFIKNOlZVO2Ov6/zlk46mT5zYSZosDLxmBm\noZe1q7dUCHUIqLTQ2+ZobRjvYkTccQgDQiR1xBvWfXGk9aiO+rmXYBHOaTsJ\noBbcGZSLIZ9twD1EIyZYEyKqGDTfby1ICkdC3LddUz+o4gHBXMx2VRxyfNUA\nCgRtgc4IOvTgXdDmTormLDoqDL27swFhjHV1wBmSgHf76if+O5K8TaxttFIw\niAXEbH/j+nzBTU5/uEituUaWssb9/RE4B/pbhu9oukCudN32cXWQs1q8NDnf\n3G5fUYvT2aMeR+JcjRSsgdvM3oUZuxqhJZ0XUD33+2ul/Nt26weAQzICdxFr\n7SBpRn5GcDjfQFDA2Ge0QqAbh5oBm9jW+Yl2lmUo51ZzeAO0vfgk9Nh2Aq3D\nSiAVrtR3ydck21/8isxhzs8daVGmX7i7+QBcKJ6tVUDhmb6lUflpPtmVzEUj\n+S5hfGrUZ9Xu01jViAQLn6Ar3XlUvJELT4jSM9Q8GKFth/MZLAYWMPkRTiUf\neYvf9tA96iqvO2CSlJY2Hur21IOj+GQeWlzbVJKzpdyL/bd8xQXge0585cZs\nd4WB\r\n=zDUQ\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCu3ncUZFcrhyReL8kcwxd4tE6KvwiQ8vxV3bK2jefK/wIhAMzA26BKgkrby0LjxKoa0cvW3lAL0hiCSSO9QDRehmHJ"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.9.29_1643311585044_0.5661230383189109"},"_hasShrinkwrap":false},"0.10.0":{"name":"hardhat-deploy","version":"0.10.0","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.8","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.6.8"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"25b8d2f84e4fcd58013bd4617a78be58f9a7d629","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.10.0","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-C6p0IvdK2CK0fIsdUK0dM+nuhCmDvuL8fi19RUPeSMMfl7BityJArAzVbJt5f68VJ3CZRMa5WV7aSc8M8sNHvg==","shasum":"6b98790010dd3f1f362c4ad45207e43c8511eadd","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.10.0.tgz","fileCount":128,"unpackedSize":7665580,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJh8+LtCRA9TVsSAnZWagAAc9oP/i/8N5Q3TD7ZpiLNZbNF\nWx41JLtFGJFLpFWXiYpiqxx3f4qPMxAM8BxLcqMVCBOd9icO2Ao1XPjlOiul\nMydWrEKBiL1bRi2Jal2nmcyQt31zMl7tUL/RV+v7JFoGYT9zEXZFdSQkb8Dp\nX3UNgDLTYW4+6WPbSnKEKUrP5C0Snp3XZGR7JReLtUoNWCLPkIQEfwQL4Faq\nuGyKvs7cMBQpiAVjttxjpxaI0eivr9rUsV06ZMYb0e3k29tCtlwjtMjTl94d\nEFFhu8NGWT440UAaWcEdbRVZEQizof/drZm0p604o4tJC6dn7A1mEGAjOioW\n2j/GLW4lKJG8mgfVjjS1KA/v/anyaujTmKxL45v23ENedSInl0Pycu6r1vId\nf/9Ifr5hLipTz+CsNj9qLdf7R00mB58Wy42uKTY4dIVgZIxd6SOCOKpes3Lv\nw9tse7xL5Rv7wL6lAywHdjeJGBp1T+kzGtS45nSITk2dJvqbFNH13lulcQG2\nSv9b/osQA6lrS6erABBw9BjrGg//Hp5+yzlpVH3kpD5yw8yOl4uaTTcvCbRC\n8Nm6WnYae5JV/7M9bnmLFMr88aD86hUpYCrWjg5s3lTikFuT744m+AOfI918\ngfoo3SgV7LkxqokdrOSoZB8VLUgn1JA1HO8hYor+IrMUlj0B3tgnzb2ujYoe\n1yQ8\r\n=1hsH\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIDeY4GdYWEXn5wee5ca+4KxUwn1rj4ibX4eYryIeIcfOAiAp+tQH2m6YV9fo8EedxNWN8xHTlC913Ilu8FLW0s6vRw=="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.10.0_1643373293557_0.07075467155647464"},"_hasShrinkwrap":false},"0.10.1":{"name":"hardhat-deploy","version":"0.10.1","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.8","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.6.8"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"2e4367fcaf2b73375e4425853d1e20d6467da5eb","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.10.1","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-5gK0ztIpbqut7C9i9zYmpMoxxFcuPz7pcNESYCRfpR1UGcFQagnoiRKUI+tK8nI6bpAlfLG06wShuiV2id9MOw==","shasum":"89fbb8af7781657b1597dd504df694a20c0cb728","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.10.1.tgz","fileCount":128,"unpackedSize":7667675,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJh9Cf5CRA9TVsSAnZWagAAgxwQAJjhqVol7TXbLz5CkDc8\n/6O7aqUme2MBm+tCMKPBMqD0M7CuYpPngP9O9YqQBk7KZNZdpZ4u85oKXSIV\nmJqLMFcG6kIeAKV5BL2lbS5P5XsLofDJDAvwsEqqibqJHg0wPQy8cwFpSJ7w\nRDftxP404S36HN91OchPdty5Dud5OdmxORXfAYbJv+vPmEA2973AfmpAS1Ii\niQWre49OFQ/I3D+h7a/ZYcPwssI3FuUg19UVmROTpNKAI21N10NG8VOMynTY\naZjRDrMKybBZEsIW+YW6GBsYSsUfBLUAu1CgaNDfgDE+exuQR4GSu/36nIrk\n3EXQYFibGIimPmAV0vPj1fHVAKgnpfnUbiYNkE+e+kmGIQlfPoJN+7q5Vi+G\n4LXGg4r9BG0UMosPRQYaFsJTJEeSagwwOXM45P8/Vlm/u81ywB2gzVfkQ5hW\nY30Alrjy1i4i4xV1nuV7rJ0h5ZBGrbZ2theIFpcbD7bxloXiP5M5xfaKmuzV\n+0fJre7zLN1npadjQ9YpUXIrt6Z9ehs1rpFo0N+F8TXvFZlQZmwm2tkGNix6\nkIVwr9ixRnA+94mCX5OyMfhCOaFHkCmaEIN+slgcatyiD4BH9zxg/zWkz8+Y\n46UaG2FW+Mx6eCCPBJUVCQSO9KHFLRq3V7m2Hz1UUYdMv9x9lcAqfqlKDKa0\nQ/bc\r\n=nnKO\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCKMwa4oQ9vIePyr06EWOKqC+7N5fjlkQdUSwQiFoD8JQIgfGPc/V55wxV3pHoaQswJMnXkAYVBII/kkgO7PkyGQ/o="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.10.1_1643390969693_0.44575655522683966"},"_hasShrinkwrap":false},"0.10.2":{"name":"hardhat-deploy","version":"0.10.2","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.8","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.6.8"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"c533a3dad115dd6758332ddc1d09b640e5cf86f3","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.10.2","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-Omkfiqulne5Bt9ZnRpzrFftBFiZ7N2kxeVyA2ec6OPmcUXqHAllS32Te4Hmx1XshIlFGlXlCWLFCbexMpsL+oA==","shasum":"64604bea2b3c4f91542f1ded8b8cf30edbcf8c2f","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.10.2.tgz","fileCount":128,"unpackedSize":7668620,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJh9GTXCRA9TVsSAnZWagAAuegQAIPM+/gS+0R3dL0tGJoS\n1EOm6JWkxOG2Jwcib0e5g5idySRyathT19OEgo/2bSONxqoI/+JZx2f1bKRB\nVwOMmqlLBW8+SNx6cVUO1qPEkhYRIos+ubIanu0ipZXBwBFEhKTIQ8Xi+gu7\nuJCIZvcg3bHj52wPLsTSfuPx1/b+A+4kX6OlxGQCLZ2JnJSVv035c7JLO+C9\nU8PynyKvHpz4IM6mdqMVdJe5+y33eu3vgA+/BPshdIhLZkf1603Wzi48hJ16\nRn2BZuSoR7e9DA3fdSRGLppspvHkURLQ+9Ew0NVCfueLRuFhr3ZQHljDSLSd\n3ML0M0kseCoGegVShV4sLsPHeLN8t7ypTeYhnmaMTBV8XsyDYcVTSWvb4TCk\nMT2RSmR9M9Cd1w2VDztFyM6bTM4+EgGu0HOWAYzQ/eYVvfdrddF8ayN/EtTC\nybp1Ns0l3g1kfnU3eAemD9kRG+DhTYqgPIuyUj7QZ0NvBkXc+sY5TAgsge3e\nPlaAqgewMvS9enVeQTKf1mE5nkkXw7kppN+HTjMe4Ek6myyRGlw1jdpT6eBv\nGK4C78xLUGyknHekPwHMeolDbsyYg2JVPWTp59NoY4teWB9MMl4dZM1357vy\nNVLoaXnsMyRmFrYUWUvusLZDK4+uF3oEk4HBQ+NTP1p+X6WDRfbNrXcHS/GD\nSd1+\r\n=K6R6\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIHowZIdBzSB7SfToVhjK1bdytGI6faisZXx+4r2k7NYpAiEAlWXngY9hT9916elw+HuUhn0ySEKwKEGub8cV2xXQPfE="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.10.2_1643406551644_0.6183591839647293"},"_hasShrinkwrap":false},"0.10.3":{"name":"hardhat-deploy","version":"0.10.3","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.8","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.6.8"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"e6694b90f083eaccd3058962b55eed7d89910320","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.10.3","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-mSxEc/561qbmhr0e5E4Y9DtjXe27Fnqy9ATz/dMgL4mzrPt4Pe/QM2b2TrGyt33ETW1bQnvMtodIGhBhCrkOrw==","shasum":"90aca05b894a7f1f572ab6f05effc4eb2faa9d6b","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.10.3.tgz","fileCount":128,"unpackedSize":7670077,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJh9Q/5CRA9TVsSAnZWagAAuRkQAJQYDCS7PZX2Ym71xTbj\n0gefdQD5wfAFkwILhkWPbwf9pZKVB+tYwIEQhJhmjMfTjES/2UWN+opbcIle\nksyyM3duydwGxIjzc+oMYwpWhFT4gQ9dV1cGyUtz+S1B3A11MeQju6RU3GoQ\n8zvuu1enahWw8ipXgnLwWpmHWB/Whsk8lw9o3VxtoWxKorterMwn8O9MoMsS\ne//rg7pS5Kta4TNSp2cXWFnT7KfvzQUBvZ6CXlcuUiWUmCKU7mQ75ODoDpF5\nWlN7kDs82b2gORfDpAcih7zay7Vh/Wfc8mFk4xZMZTT3+iHKJNClWy+1Q5/J\nC/wd//cJQDhBingZdTqAcE60Mu2llXN3cFNqTuqcbLAAToGInLoPkoNu1XBe\niLS8YpNpd0JAafBcKY2eR+P9EpvhacNKf78IHcArgp/vJSpN8jhncpkbrCqP\nLRRl0nDJLxVl2CzzmpL+OF9mk/f211jUOLT0IbtfEXbsdKXdTF9aIN/omsYm\nmSAfMNSThkqWbvFEkKFoHyagdhvramssXycHTOiFb4ATWYcFNrFsdebqg+fP\nMlBPtPnfXlOO6GUS2ET/F1GpsRzJo35PxOU/qV4Mg3oZUgPBPP/lZfCnRlXG\noqqGWvImvmHAsgq/s8k9uAtypOmmTeq+KKFl5umVkNy3a31Y+seq6eYgLASp\nRxRj\r\n=cpS3\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDhNTd5rdEJ8pnIuPvb9nFMQ7yE/Q4xIRx7ZmBQJrvRrQIhAPG4WlCWYP2mNiW3PY7y7Of+RIzAzle9h2lBaD7zRxIh"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.10.3_1643450361284_0.5983044285726813"},"_hasShrinkwrap":false},"0.10.4":{"name":"hardhat-deploy","version":"0.10.4","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.8","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.6.8"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"ee100366daa9208586eab6f510ff38986dea7e21","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.10.4","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-9b7kFWul3Gjm/JURzVicnD5mGNjNyEwFHFKU+8URJ3q4hjCvYR9Ja99ChmVMGzM8DPJhlvEVNBkcv/3wnwZpfQ==","shasum":"5e064f40f103401ee1e0b8563b6ebf9ad986b921","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.10.4.tgz","fileCount":128,"unpackedSize":7672036,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJh9V7nCRA9TVsSAnZWagAAxHcP+gMOwYTsoYQ0KM3iGZ/g\npWgMMb1W2ZdA+tulQY0h7KxJwJvJ+N3B10QCVCWnShe8siwxdMk4Inl7cMz8\nN5iXj+cLXFKi4gLBkIuhHtSQ/2bPY8Zs+0mpzVDXf3inesmVd+C2gDUp8Psl\nyaCxIDyGy57zv/F3N3PExhHuVr5xNA0ZCuvEdJjxaPew0aRIxr9VRM5DTHxF\nYioldBgxZZEncKyTb6CaY0QiOK1KrxRoWn+HYnoTAgH+7qRUJqq6mKDgUMx5\nb2//g60B+1GlmTADZEjnLyXyxOq+BECBWO/bYeBhYnvVwzJA2nTUkJcegkaK\nNzfpWfM/GLP6oIqJSTK29PRmBVJok1kdSL7FFV1nuKdkZU1owwRppbEl+Md3\nfikYDqbc5De5bZTM4nxYK7WmWvjxL5tNnhaB+vHK02MZqh0yUxNWyR4FAApV\nE6rcm+SXdLrWisMy4aVTW7lyTfT+vE8gYy90i8BjmUyPB3H5zGHSdhePjl4s\nYRaOX1m/CeicgbsDOwNL6jX8OLFMChTZPpBtcngwTrw2tfk954DT7dc6HncS\nfDLYlOpsMdVIgHy9plSb5ygaacbqes1Ozm1fAxjljLlhn4qZvxA3380lIDze\nE1d9DrZG5nOTqBnNJ5VgjfC4o+6cINa58txMvfs836M8oBPXYRC0OIqOAjkD\nkKe5\r\n=EEdN\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIAvcgBotAvkxrns1RK1n7axe/dJkKC2jDOKEytxcBOcfAiEAh9nQd5rChAfB37S4XpKoyCWuB/UZLLvcWpqI/xYlc1o="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.10.4_1643470567087_0.16076516742013136"},"_hasShrinkwrap":false},"0.11.0-next.0":{"name":"hardhat-deploy","version":"0.11.0-next.0","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.8","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.6.8"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"readme":"<h1> hardhat-deploy</h1>\n\n_A [Hardhat](https://hardhat.org) Plugin For Replicable Deployments And Easy Testing_\n\n> **A complete dev template using hardhat-deploy is available here** : https://github.com/wighawag/template-ethereum-contracts\n> It also contains various branches examplifying the capability of hardhat-deploy. Check it out.\n\n- [What is it for ?](#what-is-it-for-)\n- [hardhat-deploy in a nutshell](#hardhat-deploy-in-a-nutshell)\n- [Installation](#installation)\n  - [npm install hardhat-deploy](#npm-install-hardhat-deploy)\n  - [TypeScript support](#typescript-support)\n  - [Migrating existing deployment to hardhat-deploy](#migrating-existing-deployment-to-hardhat-deploy)\n- [Hardhat Tasks Available/Updated](#hardhat-tasks-availableupdated)\n  - [1. hardhat deploy](#1-hardhat-deploy)\n    - [**Options**](#options)\n    - [**Flags**](#flags)\n  - [2. hardhat node](#2-hardhat-node)\n    - [**Options**](#options-1)\n    - [**Flags**](#flags-1)\n  - [3. hardhat test](#3-hardhat-test)\n  - [4. hardhat etherscan-verify](#4-hardhat-etherscan-verify)\n    - [**Options**](#options-2)\n  - [5. hardhat sourcify](#5-hardhat-sourcify)\n    - [**Options**](#options-3)\n  - [6. hardhat export](#6-hardhat-export)\n    - [**Options**](#options-4)\n- [Hardhat Environment Extensions](#hardhat-environment-extensions)\n- [Configuration](#configuration)\n  - [**1. namedAccounts (ability to name addresses)**](#1-namedaccounts-ability-to-name-addresses)\n  - [**2. extra hardhat.config networks' options**](#2-extra-hardhatconfig-networks-options)\n    - [`live`](#live)\n    - [`saveDeployments`](#savedeployments)\n    - [`tags`](#tags)\n    - [`deploy`](#deploy)\n    - [`companionNetworks`](#companionnetworks)\n  - [**3. extra hardhat.config paths' options**](#3-extra-hardhatconfig-paths-options)\n  - [**4. deterministicDeployment (ability to specify a deployment factory)**](#4-deterministicdeployment-ability-to-specify-a-deployment-factory)\n  - [Importing deployment from other projects (with truffle support)](#importing-deployment-from-other-projects-with-truffle-support)\n  - [Access to Artifacts (non-deployed contract code and abi)](#access-to-artifacts-non-deployed-contract-code-and-abi)\n- [How to Deploy Contracts](#how-to-deploy-contracts)\n  - [The `deploy` Task](#the-deploy-task)\n  - [Deploy Scripts](#deploy-scripts)\n    - [An example of a deploy script :](#an-example-of-a-deploy-script-)\n  - [The `deployments` field](#the-deployments-field)\n    - [`deployments.deploy(<name>, options)`](#deploymentsdeployname-options)\n- [Handling contract using libraries](#handling-contract-using-libraries)\n- [Exporting Deployments](#exporting-deployments)\n- [Deploying and Upgrading Proxies](#deploying-and-upgrading-proxies)\n- [Builtin-In Support For Diamonds (EIP2535)](#builtin-in-support-for-diamonds-eip2535)\n- [Testing Deployed Contracts](#testing-deployed-contracts)\n  - [Creating Fixtures](#creating-fixtures)\n- [More Information On Hardhat Tasks](#more-information-on-hardhat-tasks)\n  - [**1. node task**](#1-node-task)\n  - [**2. test task**](#2-test-task)\n  - [**3. run task**](#3-run-task)\n  - [**4. console task**](#4-console-task)\n- [Deploy Scripts: Tags And Dependencies](#deploy-scripts-tags-and-dependencies)\n\n## What is it for ?\n\nThis [hardhat](https://hardhat.org) plugin adds a mechanism to deploy contracts to any network, keeping track of them and replicating the same environment for testing.\n\nIt also adds a mechanism to associate names to addresses, so test and deployment scripts can be reconfigured by simply changing the address a name points to, allowing different configurations per network. This also results in much clearer tests and deployment scripts (no more `accounts[0]` in your code).\n\nThis plugin contains a lot more features too, all geared toward a better developer experience :\n\n- chain configuration export\n- listing deployed contracts' addresses and their abis (useful for webapps)\n- library linking at time of deployment.\n- deterministic deployment across networks.\n- support for specific deploy script per network (L1 vs L2 for example)\n- ability to access deployment from \"companion\" networks\n- deployment dependency system (allowing you to only deploy what is needed).\n- deployment retrying (by saving pending tx): so you can feel confident when making a deployment that you can always recover.\n- deployments as test fixture using `evm_snapshot` to speed up testing.\n- ability to create your own test fixture that automatically benefits from `evm_snapshot`'s tests speed-up boost\n- combined with [hardhat-deploy-ethers](https://github.com/wighawag/hardhat-deploy-ethers) it has the ability to get ethers contract instance by name (like `await ethers.getContract(\"ContractName\")`).\n- importing artifact from external sources (like npm packages), including [truffle](https://www.trufflesuite.com/truffle) support.\n- importing deployments from external sources (like npm packages)\n- ability to log information in `deploy` mode only (while in test the console remains clean).\n- contains helpers to read and execute transaction on deployed contract referring to them by name.\n- These helpers contains options to auto mine on dev network (to speed up test deployments).\n- save metadata of deployed contract so they can always be fully verified, via [sourcify](https://sourcify.dev) or [etherscan](https://etherscan.io).\n- ability to submit contract source to etherscan and sourcify for verification at any time. (Because **hardhat-deploy** will save all the necessary info, it can be executed at any time.)\n- support harhdat's fork feature so deployment can be accessed even when run through fork.\n- named accounts are automatically impersonnated too, so you can perform tx as if you had their private key.\n- proxy deployment with ability to upgrade them transparently, only if code changes.\n- this include support for [openzeppelin](https://openzeppelin.com) transparent proxies\n- diamond deployment with facets, allowing you to focus on what the new version will be. It will generate the diamondCut necessary to reach the new state.\n- watch and deploy: **hardhat-deploy** can watch both your deploy script and contract code and redeploy on changes.\n- HCR (Hot Contract Replacement): the watch feature combined with proxy or diamond, gives you an experience akin to frontend Hot Module Replacement: once your contract changes, the deployment is executed and your contract retains the same address and same state, allowing you to tweak your contracts while debugging your front-end.\n\n## hardhat-deploy in a nutshell\n\nBefore going into the details, here is a very simple summary of the basic feature of **hardhat-deploy**.\n\n**hardhat-deploy** allows you to write [`deploy scripts`](#deploy-scripts) in the `deploy` folder. Each of these files that look as follows will be executed in turn when you execute the following task: `hardhat --network <networkName> deploy`\n\n```js\n// deploy/00_deploy_my_contract.js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('MyContract', {\n    from: deployer,\n    args: ['Hello'],\n    log: true,\n  });\n};\nmodule.exports.tags = ['MyContract'];\n```\n\nFurthermore you can also ensure these scripts are executed in test too by calling `await deployments.fixture(['MyContract'])` in your test.\nThis is optimized, so if multiple tests use the same contract, the deployment will be executed once and each test will start with the exact same state.\n\nThis is a huge benefit for testing since you are not required to replicate the deployment procedure in your tests. The tag feature (as seen in the script above) and [dependencies](#deploy-scripts-tags-and-dependencies) will also make your life easier when writing complex deployment procedures.\n\nYou can even group deploy scripts in different sub folder and ensure they are executed in their logical order.\n\nFurthermore hardhat-deploy can also support a multi-chain settings like L1, L2 with multiple deploy folder specific to each network.\n\n**All of this can also be bundled in a npm package so user of hardhat-deploy can reuse your deployment procedure and get started integrating with your project locally.**\n\nThere is a tutorial covering the basics here : https://github.com/wighawag/tutorial-hardhat-deploy\n\n## Installation\n\n### npm install hardhat-deploy\n\n```bash\nnpm install -D hardhat-deploy\n```\n\nAnd add the following statement to your `hardhat.config.js`:\n\n```js\nrequire('hardhat-deploy');\n```\n\nif you use `ethers.js` we recommend you also install `hardhat-deploy-ethers` which add extra features to access deployments as ethers contract.\n\nSince `hardhat-deploy-ethers` is a fork of `@nomiclabs/hardhat-ethers` and that other plugin might have an hardcoded dependency on `@nomiclabs/hardhat-ethers` the best way to install `hardhat-deploy-ethers` and ensure compatibility is the following:\n\n```bash\nnpm install --save-dev  @nomiclabs/hardhat-ethers@npm:hardhat-deploy-ethers ethers\n```\n\nWhich means you then need to do `require(\"@nomiclabs/hardhat-ethers\")` instead of `require(\"hardhat-deploy-ethers\")` in your `hardhat.config.js` file.\n\nMore details on `hardhat-deploy-ethers` repo : https://github.com/wighawag/hardhat-deploy-ethers#readme\n\n### TypeScript support\n\nWith hardhat the tsconfig.json is optional.\n\nBut if you add folders to the `include` field in `tsconfig.json`, you ll also need to include `hardhat.config.ts` like :\n\n`include\": [\"./hardhat.config.ts\", \"./scripts\", \"./deploy\", \"./test\"]`\n\nfor deploy script (see below) you can write them this way to benefit from typing :\n\n```ts\nimport {HardhatRuntimeEnvironment} from 'hardhat/types';\nimport {DeployFunction} from 'hardhat-deploy/types';\n\nconst func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {\n  // code here\n};\nexport default func;\n```\n\nSee a template that uses **hardhat-deploy** here : https://github.com/wighawag/template-ethereum-contracts\n\nThis repo has also some examples branch that exemplify specific features, like the forking testing here : https://github.com/wighawag/template-ethereum-contracts/tree/examples/fork-test\n\n### Migrating existing deployment to hardhat-deploy\n\n> Only needed for existing project that already deployed contracts and has the deployment information available **(at minimum, address and abi)**\n\nYou might want to switch your current deployment process to use **hardhat-deploy**. In that case you probably have some deployments saved elsewhere.\n\nIn order to port them to **hardhat-deploy**, you'll need to create one `.json` file per contract in the `deployments/<network>` folder (configurable via [paths config](#extra-paths-config)).\n\nThe network folder is simply the hardhat network name (as configured in hardhat.config.js) (accessible at runtime via `hre.network.name`).\nSuch folder need to have a file named `.chainId` containing the chainId as decimal.\n\nFor example for network named \"rinkeby\" (for the corresponding network) the file `deployments/rinkeby/.chainId` would be\n\n```\n4\n```\n\nNote, prior to hardhat 0.6 the chainId was appended to the folder name (expect for some known network name). This has changed and upgrading to 0.6 will require you to change the folder name and add the '.chainId' file.\n\nEach contract file must follow this type (as defined in [types.ts](types.ts)) :\n\n```ts\nexport interface Deployment {\n  address: Address;\n  abi: ABI;\n  receipt?: Receipt;\n  transactionHash?: string;\n  history?: Deployment[];\n  numDeployments?: number;\n  implementation?: string;\n  args?: any[];\n  linkedData?: any;\n  solcInputHash?: string;\n  metadata?: string;\n  bytecode?: string;\n  deployedBytecode?: string;\n  libraries?: Libraries;\n  userdoc?: any;\n  devdoc?: any;\n  methodIdentifiers?: any;\n  diamondCut?: FacetCut[];\n  facets?: Facet[];\n  storageLayout?: any;\n  gasEstimates?: any;\n}\n```\n\nAs you can see, only abi and address are mandatory. But having the other fields allow more feature. For example, metadata and args allow you to benefit from contract code verification.\n\nFor Receipt, the following type is expected:\n\n```ts\nexport type Receipt = {\n  from: string;\n  transactionHash: string;\n  blockHash: string;\n  blockNumber: number;\n  transactionIndex: number;\n  cumulativeGasUsed: string;\n  gasUsed: string;\n  contractAddress?: string;\n  to?: string;\n  logs?: Log[];\n  events?: any[];\n  logsBloom?: string;\n  byzantium?: boolean;\n  status?: number;\n  confirmations?: number;\n};\n```\n\nHere is an example:\n\nLet's say you have:\n\n- 2 Contract named Greeter and Registry deployed on rinkeby\n- 1 contract named Greeter on mainnet\n- 2 Contract named Greeter and Registry deployed on a network named rinkeby2\n\nYou would get the following folder structure:\n\n```\ndeployments/\n  mainnet/\n    .chainId\n    Greeter.json\n  rinkeby/\n    .chainId\n    Greeter.json\n    Registry.json\n  rinkeby2/\n    .chainId\n    Greeter.json\n    Registry.json\n```\n\nThe reason why **hardhat-deploy** save chainId in the `.chainId` file is both for\n\n- safety: so that if you were to change the network name to point to a different chain, it would not attempt to read the wrong folder and assume that a contract has been deployed while it has not.\n- ability to know the chainId without requring to be connected to a node (and so not dependent on hardhat.config.js settings). Useful for `export` task.\n\n---\n\n## Hardhat Tasks Available/Updated\n\nhardhat deploy add several task to hardhat. It also modify existing one, adding new options and new behavior. All of these are described here:\n\n---\n\n### 1. hardhat deploy\n\n---\n\nThis plugin adds the _deploy_ task to Hardhat.\n\nThis task will execute the scripts in the `deploy` folder and save the contract deployments to disk. These deployments are supposed to be saved for example in a git repository. This way they can be accessed later. But you are free to save them elsewhere and get them back via your mechanism of choice.\n\nWith the deployment saved, it allows you to deploy a contract only if changes were made.\n\nDeploy scripts (also called Deploy functions) can also perform aribtrary logic.\n\nFor further details on how to use it and write deploy script, see [section](#deploy-scripts) below.\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployments, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice (in wei) to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--reset`: This flag resets the deployments from scratch. Previously deployed contract are not considered and deleted from disk.\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n---\n\n### 2. hardhat node\n\n---\n\nThis plugin modify the _node_ task so that it also execute the deployment script before exposing the server http RPC interface\n\nIt add similar options than the `deploy` task :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--no-reset`: This flag prevent the reseting of the existing deployments. This is usually not desired when running the `node` task as a network is created from scratch and previous deployemnt are irrelevant.\n\n`--show-accounts`: this flag will output the account private keys\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n`--no-deploy` that discard all other options to revert to normal `hardhat node` behavior without any deployment being performed.\n\n> :warning: Note that the deployments are saved as if the network name is `localhost`. This is because `hardhat node` is expected to be used as localhost: You can for example execute `hardhat --network localhost console` after `node` is running. Doing `hardhat --network hardhat console` would indeed not do anything useful. It still take the configuration from `hardhat` in the hardhat.config.js file though.\n\n---\n\n### 3. hardhat test\n\n---\n\nThis plugin adds a flag argument `--deploy-fixture` to the _test_ task which if enabled will run the global deployments fixture before the tests and snapshots it. This will generaly speed up the tests as further test will be able to revert back to the full deployment.\n\n> :warning: Note though that if your test behave differently whether that option is on or not, this most likely mean that your deploy scripts' tags and dependencies are not configured correctly. This is because the global fixture will ensure all contract are deployed while test will usually (for efficiency) ask for a particular tag.\n\n---\n\n### 4. hardhat etherscan-verify\n\n---\n\nThis plugin adds the _etherscan-verify_ task to Hardhat.\n\nThis task will submit the contract source and other info of all deployed contracts to allow etherscan to verify and record the sources.\n\nInstead of using the full solc input, this task will first attempt to send the minimal sources from the metadata.\nBut Etherscan sometime fails due to a bug in solidity compiler (<https://github.com/ethereum/solidity/issues/9573>). As such this task can fallback on full solc input (see option --solc-input). Note that if your contract was deployed with a previous version of **hardhat-deploy**, it might not contains the full information. The issue seems to be fully resolved since solc version 0.8.\n\nThis task will also attempt to automatically find the SPDX license in the source.\n\nTo execute that task, you need to specifiy the network to run against :\n\n```bash\nhardhat --network mainnet etherscan-verify [--api-key <apikey>] [--apiurl <url>]\n```\n\n#### **Options**\n\nNote that harhdat-deploy now use a different config format to not conflict with `hardhat-etherscan`\n\n`--api-key <api key>`: let you specify your etherscan api key. Alternatively, you can provide it via the env variable `ETHERSCAN_API_KEY` or through the hardhat.config.ts verify field:\n\n```js\n{\n  ...\n  verify: {\n    etherscan: {\n      apiKey: '<API key>'\n    }\n  }\n}\n```\n\n`--api-url <url>`: let you specify your etherscan url to submit the source to. Can also be configured per network in `hardhat.config.js`:\n\n```js\n{\n  ...\n  networks: {\n    mynetwork: {\n      ...\n      verify: {\n        etherscan: {\n          apiUrl: 'http://mynetwork.xyz'\n        }\n      }\n    }\n  }\n}\n```\n\n`--license <SPDX license id>`: SPDX license (useful if SPDX is not listed in the sources), need to be supported by etherscan: https://etherscan.io/contract-license-types\n\n`--force-license`: if set, will force the use of the license specified by --license option, ignoring the one in the source (useful for license not supported by etherscan)\n\n`--solc-input`: fallback on solc-input id needed (useful when etherscan fails on the minimum sources, see https://github.com/ethereum/solidity/issues/9573)\n\n`--sleep`: sleep 500ms between each verification, so API rate limit is not exceeded\n\n---\n\n### 5. hardhat sourcify\n\n---\n\nThis plugin adds the _sourcify_ task to Hardhat.\n\nSimilar to `hardhat etherscan-verify` this task will submit the contract source and other info of all deployed contracts to sourcify.\n\n```bash\nhardhat --network mainnet sourcify\n```\n\nLater this task might instead pin the metadata to ipfs, so sourcify can automatically verify them.\n\n#### **Options**\n\n`--endpoint <endpoint>`: specify the sourcify endpoint, default to https://sourcify.dev/server/\n\n`--write-failing-metadata`: if set and the sourcify task fails to verify, the metadata file will be written to disk, so you can more easily figure out what has gone wrong.\n\n---\n\n### 6. hardhat export\n\n---\n\nThis plugin adds the _export_ task to Hardhat.\n\nThis task will export the contract deployed (saved in `deployments` folder) to a file with a simple format containing only contract addresses and abi, useful for web apps.\n\nOne of the following options need to be set for this task to have any effects :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\nThis last option has some limitations, when combined with the use of external deployments (see [Configuration](#configuration)). If such external deployments were using older version of **hardhat-deploy** or truffle, the chainId might be missing. In order for these to be exported, the hardhat network config need to explicity state the chainId in the `networks` config of `hardhat.config.js`.\n\nWith both `--export` and `--export-all`, using the special `<filepath>` value of `-` will output to `STDOUT` rather than writing a normal file.\n\n---\n\n---\n\n## Hardhat Environment Extensions\n\nThis plugin extends the Hardhat Runtime Environment by adding 4 fields:\n\n- `getNamedAccounts: () => Promise<{ [name: string]: string }>`: a function returning an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [Configuration](#configuration)).\n\n- `getUnnamedAccounts: () => Promise<string[]}>`: accounts which has no names, useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`: contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId(): Promise<string>`: offer an easy way to fetch the current chainId.\n\n---\n\n---\n\n## Configuration\n\n---\n\n### **1. namedAccounts (ability to name addresses)**\n\n---\n\nThis plugin extends the `HardhatConfig`'s object with an optional `namedAccounts` field.\n\n`namedAccounts` allows you to associate names to addresses and have them configured per chain.\nThis allows you to have meaningful names in your tests while the addresses match to multi sig in real network for example.\n\n```js\n{\n    namedAccounts: {\n        deployer: {\n            default: 0, // here this will by default take the first account as deployer\n            1: 0, // similarly on mainnet it will take the first account as deployer. Note though that depending on how hardhat network are configured, the account 0 on one network can be different than on another\n            4: '0xA296a3d5F026953e17F472B497eC29a5631FB51B', // but for rinkeby it will be a specific address\n            \"goerli\": '0x84b9514E013710b9dD0811c9Fe46b837a4A0d8E0', //it can also specify a specific netwotk name (specified in hardhat.config.js)\n        },\n        feeCollector:{\n            default: 1, // here this will by default take the second account as feeCollector (so in the test this will be a different account than the deployer)\n            1: '0xa5610E1f289DbDe94F3428A9df22E8B518f65751', // on the mainnet the feeCollector could be a multi sig\n            4: '0xa250ac77360d4e837a13628bC828a2aDf7BabfB3', // on rinkeby it could be another account\n        }\n    }\n}\n```\n\n<!-- You can also specify addresses with the `ledger://` prefix. In which case the account fetched will still be the corresponding address, but behind the scene, the transaction will be created via the hardware waller. Currently the feature is not working very well though and better support is needed. -->\n\n---\n\n### **2. extra hardhat.config networks' options**\n\n---\n\n**hardhat-deploy** add 5 new fields to `networks` configuration\n\n#### `live`\n\nthis is not used internally but is useful to perform action on a network whether it is a live network (rinkeby, mainnet, etc) or a temporary one (localhost, hardhat). The default is true (except for localhost and hardhat where the default is false).\n\n#### `saveDeployments`\n\nthis tell whether **hardhat-deploy** should save the deployments to disk or not. Default to true, except for the hardhat network.\n\n#### `tags`\n\nnetwork can have tags to represent them. The config is an array and at runtime the hre.network.tags is an object whose fields (the tags) are set to true.\n\nThis is useful to conidtionaly operate on network based on their use case.\n\nExample:\n\n```js\n{\n  networks: {\n    localhost: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"local\"]\n    },\n    hardhat: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"test\", \"local\"]\n    },\n    rinkeby: {\n      live: true,\n      saveDeployments: true,\n      tags: [\"staging\"]\n    }\n  }\n}\n```\n\n#### `deploy`\n\nthe deploy field override the paths.deploy option and let you define a set of folder containing the deploy scripts to be executed for this network.\n\nYou can thus have one network that will be executing L1 deployment and other L2 deployments, etc...\n\nYou could also have a folder that deploy contracts that are live on mainnet but that you need to replicate for your test or local network.\n\n#### `companionNetworks`\n\nthe companionNetworks field is an object whose key is any name you desire and the value is the name of a network that will be accessible inside the deploy script. For example:\n\n```js\n{\n  ...\n  networks: {\n    optimism: {\n      url: 'http://127.0.0.1:8545',\n      ovm: true,\n      companionNetworks: {\n        l1: 'localhost',\n      },\n    }\n  }\n  ...\n}\n```\n\nBy using name you can have the same deploy script used in different set of network.\n\nFor your test you could have the companion networks pointing to the same hardhat network, for test deployment, you could have rinkeby acting like your l2 while goerli act as your l1.\n\nAn example repo that show case a multi-network setup with optimism can be found here : https://github.com/wighawag/template-ethereum-contracts/tree/examples/optimism\n\ndeploy script can then access the network and its deployment as follow :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  const OVM_L1ERC20Gateway = await hre.companionNetworks['l1'].deployments.get(\n    'OVM_L1ERC20Gateway'\n  ); // layer 1\n\n  await execute(\n    'SimpleERC20_OVM',\n    {from: deployer, log: true},\n    'init',\n    OVM_L1ERC20Gateway.address\n  );\n};\n```\n\n---\n\n### **3. extra hardhat.config paths' options**\n\n---\n\n`hardhat-deploy` also adds fields to `HardhatConfig`'s `ProjectPaths` object.\n\nHere is an example showing the default values :\n\n```js\n{\n    paths: {\n        deploy: 'deploy',\n        deployments: 'deployments',\n        imports: 'imports'\n    }\n}\n```\n\nThe `deploy` folder is expected to contains the deploy script that are executed upon invocation of `hardhat deploy` or `hardhat node`.\nIt can also be an array of folder path.\n\nThe `deployments` folder will contains the resulting deployments (contract addresses along their abi, bytecode, metadata...). One folder per network and one file per contract.\n\nThe `imports` folder is expected to contains artifacts that were pre-compiled. Useful if you want to upgrade to a new solidity version but want to keep using previously compiled contracts. The artifact is the same format as normal hardhat artifact, so you can easily copy them over, before switching to a new compiler version.\n\n> This is less useful now that hardhat support multiple solidity compiler at once.\n\n---\n\n---\n\n### **4. deterministicDeployment (ability to specify a deployment factory)**\n\n---\n\nThis plugin extends the `HardhatConfig`'s object with an optional `deterministicDeployment` field.\n\n`deterministicDeployment` allows you to associate information that are used on each network for deterministic deployment. The information for each deterministic deployment consist out of a `factory`, a `deployer`, the required `funding` and a `signedTx` to deploy the factory. The default deterministic deployment used is the [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy). The factory expects a 32 bytes `salt` concatenated with the deployment data (see [EIP-1014](https://eips.ethereum.org/EIPS/eip-1014) for more information on these parameters).\n\nUsing the `deterministicDeployment` it is possible to define a different setup for the deterministic deployment. One use case for this is the deterministic deployment on networks that required replay protection (such as Celo or Avalanche). The [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy) can only be deployed on networks that don't enforce replay protection, therefore on other networks an alternative library has to be used. An example for this would be the [Safe Singleton Factory](https://github.com/gnosis/safe-singleton-factory) that is an adjusted version of the [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy) that contains signed transactions that include replay protection.\n\nThe information can be defined either as an object\n\n```js\n{\n    deterministicDeployment: {\n      \"4\": {\n        factory: \"<factory_address>\",\n        deployer: \"<deployer_address>\",\n        funding: \"<required_funding_in_wei>\",\n        signedTx: \"<raw_signed_tx>\",\n      }\n    }\n}\n```\n\nor as an function that returns the information for the deterministic deployment\n\n```js\n{\n  deterministicDeployment: (network: string) => {\n    return {\n      factory: '<factory_address>',\n      deployer: '<deployer_address>',\n      funding: '<required_funding_in_wei>',\n      signedTx: '<raw_signed_tx>',\n    };\n  };\n}\n```\n\n### Importing deployment from other projects (with truffle support)\n\n`hardhat-deploy` also add the `external` field to `HardhatConfig`\n\nSuch field allows to specify paths for external artifacts or **deployments**.\n\nThe external object has 2 fields:\n\n```js\n{\n    external: {\n        contracts: [\n          {\n            artifacts: \"node_modules/@cartesi/arbitration/export/artifacts\",\n            deploy: \"node_modules/@cartesi/arbitration/export/deploy\"\n          },\n          {\n            artifacts: \"node_modules/someotherpackage/artifacts\",\n          }\n        ],\n        deployments: {\n          rinkeby: [\"node_modules/@cartesi/arbitration/build/contracts\"],\n        },\n    }\n}\n```\n\nThe `contracts` field specify an array of object which itself have 2 fields.\n\n- `artifacts`: (mandatory) it is a path to an artifact folder. This support both hardhat and truffle artifacts.\n- `deploy`: (optional) it specifies a path to a folder where reside deploy script. The deploy scripts have only access to the artifact specified in the artifacts field. This allow project to share their deployment procedure. A boon for developer aiming at integrating it as they can get the contracts to be deployed for testing locally.\n\nThe `deployments` fields specify an object whose field nasme are the hardhat network and the value is an array of path to look for deployments. It supports both **hardhat-deploy** and truffle formats.\n\n---\n\n### Access to Artifacts (non-deployed contract code and abi)\n\nArtifacts in hardhat terminology represent a compiled contract (not yet deployed) with at least its bytecode and abi.\n\n`hardhat-deploy` gives can access to these artifact via the `deployments.getArtifact` function :\n\n```js\nconst {deployments} = require('hardhat');\nconst artifact = await deployments.getArtifact(artifactName);\n```\n\nWith the `hardhat-deploy-ethers` plugin you can get an artifact as an ethers contract factory, ready to be deployed, via the following:\n\n```js\nconst {deployments, ethers} = require('hardhat');\nconst factory = await ethers.getContractFactory(artifactName);\n```\n\n> Note that the artifact's files need to be either in `artifacts` folder that hardhat generate on compilation or in the `imports` folder where you can store contracts compiled elsewhere. They can also be present in the folder specified in `external.artifacts` see [Importing deployment from other projects](#importing-deployment-from-other-projects-with-truffle-support)\n\n---\n\n---\n\n## How to Deploy Contracts\n\n---\n\n### The `deploy` Task\n\n`hardhat --network <networkName> deploy [options and flags]`\n\nThis is a new task that the `hardhat-deploy` adds. As the name suggests it deploys contracts.\nTo be exact it will look for files in the folder `deploy` or whatever was configured in `paths.deploy`, see [paths config](#extra-paths-config)\n\nIt will scan for files in alphabetical order and execute them in turn.\n\n- it will `require` each of these files and execute the exported function with the HRE as argument\n\nTo specify the network, you can use the builtin hardhat argument `--network <network name>` or set the env variable `HARDHAT_NETWORK`\n\n> :warning: Note that running `hardhat deploy` without specifying a network will use the default network. If the default network is hardhat (the default's default) then nothing will happen as a result as everything happens in memory, but this can be used to ensure the deployment is without issues.\n\n---\n\n### Deploy Scripts\n\nThe deploy scripts need to be of the following type :\n\n```ts\nexport interface DeployFunction {\n  (env: HardhatRuntimeEnvironment): Promise<void | boolean>;\n  skip?: (env: HardhatRuntimeEnvironment) => Promise<boolean>;\n  tags?: string[];\n  dependencies?: string[];\n  runAtTheEnd?: boolean;\n  id?: string;\n}\n```\n\nThe skip function can be used to skip executing the script under whatever condition. It simply need to resolve a promise to true.\n\nThe tags is a list of string that when the _deploy_ task is executed with, the script will be executed (unless it skips). In other word if the deploy task is executed with a tag that does not belong to that script, that script will not be executed unless it is a dependency of a script that does get executed.\n\nThe dependencies is a list of tag that will be executed if that script is executed. So if the script is executed, every script whose tag match any of the dependencies will be executed first.\n\nThe `runAtTheEnd` is a boolean that if set to true, will queue that script to be executed after all other scripts are executed.\n\nThese set of fields allow more flexibility to organize the scripts. You are not limited to alphabetical order and you can even organise deploy script in sub folders.\n\nFinally the function can return true if it wishes to never be executed again. This can be usfeul to emulate migration scripts that are meant to be executed only once. Once such script return true (async), the `id` field is used to track execution and if that field is not present when the script return true, it will fails.\n\nIn other words, if you want a particular deploy script to run only once, it needs to both return true (async) and have an `id` set.\n\nIn any case, as a general advice every deploy function should be idempotent. This is so they can always recover from failure or pending transaction. This is what underpin most of hardhat-deploy philosophy.\n\nThis is why the `hre.deployments.deploy` function will by default only deploy if the contract code has changed, making it easier to write idempotent script.\n\n#### An example of a deploy script :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  // the following will only deploy \"GenericMetaTxProcessor\" if the contract was never deployed or if the code changed since last deployment\n  await deploy('GenericMetaTxProcessor', {\n    from: deployer,\n    gasLimit: 4000000,\n    args: [],\n  });\n};\n```\n\nAs you can see the HRE passed in has 4 new fields :\n\n- `getNamedAccounts` is a function that returns a promise to an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [`namedAccounts`](#namedaccounts)).\n\n- `getUnnamedAccounts` is a function that return a promise to an array of accounts which were not named (see [`namedAccounts`](#namedaccounts)). It is useful for tests where you want to be sure that the account has no speicifc role in the system (no token given, no admin access, etc...).\n\n- `getChainId` is a function which return a promise for the chainId, as convenience\n\n- `deployments` is an object which contains functions to access past deployments or to save new ones, as well as helpers functions.\n\nThat latter field contains for example the `deploy` function that allows you to deploy contract and save them. It contains a lot more functions though :\n\n---\n\n### The `deployments` field\n\nThe deployments field contains several helpers function to deploy contract but also execute transaction.\n\n```ts\nexport interface DeploymentsExtension {\n  deploy(name: string, options: DeployOptions): Promise<DeployResult>; // deploy a contract\n  diamond: {\n    // deploy diamond based contract (see section below)\n    deploy(name: string, options: DiamondOptions): Promise<DeployResult>;\n  };\n  deterministic( // return the determinsitic address as well as a function to deploy the contract, can pass the `salt` field in the option to use different salt\n    name: string,\n    options: Create2DeployOptions\n  ): Promise<{\n    address: Address;\n    implementationAddress?: Address;\n    deploy(): Promise<DeployResult>;\n  }>;\n  fetchIfDifferent( // return true if new compiled code is different than deployed contract\n    name: string,\n    options: DeployOptions\n  ): Promise<{differences: boolean; address?: string}>;\n  save(name: string, deployment: DeploymentSubmission): Promise<void>; // low level save of deployment\n  get(name: string): Promise<Deployment>; // fetch a deployment by name, throw if not existing\n  getOrNull(name: string): Promise<Deployment | null>; // fetch deployment by name, return null if not existing\n  getDeploymentsFromAddress(address: string): Promise<Deployment[]>;\n  all(): Promise<{[name: string]: Deployment}>; // return all deployments\n  getArtifact(name: string): Promise<Artifact>; // return a hardhat artifact (compiled contract without deployment)\n  getExtendedArtifact(name: string): Promise<ExtendedArtifact>; // return a extended artifact (with more info) (compiled contract without deployment)\n  run( // execute deployment scripts\n    tags?: string | string[],\n    options?: {\n      resetMemory?: boolean;\n      deletePreviousDeployments?: boolean;\n      writeDeploymentsToFiles?: boolean;\n      export?: string;\n      exportAll?: string;\n    }\n  ): Promise<{[name: string]: Deployment}>;\n  fixture( // execute deployment as fixture for test // use evm_snapshot to revert back\n    tags?: string | string[],\n    options?: {fallbackToGlobal?: boolean; keepExistingDeployments?: boolean}\n  ): Promise<{[name: string]: Deployment}>;\n  createFixture<T, O>( // execute a function as fixture using evm_snaphost to revert back each time\n    func: FixtureFunc<T, O>,\n    id?: string\n  ): (options?: O) => Promise<T>;\n  log(...args: any[]): void; // log data only ig log enabled (disabled in test fixture)\n\n  execute( // execute function call on contract\n    name: string,\n    options: TxOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<Receipt>;\n  rawTx(tx: SimpleTx): Promise<Receipt>; // execute a simple transaction\n  catchUnknownSigner( // you can wrap other function with this function and it will catch failure due to missing signer with the details of the tx to be executed\n    action: Promise<any> | (() => Promise<any>),\n    options?: {log?: boolean}\n  ): Promise<null | {\n    from: string;\n    to?: string;\n    value?: string;\n    data?: string;\n  }>;\n  read( // make a read-only call to a contract\n    name: string,\n    options: CallOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<any>;\n  read(name: string, methodName: string, ...args: any[]): Promise<any>;\n  // rawCall(to: Address, data: string): Promise<any>; // TODO ?\n}\n```\n\n---\n\n#### `deployments.deploy(<name>, options)`\n\n---\n\nThe `deploy` function, as mentioned above, allows you to deploy a contract and save it under a specific name.\n\nThe deploy function expect 2 parameters: one for the name and one for the options\n\nSee below the full list of fields that the option parameter allows and requires:\n\n```ts\nexport interface DeployOptions = {\n  from: string; // address (or private key) that will perform the transaction. you can use `getNamedAccounts` to retrived the address you want by name.\n  contract?: // this is an optional field. If not specified it defaults to the contract with the same name as the first parameter\n    | string // this field can be either a string for the name of the contract\n    | { // or abi and bytecode\n        abi: ABI;\n        bytecode: string;\n        deployedBytecode?: string;\n      };\n  args?: any[]; // the list of argument for the constructor (or the upgrade function in case of proxy)\n  skipIfAlreadyDeployed?: boolean; // if set it to true, will not attempt to deploy even if the contract deployed under the same name is different\n  log?: boolean; // if true, it will log the result of the deployment (tx hash, address and gas used)\n  linkedData?: any; // This allow to associate any JSON data to the deployment. Useful for merkle tree data for example\n  libraries?: { [libraryName: string]: Address }; // This let you associate libraries to the deployed contract\n  proxy?: boolean | string | ProxyOptions; // This options allow to consider your contract as a proxy (see below for more details)\n\n  // here some common tx options :\n  gasLimit?: string | number | BigNumber;\n  gasPrice?: string | BigNumber;\n  value?: string | BigNumber;\n  nonce?: string | number | BigNumber;\n\n  estimatedGasLimit?: string | number | BigNumber; // to speed up the estimation, it is possible to provide an upper gasLimit\n  estimateGasExtra?: string | number | BigNumber; // this option allow you to add a gas buffer on top of the estimation\n\n  autoMine?: boolean; // this force a evm_mine to be executed. this is useful to speed deployment on test network that allow to specify a block delay (ganache for example). This option basically skip the delay by force mining.\n  deterministicDeployment? boolean | string; // if true, it will deploy the contract at a deterministic address based on bytecode and constructor arguments. The address will be the same across all network. It use create2 opcode for that, if it is a string, the string will be used as the salt.\n  waitConfirmations?: number; // number of the confirmations to wait after the transactions is included in the chain\n};\n```\n\n---\n\n---\n\n## Handling contract using libraries\n\nIn the deploy function, one of the `DeployOptions` field is the `libraries` field. It allows you to associate external contract as libraries at the time of deployment.\n\nFirst, you have deploy the library using the `deploy` function, then when we deploy a contract that needs the linked library, we can pass the deployed library name and address in as an argument to the `libraries` object.\n\nFirst step: deploy the library:\n\n```js\nconst exampleLibrary = await deploy(\"ExampleLibary\", {\n    from: <deployer>\n});\n\n```\n\nExampleLibrary is now deployed to whatever network was chosen (`hardhat deploy --network <networkName>`)\n\nFor example, if we are deploying on Rinkeby, this library will get deployed on rinkeby, and the `exampleLibrary` variable will be a deployment object that contains the abi as well as the deployed address for the contract.\n\nNow that the library is deployed, we can link it in our next deployed contract.\n\n```js\nconst example = await deploy(\"Example\", {\n    from: <deployer>\n    args: [\"example string argument for the 'Example' contract constructor\"],\n    libraries: {\n        ExampleLibrary: exampleLibrary.address\n    }\n});\n\n```\n\nThis `libraries` object takes the name of the library, and its deployed address on the network. Multiple libraries can be passed into the `libraries` object.\n\n---\n\n---\n\n## Exporting Deployments\n\nApart from deployments saved in the `deployments` folder which contains all information available about the contract (compile time data + deployment data), `hardhat-deploy` allows you to export lightweight files.\n\nThese can be used for example to power your frontend with contract's address and abi.\n\nThis come into 2 flavors.\n\nThe first one is exported via the `--export <file>` option and follow the following format :\n\n```ts\nexport interface Export {\n  chainId: string;\n  name: string;\n  contracts: {[name: string]: ContractExport};\n}\n```\n\nwhere name is the name of the network configuration chosen (see hardhat option `--network`)\n\nThe second one is exported via the `--export-all <file>` option and follow the following format :\n\n```ts\nexport type MultiExport = {\n  [chainId: string]: Export[];\n};\n```\n\nAs you see the second format include the previous. While in most case you'll need the single export where your application will support only one network, there are case where your app would want to support multiple networks at nonce. This second format allow for that.\n\nFurthermore as hardhat support multiple network configuration for the same network (rinkeby, mainnet...), the export-all format will contains each of them grouped by their chainId.\n\n\nNote: from v0.10.4 the old multi-export down is no more:\n\n```\nexport type MultiExport = {\n  [chainId: string]: {[name: string]: Export};\n};\n```\n\n---\n\n---\n\n## Deploying and Upgrading Proxies\n\nAs mentioned above, the deploy function can also deploy a contract through a proxy. It can be done without modification of the contract as long as its number of constructor arguments matches the proxy initialization/update function.\n\nThe default Proxy is both ERC-1967 and ERC-173 Compliant, but other proxy can be specified, like openzeppelin transparent proxies.\n\nCode for the default Proxy can be found [here](solc_0.7/proxy/EIP173Proxy.sol).\n\nTo perform such proxy deployment, you just need to invoke the deploy function with the following options : `{..., proxy: true}`\n\nSee example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: true,\n  });\n};\n```\n\nYou can also set it to `proxy: \"<upgradeMethodName>\"` in which case the function `<upgradeMethodName>` will be executed upon upgrade.\nthe `args` field will be then used for that function instead of the contructor. It is also possible to then have a constructor with the same arguments and have the proxy be disabled. It can be useful if you want to have your contract as upgradeable in a test network but be non-upgradeable on the mainnet.\n\nSee example :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  network,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: network.live ? false : 'postUpgrade',\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nThe proxy option can also be an object which can set the specific owner that the proxy is going to be managed by.\n\nSee example:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: {\n      owner: greeterOwner,\n      methodName: 'postUpgrade',\n    },\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nNote that for the second invokation, this deployment will not be executed from the specified `from: deployer` as otherwise these tx will always fails. It will instead be automatically executed from the proxy's current owner (in that case : `greeterOwner`)\n\nNow, it is likely you do not want to locally handle the private key / mnemonic of the account that manage the proxy or it could even be that the `greeterOwner` in question is a multi sig. As such that second invocation will throw an error as it cannot find a local signer for it.\n\nThe error will output the necessary information to upgrade the contract but `hardhat-deploy` comes also with a utility function for such case: `deployments.catchUnknwonSigner` which will catch the error and output to the console the necessary information while continuing to next step.\n\nHere is the full example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy, catchUnknownSigner} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await catchUnknownSigner(\n    deploy('Greeter', {\n      from: deployer,\n      proxy: {\n        owner: greeterOwner,\n        methodName: 'postUpgrade',\n      },\n      args: ['arg1', 2, 3],\n    })\n  );\n  // you could pause the deployment here and wait for input to continue\n};\n```\n\nThe full proxy options is as follow:\n\n```ts\ntype ProxyOptionsBase = {\n  owner?: Address; // this set the owner of the proxy. further upgrade will need to be executed from that owner\n  upgradeIndex?: number; // allow you to breakdown your upgrades into separate deploy scriot, each with their own index. A deploy call with a specific upgradeIndex will be executed only once, only if the current upgradeIndex is one less.\n  proxyContract?: // default to \"EIP173Proxy\". See below for more details\n  string | ArtifactData;\n  viaAdminContract?: // allow to specify a contract that act as a middle man to perform upgrades. Useful and Recommended for Transparent Proxies\n  | string\n    | {\n        name: string;\n        artifact?: string | ArtifactData;\n      };\n};\n\nexport type ProxyOptions =\n  | (ProxyOptionsBase & {\n      methodName?: string; // method to be executed when the proxy is deployed for the first time or when the implementation is modified. Use the deployOptions args field for arguments\n    })\n  | (ProxyOptionsBase & {\n      execute?:\n        | {\n            methodName: string; // method to be executed when the proxy is deployed for the first time or when the implementation is modified.\n            args: any[];\n          }\n        | {\n            init: {\n              methodName: string; // method to be executed when the proxy is deployed\n              args: any[];\n            };\n            onUpgrade?: {\n              methodName: string; // method to be executed when the proxy is upgraded (not first deployment)\n              args: any[];\n            };\n          };\n    });\n```\n\nThe `proxyContract` field allow you to specify your own Proxy contract. If it is a string, it will first attempt to get an artifact with that name. If not found it will fallback on the following if\n\nit matches:\n\n- `EIP173Proxy`: use the default Proxy that is EIP-173 compliant\n\n- `EIP173ProxyWithReceive`: Same as above except that the proxy contains a receive hook to accept empty ETH payment.\n\n- `OpenZeppelinTransparentProxy`: Use Openzeppelin Transparent Proxy (copied from openzeppelin repo, see code [here](solc_0.7/openzeppelin/proxy/TransparentUpgradeableProxy.sol))\n  When this option is chosen, the `DefaultProxyAdmin` is also used as admin since Transparent Proxy kind of need an intermediarry contract for administration. This can be configured via the `viaAdminContract` option. Note that the DefaultProxyAdmin is slightly different than the one used by openzeppelin as it allow you to set a different owner than msg.sender on first deploy, something openzeppelin version do not allow, see : https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2639\n\n- `OptimizedTransparentProxy`: This contract is similar to above, except that it is optimized to not require storage read for the admin on every call.\n\n## Builtin-In Support For Diamonds (EIP2535)\n\nThe deployments field also expose the diamond field: `hre.deployments.diamond` that let you deploy [Diamonds](https://eips.ethereum.org/EIPS/eip-2535) in an easy way.\n\nInstead of specifying the facets to cut out or cut in, which the diamond contract expects, you specify the facets you want to end up having on the deployed contract.\n\n`diamond.deploy` expect the facet as names. The names represent contract to be deployed as facet. In future version you ll be able to specify deployed contract or artifact object as facet.\n\nTo deploy a contract with 3 facet you can do as follow :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: deployer,\n    owner: diamondAdmin,\n    facets: ['Facet1', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nif you then later execute the following script:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: diamondAdmin, // this need to be the diamondAdmin for upgrade\n    owner: diamondAdmin,\n    facets: ['NewFacet', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nThen the NewFacet will be deployed automatically if needed and then the diamondCut will cut Facet1 out and add NewFacet.\n\nNote that if the code for Facet2 and Facet3 changes, they will also be redeployed automatically and the diamondCuts will replace the existing facets with these new ones.\n\nNote that The Diamond contract's code is part of `hardhat-deploy` and contains 3 built-in facet that can be removed manually if desired.\nThese facets are used for ownership, diamondCut and diamond loupe.\n\nThe implementation is the [reference implementation by Nick Mudge](https://github.com/mudgen/diamond-3)\n\nLike normal proxies you can also execute a function at the time of an upgrade.\n\nThis is done by specifying the execute field in the diamond deploy options :\n\n```js\ndiamond.deploy('ADiamondContract', {\n  from: deployer,\n  owner: diamondAdmin,\n  facets: ['NewFacet', 'Facet2', 'Facet3'],\n  execute: {\n    methodName: 'postUpgrade',\n    args: ['one', 2, '0x3'],\n  },\n});\n```\n\nSince the diamond standard has no builtin mechanism to make the deployment of Diamond with function execution, the Diamond when deployed is actually deployed through a special contract, the `Diamantaire` (see code [here](solc_0.7/diamond/Diamantaire.sol)) that act as factory to build Diamond. It uses deterministic deployment for that so, it is transparently managed by `hardhat-deploy`. It also embed the implementation of the builtin facet, removing the need to have different instances of each live.\n\n<!-- The Diamantaire also support the deterministic deployment of Diamonds.\nAn extra field can be passed to the Diamond deployment options : `deterministicSalt`. It has to be a non-zero 32bytes string (in hex format).\nNote that if you want to deploy 2 diamonds with same owner, you'll need 2 different deterministicSalt for them to be 2 separate contracts. -->\n\n## Testing Deployed Contracts\n\nYou can continue using the usual test task:\n\n`hardhat test`\n\nTests can use the `hre.deployments.fixture` function to run the deployment and snapshot it so that tests don't need to perform all the deployment transactions every time. They can simply reuse the snapshot for every test (this leverages `evm_snapshot` and `evm_revert` provided by both `hardhat` and `ganache`). You can for example set them in a `beforeEach`.\n\nHere is an example of a test :\n\n```js\nconst {deployments} = require('hardhat');\n\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    await deployments.fixture(['Token']);\n    const Token = await deployments.get('Token'); // Token is available because the fixture was executed\n    console.log(Token.address);\n    const ERC721BidSale = await deployments.get('ERC721BidSale');\n    console.log({ERC721BidSale});\n  });\n});\n```\n\nTests can also leverage named accounts for clearer test. Combined with `hardhat-deploy-ethers` plugin, you can write succint test :\n\n```js\nconst {ethers, getNamedAccounts} = require('hardhat');\n\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    await deployments.fixture(['Token']);\n    const {tokenOwner} = await getNamedAccounts();\n    const TokenContract = await ethers.getContract('Token', tokenOwner);\n    await TokenContract.mint(2).then((tx) => tx.wait());\n  });\n});\n```\n\n---\n\n### Creating Fixtures\n\nFurthermore, tests can easily create efficient fixture using `deployments.createFixture`\n\nSee example :\n\n```js\nconst setupTest = deployments.createFixture(\n  async ({deployments, getNamedAccounts, ethers}, options) => {\n    await deployments.fixture(); // ensure you start from a fresh deployments\n    const {tokenOwner} = await getNamedAccounts();\n    const TokenContract = await ethers.getContract('Token', tokenOwner);\n    await TokenContract.mint(10).then((tx) => tx.wait()); //this mint is executed once and then `createFixture` will ensure it is snapshotted\n    return {\n      tokenOwner: {\n        address: tokenOwner,\n        TokenContract,\n      },\n    };\n  }\n);\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    const {tokenOwner} = await setupTest();\n    await tokenOwner.TokenContract.mint(2);\n  });\n});\n```\n\nWhile this example is trivial, some fixture can requires several transaction and the ability to snapshot them automatically speed up the tests greatly.\n\n---\n\n---\n\n## More Information On Hardhat Tasks\n\n---\n\n### **1. node task**\n\nas mentioned above, the node task is slighly modified and augmented with various flags and options\n\n`hardhat node`\n\nIn particular it adds an argument `--export` that allows you to specify a destination file where the info about the contracts deployed is written.\nYour webapp can then access all contracts information.\n\n---\n\n### **2. test task**\n\n`hardhat test`\n\nthe test task is augmented with one flag argument `--deploy-fixture` that allows to run all deployments in a fixture snapshot before executing the tests. This can speed up the tests that use specific tags as the global fixture take precedence (unless specified).\n\nIn other word tests can use `deployments.fixture(<specific tag>)` where specific tag only deploys the minimal contracts for tests, while still benefiting from global deployment snapshot if used.\n\nIf a test needs the deployments to only include the specific deployment specified by the tag, it can use the following :\n\n```js\ndeployments.fixture('<specific tag>', {fallbackToGlobal: false});\n```\n\nDue to how snapshot/revert works in hardhat, this means that these tests will not benefit from the global fixture snapshot and will have to deploy their contracts as part of the fixture call. This is automatic but means that these tests will run slower.\n\n---\n\n### **3. run task**\n\n`hardhat --network <networkName> run <script>`\n\nThe run task act as before but thanks to the `hre.deployments` field it can access deployed contract :\n\n```js\nconst hre = require('hardhat');\nconst {deployments, getNamedAccounts} = hre;\n\n(async () => {\n  console.log(await deployments.all());\n  console.log({namedAccounts: await getNamedAccounts()});\n})();\n```\n\nYou can also run it directly from the command line as usual.\n\n`HARDHAT_NETWORK=rinkeby node <script>` is the equivalent except it does not load the hardhat environment twice (which the run task does)\n\n---\n\n### **4. console task**\n\n`hardhat console`\n\nThe same applies to the `console` task.\n\n---\n\n## Deploy Scripts: Tags And Dependencies\n\n---\n\nIt is possible to execute only specific parts of the deployments with `hardhat deploy --tags <tags>`\n\nTags represent what the deploy script acts on. In general it will be a single string value, the name of the contract it deploys or modifies.\n\nThen if another deploy script has such tag as a dependency, then when this latter deploy script has a specific tag and that tag is requested, the dependency will be executed first.\n\nHere is an example of two deploy scripts :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const deployResult = await deploy('Token', {\n    from: deployer,\n    args: ['hello', 100],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Token deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Token'];\n```\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const Token = await deployments.get('Token');\n  const deployResult = await deploy('Sale', {\n    from: deployer,\n    contract: 'ERC721BidSale',\n    args: [Token.address, 1, 3600],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Sale deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.dependencies = ['Token']; // this ensure the Token script above is executed first, so `deployments.get('Token')` succeeds\n```\n\nAs you can see the second one depends on the first. This is because the second script depends on a tag that the first script registers as using.\n\nWith that when `hardhat deploy --tags Sale` is executed\n\nthen both scripts will be run, ensuring Sale is ready.\n\nYou can also define the script to run after another script is run by setting `runAtTheEnd` to be true. For example:\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, execute, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer, admin} = namedAccounts;\n  await execute('Sale', {from: deployer}, 'setAdmin', admin);\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.runAtTheEnd = true;\n```\n\nTags can also be used in test with `deployments.fixture`. This allow you to test a subset of the deploy script.\n","readmeFilename":"README.md","gitHead":"54ad19520b68e3cd530cafb42ed37a32c4f71a82","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.0-next.0","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-nGhVTCNHkq0cvNodqpnIGt624fJF4UyiGHH5qxyRclGGlRu1bNziswb2Yg+5wlRgPT+9q/AYVRykqG7K8tn8Mw==","shasum":"6032a71bd1a1bbfa4bbbd84d850ae145c8fe044b","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.0-next.0.tgz","fileCount":146,"unpackedSize":11112515,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJh+WB5CRA9TVsSAnZWagAAIt8P/16U8ufanDbkErGLsmwu\nVyQAFXTHQdRGdt5gBxewUKmtcRbzslnhhbD6/4RcwlCM3Sv/5GAEC8HM1uSZ\nmtPfgI0YHdV3Q5eYQ1iUglPFkN+puZrdF1E6yCElIAiKhbxI8P6MoSwZDfjv\nqJIWNTgloe58g6Z/Y9OMyS+FuZqQ4qTTRg00RHlGFWWCFvFdokOHvCEHSTtb\nkA5NR+3t0CkTFDaayEQ/qj9xCK3JKjm6XHrGj7p9IAO+LFzOaVyjzQJAKfYi\n7j9ZQrU2AXTFJBEVysK4AOl94h+e6K9FNn+98DACEN8CqBgqIFI4xc2/GDQe\nAdJ740vmkuxqEV5uPvFTyKjGNVPIZMPU5J2R47fuYufve3y7WFrIW1VZKG42\nD0JV5XePn5sPVMH4qxJkyMW5Bv1h6XtlZLA20T8q4BkKDEknV/ITE0Jjakdc\nvOzcGMKaGbFrTciDneD7MynrGLeyfAdu8ZJLAg47kQmcp2T/kG1U+bepZJD5\nA/n+x1pdDRRJldMRNmHlgqUYPdQsAO79TPrT0H+uwmOFkTnxS9BCU/67PAY2\n3JCZprlb0j00Q/c2oOv9qklP0IBowzs66NGsox8R7JdjnOOznbCmZX9FPr8U\n5DvPjMUkQ+ZNA8v4+JlOGb+RjZ2y9N2g95eO06YE/T/lSlyL9gSJL9ShYJmC\nQZHJ\r\n=/Z/E\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCID4JMorzg0C5AQdCUpRvQCmSHClw3tgJ1NPFRedXx175AiAg6lQ3ZNYabshFyRZDnVEwa7vOZYRiVsi7wYwN0RM/Dg=="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.0-next.0_1643733112909_0.8278192495172507"},"_hasShrinkwrap":false},"0.11.0-next.1":{"name":"hardhat-deploy","version":"0.11.0-next.1","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.8","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.6.8"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"readme":"<h1> hardhat-deploy</h1>\n\n_A [Hardhat](https://hardhat.org) Plugin For Replicable Deployments And Easy Testing_\n\n> **A complete dev template using hardhat-deploy is available here** : https://github.com/wighawag/template-ethereum-contracts\n> It also contains various branches examplifying the capability of hardhat-deploy. Check it out.\n\n- [What is it for ?](#what-is-it-for-)\n- [hardhat-deploy in a nutshell](#hardhat-deploy-in-a-nutshell)\n- [Installation](#installation)\n  - [npm install hardhat-deploy](#npm-install-hardhat-deploy)\n  - [TypeScript support](#typescript-support)\n  - [Migrating existing deployment to hardhat-deploy](#migrating-existing-deployment-to-hardhat-deploy)\n- [Hardhat Tasks Available/Updated](#hardhat-tasks-availableupdated)\n  - [1. hardhat deploy](#1-hardhat-deploy)\n    - [**Options**](#options)\n    - [**Flags**](#flags)\n  - [2. hardhat node](#2-hardhat-node)\n    - [**Options**](#options-1)\n    - [**Flags**](#flags-1)\n  - [3. hardhat test](#3-hardhat-test)\n  - [4. hardhat etherscan-verify](#4-hardhat-etherscan-verify)\n    - [**Options**](#options-2)\n  - [5. hardhat sourcify](#5-hardhat-sourcify)\n    - [**Options**](#options-3)\n  - [6. hardhat export](#6-hardhat-export)\n    - [**Options**](#options-4)\n- [Hardhat Environment Extensions](#hardhat-environment-extensions)\n- [Configuration](#configuration)\n  - [**1. namedAccounts (ability to name addresses)**](#1-namedaccounts-ability-to-name-addresses)\n  - [**2. extra hardhat.config networks' options**](#2-extra-hardhatconfig-networks-options)\n    - [`live`](#live)\n    - [`saveDeployments`](#savedeployments)\n    - [`tags`](#tags)\n    - [`deploy`](#deploy)\n    - [`companionNetworks`](#companionnetworks)\n  - [**3. extra hardhat.config paths' options**](#3-extra-hardhatconfig-paths-options)\n  - [**4. deterministicDeployment (ability to specify a deployment factory)**](#4-deterministicdeployment-ability-to-specify-a-deployment-factory)\n  - [Importing deployment from other projects (with truffle support)](#importing-deployment-from-other-projects-with-truffle-support)\n  - [Access to Artifacts (non-deployed contract code and abi)](#access-to-artifacts-non-deployed-contract-code-and-abi)\n- [How to Deploy Contracts](#how-to-deploy-contracts)\n  - [The `deploy` Task](#the-deploy-task)\n  - [Deploy Scripts](#deploy-scripts)\n    - [An example of a deploy script :](#an-example-of-a-deploy-script-)\n  - [The `deployments` field](#the-deployments-field)\n    - [`deployments.deploy(<name>, options)`](#deploymentsdeployname-options)\n- [Handling contract using libraries](#handling-contract-using-libraries)\n- [Exporting Deployments](#exporting-deployments)\n- [Deploying and Upgrading Proxies](#deploying-and-upgrading-proxies)\n- [Builtin-In Support For Diamonds (EIP2535)](#builtin-in-support-for-diamonds-eip2535)\n- [Testing Deployed Contracts](#testing-deployed-contracts)\n  - [Creating Fixtures](#creating-fixtures)\n- [More Information On Hardhat Tasks](#more-information-on-hardhat-tasks)\n  - [**1. node task**](#1-node-task)\n  - [**2. test task**](#2-test-task)\n  - [**3. run task**](#3-run-task)\n  - [**4. console task**](#4-console-task)\n- [Deploy Scripts: Tags And Dependencies](#deploy-scripts-tags-and-dependencies)\n\n## What is it for ?\n\nThis [hardhat](https://hardhat.org) plugin adds a mechanism to deploy contracts to any network, keeping track of them and replicating the same environment for testing.\n\nIt also adds a mechanism to associate names to addresses, so test and deployment scripts can be reconfigured by simply changing the address a name points to, allowing different configurations per network. This also results in much clearer tests and deployment scripts (no more `accounts[0]` in your code).\n\nThis plugin contains a lot more features too, all geared toward a better developer experience :\n\n- chain configuration export\n- listing deployed contracts' addresses and their abis (useful for webapps)\n- library linking at time of deployment.\n- deterministic deployment across networks.\n- support for specific deploy script per network (L1 vs L2 for example)\n- ability to access deployment from \"companion\" networks\n- deployment dependency system (allowing you to only deploy what is needed).\n- deployment retrying (by saving pending tx): so you can feel confident when making a deployment that you can always recover.\n- deployments as test fixture using `evm_snapshot` to speed up testing.\n- ability to create your own test fixture that automatically benefits from `evm_snapshot`'s tests speed-up boost\n- combined with [hardhat-deploy-ethers](https://github.com/wighawag/hardhat-deploy-ethers) it has the ability to get ethers contract instance by name (like `await ethers.getContract(\"ContractName\")`).\n- importing artifact from external sources (like npm packages), including [truffle](https://www.trufflesuite.com/truffle) support.\n- importing deployments from external sources (like npm packages)\n- ability to log information in `deploy` mode only (while in test the console remains clean).\n- contains helpers to read and execute transaction on deployed contract referring to them by name.\n- These helpers contains options to auto mine on dev network (to speed up test deployments).\n- save metadata of deployed contract so they can always be fully verified, via [sourcify](https://sourcify.dev) or [etherscan](https://etherscan.io).\n- ability to submit contract source to etherscan and sourcify for verification at any time. (Because **hardhat-deploy** will save all the necessary info, it can be executed at any time.)\n- support harhdat's fork feature so deployment can be accessed even when run through fork.\n- named accounts are automatically impersonnated too, so you can perform tx as if you had their private key.\n- proxy deployment with ability to upgrade them transparently, only if code changes.\n- this include support for [openzeppelin](https://openzeppelin.com) transparent proxies\n- diamond deployment with facets, allowing you to focus on what the new version will be. It will generate the diamondCut necessary to reach the new state.\n- watch and deploy: **hardhat-deploy** can watch both your deploy script and contract code and redeploy on changes.\n- HCR (Hot Contract Replacement): the watch feature combined with proxy or diamond, gives you an experience akin to frontend Hot Module Replacement: once your contract changes, the deployment is executed and your contract retains the same address and same state, allowing you to tweak your contracts while debugging your front-end.\n\n## hardhat-deploy in a nutshell\n\nBefore going into the details, here is a very simple summary of the basic feature of **hardhat-deploy**.\n\n**hardhat-deploy** allows you to write [`deploy scripts`](#deploy-scripts) in the `deploy` folder. Each of these files that look as follows will be executed in turn when you execute the following task: `hardhat --network <networkName> deploy`\n\n```js\n// deploy/00_deploy_my_contract.js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('MyContract', {\n    from: deployer,\n    args: ['Hello'],\n    log: true,\n  });\n};\nmodule.exports.tags = ['MyContract'];\n```\n\nFurthermore you can also ensure these scripts are executed in test too by calling `await deployments.fixture(['MyContract'])` in your test.\nThis is optimized, so if multiple tests use the same contract, the deployment will be executed once and each test will start with the exact same state.\n\nThis is a huge benefit for testing since you are not required to replicate the deployment procedure in your tests. The tag feature (as seen in the script above) and [dependencies](#deploy-scripts-tags-and-dependencies) will also make your life easier when writing complex deployment procedures.\n\nYou can even group deploy scripts in different sub folder and ensure they are executed in their logical order.\n\nFurthermore hardhat-deploy can also support a multi-chain settings like L1, L2 with multiple deploy folder specific to each network.\n\n**All of this can also be bundled in a npm package so user of hardhat-deploy can reuse your deployment procedure and get started integrating with your project locally.**\n\nThere is a tutorial covering the basics here : https://github.com/wighawag/tutorial-hardhat-deploy\n\n## Installation\n\n### npm install hardhat-deploy\n\n```bash\nnpm install -D hardhat-deploy\n```\n\nAnd add the following statement to your `hardhat.config.js`:\n\n```js\nrequire('hardhat-deploy');\n```\n\nif you use `ethers.js` we recommend you also install `hardhat-deploy-ethers` which add extra features to access deployments as ethers contract.\n\nSince `hardhat-deploy-ethers` is a fork of `@nomiclabs/hardhat-ethers` and that other plugin might have an hardcoded dependency on `@nomiclabs/hardhat-ethers` the best way to install `hardhat-deploy-ethers` and ensure compatibility is the following:\n\n```bash\nnpm install --save-dev  @nomiclabs/hardhat-ethers@npm:hardhat-deploy-ethers ethers\n```\n\nWhich means you then need to do `require(\"@nomiclabs/hardhat-ethers\")` instead of `require(\"hardhat-deploy-ethers\")` in your `hardhat.config.js` file.\n\nMore details on `hardhat-deploy-ethers` repo : https://github.com/wighawag/hardhat-deploy-ethers#readme\n\n### TypeScript support\n\nWith hardhat the tsconfig.json is optional.\n\nBut if you add folders to the `include` field in `tsconfig.json`, you ll also need to include `hardhat.config.ts` like :\n\n`include\": [\"./hardhat.config.ts\", \"./scripts\", \"./deploy\", \"./test\"]`\n\nfor deploy script (see below) you can write them this way to benefit from typing :\n\n```ts\nimport {HardhatRuntimeEnvironment} from 'hardhat/types';\nimport {DeployFunction} from 'hardhat-deploy/types';\n\nconst func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {\n  // code here\n};\nexport default func;\n```\n\nSee a template that uses **hardhat-deploy** here : https://github.com/wighawag/template-ethereum-contracts\n\nThis repo has also some examples branch that exemplify specific features, like the forking testing here : https://github.com/wighawag/template-ethereum-contracts/tree/examples/fork-test\n\n### Migrating existing deployment to hardhat-deploy\n\n> Only needed for existing project that already deployed contracts and has the deployment information available **(at minimum, address and abi)**\n\nYou might want to switch your current deployment process to use **hardhat-deploy**. In that case you probably have some deployments saved elsewhere.\n\nIn order to port them to **hardhat-deploy**, you'll need to create one `.json` file per contract in the `deployments/<network>` folder (configurable via [paths config](#extra-paths-config)).\n\nThe network folder is simply the hardhat network name (as configured in hardhat.config.js) (accessible at runtime via `hre.network.name`).\nSuch folder need to have a file named `.chainId` containing the chainId as decimal.\n\nFor example for network named \"rinkeby\" (for the corresponding network) the file `deployments/rinkeby/.chainId` would be\n\n```\n4\n```\n\nNote, prior to hardhat 0.6 the chainId was appended to the folder name (expect for some known network name). This has changed and upgrading to 0.6 will require you to change the folder name and add the '.chainId' file.\n\nEach contract file must follow this type (as defined in [types.ts](types.ts)) :\n\n```ts\nexport interface Deployment {\n  address: Address;\n  abi: ABI;\n  receipt?: Receipt;\n  transactionHash?: string;\n  history?: Deployment[];\n  numDeployments?: number;\n  implementation?: string;\n  args?: any[];\n  linkedData?: any;\n  solcInputHash?: string;\n  metadata?: string;\n  bytecode?: string;\n  deployedBytecode?: string;\n  libraries?: Libraries;\n  userdoc?: any;\n  devdoc?: any;\n  methodIdentifiers?: any;\n  diamondCut?: FacetCut[];\n  facets?: Facet[];\n  storageLayout?: any;\n  gasEstimates?: any;\n}\n```\n\nAs you can see, only abi and address are mandatory. But having the other fields allow more feature. For example, metadata and args allow you to benefit from contract code verification.\n\nFor Receipt, the following type is expected:\n\n```ts\nexport type Receipt = {\n  from: string;\n  transactionHash: string;\n  blockHash: string;\n  blockNumber: number;\n  transactionIndex: number;\n  cumulativeGasUsed: string;\n  gasUsed: string;\n  contractAddress?: string;\n  to?: string;\n  logs?: Log[];\n  events?: any[];\n  logsBloom?: string;\n  byzantium?: boolean;\n  status?: number;\n  confirmations?: number;\n};\n```\n\nHere is an example:\n\nLet's say you have:\n\n- 2 Contract named Greeter and Registry deployed on rinkeby\n- 1 contract named Greeter on mainnet\n- 2 Contract named Greeter and Registry deployed on a network named rinkeby2\n\nYou would get the following folder structure:\n\n```\ndeployments/\n  mainnet/\n    .chainId\n    Greeter.json\n  rinkeby/\n    .chainId\n    Greeter.json\n    Registry.json\n  rinkeby2/\n    .chainId\n    Greeter.json\n    Registry.json\n```\n\nThe reason why **hardhat-deploy** save chainId in the `.chainId` file is both for\n\n- safety: so that if you were to change the network name to point to a different chain, it would not attempt to read the wrong folder and assume that a contract has been deployed while it has not.\n- ability to know the chainId without requring to be connected to a node (and so not dependent on hardhat.config.js settings). Useful for `export` task.\n\n---\n\n## Hardhat Tasks Available/Updated\n\nhardhat deploy add several task to hardhat. It also modify existing one, adding new options and new behavior. All of these are described here:\n\n---\n\n### 1. hardhat deploy\n\n---\n\nThis plugin adds the _deploy_ task to Hardhat.\n\nThis task will execute the scripts in the `deploy` folder and save the contract deployments to disk. These deployments are supposed to be saved for example in a git repository. This way they can be accessed later. But you are free to save them elsewhere and get them back via your mechanism of choice.\n\nWith the deployment saved, it allows you to deploy a contract only if changes were made.\n\nDeploy scripts (also called Deploy functions) can also perform aribtrary logic.\n\nFor further details on how to use it and write deploy script, see [section](#deploy-scripts) below.\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployments, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice (in wei) to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--reset`: This flag resets the deployments from scratch. Previously deployed contract are not considered and deleted from disk.\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n---\n\n### 2. hardhat node\n\n---\n\nThis plugin modify the _node_ task so that it also execute the deployment script before exposing the server http RPC interface\n\nIt add similar options than the `deploy` task :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--no-reset`: This flag prevent the reseting of the existing deployments. This is usually not desired when running the `node` task as a network is created from scratch and previous deployemnt are irrelevant.\n\n`--show-accounts`: this flag will output the account private keys\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n`--no-deploy` that discard all other options to revert to normal `hardhat node` behavior without any deployment being performed.\n\n> :warning: Note that the deployments are saved as if the network name is `localhost`. This is because `hardhat node` is expected to be used as localhost: You can for example execute `hardhat --network localhost console` after `node` is running. Doing `hardhat --network hardhat console` would indeed not do anything useful. It still take the configuration from `hardhat` in the hardhat.config.js file though.\n\n---\n\n### 3. hardhat test\n\n---\n\nThis plugin adds a flag argument `--deploy-fixture` to the _test_ task which if enabled will run the global deployments fixture before the tests and snapshots it. This will generaly speed up the tests as further test will be able to revert back to the full deployment.\n\n> :warning: Note though that if your test behave differently whether that option is on or not, this most likely mean that your deploy scripts' tags and dependencies are not configured correctly. This is because the global fixture will ensure all contract are deployed while test will usually (for efficiency) ask for a particular tag.\n\n---\n\n### 4. hardhat etherscan-verify\n\n---\n\nThis plugin adds the _etherscan-verify_ task to Hardhat.\n\nThis task will submit the contract source and other info of all deployed contracts to allow etherscan to verify and record the sources.\n\nInstead of using the full solc input, this task will first attempt to send the minimal sources from the metadata.\nBut Etherscan sometime fails due to a bug in solidity compiler (<https://github.com/ethereum/solidity/issues/9573>). As such this task can fallback on full solc input (see option --solc-input). Note that if your contract was deployed with a previous version of **hardhat-deploy**, it might not contains the full information. The issue seems to be fully resolved since solc version 0.8.\n\nThis task will also attempt to automatically find the SPDX license in the source.\n\nTo execute that task, you need to specifiy the network to run against :\n\n```bash\nhardhat --network mainnet etherscan-verify [--api-key <apikey>] [--apiurl <url>]\n```\n\n#### **Options**\n\nNote that harhdat-deploy now use a different config format to not conflict with `hardhat-etherscan`\n\n`--api-key <api key>`: let you specify your etherscan api key. Alternatively, you can provide it via the env variable `ETHERSCAN_API_KEY` or through the hardhat.config.ts verify field:\n\n```js\n{\n  ...\n  verify: {\n    etherscan: {\n      apiKey: '<API key>'\n    }\n  }\n}\n```\n\n`--api-url <url>`: let you specify your etherscan url to submit the source to. Can also be configured per network in `hardhat.config.js`:\n\n```js\n{\n  ...\n  networks: {\n    mynetwork: {\n      ...\n      verify: {\n        etherscan: {\n          apiUrl: 'http://mynetwork.xyz'\n        }\n      }\n    }\n  }\n}\n```\n\n`--license <SPDX license id>`: SPDX license (useful if SPDX is not listed in the sources), need to be supported by etherscan: https://etherscan.io/contract-license-types\n\n`--force-license`: if set, will force the use of the license specified by --license option, ignoring the one in the source (useful for license not supported by etherscan)\n\n`--solc-input`: fallback on solc-input id needed (useful when etherscan fails on the minimum sources, see https://github.com/ethereum/solidity/issues/9573)\n\n`--sleep`: sleep 500ms between each verification, so API rate limit is not exceeded\n\n---\n\n### 5. hardhat sourcify\n\n---\n\nThis plugin adds the _sourcify_ task to Hardhat.\n\nSimilar to `hardhat etherscan-verify` this task will submit the contract source and other info of all deployed contracts to sourcify.\n\n```bash\nhardhat --network mainnet sourcify\n```\n\nLater this task might instead pin the metadata to ipfs, so sourcify can automatically verify them.\n\n#### **Options**\n\n`--endpoint <endpoint>`: specify the sourcify endpoint, default to https://sourcify.dev/server/\n\n`--write-failing-metadata`: if set and the sourcify task fails to verify, the metadata file will be written to disk, so you can more easily figure out what has gone wrong.\n\n---\n\n### 6. hardhat export\n\n---\n\nThis plugin adds the _export_ task to Hardhat.\n\nThis task will export the contract deployed (saved in `deployments` folder) to a file with a simple format containing only contract addresses and abi, useful for web apps.\n\nOne of the following options need to be set for this task to have any effects :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\nThis last option has some limitations, when combined with the use of external deployments (see [Configuration](#configuration)). If such external deployments were using older version of **hardhat-deploy** or truffle, the chainId might be missing. In order for these to be exported, the hardhat network config need to explicity state the chainId in the `networks` config of `hardhat.config.js`.\n\nWith both `--export` and `--export-all`, using the special `<filepath>` value of `-` will output to `STDOUT` rather than writing a normal file.\n\n---\n\n---\n\n## Hardhat Environment Extensions\n\nThis plugin extends the Hardhat Runtime Environment by adding 4 fields:\n\n- `getNamedAccounts: () => Promise<{ [name: string]: string }>`: a function returning an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [Configuration](#configuration)).\n\n- `getUnnamedAccounts: () => Promise<string[]}>`: accounts which has no names, useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`: contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId(): Promise<string>`: offer an easy way to fetch the current chainId.\n\n---\n\n---\n\n## Configuration\n\n---\n\n### **1. namedAccounts (ability to name addresses)**\n\n---\n\nThis plugin extends the `HardhatConfig`'s object with an optional `namedAccounts` field.\n\n`namedAccounts` allows you to associate names to addresses and have them configured per chain.\nThis allows you to have meaningful names in your tests while the addresses match to multi sig in real network for example.\n\n```js\n{\n    namedAccounts: {\n        deployer: {\n            default: 0, // here this will by default take the first account as deployer\n            1: 0, // similarly on mainnet it will take the first account as deployer. Note though that depending on how hardhat network are configured, the account 0 on one network can be different than on another\n            4: '0xA296a3d5F026953e17F472B497eC29a5631FB51B', // but for rinkeby it will be a specific address\n            \"goerli\": '0x84b9514E013710b9dD0811c9Fe46b837a4A0d8E0', //it can also specify a specific netwotk name (specified in hardhat.config.js)\n        },\n        feeCollector:{\n            default: 1, // here this will by default take the second account as feeCollector (so in the test this will be a different account than the deployer)\n            1: '0xa5610E1f289DbDe94F3428A9df22E8B518f65751', // on the mainnet the feeCollector could be a multi sig\n            4: '0xa250ac77360d4e837a13628bC828a2aDf7BabfB3', // on rinkeby it could be another account\n        }\n    }\n}\n```\n\n<!-- You can also specify addresses with the `ledger://` prefix. In which case the account fetched will still be the corresponding address, but behind the scene, the transaction will be created via the hardware waller. Currently the feature is not working very well though and better support is needed. -->\n\n---\n\n### **2. extra hardhat.config networks' options**\n\n---\n\n**hardhat-deploy** add 5 new fields to `networks` configuration\n\n#### `live`\n\nthis is not used internally but is useful to perform action on a network whether it is a live network (rinkeby, mainnet, etc) or a temporary one (localhost, hardhat). The default is true (except for localhost and hardhat where the default is false).\n\n#### `saveDeployments`\n\nthis tell whether **hardhat-deploy** should save the deployments to disk or not. Default to true, except for the hardhat network.\n\n#### `tags`\n\nnetwork can have tags to represent them. The config is an array and at runtime the hre.network.tags is an object whose fields (the tags) are set to true.\n\nThis is useful to conidtionaly operate on network based on their use case.\n\nExample:\n\n```js\n{\n  networks: {\n    localhost: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"local\"]\n    },\n    hardhat: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"test\", \"local\"]\n    },\n    rinkeby: {\n      live: true,\n      saveDeployments: true,\n      tags: [\"staging\"]\n    }\n  }\n}\n```\n\n#### `deploy`\n\nthe deploy field override the paths.deploy option and let you define a set of folder containing the deploy scripts to be executed for this network.\n\nYou can thus have one network that will be executing L1 deployment and other L2 deployments, etc...\n\nYou could also have a folder that deploy contracts that are live on mainnet but that you need to replicate for your test or local network.\n\n#### `companionNetworks`\n\nthe companionNetworks field is an object whose key is any name you desire and the value is the name of a network that will be accessible inside the deploy script. For example:\n\n```js\n{\n  ...\n  networks: {\n    optimism: {\n      url: 'http://127.0.0.1:8545',\n      ovm: true,\n      companionNetworks: {\n        l1: 'localhost',\n      },\n    }\n  }\n  ...\n}\n```\n\nBy using name you can have the same deploy script used in different set of network.\n\nFor your test you could have the companion networks pointing to the same hardhat network, for test deployment, you could have rinkeby acting like your l2 while goerli act as your l1.\n\nAn example repo that show case a multi-network setup with optimism can be found here : https://github.com/wighawag/template-ethereum-contracts/tree/examples/optimism\n\ndeploy script can then access the network and its deployment as follow :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  const OVM_L1ERC20Gateway = await hre.companionNetworks['l1'].deployments.get(\n    'OVM_L1ERC20Gateway'\n  ); // layer 1\n\n  await execute(\n    'SimpleERC20_OVM',\n    {from: deployer, log: true},\n    'init',\n    OVM_L1ERC20Gateway.address\n  );\n};\n```\n\n---\n\n### **3. extra hardhat.config paths' options**\n\n---\n\n`hardhat-deploy` also adds fields to `HardhatConfig`'s `ProjectPaths` object.\n\nHere is an example showing the default values :\n\n```js\n{\n    paths: {\n        deploy: 'deploy',\n        deployments: 'deployments',\n        imports: 'imports'\n    }\n}\n```\n\nThe `deploy` folder is expected to contains the deploy script that are executed upon invocation of `hardhat deploy` or `hardhat node`.\nIt can also be an array of folder path.\n\nThe `deployments` folder will contains the resulting deployments (contract addresses along their abi, bytecode, metadata...). One folder per network and one file per contract.\n\nThe `imports` folder is expected to contains artifacts that were pre-compiled. Useful if you want to upgrade to a new solidity version but want to keep using previously compiled contracts. The artifact is the same format as normal hardhat artifact, so you can easily copy them over, before switching to a new compiler version.\n\n> This is less useful now that hardhat support multiple solidity compiler at once.\n\n---\n\n---\n\n### **4. deterministicDeployment (ability to specify a deployment factory)**\n\n---\n\nThis plugin extends the `HardhatConfig`'s object with an optional `deterministicDeployment` field.\n\n`deterministicDeployment` allows you to associate information that are used on each network for deterministic deployment. The information for each deterministic deployment consist out of a `factory`, a `deployer`, the required `funding` and a `signedTx` to deploy the factory. The default deterministic deployment used is the [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy). The factory expects a 32 bytes `salt` concatenated with the deployment data (see [EIP-1014](https://eips.ethereum.org/EIPS/eip-1014) for more information on these parameters).\n\nUsing the `deterministicDeployment` it is possible to define a different setup for the deterministic deployment. One use case for this is the deterministic deployment on networks that required replay protection (such as Celo or Avalanche). The [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy) can only be deployed on networks that don't enforce replay protection, therefore on other networks an alternative library has to be used. An example for this would be the [Safe Singleton Factory](https://github.com/gnosis/safe-singleton-factory) that is an adjusted version of the [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy) that contains signed transactions that include replay protection.\n\nThe information can be defined either as an object\n\n```js\n{\n    deterministicDeployment: {\n      \"4\": {\n        factory: \"<factory_address>\",\n        deployer: \"<deployer_address>\",\n        funding: \"<required_funding_in_wei>\",\n        signedTx: \"<raw_signed_tx>\",\n      }\n    }\n}\n```\n\nor as an function that returns the information for the deterministic deployment\n\n```js\n{\n  deterministicDeployment: (network: string) => {\n    return {\n      factory: '<factory_address>',\n      deployer: '<deployer_address>',\n      funding: '<required_funding_in_wei>',\n      signedTx: '<raw_signed_tx>',\n    };\n  };\n}\n```\n\n### Importing deployment from other projects (with truffle support)\n\n`hardhat-deploy` also add the `external` field to `HardhatConfig`\n\nSuch field allows to specify paths for external artifacts or **deployments**.\n\nThe external object has 2 fields:\n\n```js\n{\n    external: {\n        contracts: [\n          {\n            artifacts: \"node_modules/@cartesi/arbitration/export/artifacts\",\n            deploy: \"node_modules/@cartesi/arbitration/export/deploy\"\n          },\n          {\n            artifacts: \"node_modules/someotherpackage/artifacts\",\n          }\n        ],\n        deployments: {\n          rinkeby: [\"node_modules/@cartesi/arbitration/build/contracts\"],\n        },\n    }\n}\n```\n\nThe `contracts` field specify an array of object which itself have 2 fields.\n\n- `artifacts`: (mandatory) it is a path to an artifact folder. This support both hardhat and truffle artifacts.\n- `deploy`: (optional) it specifies a path to a folder where reside deploy script. The deploy scripts have only access to the artifact specified in the artifacts field. This allow project to share their deployment procedure. A boon for developer aiming at integrating it as they can get the contracts to be deployed for testing locally.\n\nThe `deployments` fields specify an object whose field nasme are the hardhat network and the value is an array of path to look for deployments. It supports both **hardhat-deploy** and truffle formats.\n\n---\n\n### Access to Artifacts (non-deployed contract code and abi)\n\nArtifacts in hardhat terminology represent a compiled contract (not yet deployed) with at least its bytecode and abi.\n\n`hardhat-deploy` gives can access to these artifact via the `deployments.getArtifact` function :\n\n```js\nconst {deployments} = require('hardhat');\nconst artifact = await deployments.getArtifact(artifactName);\n```\n\nWith the `hardhat-deploy-ethers` plugin you can get an artifact as an ethers contract factory, ready to be deployed, via the following:\n\n```js\nconst {deployments, ethers} = require('hardhat');\nconst factory = await ethers.getContractFactory(artifactName);\n```\n\n> Note that the artifact's files need to be either in `artifacts` folder that hardhat generate on compilation or in the `imports` folder where you can store contracts compiled elsewhere. They can also be present in the folder specified in `external.artifacts` see [Importing deployment from other projects](#importing-deployment-from-other-projects-with-truffle-support)\n\n---\n\n---\n\n## How to Deploy Contracts\n\n---\n\n### The `deploy` Task\n\n`hardhat --network <networkName> deploy [options and flags]`\n\nThis is a new task that the `hardhat-deploy` adds. As the name suggests it deploys contracts.\nTo be exact it will look for files in the folder `deploy` or whatever was configured in `paths.deploy`, see [paths config](#extra-paths-config)\n\nIt will scan for files in alphabetical order and execute them in turn.\n\n- it will `require` each of these files and execute the exported function with the HRE as argument\n\nTo specify the network, you can use the builtin hardhat argument `--network <network name>` or set the env variable `HARDHAT_NETWORK`\n\n> :warning: Note that running `hardhat deploy` without specifying a network will use the default network. If the default network is hardhat (the default's default) then nothing will happen as a result as everything happens in memory, but this can be used to ensure the deployment is without issues.\n\n---\n\n### Deploy Scripts\n\nThe deploy scripts need to be of the following type :\n\n```ts\nexport interface DeployFunction {\n  (env: HardhatRuntimeEnvironment): Promise<void | boolean>;\n  skip?: (env: HardhatRuntimeEnvironment) => Promise<boolean>;\n  tags?: string[];\n  dependencies?: string[];\n  runAtTheEnd?: boolean;\n  id?: string;\n}\n```\n\nThe skip function can be used to skip executing the script under whatever condition. It simply need to resolve a promise to true.\n\nThe tags is a list of string that when the _deploy_ task is executed with, the script will be executed (unless it skips). In other word if the deploy task is executed with a tag that does not belong to that script, that script will not be executed unless it is a dependency of a script that does get executed.\n\nThe dependencies is a list of tag that will be executed if that script is executed. So if the script is executed, every script whose tag match any of the dependencies will be executed first.\n\nThe `runAtTheEnd` is a boolean that if set to true, will queue that script to be executed after all other scripts are executed.\n\nThese set of fields allow more flexibility to organize the scripts. You are not limited to alphabetical order and you can even organise deploy script in sub folders.\n\nFinally the function can return true if it wishes to never be executed again. This can be usfeul to emulate migration scripts that are meant to be executed only once. Once such script return true (async), the `id` field is used to track execution and if that field is not present when the script return true, it will fails.\n\nIn other words, if you want a particular deploy script to run only once, it needs to both return true (async) and have an `id` set.\n\nIn any case, as a general advice every deploy function should be idempotent. This is so they can always recover from failure or pending transaction. This is what underpin most of hardhat-deploy philosophy.\n\nThis is why the `hre.deployments.deploy` function will by default only deploy if the contract code has changed, making it easier to write idempotent script.\n\n#### An example of a deploy script :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  // the following will only deploy \"GenericMetaTxProcessor\" if the contract was never deployed or if the code changed since last deployment\n  await deploy('GenericMetaTxProcessor', {\n    from: deployer,\n    gasLimit: 4000000,\n    args: [],\n  });\n};\n```\n\nAs you can see the HRE passed in has 4 new fields :\n\n- `getNamedAccounts` is a function that returns a promise to an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [`namedAccounts`](#namedaccounts)).\n\n- `getUnnamedAccounts` is a function that return a promise to an array of accounts which were not named (see [`namedAccounts`](#namedaccounts)). It is useful for tests where you want to be sure that the account has no speicifc role in the system (no token given, no admin access, etc...).\n\n- `getChainId` is a function which return a promise for the chainId, as convenience\n\n- `deployments` is an object which contains functions to access past deployments or to save new ones, as well as helpers functions.\n\nThat latter field contains for example the `deploy` function that allows you to deploy contract and save them. It contains a lot more functions though :\n\n---\n\n### The `deployments` field\n\nThe deployments field contains several helpers function to deploy contract but also execute transaction.\n\n```ts\nexport interface DeploymentsExtension {\n  deploy(name: string, options: DeployOptions): Promise<DeployResult>; // deploy a contract\n  diamond: {\n    // deploy diamond based contract (see section below)\n    deploy(name: string, options: DiamondOptions): Promise<DeployResult>;\n  };\n  deterministic( // return the determinsitic address as well as a function to deploy the contract, can pass the `salt` field in the option to use different salt\n    name: string,\n    options: Create2DeployOptions\n  ): Promise<{\n    address: Address;\n    implementationAddress?: Address;\n    deploy(): Promise<DeployResult>;\n  }>;\n  fetchIfDifferent( // return true if new compiled code is different than deployed contract\n    name: string,\n    options: DeployOptions\n  ): Promise<{differences: boolean; address?: string}>;\n  save(name: string, deployment: DeploymentSubmission): Promise<void>; // low level save of deployment\n  get(name: string): Promise<Deployment>; // fetch a deployment by name, throw if not existing\n  getOrNull(name: string): Promise<Deployment | null>; // fetch deployment by name, return null if not existing\n  getDeploymentsFromAddress(address: string): Promise<Deployment[]>;\n  all(): Promise<{[name: string]: Deployment}>; // return all deployments\n  getArtifact(name: string): Promise<Artifact>; // return a hardhat artifact (compiled contract without deployment)\n  getExtendedArtifact(name: string): Promise<ExtendedArtifact>; // return a extended artifact (with more info) (compiled contract without deployment)\n  run( // execute deployment scripts\n    tags?: string | string[],\n    options?: {\n      resetMemory?: boolean;\n      deletePreviousDeployments?: boolean;\n      writeDeploymentsToFiles?: boolean;\n      export?: string;\n      exportAll?: string;\n    }\n  ): Promise<{[name: string]: Deployment}>;\n  fixture( // execute deployment as fixture for test // use evm_snapshot to revert back\n    tags?: string | string[],\n    options?: {fallbackToGlobal?: boolean; keepExistingDeployments?: boolean}\n  ): Promise<{[name: string]: Deployment}>;\n  createFixture<T, O>( // execute a function as fixture using evm_snaphost to revert back each time\n    func: FixtureFunc<T, O>,\n    id?: string\n  ): (options?: O) => Promise<T>;\n  log(...args: any[]): void; // log data only ig log enabled (disabled in test fixture)\n\n  execute( // execute function call on contract\n    name: string,\n    options: TxOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<Receipt>;\n  rawTx(tx: SimpleTx): Promise<Receipt>; // execute a simple transaction\n  catchUnknownSigner( // you can wrap other function with this function and it will catch failure due to missing signer with the details of the tx to be executed\n    action: Promise<any> | (() => Promise<any>),\n    options?: {log?: boolean}\n  ): Promise<null | {\n    from: string;\n    to?: string;\n    value?: string;\n    data?: string;\n  }>;\n  read( // make a read-only call to a contract\n    name: string,\n    options: CallOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<any>;\n  read(name: string, methodName: string, ...args: any[]): Promise<any>;\n  // rawCall(to: Address, data: string): Promise<any>; // TODO ?\n}\n```\n\n---\n\n#### `deployments.deploy(<name>, options)`\n\n---\n\nThe `deploy` function, as mentioned above, allows you to deploy a contract and save it under a specific name.\n\nThe deploy function expect 2 parameters: one for the name and one for the options\n\nSee below the full list of fields that the option parameter allows and requires:\n\n```ts\nexport interface DeployOptions = {\n  from: string; // address (or private key) that will perform the transaction. you can use `getNamedAccounts` to retrived the address you want by name.\n  contract?: // this is an optional field. If not specified it defaults to the contract with the same name as the first parameter\n    | string // this field can be either a string for the name of the contract\n    | { // or abi and bytecode\n        abi: ABI;\n        bytecode: string;\n        deployedBytecode?: string;\n      };\n  args?: any[]; // the list of argument for the constructor (or the upgrade function in case of proxy)\n  skipIfAlreadyDeployed?: boolean; // if set it to true, will not attempt to deploy even if the contract deployed under the same name is different\n  log?: boolean; // if true, it will log the result of the deployment (tx hash, address and gas used)\n  linkedData?: any; // This allow to associate any JSON data to the deployment. Useful for merkle tree data for example\n  libraries?: { [libraryName: string]: Address }; // This let you associate libraries to the deployed contract\n  proxy?: boolean | string | ProxyOptions; // This options allow to consider your contract as a proxy (see below for more details)\n\n  // here some common tx options :\n  gasLimit?: string | number | BigNumber;\n  gasPrice?: string | BigNumber;\n  value?: string | BigNumber;\n  nonce?: string | number | BigNumber;\n\n  estimatedGasLimit?: string | number | BigNumber; // to speed up the estimation, it is possible to provide an upper gasLimit\n  estimateGasExtra?: string | number | BigNumber; // this option allow you to add a gas buffer on top of the estimation\n\n  autoMine?: boolean; // this force a evm_mine to be executed. this is useful to speed deployment on test network that allow to specify a block delay (ganache for example). This option basically skip the delay by force mining.\n  deterministicDeployment? boolean | string; // if true, it will deploy the contract at a deterministic address based on bytecode and constructor arguments. The address will be the same across all network. It use create2 opcode for that, if it is a string, the string will be used as the salt.\n  waitConfirmations?: number; // number of the confirmations to wait after the transactions is included in the chain\n};\n```\n\n---\n\n---\n\n## Handling contract using libraries\n\nIn the deploy function, one of the `DeployOptions` field is the `libraries` field. It allows you to associate external contract as libraries at the time of deployment.\n\nFirst, you have deploy the library using the `deploy` function, then when we deploy a contract that needs the linked library, we can pass the deployed library name and address in as an argument to the `libraries` object.\n\nFirst step: deploy the library:\n\n```js\nconst exampleLibrary = await deploy(\"ExampleLibary\", {\n    from: <deployer>\n});\n\n```\n\nExampleLibrary is now deployed to whatever network was chosen (`hardhat deploy --network <networkName>`)\n\nFor example, if we are deploying on Rinkeby, this library will get deployed on rinkeby, and the `exampleLibrary` variable will be a deployment object that contains the abi as well as the deployed address for the contract.\n\nNow that the library is deployed, we can link it in our next deployed contract.\n\n```js\nconst example = await deploy(\"Example\", {\n    from: <deployer>\n    args: [\"example string argument for the 'Example' contract constructor\"],\n    libraries: {\n        ExampleLibrary: exampleLibrary.address\n    }\n});\n\n```\n\nThis `libraries` object takes the name of the library, and its deployed address on the network. Multiple libraries can be passed into the `libraries` object.\n\n---\n\n---\n\n## Exporting Deployments\n\nApart from deployments saved in the `deployments` folder which contains all information available about the contract (compile time data + deployment data), `hardhat-deploy` allows you to export lightweight files.\n\nThese can be used for example to power your frontend with contract's address and abi.\n\nThis come into 2 flavors.\n\nThe first one is exported via the `--export <file>` option and follow the following format :\n\n```ts\nexport interface Export {\n  chainId: string;\n  name: string;\n  contracts: {[name: string]: ContractExport};\n}\n```\n\nwhere name is the name of the network configuration chosen (see hardhat option `--network`)\n\nThe second one is exported via the `--export-all <file>` option and follow the following format :\n\n```ts\nexport type MultiExport = {\n  [chainId: string]: Export[];\n};\n```\n\nAs you see the second format include the previous. While in most case you'll need the single export where your application will support only one network, there are case where your app would want to support multiple networks at nonce. This second format allow for that.\n\nFurthermore as hardhat support multiple network configuration for the same network (rinkeby, mainnet...), the export-all format will contains each of them grouped by their chainId.\n\n\nNote: from v0.10.4 the old multi-export down is no more:\n\n```\nexport type MultiExport = {\n  [chainId: string]: {[name: string]: Export};\n};\n```\n\n---\n\n---\n\n## Deploying and Upgrading Proxies\n\nAs mentioned above, the deploy function can also deploy a contract through a proxy. It can be done without modification of the contract as long as its number of constructor arguments matches the proxy initialization/update function.\n\nThe default Proxy is both ERC-1967 and ERC-173 Compliant, but other proxy can be specified, like openzeppelin transparent proxies.\n\nCode for the default Proxy can be found [here](solc_0.7/proxy/EIP173Proxy.sol).\n\nTo perform such proxy deployment, you just need to invoke the deploy function with the following options : `{..., proxy: true}`\n\nSee example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: true,\n  });\n};\n```\n\nYou can also set it to `proxy: \"<upgradeMethodName>\"` in which case the function `<upgradeMethodName>` will be executed upon upgrade.\nthe `args` field will be then used for that function instead of the contructor. It is also possible to then have a constructor with the same arguments and have the proxy be disabled. It can be useful if you want to have your contract as upgradeable in a test network but be non-upgradeable on the mainnet.\n\nSee example :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  network,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: network.live ? false : 'postUpgrade',\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nThe proxy option can also be an object which can set the specific owner that the proxy is going to be managed by.\n\nSee example:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: {\n      owner: greeterOwner,\n      methodName: 'postUpgrade',\n    },\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nNote that for the second invokation, this deployment will not be executed from the specified `from: deployer` as otherwise these tx will always fails. It will instead be automatically executed from the proxy's current owner (in that case : `greeterOwner`)\n\nNow, it is likely you do not want to locally handle the private key / mnemonic of the account that manage the proxy or it could even be that the `greeterOwner` in question is a multi sig. As such that second invocation will throw an error as it cannot find a local signer for it.\n\nThe error will output the necessary information to upgrade the contract but `hardhat-deploy` comes also with a utility function for such case: `deployments.catchUnknwonSigner` which will catch the error and output to the console the necessary information while continuing to next step.\n\nHere is the full example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy, catchUnknownSigner} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await catchUnknownSigner(\n    deploy('Greeter', {\n      from: deployer,\n      proxy: {\n        owner: greeterOwner,\n        methodName: 'postUpgrade',\n      },\n      args: ['arg1', 2, 3],\n    })\n  );\n  // you could pause the deployment here and wait for input to continue\n};\n```\n\nThe full proxy options is as follow:\n\n```ts\ntype ProxyOptionsBase = {\n  owner?: Address; // this set the owner of the proxy. further upgrade will need to be executed from that owner\n  upgradeIndex?: number; // allow you to breakdown your upgrades into separate deploy scriot, each with their own index. A deploy call with a specific upgradeIndex will be executed only once, only if the current upgradeIndex is one less.\n  proxyContract?: // default to \"EIP173Proxy\". See below for more details\n  string | ArtifactData;\n  viaAdminContract?: // allow to specify a contract that act as a middle man to perform upgrades. Useful and Recommended for Transparent Proxies\n  | string\n    | {\n        name: string;\n        artifact?: string | ArtifactData;\n      };\n};\n\nexport type ProxyOptions =\n  | (ProxyOptionsBase & {\n      methodName?: string; // method to be executed when the proxy is deployed for the first time or when the implementation is modified. Use the deployOptions args field for arguments\n    })\n  | (ProxyOptionsBase & {\n      execute?:\n        | {\n            methodName: string; // method to be executed when the proxy is deployed for the first time or when the implementation is modified.\n            args: any[];\n          }\n        | {\n            init: {\n              methodName: string; // method to be executed when the proxy is deployed\n              args: any[];\n            };\n            onUpgrade?: {\n              methodName: string; // method to be executed when the proxy is upgraded (not first deployment)\n              args: any[];\n            };\n          };\n    });\n```\n\nThe `proxyContract` field allow you to specify your own Proxy contract. If it is a string, it will first attempt to get an artifact with that name. If not found it will fallback on the following if\n\nit matches:\n\n- `EIP173Proxy`: use the default Proxy that is EIP-173 compliant\n\n- `EIP173ProxyWithReceive`: Same as above except that the proxy contains a receive hook to accept empty ETH payment.\n\n- `OpenZeppelinTransparentProxy`: Use Openzeppelin Transparent Proxy (copied from openzeppelin repo, see code [here](solc_0.7/openzeppelin/proxy/TransparentUpgradeableProxy.sol))\n  When this option is chosen, the `DefaultProxyAdmin` is also used as admin since Transparent Proxy kind of need an intermediarry contract for administration. This can be configured via the `viaAdminContract` option. Note that the DefaultProxyAdmin is slightly different than the one used by openzeppelin as it allow you to set a different owner than msg.sender on first deploy, something openzeppelin version do not allow, see : https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2639\n\n- `OptimizedTransparentProxy`: This contract is similar to above, except that it is optimized to not require storage read for the admin on every call.\n\n## Builtin-In Support For Diamonds (EIP2535)\n\nThe deployments field also expose the diamond field: `hre.deployments.diamond` that let you deploy [Diamonds](https://eips.ethereum.org/EIPS/eip-2535) in an easy way.\n\nInstead of specifying the facets to cut out or cut in, which the diamond contract expects, you specify the facets you want to end up having on the deployed contract.\n\n`diamond.deploy` expect the facet as names. The names represent contract to be deployed as facet. In future version you ll be able to specify deployed contract or artifact object as facet.\n\nTo deploy a contract with 3 facet you can do as follow :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: deployer,\n    owner: diamondAdmin,\n    facets: ['Facet1', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nif you then later execute the following script:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: diamondAdmin, // this need to be the diamondAdmin for upgrade\n    owner: diamondAdmin,\n    facets: ['NewFacet', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nThen the NewFacet will be deployed automatically if needed and then the diamondCut will cut Facet1 out and add NewFacet.\n\nNote that if the code for Facet2 and Facet3 changes, they will also be redeployed automatically and the diamondCuts will replace the existing facets with these new ones.\n\nNote that The Diamond contract's code is part of `hardhat-deploy` and contains 3 built-in facet that can be removed manually if desired.\nThese facets are used for ownership, diamondCut and diamond loupe.\n\nThe implementation is the [reference implementation by Nick Mudge](https://github.com/mudgen/diamond-3)\n\nLike normal proxies you can also execute a function at the time of an upgrade.\n\nThis is done by specifying the execute field in the diamond deploy options :\n\n```js\ndiamond.deploy('ADiamondContract', {\n  from: deployer,\n  owner: diamondAdmin,\n  facets: ['NewFacet', 'Facet2', 'Facet3'],\n  execute: {\n    methodName: 'postUpgrade',\n    args: ['one', 2, '0x3'],\n  },\n});\n```\n\nSince the diamond standard has no builtin mechanism to make the deployment of Diamond with function execution, the Diamond when deployed is actually deployed through a special contract, the `Diamantaire` (see code [here](solc_0.7/diamond/Diamantaire.sol)) that act as factory to build Diamond. It uses deterministic deployment for that so, it is transparently managed by `hardhat-deploy`. It also embed the implementation of the builtin facet, removing the need to have different instances of each live.\n\n<!-- The Diamantaire also support the deterministic deployment of Diamonds.\nAn extra field can be passed to the Diamond deployment options : `deterministicSalt`. It has to be a non-zero 32bytes string (in hex format).\nNote that if you want to deploy 2 diamonds with same owner, you'll need 2 different deterministicSalt for them to be 2 separate contracts. -->\n\n## Testing Deployed Contracts\n\nYou can continue using the usual test task:\n\n`hardhat test`\n\nTests can use the `hre.deployments.fixture` function to run the deployment and snapshot it so that tests don't need to perform all the deployment transactions every time. They can simply reuse the snapshot for every test (this leverages `evm_snapshot` and `evm_revert` provided by both `hardhat` and `ganache`). You can for example set them in a `beforeEach`.\n\nHere is an example of a test :\n\n```js\nconst {deployments} = require('hardhat');\n\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    await deployments.fixture(['Token']);\n    const Token = await deployments.get('Token'); // Token is available because the fixture was executed\n    console.log(Token.address);\n    const ERC721BidSale = await deployments.get('ERC721BidSale');\n    console.log({ERC721BidSale});\n  });\n});\n```\n\nTests can also leverage named accounts for clearer test. Combined with `hardhat-deploy-ethers` plugin, you can write succint test :\n\n```js\nconst {ethers, getNamedAccounts} = require('hardhat');\n\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    await deployments.fixture(['Token']);\n    const {tokenOwner} = await getNamedAccounts();\n    const TokenContract = await ethers.getContract('Token', tokenOwner);\n    await TokenContract.mint(2).then((tx) => tx.wait());\n  });\n});\n```\n\n---\n\n### Creating Fixtures\n\nFurthermore, tests can easily create efficient fixture using `deployments.createFixture`\n\nSee example :\n\n```js\nconst setupTest = deployments.createFixture(\n  async ({deployments, getNamedAccounts, ethers}, options) => {\n    await deployments.fixture(); // ensure you start from a fresh deployments\n    const {tokenOwner} = await getNamedAccounts();\n    const TokenContract = await ethers.getContract('Token', tokenOwner);\n    await TokenContract.mint(10).then((tx) => tx.wait()); //this mint is executed once and then `createFixture` will ensure it is snapshotted\n    return {\n      tokenOwner: {\n        address: tokenOwner,\n        TokenContract,\n      },\n    };\n  }\n);\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    const {tokenOwner} = await setupTest();\n    await tokenOwner.TokenContract.mint(2);\n  });\n});\n```\n\nWhile this example is trivial, some fixture can requires several transaction and the ability to snapshot them automatically speed up the tests greatly.\n\n---\n\n---\n\n## More Information On Hardhat Tasks\n\n---\n\n### **1. node task**\n\nas mentioned above, the node task is slighly modified and augmented with various flags and options\n\n`hardhat node`\n\nIn particular it adds an argument `--export` that allows you to specify a destination file where the info about the contracts deployed is written.\nYour webapp can then access all contracts information.\n\n---\n\n### **2. test task**\n\n`hardhat test`\n\nthe test task is augmented with one flag argument `--deploy-fixture` that allows to run all deployments in a fixture snapshot before executing the tests. This can speed up the tests that use specific tags as the global fixture take precedence (unless specified).\n\nIn other word tests can use `deployments.fixture(<specific tag>)` where specific tag only deploys the minimal contracts for tests, while still benefiting from global deployment snapshot if used.\n\nIf a test needs the deployments to only include the specific deployment specified by the tag, it can use the following :\n\n```js\ndeployments.fixture('<specific tag>', {fallbackToGlobal: false});\n```\n\nDue to how snapshot/revert works in hardhat, this means that these tests will not benefit from the global fixture snapshot and will have to deploy their contracts as part of the fixture call. This is automatic but means that these tests will run slower.\n\n---\n\n### **3. run task**\n\n`hardhat --network <networkName> run <script>`\n\nThe run task act as before but thanks to the `hre.deployments` field it can access deployed contract :\n\n```js\nconst hre = require('hardhat');\nconst {deployments, getNamedAccounts} = hre;\n\n(async () => {\n  console.log(await deployments.all());\n  console.log({namedAccounts: await getNamedAccounts()});\n})();\n```\n\nYou can also run it directly from the command line as usual.\n\n`HARDHAT_NETWORK=rinkeby node <script>` is the equivalent except it does not load the hardhat environment twice (which the run task does)\n\n---\n\n### **4. console task**\n\n`hardhat console`\n\nThe same applies to the `console` task.\n\n---\n\n## Deploy Scripts: Tags And Dependencies\n\n---\n\nIt is possible to execute only specific parts of the deployments with `hardhat deploy --tags <tags>`\n\nTags represent what the deploy script acts on. In general it will be a single string value, the name of the contract it deploys or modifies.\n\nThen if another deploy script has such tag as a dependency, then when this latter deploy script has a specific tag and that tag is requested, the dependency will be executed first.\n\nHere is an example of two deploy scripts :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const deployResult = await deploy('Token', {\n    from: deployer,\n    args: ['hello', 100],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Token deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Token'];\n```\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const Token = await deployments.get('Token');\n  const deployResult = await deploy('Sale', {\n    from: deployer,\n    contract: 'ERC721BidSale',\n    args: [Token.address, 1, 3600],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Sale deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.dependencies = ['Token']; // this ensure the Token script above is executed first, so `deployments.get('Token')` succeeds\n```\n\nAs you can see the second one depends on the first. This is because the second script depends on a tag that the first script registers as using.\n\nWith that when `hardhat deploy --tags Sale` is executed\n\nthen both scripts will be run, ensuring Sale is ready.\n\nYou can also define the script to run after another script is run by setting `runAtTheEnd` to be true. For example:\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, execute, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer, admin} = namedAccounts;\n  await execute('Sale', {from: deployer}, 'setAdmin', admin);\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.runAtTheEnd = true;\n```\n\nTags can also be used in test with `deployments.fixture`. This allow you to test a subset of the deploy script.\n","readmeFilename":"README.md","gitHead":"e40546ab0d3d4fe487d98de5ff082b32c0671054","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.0-next.1","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-NOmtFanr0yTaJVaOGU1wEANkmXE2+LWA3GTOgBQmJK+Ur02LG9wxE1Su8W2R/11XMuN3s1eKdpsZv/2RRLj8eQ==","shasum":"390b0b34083353f9c5ec08098a0cbd0d9d5de644","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.0-next.1.tgz","fileCount":146,"unpackedSize":11136985,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJh+WWdCRA9TVsSAnZWagAABUkP/3vPE+IWffF7gbfiJ2t3\nnEkCru3O/4JdJbfRBKYPX0V9igPF2GhxMOdZ7UnwO5xVjlrXDU5bhvUDRX05\ndem4EW5fGK3HYPzFOQmXSnfSK6w7gVtD94TN8a9HHyDZJHVxcKphZCfL3m0O\nug52BCPOP15hrYJMANmNkaSXZAIfrQ52vFtp9CEe9CpRgRGftbghLBf3dKRT\nY885Z+jUkOuC8B7FLro3lcCoTAta5xBpd4rlwXwP2kgcXMm71/IfXiuHNJFP\nNJ9FQN0TTfs52nf4IE6aggmSW4hkOQ9EVGD7XUEhBFqDlrwqTERD7WI8oB2M\naPMP0jKG1ipNvRcDgEYr6TsklQ73nKhps+C0bx73Tn2TYQ1hN5ej2mgnKCnQ\nznJJ9IbHu1JGJTdqb1xLJ+mF7cFYoaS+tguPJqfsIbYfxMseFdROlm8pi5eT\nbCql+xLwXmFOBbi6ar4MWdWmlPv0LUX52GYR6ancsDUkaK/UldBLPEYcWjEh\nHRI7P2t5wmbG0ilig1onb2I5amv4HJP53QtGS/2uML7vsL4B3iAPfA1cVkCn\nLz5Toif34oZIMQMbssOWQzfv7gwIPrTm0DgrutUp5SCbjuZ8cffNbVwnaCx2\nxRGWRzx1ZfzJyw7XaXCcppyO8Mygk0GoBuJS1kjwVK4eoL+quaAVDZUrTnFG\nGrrp\r\n=ITxg\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCx3cksyjB6KPgqRxF6T7WOOB8wBQyJDbqARSr8NJZD+gIgHuAv9kKqvhTGT6LuCwsCt8xxk5s9P3tDBoFNAhp832o="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.0-next.1_1643734429276_0.5475504226516812"},"_hasShrinkwrap":false},"0.11.0-next.2":{"name":"hardhat-deploy","version":"0.11.0-next.2","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.8","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.6.8"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"e8737d53247acf5d6ad91a2b6f3da63b79933fdf","readme":"<h1> hardhat-deploy</h1>\n\n_A [Hardhat](https://hardhat.org) Plugin For Replicable Deployments And Easy Testing_\n\n> **A complete dev template using hardhat-deploy is available here** : https://github.com/wighawag/template-ethereum-contracts\n> It also contains various branches examplifying the capability of hardhat-deploy. Check it out.\n\n- [What is it for ?](#what-is-it-for-)\n- [hardhat-deploy in a nutshell](#hardhat-deploy-in-a-nutshell)\n- [Installation](#installation)\n  - [npm install hardhat-deploy](#npm-install-hardhat-deploy)\n  - [TypeScript support](#typescript-support)\n  - [Migrating existing deployment to hardhat-deploy](#migrating-existing-deployment-to-hardhat-deploy)\n- [Hardhat Tasks Available/Updated](#hardhat-tasks-availableupdated)\n  - [1. hardhat deploy](#1-hardhat-deploy)\n    - [**Options**](#options)\n    - [**Flags**](#flags)\n  - [2. hardhat node](#2-hardhat-node)\n    - [**Options**](#options-1)\n    - [**Flags**](#flags-1)\n  - [3. hardhat test](#3-hardhat-test)\n  - [4. hardhat etherscan-verify](#4-hardhat-etherscan-verify)\n    - [**Options**](#options-2)\n  - [5. hardhat sourcify](#5-hardhat-sourcify)\n    - [**Options**](#options-3)\n  - [6. hardhat export](#6-hardhat-export)\n    - [**Options**](#options-4)\n- [Hardhat Environment Extensions](#hardhat-environment-extensions)\n- [Configuration](#configuration)\n  - [**1. namedAccounts (ability to name addresses)**](#1-namedaccounts-ability-to-name-addresses)\n  - [**2. extra hardhat.config networks' options**](#2-extra-hardhatconfig-networks-options)\n    - [`live`](#live)\n    - [`saveDeployments`](#savedeployments)\n    - [`tags`](#tags)\n    - [`deploy`](#deploy)\n    - [`companionNetworks`](#companionnetworks)\n  - [**3. extra hardhat.config paths' options**](#3-extra-hardhatconfig-paths-options)\n  - [**4. deterministicDeployment (ability to specify a deployment factory)**](#4-deterministicdeployment-ability-to-specify-a-deployment-factory)\n  - [Importing deployment from other projects (with truffle support)](#importing-deployment-from-other-projects-with-truffle-support)\n  - [Access to Artifacts (non-deployed contract code and abi)](#access-to-artifacts-non-deployed-contract-code-and-abi)\n- [How to Deploy Contracts](#how-to-deploy-contracts)\n  - [The `deploy` Task](#the-deploy-task)\n  - [Deploy Scripts](#deploy-scripts)\n    - [An example of a deploy script :](#an-example-of-a-deploy-script-)\n  - [The `deployments` field](#the-deployments-field)\n    - [`deployments.deploy(<name>, options)`](#deploymentsdeployname-options)\n- [Handling contract using libraries](#handling-contract-using-libraries)\n- [Exporting Deployments](#exporting-deployments)\n- [Deploying and Upgrading Proxies](#deploying-and-upgrading-proxies)\n- [Builtin-In Support For Diamonds (EIP2535)](#builtin-in-support-for-diamonds-eip2535)\n- [Testing Deployed Contracts](#testing-deployed-contracts)\n  - [Creating Fixtures](#creating-fixtures)\n- [More Information On Hardhat Tasks](#more-information-on-hardhat-tasks)\n  - [**1. node task**](#1-node-task)\n  - [**2. test task**](#2-test-task)\n  - [**3. run task**](#3-run-task)\n  - [**4. console task**](#4-console-task)\n- [Deploy Scripts: Tags And Dependencies](#deploy-scripts-tags-and-dependencies)\n\n## What is it for ?\n\nThis [hardhat](https://hardhat.org) plugin adds a mechanism to deploy contracts to any network, keeping track of them and replicating the same environment for testing.\n\nIt also adds a mechanism to associate names to addresses, so test and deployment scripts can be reconfigured by simply changing the address a name points to, allowing different configurations per network. This also results in much clearer tests and deployment scripts (no more `accounts[0]` in your code).\n\nThis plugin contains a lot more features too, all geared toward a better developer experience :\n\n- chain configuration export\n- listing deployed contracts' addresses and their abis (useful for webapps)\n- library linking at time of deployment.\n- deterministic deployment across networks.\n- support for specific deploy script per network (L1 vs L2 for example)\n- ability to access deployment from \"companion\" networks\n- deployment dependency system (allowing you to only deploy what is needed).\n- deployment retrying (by saving pending tx): so you can feel confident when making a deployment that you can always recover.\n- deployments as test fixture using `evm_snapshot` to speed up testing.\n- ability to create your own test fixture that automatically benefits from `evm_snapshot`'s tests speed-up boost\n- combined with [hardhat-deploy-ethers](https://github.com/wighawag/hardhat-deploy-ethers) it has the ability to get ethers contract instance by name (like `await ethers.getContract(\"ContractName\")`).\n- importing artifact from external sources (like npm packages), including [truffle](https://www.trufflesuite.com/truffle) support.\n- importing deployments from external sources (like npm packages)\n- ability to log information in `deploy` mode only (while in test the console remains clean).\n- contains helpers to read and execute transaction on deployed contract referring to them by name.\n- These helpers contains options to auto mine on dev network (to speed up test deployments).\n- save metadata of deployed contract so they can always be fully verified, via [sourcify](https://sourcify.dev) or [etherscan](https://etherscan.io).\n- ability to submit contract source to etherscan and sourcify for verification at any time. (Because **hardhat-deploy** will save all the necessary info, it can be executed at any time.)\n- support harhdat's fork feature so deployment can be accessed even when run through fork.\n- named accounts are automatically impersonnated too, so you can perform tx as if you had their private key.\n- proxy deployment with ability to upgrade them transparently, only if code changes.\n- this include support for [openzeppelin](https://openzeppelin.com) transparent proxies\n- diamond deployment with facets, allowing you to focus on what the new version will be. It will generate the diamondCut necessary to reach the new state.\n- watch and deploy: **hardhat-deploy** can watch both your deploy script and contract code and redeploy on changes.\n- HCR (Hot Contract Replacement): the watch feature combined with proxy or diamond, gives you an experience akin to frontend Hot Module Replacement: once your contract changes, the deployment is executed and your contract retains the same address and same state, allowing you to tweak your contracts while debugging your front-end.\n\n## hardhat-deploy in a nutshell\n\nBefore going into the details, here is a very simple summary of the basic feature of **hardhat-deploy**.\n\n**hardhat-deploy** allows you to write [`deploy scripts`](#deploy-scripts) in the `deploy` folder. Each of these files that look as follows will be executed in turn when you execute the following task: `hardhat --network <networkName> deploy`\n\n```js\n// deploy/00_deploy_my_contract.js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('MyContract', {\n    from: deployer,\n    args: ['Hello'],\n    log: true,\n  });\n};\nmodule.exports.tags = ['MyContract'];\n```\n\nFurthermore you can also ensure these scripts are executed in test too by calling `await deployments.fixture(['MyContract'])` in your test.\nThis is optimized, so if multiple tests use the same contract, the deployment will be executed once and each test will start with the exact same state.\n\nThis is a huge benefit for testing since you are not required to replicate the deployment procedure in your tests. The tag feature (as seen in the script above) and [dependencies](#deploy-scripts-tags-and-dependencies) will also make your life easier when writing complex deployment procedures.\n\nYou can even group deploy scripts in different sub folder and ensure they are executed in their logical order.\n\nFurthermore hardhat-deploy can also support a multi-chain settings like L1, L2 with multiple deploy folder specific to each network.\n\n**All of this can also be bundled in a npm package so user of hardhat-deploy can reuse your deployment procedure and get started integrating with your project locally.**\n\nThere is a tutorial covering the basics here : https://github.com/wighawag/tutorial-hardhat-deploy\n\n## Installation\n\n### npm install hardhat-deploy\n\n```bash\nnpm install -D hardhat-deploy\n```\n\nAnd add the following statement to your `hardhat.config.js`:\n\n```js\nrequire('hardhat-deploy');\n```\n\nif you use `ethers.js` we recommend you also install `hardhat-deploy-ethers` which add extra features to access deployments as ethers contract.\n\nSince `hardhat-deploy-ethers` is a fork of `@nomiclabs/hardhat-ethers` and that other plugin might have an hardcoded dependency on `@nomiclabs/hardhat-ethers` the best way to install `hardhat-deploy-ethers` and ensure compatibility is the following:\n\n```bash\nnpm install --save-dev  @nomiclabs/hardhat-ethers@npm:hardhat-deploy-ethers ethers\n```\n\nWhich means you then need to do `require(\"@nomiclabs/hardhat-ethers\")` instead of `require(\"hardhat-deploy-ethers\")` in your `hardhat.config.js` file.\n\nMore details on `hardhat-deploy-ethers` repo : https://github.com/wighawag/hardhat-deploy-ethers#readme\n\n### TypeScript support\n\nWith hardhat the tsconfig.json is optional.\n\nBut if you add folders to the `include` field in `tsconfig.json`, you ll also need to include `hardhat.config.ts` like :\n\n`include\": [\"./hardhat.config.ts\", \"./scripts\", \"./deploy\", \"./test\"]`\n\nfor deploy script (see below) you can write them this way to benefit from typing :\n\n```ts\nimport {HardhatRuntimeEnvironment} from 'hardhat/types';\nimport {DeployFunction} from 'hardhat-deploy/types';\n\nconst func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {\n  // code here\n};\nexport default func;\n```\n\nSee a template that uses **hardhat-deploy** here : https://github.com/wighawag/template-ethereum-contracts\n\nThis repo has also some examples branch that exemplify specific features, like the forking testing here : https://github.com/wighawag/template-ethereum-contracts/tree/examples/fork-test\n\n### Migrating existing deployment to hardhat-deploy\n\n> Only needed for existing project that already deployed contracts and has the deployment information available **(at minimum, address and abi)**\n\nYou might want to switch your current deployment process to use **hardhat-deploy**. In that case you probably have some deployments saved elsewhere.\n\nIn order to port them to **hardhat-deploy**, you'll need to create one `.json` file per contract in the `deployments/<network>` folder (configurable via [paths config](#extra-paths-config)).\n\nThe network folder is simply the hardhat network name (as configured in hardhat.config.js) (accessible at runtime via `hre.network.name`).\nSuch folder need to have a file named `.chainId` containing the chainId as decimal.\n\nFor example for network named \"rinkeby\" (for the corresponding network) the file `deployments/rinkeby/.chainId` would be\n\n```\n4\n```\n\nNote, prior to hardhat 0.6 the chainId was appended to the folder name (expect for some known network name). This has changed and upgrading to 0.6 will require you to change the folder name and add the '.chainId' file.\n\nEach contract file must follow this type (as defined in [types.ts](types.ts)) :\n\n```ts\nexport interface Deployment {\n  address: Address;\n  abi: ABI;\n  receipt?: Receipt;\n  transactionHash?: string;\n  history?: Deployment[];\n  numDeployments?: number;\n  implementation?: string;\n  args?: any[];\n  linkedData?: any;\n  solcInputHash?: string;\n  metadata?: string;\n  bytecode?: string;\n  deployedBytecode?: string;\n  libraries?: Libraries;\n  userdoc?: any;\n  devdoc?: any;\n  methodIdentifiers?: any;\n  diamondCut?: FacetCut[];\n  facets?: Facet[];\n  storageLayout?: any;\n  gasEstimates?: any;\n}\n```\n\nAs you can see, only abi and address are mandatory. But having the other fields allow more feature. For example, metadata and args allow you to benefit from contract code verification.\n\nFor Receipt, the following type is expected:\n\n```ts\nexport type Receipt = {\n  from: string;\n  transactionHash: string;\n  blockHash: string;\n  blockNumber: number;\n  transactionIndex: number;\n  cumulativeGasUsed: string;\n  gasUsed: string;\n  contractAddress?: string;\n  to?: string;\n  logs?: Log[];\n  events?: any[];\n  logsBloom?: string;\n  byzantium?: boolean;\n  status?: number;\n  confirmations?: number;\n};\n```\n\nHere is an example:\n\nLet's say you have:\n\n- 2 Contract named Greeter and Registry deployed on rinkeby\n- 1 contract named Greeter on mainnet\n- 2 Contract named Greeter and Registry deployed on a network named rinkeby2\n\nYou would get the following folder structure:\n\n```\ndeployments/\n  mainnet/\n    .chainId\n    Greeter.json\n  rinkeby/\n    .chainId\n    Greeter.json\n    Registry.json\n  rinkeby2/\n    .chainId\n    Greeter.json\n    Registry.json\n```\n\nThe reason why **hardhat-deploy** save chainId in the `.chainId` file is both for\n\n- safety: so that if you were to change the network name to point to a different chain, it would not attempt to read the wrong folder and assume that a contract has been deployed while it has not.\n- ability to know the chainId without requring to be connected to a node (and so not dependent on hardhat.config.js settings). Useful for `export` task.\n\n---\n\n## Hardhat Tasks Available/Updated\n\nhardhat deploy add several task to hardhat. It also modify existing one, adding new options and new behavior. All of these are described here:\n\n---\n\n### 1. hardhat deploy\n\n---\n\nThis plugin adds the _deploy_ task to Hardhat.\n\nThis task will execute the scripts in the `deploy` folder and save the contract deployments to disk. These deployments are supposed to be saved for example in a git repository. This way they can be accessed later. But you are free to save them elsewhere and get them back via your mechanism of choice.\n\nWith the deployment saved, it allows you to deploy a contract only if changes were made.\n\nDeploy scripts (also called Deploy functions) can also perform aribtrary logic.\n\nFor further details on how to use it and write deploy script, see [section](#deploy-scripts) below.\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployments, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice (in wei) to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--reset`: This flag resets the deployments from scratch. Previously deployed contract are not considered and deleted from disk.\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n---\n\n### 2. hardhat node\n\n---\n\nThis plugin modify the _node_ task so that it also execute the deployment script before exposing the server http RPC interface\n\nIt add similar options than the `deploy` task :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--no-reset`: This flag prevent the reseting of the existing deployments. This is usually not desired when running the `node` task as a network is created from scratch and previous deployemnt are irrelevant.\n\n`--show-accounts`: this flag will output the account private keys\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n`--no-deploy` that discard all other options to revert to normal `hardhat node` behavior without any deployment being performed.\n\n> :warning: Note that the deployments are saved as if the network name is `localhost`. This is because `hardhat node` is expected to be used as localhost: You can for example execute `hardhat --network localhost console` after `node` is running. Doing `hardhat --network hardhat console` would indeed not do anything useful. It still take the configuration from `hardhat` in the hardhat.config.js file though.\n\n---\n\n### 3. hardhat test\n\n---\n\nThis plugin adds a flag argument `--deploy-fixture` to the _test_ task which if enabled will run the global deployments fixture before the tests and snapshots it. This will generaly speed up the tests as further test will be able to revert back to the full deployment.\n\n> :warning: Note though that if your test behave differently whether that option is on or not, this most likely mean that your deploy scripts' tags and dependencies are not configured correctly. This is because the global fixture will ensure all contract are deployed while test will usually (for efficiency) ask for a particular tag.\n\n---\n\n### 4. hardhat etherscan-verify\n\n---\n\nThis plugin adds the _etherscan-verify_ task to Hardhat.\n\nThis task will submit the contract source and other info of all deployed contracts to allow etherscan to verify and record the sources.\n\nInstead of using the full solc input, this task will first attempt to send the minimal sources from the metadata.\nBut Etherscan sometime fails due to a bug in solidity compiler (<https://github.com/ethereum/solidity/issues/9573>). As such this task can fallback on full solc input (see option --solc-input). Note that if your contract was deployed with a previous version of **hardhat-deploy**, it might not contains the full information. The issue seems to be fully resolved since solc version 0.8.\n\nThis task will also attempt to automatically find the SPDX license in the source.\n\nTo execute that task, you need to specifiy the network to run against :\n\n```bash\nhardhat --network mainnet etherscan-verify [--api-key <apikey>] [--apiurl <url>]\n```\n\n#### **Options**\n\nNote that harhdat-deploy now use a different config format to not conflict with `hardhat-etherscan`\n\n`--api-key <api key>`: let you specify your etherscan api key. Alternatively, you can provide it via the env variable `ETHERSCAN_API_KEY` or through the hardhat.config.ts verify field:\n\n```js\n{\n  ...\n  verify: {\n    etherscan: {\n      apiKey: '<API key>'\n    }\n  }\n}\n```\n\n`--api-url <url>`: let you specify your etherscan url to submit the source to. Can also be configured per network in `hardhat.config.js`:\n\n```js\n{\n  ...\n  networks: {\n    mynetwork: {\n      ...\n      verify: {\n        etherscan: {\n          apiUrl: 'http://mynetwork.xyz'\n        }\n      }\n    }\n  }\n}\n```\n\n`--license <SPDX license id>`: SPDX license (useful if SPDX is not listed in the sources), need to be supported by etherscan: https://etherscan.io/contract-license-types\n\n`--force-license`: if set, will force the use of the license specified by --license option, ignoring the one in the source (useful for license not supported by etherscan)\n\n`--solc-input`: fallback on solc-input id needed (useful when etherscan fails on the minimum sources, see https://github.com/ethereum/solidity/issues/9573)\n\n`--sleep`: sleep 500ms between each verification, so API rate limit is not exceeded\n\n---\n\n### 5. hardhat sourcify\n\n---\n\nThis plugin adds the _sourcify_ task to Hardhat.\n\nSimilar to `hardhat etherscan-verify` this task will submit the contract source and other info of all deployed contracts to sourcify.\n\n```bash\nhardhat --network mainnet sourcify\n```\n\nLater this task might instead pin the metadata to ipfs, so sourcify can automatically verify them.\n\n#### **Options**\n\n`--endpoint <endpoint>`: specify the sourcify endpoint, default to https://sourcify.dev/server/\n\n`--write-failing-metadata`: if set and the sourcify task fails to verify, the metadata file will be written to disk, so you can more easily figure out what has gone wrong.\n\n---\n\n### 6. hardhat export\n\n---\n\nThis plugin adds the _export_ task to Hardhat.\n\nThis task will export the contract deployed (saved in `deployments` folder) to a file with a simple format containing only contract addresses and abi, useful for web apps.\n\nOne of the following options need to be set for this task to have any effects :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\nThis last option has some limitations, when combined with the use of external deployments (see [Configuration](#configuration)). If such external deployments were using older version of **hardhat-deploy** or truffle, the chainId might be missing. In order for these to be exported, the hardhat network config need to explicity state the chainId in the `networks` config of `hardhat.config.js`.\n\nWith both `--export` and `--export-all`, using the special `<filepath>` value of `-` will output to `STDOUT` rather than writing a normal file.\n\n---\n\n---\n\n## Hardhat Environment Extensions\n\nThis plugin extends the Hardhat Runtime Environment by adding 4 fields:\n\n- `getNamedAccounts: () => Promise<{ [name: string]: string }>`: a function returning an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [Configuration](#configuration)).\n\n- `getUnnamedAccounts: () => Promise<string[]}>`: accounts which has no names, useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`: contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId(): Promise<string>`: offer an easy way to fetch the current chainId.\n\n---\n\n---\n\n## Configuration\n\n---\n\n### **1. namedAccounts (ability to name addresses)**\n\n---\n\nThis plugin extends the `HardhatConfig`'s object with an optional `namedAccounts` field.\n\n`namedAccounts` allows you to associate names to addresses and have them configured per chain.\nThis allows you to have meaningful names in your tests while the addresses match to multi sig in real network for example.\n\n```js\n{\n    namedAccounts: {\n        deployer: {\n            default: 0, // here this will by default take the first account as deployer\n            1: 0, // similarly on mainnet it will take the first account as deployer. Note though that depending on how hardhat network are configured, the account 0 on one network can be different than on another\n            4: '0xA296a3d5F026953e17F472B497eC29a5631FB51B', // but for rinkeby it will be a specific address\n            \"goerli\": '0x84b9514E013710b9dD0811c9Fe46b837a4A0d8E0', //it can also specify a specific netwotk name (specified in hardhat.config.js)\n        },\n        feeCollector:{\n            default: 1, // here this will by default take the second account as feeCollector (so in the test this will be a different account than the deployer)\n            1: '0xa5610E1f289DbDe94F3428A9df22E8B518f65751', // on the mainnet the feeCollector could be a multi sig\n            4: '0xa250ac77360d4e837a13628bC828a2aDf7BabfB3', // on rinkeby it could be another account\n        }\n    }\n}\n```\n\n<!-- You can also specify addresses with the `ledger://` prefix. In which case the account fetched will still be the corresponding address, but behind the scene, the transaction will be created via the hardware waller. Currently the feature is not working very well though and better support is needed. -->\n\n---\n\n### **2. extra hardhat.config networks' options**\n\n---\n\n**hardhat-deploy** add 5 new fields to `networks` configuration\n\n#### `live`\n\nthis is not used internally but is useful to perform action on a network whether it is a live network (rinkeby, mainnet, etc) or a temporary one (localhost, hardhat). The default is true (except for localhost and hardhat where the default is false).\n\n#### `saveDeployments`\n\nthis tell whether **hardhat-deploy** should save the deployments to disk or not. Default to true, except for the hardhat network.\n\n#### `tags`\n\nnetwork can have tags to represent them. The config is an array and at runtime the hre.network.tags is an object whose fields (the tags) are set to true.\n\nThis is useful to conidtionaly operate on network based on their use case.\n\nExample:\n\n```js\n{\n  networks: {\n    localhost: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"local\"]\n    },\n    hardhat: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"test\", \"local\"]\n    },\n    rinkeby: {\n      live: true,\n      saveDeployments: true,\n      tags: [\"staging\"]\n    }\n  }\n}\n```\n\n#### `deploy`\n\nthe deploy field override the paths.deploy option and let you define a set of folder containing the deploy scripts to be executed for this network.\n\nYou can thus have one network that will be executing L1 deployment and other L2 deployments, etc...\n\nYou could also have a folder that deploy contracts that are live on mainnet but that you need to replicate for your test or local network.\n\n#### `companionNetworks`\n\nthe companionNetworks field is an object whose key is any name you desire and the value is the name of a network that will be accessible inside the deploy script. For example:\n\n```js\n{\n  ...\n  networks: {\n    optimism: {\n      url: 'http://127.0.0.1:8545',\n      ovm: true,\n      companionNetworks: {\n        l1: 'localhost',\n      },\n    }\n  }\n  ...\n}\n```\n\nBy using name you can have the same deploy script used in different set of network.\n\nFor your test you could have the companion networks pointing to the same hardhat network, for test deployment, you could have rinkeby acting like your l2 while goerli act as your l1.\n\nAn example repo that show case a multi-network setup with optimism can be found here : https://github.com/wighawag/template-ethereum-contracts/tree/examples/optimism\n\ndeploy script can then access the network and its deployment as follow :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  const OVM_L1ERC20Gateway = await hre.companionNetworks['l1'].deployments.get(\n    'OVM_L1ERC20Gateway'\n  ); // layer 1\n\n  await execute(\n    'SimpleERC20_OVM',\n    {from: deployer, log: true},\n    'init',\n    OVM_L1ERC20Gateway.address\n  );\n};\n```\n\n---\n\n### **3. extra hardhat.config paths' options**\n\n---\n\n`hardhat-deploy` also adds fields to `HardhatConfig`'s `ProjectPaths` object.\n\nHere is an example showing the default values :\n\n```js\n{\n    paths: {\n        deploy: 'deploy',\n        deployments: 'deployments',\n        imports: 'imports'\n    }\n}\n```\n\nThe `deploy` folder is expected to contains the deploy script that are executed upon invocation of `hardhat deploy` or `hardhat node`.\nIt can also be an array of folder path.\n\nThe `deployments` folder will contains the resulting deployments (contract addresses along their abi, bytecode, metadata...). One folder per network and one file per contract.\n\nThe `imports` folder is expected to contains artifacts that were pre-compiled. Useful if you want to upgrade to a new solidity version but want to keep using previously compiled contracts. The artifact is the same format as normal hardhat artifact, so you can easily copy them over, before switching to a new compiler version.\n\n> This is less useful now that hardhat support multiple solidity compiler at once.\n\n---\n\n---\n\n### **4. deterministicDeployment (ability to specify a deployment factory)**\n\n---\n\nThis plugin extends the `HardhatConfig`'s object with an optional `deterministicDeployment` field.\n\n`deterministicDeployment` allows you to associate information that are used on each network for deterministic deployment. The information for each deterministic deployment consist out of a `factory`, a `deployer`, the required `funding` and a `signedTx` to deploy the factory. The default deterministic deployment used is the [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy). The factory expects a 32 bytes `salt` concatenated with the deployment data (see [EIP-1014](https://eips.ethereum.org/EIPS/eip-1014) for more information on these parameters).\n\nUsing the `deterministicDeployment` it is possible to define a different setup for the deterministic deployment. One use case for this is the deterministic deployment on networks that required replay protection (such as Celo or Avalanche). The [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy) can only be deployed on networks that don't enforce replay protection, therefore on other networks an alternative library has to be used. An example for this would be the [Safe Singleton Factory](https://github.com/gnosis/safe-singleton-factory) that is an adjusted version of the [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy) that contains signed transactions that include replay protection.\n\nThe information can be defined either as an object\n\n```js\n{\n    deterministicDeployment: {\n      \"4\": {\n        factory: \"<factory_address>\",\n        deployer: \"<deployer_address>\",\n        funding: \"<required_funding_in_wei>\",\n        signedTx: \"<raw_signed_tx>\",\n      }\n    }\n}\n```\n\nor as an function that returns the information for the deterministic deployment\n\n```js\n{\n  deterministicDeployment: (network: string) => {\n    return {\n      factory: '<factory_address>',\n      deployer: '<deployer_address>',\n      funding: '<required_funding_in_wei>',\n      signedTx: '<raw_signed_tx>',\n    };\n  };\n}\n```\n\n### Importing deployment from other projects (with truffle support)\n\n`hardhat-deploy` also add the `external` field to `HardhatConfig`\n\nSuch field allows to specify paths for external artifacts or **deployments**.\n\nThe external object has 2 fields:\n\n```js\n{\n    external: {\n        contracts: [\n          {\n            artifacts: \"node_modules/@cartesi/arbitration/export/artifacts\",\n            deploy: \"node_modules/@cartesi/arbitration/export/deploy\"\n          },\n          {\n            artifacts: \"node_modules/someotherpackage/artifacts\",\n          }\n        ],\n        deployments: {\n          rinkeby: [\"node_modules/@cartesi/arbitration/build/contracts\"],\n        },\n    }\n}\n```\n\nThe `contracts` field specify an array of object which itself have 2 fields.\n\n- `artifacts`: (mandatory) it is a path to an artifact folder. This support both hardhat and truffle artifacts.\n- `deploy`: (optional) it specifies a path to a folder where reside deploy script. The deploy scripts have only access to the artifact specified in the artifacts field. This allow project to share their deployment procedure. A boon for developer aiming at integrating it as they can get the contracts to be deployed for testing locally.\n\nThe `deployments` fields specify an object whose field nasme are the hardhat network and the value is an array of path to look for deployments. It supports both **hardhat-deploy** and truffle formats.\n\n---\n\n### Access to Artifacts (non-deployed contract code and abi)\n\nArtifacts in hardhat terminology represent a compiled contract (not yet deployed) with at least its bytecode and abi.\n\n`hardhat-deploy` gives can access to these artifact via the `deployments.getArtifact` function :\n\n```js\nconst {deployments} = require('hardhat');\nconst artifact = await deployments.getArtifact(artifactName);\n```\n\nWith the `hardhat-deploy-ethers` plugin you can get an artifact as an ethers contract factory, ready to be deployed, via the following:\n\n```js\nconst {deployments, ethers} = require('hardhat');\nconst factory = await ethers.getContractFactory(artifactName);\n```\n\n> Note that the artifact's files need to be either in `artifacts` folder that hardhat generate on compilation or in the `imports` folder where you can store contracts compiled elsewhere. They can also be present in the folder specified in `external.artifacts` see [Importing deployment from other projects](#importing-deployment-from-other-projects-with-truffle-support)\n\n---\n\n---\n\n## How to Deploy Contracts\n\n---\n\n### The `deploy` Task\n\n`hardhat --network <networkName> deploy [options and flags]`\n\nThis is a new task that the `hardhat-deploy` adds. As the name suggests it deploys contracts.\nTo be exact it will look for files in the folder `deploy` or whatever was configured in `paths.deploy`, see [paths config](#extra-paths-config)\n\nIt will scan for files in alphabetical order and execute them in turn.\n\n- it will `require` each of these files and execute the exported function with the HRE as argument\n\nTo specify the network, you can use the builtin hardhat argument `--network <network name>` or set the env variable `HARDHAT_NETWORK`\n\n> :warning: Note that running `hardhat deploy` without specifying a network will use the default network. If the default network is hardhat (the default's default) then nothing will happen as a result as everything happens in memory, but this can be used to ensure the deployment is without issues.\n\n---\n\n### Deploy Scripts\n\nThe deploy scripts need to be of the following type :\n\n```ts\nexport interface DeployFunction {\n  (env: HardhatRuntimeEnvironment): Promise<void | boolean>;\n  skip?: (env: HardhatRuntimeEnvironment) => Promise<boolean>;\n  tags?: string[];\n  dependencies?: string[];\n  runAtTheEnd?: boolean;\n  id?: string;\n}\n```\n\nThe skip function can be used to skip executing the script under whatever condition. It simply need to resolve a promise to true.\n\nThe tags is a list of string that when the _deploy_ task is executed with, the script will be executed (unless it skips). In other word if the deploy task is executed with a tag that does not belong to that script, that script will not be executed unless it is a dependency of a script that does get executed.\n\nThe dependencies is a list of tag that will be executed if that script is executed. So if the script is executed, every script whose tag match any of the dependencies will be executed first.\n\nThe `runAtTheEnd` is a boolean that if set to true, will queue that script to be executed after all other scripts are executed.\n\nThese set of fields allow more flexibility to organize the scripts. You are not limited to alphabetical order and you can even organise deploy script in sub folders.\n\nFinally the function can return true if it wishes to never be executed again. This can be usfeul to emulate migration scripts that are meant to be executed only once. Once such script return true (async), the `id` field is used to track execution and if that field is not present when the script return true, it will fails.\n\nIn other words, if you want a particular deploy script to run only once, it needs to both return true (async) and have an `id` set.\n\nIn any case, as a general advice every deploy function should be idempotent. This is so they can always recover from failure or pending transaction. This is what underpin most of hardhat-deploy philosophy.\n\nThis is why the `hre.deployments.deploy` function will by default only deploy if the contract code has changed, making it easier to write idempotent script.\n\n#### An example of a deploy script :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  // the following will only deploy \"GenericMetaTxProcessor\" if the contract was never deployed or if the code changed since last deployment\n  await deploy('GenericMetaTxProcessor', {\n    from: deployer,\n    gasLimit: 4000000,\n    args: [],\n  });\n};\n```\n\nAs you can see the HRE passed in has 4 new fields :\n\n- `getNamedAccounts` is a function that returns a promise to an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [`namedAccounts`](#namedaccounts)).\n\n- `getUnnamedAccounts` is a function that return a promise to an array of accounts which were not named (see [`namedAccounts`](#namedaccounts)). It is useful for tests where you want to be sure that the account has no speicifc role in the system (no token given, no admin access, etc...).\n\n- `getChainId` is a function which return a promise for the chainId, as convenience\n\n- `deployments` is an object which contains functions to access past deployments or to save new ones, as well as helpers functions.\n\nThat latter field contains for example the `deploy` function that allows you to deploy contract and save them. It contains a lot more functions though :\n\n---\n\n### The `deployments` field\n\nThe deployments field contains several helpers function to deploy contract but also execute transaction.\n\n```ts\nexport interface DeploymentsExtension {\n  deploy(name: string, options: DeployOptions): Promise<DeployResult>; // deploy a contract\n  diamond: {\n    // deploy diamond based contract (see section below)\n    deploy(name: string, options: DiamondOptions): Promise<DeployResult>;\n  };\n  deterministic( // return the determinsitic address as well as a function to deploy the contract, can pass the `salt` field in the option to use different salt\n    name: string,\n    options: Create2DeployOptions\n  ): Promise<{\n    address: Address;\n    implementationAddress?: Address;\n    deploy(): Promise<DeployResult>;\n  }>;\n  fetchIfDifferent( // return true if new compiled code is different than deployed contract\n    name: string,\n    options: DeployOptions\n  ): Promise<{differences: boolean; address?: string}>;\n  save(name: string, deployment: DeploymentSubmission): Promise<void>; // low level save of deployment\n  get(name: string): Promise<Deployment>; // fetch a deployment by name, throw if not existing\n  getOrNull(name: string): Promise<Deployment | null>; // fetch deployment by name, return null if not existing\n  getDeploymentsFromAddress(address: string): Promise<Deployment[]>;\n  all(): Promise<{[name: string]: Deployment}>; // return all deployments\n  getArtifact(name: string): Promise<Artifact>; // return a hardhat artifact (compiled contract without deployment)\n  getExtendedArtifact(name: string): Promise<ExtendedArtifact>; // return a extended artifact (with more info) (compiled contract without deployment)\n  run( // execute deployment scripts\n    tags?: string | string[],\n    options?: {\n      resetMemory?: boolean;\n      deletePreviousDeployments?: boolean;\n      writeDeploymentsToFiles?: boolean;\n      export?: string;\n      exportAll?: string;\n    }\n  ): Promise<{[name: string]: Deployment}>;\n  fixture( // execute deployment as fixture for test // use evm_snapshot to revert back\n    tags?: string | string[],\n    options?: {fallbackToGlobal?: boolean; keepExistingDeployments?: boolean}\n  ): Promise<{[name: string]: Deployment}>;\n  createFixture<T, O>( // execute a function as fixture using evm_snaphost to revert back each time\n    func: FixtureFunc<T, O>,\n    id?: string\n  ): (options?: O) => Promise<T>;\n  log(...args: any[]): void; // log data only ig log enabled (disabled in test fixture)\n\n  execute( // execute function call on contract\n    name: string,\n    options: TxOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<Receipt>;\n  rawTx(tx: SimpleTx): Promise<Receipt>; // execute a simple transaction\n  catchUnknownSigner( // you can wrap other function with this function and it will catch failure due to missing signer with the details of the tx to be executed\n    action: Promise<any> | (() => Promise<any>),\n    options?: {log?: boolean}\n  ): Promise<null | {\n    from: string;\n    to?: string;\n    value?: string;\n    data?: string;\n  }>;\n  read( // make a read-only call to a contract\n    name: string,\n    options: CallOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<any>;\n  read(name: string, methodName: string, ...args: any[]): Promise<any>;\n  // rawCall(to: Address, data: string): Promise<any>; // TODO ?\n}\n```\n\n---\n\n#### `deployments.deploy(<name>, options)`\n\n---\n\nThe `deploy` function, as mentioned above, allows you to deploy a contract and save it under a specific name.\n\nThe deploy function expect 2 parameters: one for the name and one for the options\n\nSee below the full list of fields that the option parameter allows and requires:\n\n```ts\nexport interface DeployOptions = {\n  from: string; // address (or private key) that will perform the transaction. you can use `getNamedAccounts` to retrived the address you want by name.\n  contract?: // this is an optional field. If not specified it defaults to the contract with the same name as the first parameter\n    | string // this field can be either a string for the name of the contract\n    | { // or abi and bytecode\n        abi: ABI;\n        bytecode: string;\n        deployedBytecode?: string;\n      };\n  args?: any[]; // the list of argument for the constructor (or the upgrade function in case of proxy)\n  skipIfAlreadyDeployed?: boolean; // if set it to true, will not attempt to deploy even if the contract deployed under the same name is different\n  log?: boolean; // if true, it will log the result of the deployment (tx hash, address and gas used)\n  linkedData?: any; // This allow to associate any JSON data to the deployment. Useful for merkle tree data for example\n  libraries?: { [libraryName: string]: Address }; // This let you associate libraries to the deployed contract\n  proxy?: boolean | string | ProxyOptions; // This options allow to consider your contract as a proxy (see below for more details)\n\n  // here some common tx options :\n  gasLimit?: string | number | BigNumber;\n  gasPrice?: string | BigNumber;\n  value?: string | BigNumber;\n  nonce?: string | number | BigNumber;\n\n  estimatedGasLimit?: string | number | BigNumber; // to speed up the estimation, it is possible to provide an upper gasLimit\n  estimateGasExtra?: string | number | BigNumber; // this option allow you to add a gas buffer on top of the estimation\n\n  autoMine?: boolean; // this force a evm_mine to be executed. this is useful to speed deployment on test network that allow to specify a block delay (ganache for example). This option basically skip the delay by force mining.\n  deterministicDeployment? boolean | string; // if true, it will deploy the contract at a deterministic address based on bytecode and constructor arguments. The address will be the same across all network. It use create2 opcode for that, if it is a string, the string will be used as the salt.\n  waitConfirmations?: number; // number of the confirmations to wait after the transactions is included in the chain\n};\n```\n\n---\n\n---\n\n## Handling contract using libraries\n\nIn the deploy function, one of the `DeployOptions` field is the `libraries` field. It allows you to associate external contract as libraries at the time of deployment.\n\nFirst, you have deploy the library using the `deploy` function, then when we deploy a contract that needs the linked library, we can pass the deployed library name and address in as an argument to the `libraries` object.\n\nFirst step: deploy the library:\n\n```js\nconst exampleLibrary = await deploy(\"ExampleLibary\", {\n    from: <deployer>\n});\n\n```\n\nExampleLibrary is now deployed to whatever network was chosen (`hardhat deploy --network <networkName>`)\n\nFor example, if we are deploying on Rinkeby, this library will get deployed on rinkeby, and the `exampleLibrary` variable will be a deployment object that contains the abi as well as the deployed address for the contract.\n\nNow that the library is deployed, we can link it in our next deployed contract.\n\n```js\nconst example = await deploy(\"Example\", {\n    from: <deployer>\n    args: [\"example string argument for the 'Example' contract constructor\"],\n    libraries: {\n        ExampleLibrary: exampleLibrary.address\n    }\n});\n\n```\n\nThis `libraries` object takes the name of the library, and its deployed address on the network. Multiple libraries can be passed into the `libraries` object.\n\n---\n\n---\n\n## Exporting Deployments\n\nApart from deployments saved in the `deployments` folder which contains all information available about the contract (compile time data + deployment data), `hardhat-deploy` allows you to export lightweight files.\n\nThese can be used for example to power your frontend with contract's address and abi.\n\nThis come into 2 flavors.\n\nThe first one is exported via the `--export <file>` option and follow the following format :\n\n```ts\nexport interface Export {\n  chainId: string;\n  name: string;\n  contracts: {[name: string]: ContractExport};\n}\n```\n\nwhere name is the name of the network configuration chosen (see hardhat option `--network`)\n\nThe second one is exported via the `--export-all <file>` option and follow the following format :\n\n```ts\nexport type MultiExport = {\n  [chainId: string]: Export[];\n};\n```\n\nAs you see the second format include the previous. While in most case you'll need the single export where your application will support only one network, there are case where your app would want to support multiple networks at nonce. This second format allow for that.\n\nFurthermore as hardhat support multiple network configuration for the same network (rinkeby, mainnet...), the export-all format will contains each of them grouped by their chainId.\n\n\nNote: from v0.10.4 the old multi-export down is no more:\n\n```\nexport type MultiExport = {\n  [chainId: string]: {[name: string]: Export};\n};\n```\n\n---\n\n---\n\n## Deploying and Upgrading Proxies\n\nAs mentioned above, the deploy function can also deploy a contract through a proxy. It can be done without modification of the contract as long as its number of constructor arguments matches the proxy initialization/update function.\n\nThe default Proxy is both ERC-1967 and ERC-173 Compliant, but other proxy can be specified, like openzeppelin transparent proxies.\n\nCode for the default Proxy can be found [here](solc_0.7/proxy/EIP173Proxy.sol).\n\nTo perform such proxy deployment, you just need to invoke the deploy function with the following options : `{..., proxy: true}`\n\nSee example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: true,\n  });\n};\n```\n\nYou can also set it to `proxy: \"<upgradeMethodName>\"` in which case the function `<upgradeMethodName>` will be executed upon upgrade.\nthe `args` field will be then used for that function instead of the contructor. It is also possible to then have a constructor with the same arguments and have the proxy be disabled. It can be useful if you want to have your contract as upgradeable in a test network but be non-upgradeable on the mainnet.\n\nSee example :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  network,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: network.live ? false : 'postUpgrade',\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nThe proxy option can also be an object which can set the specific owner that the proxy is going to be managed by.\n\nSee example:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: {\n      owner: greeterOwner,\n      methodName: 'postUpgrade',\n    },\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nNote that for the second invokation, this deployment will not be executed from the specified `from: deployer` as otherwise these tx will always fails. It will instead be automatically executed from the proxy's current owner (in that case : `greeterOwner`)\n\nNow, it is likely you do not want to locally handle the private key / mnemonic of the account that manage the proxy or it could even be that the `greeterOwner` in question is a multi sig. As such that second invocation will throw an error as it cannot find a local signer for it.\n\nThe error will output the necessary information to upgrade the contract but `hardhat-deploy` comes also with a utility function for such case: `deployments.catchUnknwonSigner` which will catch the error and output to the console the necessary information while continuing to next step.\n\nHere is the full example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy, catchUnknownSigner} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await catchUnknownSigner(\n    deploy('Greeter', {\n      from: deployer,\n      proxy: {\n        owner: greeterOwner,\n        methodName: 'postUpgrade',\n      },\n      args: ['arg1', 2, 3],\n    })\n  );\n  // you could pause the deployment here and wait for input to continue\n};\n```\n\nThe full proxy options is as follow:\n\n```ts\ntype ProxyOptionsBase = {\n  owner?: Address; // this set the owner of the proxy. further upgrade will need to be executed from that owner\n  upgradeIndex?: number; // allow you to breakdown your upgrades into separate deploy scriot, each with their own index. A deploy call with a specific upgradeIndex will be executed only once, only if the current upgradeIndex is one less.\n  proxyContract?: // default to \"EIP173Proxy\". See below for more details\n  string | ArtifactData;\n  viaAdminContract?: // allow to specify a contract that act as a middle man to perform upgrades. Useful and Recommended for Transparent Proxies\n  | string\n    | {\n        name: string;\n        artifact?: string | ArtifactData;\n      };\n};\n\nexport type ProxyOptions =\n  | (ProxyOptionsBase & {\n      methodName?: string; // method to be executed when the proxy is deployed for the first time or when the implementation is modified. Use the deployOptions args field for arguments\n    })\n  | (ProxyOptionsBase & {\n      execute?:\n        | {\n            methodName: string; // method to be executed when the proxy is deployed for the first time or when the implementation is modified.\n            args: any[];\n          }\n        | {\n            init: {\n              methodName: string; // method to be executed when the proxy is deployed\n              args: any[];\n            };\n            onUpgrade?: {\n              methodName: string; // method to be executed when the proxy is upgraded (not first deployment)\n              args: any[];\n            };\n          };\n    });\n```\n\nThe `proxyContract` field allow you to specify your own Proxy contract. If it is a string, it will first attempt to get an artifact with that name. If not found it will fallback on the following if\n\nit matches:\n\n- `EIP173Proxy`: use the default Proxy that is EIP-173 compliant\n\n- `EIP173ProxyWithReceive`: Same as above except that the proxy contains a receive hook to accept empty ETH payment.\n\n- `OpenZeppelinTransparentProxy`: Use Openzeppelin Transparent Proxy (copied from openzeppelin repo, see code [here](solc_0.7/openzeppelin/proxy/TransparentUpgradeableProxy.sol))\n  When this option is chosen, the `DefaultProxyAdmin` is also used as admin since Transparent Proxy kind of need an intermediarry contract for administration. This can be configured via the `viaAdminContract` option. Note that the DefaultProxyAdmin is slightly different than the one used by openzeppelin as it allow you to set a different owner than msg.sender on first deploy, something openzeppelin version do not allow, see : https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2639\n\n- `OptimizedTransparentProxy`: This contract is similar to above, except that it is optimized to not require storage read for the admin on every call.\n\n## Builtin-In Support For Diamonds (EIP2535)\n\nThe deployments field also expose the diamond field: `hre.deployments.diamond` that let you deploy [Diamonds](https://eips.ethereum.org/EIPS/eip-2535) in an easy way.\n\nInstead of specifying the facets to cut out or cut in, which the diamond contract expects, you specify the facets you want to end up having on the deployed contract.\n\n`diamond.deploy` expect the facet as names. The names represent contract to be deployed as facet. In future version you ll be able to specify deployed contract or artifact object as facet.\n\nTo deploy a contract with 3 facet you can do as follow :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: deployer,\n    owner: diamondAdmin,\n    facets: ['Facet1', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nif you then later execute the following script:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: diamondAdmin, // this need to be the diamondAdmin for upgrade\n    owner: diamondAdmin,\n    facets: ['NewFacet', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nThen the NewFacet will be deployed automatically if needed and then the diamondCut will cut Facet1 out and add NewFacet.\n\nNote that if the code for Facet2 and Facet3 changes, they will also be redeployed automatically and the diamondCuts will replace the existing facets with these new ones.\n\nNote that The Diamond contract's code is part of `hardhat-deploy` and contains 3 built-in facet that can be removed manually if desired.\nThese facets are used for ownership, diamondCut and diamond loupe.\n\nThe implementation is the [reference implementation by Nick Mudge](https://github.com/mudgen/diamond-3)\n\nLike normal proxies you can also execute a function at the time of an upgrade.\n\nThis is done by specifying the execute field in the diamond deploy options :\n\n```js\ndiamond.deploy('ADiamondContract', {\n  from: deployer,\n  owner: diamondAdmin,\n  facets: ['NewFacet', 'Facet2', 'Facet3'],\n  execute: {\n    methodName: 'postUpgrade',\n    args: ['one', 2, '0x3'],\n  },\n});\n```\n\nSince the diamond standard has no builtin mechanism to make the deployment of Diamond with function execution, the Diamond when deployed is actually deployed through a special contract, the `Diamantaire` (see code [here](solc_0.7/diamond/Diamantaire.sol)) that act as factory to build Diamond. It uses deterministic deployment for that so, it is transparently managed by `hardhat-deploy`. It also embed the implementation of the builtin facet, removing the need to have different instances of each live.\n\n<!-- The Diamantaire also support the deterministic deployment of Diamonds.\nAn extra field can be passed to the Diamond deployment options : `deterministicSalt`. It has to be a non-zero 32bytes string (in hex format).\nNote that if you want to deploy 2 diamonds with same owner, you'll need 2 different deterministicSalt for them to be 2 separate contracts. -->\n\n## Testing Deployed Contracts\n\nYou can continue using the usual test task:\n\n`hardhat test`\n\nTests can use the `hre.deployments.fixture` function to run the deployment and snapshot it so that tests don't need to perform all the deployment transactions every time. They can simply reuse the snapshot for every test (this leverages `evm_snapshot` and `evm_revert` provided by both `hardhat` and `ganache`). You can for example set them in a `beforeEach`.\n\nHere is an example of a test :\n\n```js\nconst {deployments} = require('hardhat');\n\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    await deployments.fixture(['Token']);\n    const Token = await deployments.get('Token'); // Token is available because the fixture was executed\n    console.log(Token.address);\n    const ERC721BidSale = await deployments.get('ERC721BidSale');\n    console.log({ERC721BidSale});\n  });\n});\n```\n\nTests can also leverage named accounts for clearer test. Combined with `hardhat-deploy-ethers` plugin, you can write succint test :\n\n```js\nconst {ethers, getNamedAccounts} = require('hardhat');\n\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    await deployments.fixture(['Token']);\n    const {tokenOwner} = await getNamedAccounts();\n    const TokenContract = await ethers.getContract('Token', tokenOwner);\n    await TokenContract.mint(2).then((tx) => tx.wait());\n  });\n});\n```\n\n---\n\n### Creating Fixtures\n\nFurthermore, tests can easily create efficient fixture using `deployments.createFixture`\n\nSee example :\n\n```js\nconst setupTest = deployments.createFixture(\n  async ({deployments, getNamedAccounts, ethers}, options) => {\n    await deployments.fixture(); // ensure you start from a fresh deployments\n    const {tokenOwner} = await getNamedAccounts();\n    const TokenContract = await ethers.getContract('Token', tokenOwner);\n    await TokenContract.mint(10).then((tx) => tx.wait()); //this mint is executed once and then `createFixture` will ensure it is snapshotted\n    return {\n      tokenOwner: {\n        address: tokenOwner,\n        TokenContract,\n      },\n    };\n  }\n);\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    const {tokenOwner} = await setupTest();\n    await tokenOwner.TokenContract.mint(2);\n  });\n});\n```\n\nWhile this example is trivial, some fixture can requires several transaction and the ability to snapshot them automatically speed up the tests greatly.\n\n---\n\n---\n\n## More Information On Hardhat Tasks\n\n---\n\n### **1. node task**\n\nas mentioned above, the node task is slighly modified and augmented with various flags and options\n\n`hardhat node`\n\nIn particular it adds an argument `--export` that allows you to specify a destination file where the info about the contracts deployed is written.\nYour webapp can then access all contracts information.\n\n---\n\n### **2. test task**\n\n`hardhat test`\n\nthe test task is augmented with one flag argument `--deploy-fixture` that allows to run all deployments in a fixture snapshot before executing the tests. This can speed up the tests that use specific tags as the global fixture take precedence (unless specified).\n\nIn other word tests can use `deployments.fixture(<specific tag>)` where specific tag only deploys the minimal contracts for tests, while still benefiting from global deployment snapshot if used.\n\nIf a test needs the deployments to only include the specific deployment specified by the tag, it can use the following :\n\n```js\ndeployments.fixture('<specific tag>', {fallbackToGlobal: false});\n```\n\nDue to how snapshot/revert works in hardhat, this means that these tests will not benefit from the global fixture snapshot and will have to deploy their contracts as part of the fixture call. This is automatic but means that these tests will run slower.\n\n---\n\n### **3. run task**\n\n`hardhat --network <networkName> run <script>`\n\nThe run task act as before but thanks to the `hre.deployments` field it can access deployed contract :\n\n```js\nconst hre = require('hardhat');\nconst {deployments, getNamedAccounts} = hre;\n\n(async () => {\n  console.log(await deployments.all());\n  console.log({namedAccounts: await getNamedAccounts()});\n})();\n```\n\nYou can also run it directly from the command line as usual.\n\n`HARDHAT_NETWORK=rinkeby node <script>` is the equivalent except it does not load the hardhat environment twice (which the run task does)\n\n---\n\n### **4. console task**\n\n`hardhat console`\n\nThe same applies to the `console` task.\n\n---\n\n## Deploy Scripts: Tags And Dependencies\n\n---\n\nIt is possible to execute only specific parts of the deployments with `hardhat deploy --tags <tags>`\n\nTags represent what the deploy script acts on. In general it will be a single string value, the name of the contract it deploys or modifies.\n\nThen if another deploy script has such tag as a dependency, then when this latter deploy script has a specific tag and that tag is requested, the dependency will be executed first.\n\nHere is an example of two deploy scripts :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const deployResult = await deploy('Token', {\n    from: deployer,\n    args: ['hello', 100],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Token deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Token'];\n```\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const Token = await deployments.get('Token');\n  const deployResult = await deploy('Sale', {\n    from: deployer,\n    contract: 'ERC721BidSale',\n    args: [Token.address, 1, 3600],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Sale deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.dependencies = ['Token']; // this ensure the Token script above is executed first, so `deployments.get('Token')` succeeds\n```\n\nAs you can see the second one depends on the first. This is because the second script depends on a tag that the first script registers as using.\n\nWith that when `hardhat deploy --tags Sale` is executed\n\nthen both scripts will be run, ensuring Sale is ready.\n\nYou can also define the script to run after another script is run by setting `runAtTheEnd` to be true. For example:\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, execute, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer, admin} = namedAccounts;\n  await execute('Sale', {from: deployer}, 'setAdmin', admin);\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.runAtTheEnd = true;\n```\n\nTags can also be used in test with `deployments.fixture`. This allow you to test a subset of the deploy script.\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.0-next.2","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-ALphAaLuqR3elDs+G7FnUo1REAjvZWEObWyyPhuaHA2m9A6iqwzSgooAIfNqvgv9vl1opAVv5IRlis4WapOiWw==","shasum":"0891f211be979e824b1f7686d2eae65152d90b7f","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.0-next.2.tgz","fileCount":146,"unpackedSize":11137796,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJh+W7UCRA9TVsSAnZWagAAkAoP/0e6v33iV+XSuf+7Ze5f\nfRVR3imXn1W9QXSf1IZRdIcTBKhOd4k+sj5zQRHUVZhw+QjBSuBJajcliH0q\noFbi3i5LQDD8/+fj0dWmrxSVeQS1t/ZTisq8tCpaYvCW38JPoTp9fp9uovO0\nYie0nfU02phhVEd5e5AILI+2dwHs2QfIx/GPyIsTZMtLKSIwxertrNOOg89A\naEg4wcnU0FNVZbu3nnjuFRJvB6QRHsON76tGKBqe/JRcZbjQH1Z9+xuov7Gc\ndYi0+VdmV77ZIGoQmugWcFMZ6KCo9ecr6YZ5oFZ5cPBHuP6F9nzswyZKSSXw\nhtLbuAxVdTYgeSdamMCR2bqOhA9i6kCu7FnM03eqevH+reh5lt75J1fqaTm0\nRug1ga530kmC5U6d4reZbFsBLZVJEPyMbSwqphlIncBORWsHrXYBv9m/cEKN\nnuitlzqTEl4Oqk4etL4VJE5ewqwTX9PZCOaIgXc2SRFL8vZ3JYjLQgc7Xk77\necHieIYnGG7T3LCRwjErWSLTy4bxH0hpb6xNeOUhpBed2hzS4Q1aHPKtaLaz\n5tJs80F5i3LqSZrinLc9/deSK47N5JgMKn+jrDzPF7nPKcz6HsCyETtnf6DP\nDogZWo3kUUJlLustD0yUCNumM3rtoy3ivGzR1X1xOeNYu87gDJ99jegsQkvh\neRzY\r\n=ElCg\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCMYNAGlAwHZ8k+QXkfbOLcFnrUxs17A0CVjTYTKUyhugIhAL8R4cfgNZUhBeCFZQmIuDCq50jz84kY+H8n8lYkCtls"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.0-next.2_1643736788244_0.7890870446479632"},"_hasShrinkwrap":false},"0.10.5":{"name":"hardhat-deploy","version":"0.10.5","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.8","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.6.8"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"f0cce12df1c4061aa0a0b57f52488c263b296ab5","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.10.5","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-qBfcOfROd/WPbimxX0ZkcDyohD5DK2HrROIgRABiDvsyl8DjN7z8SRvoAGjBdUA34ov/pN3zXW1MBVGil3t7pg==","shasum":"d3f8ea85220f201110ce9205a601f27b369cc918","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.10.5.tgz","fileCount":120,"unpackedSize":7446225,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJiARb/CRA9TVsSAnZWagAAgKQP/0W/vBGI+RGayxfPH/UL\nKjX2K8QROIPdb29W5yqNU2ww/W8+Yqk+bkVaBVDsPhCr0ptEQKgCvPPO5kXQ\naRHx92DrGCvO+GAokuAqJ638ds2aFsYwH+joIpCqJQMOVwS9NIw6t/eKiGBs\ncaNAS6LupSaQSIiIYoQ95rvTVdNxUVQgtLXTRkVUYFdTJD/D2S37JcXTfaeQ\nDTSL6QXes2F05EWSDiKI8PQO4ES+4wSIdtRuUnMW+xDiXBpXbPCey5nkPgF6\nUAg0yMV/bQ+WBf4CV6UuhqfHc/vJl/vOUGYVrPqiS87job8ZChB6Hy96+fVR\nv0sDlFYZBgcSsO8+nYvBkyxNgFYdvl2VVy257dpkrDMWmVdA8Q7yX+8UrVZt\nRxBQnLIbJgFqjqXnjXPutoND43WvltNo+4wk1I14+PQlGEtNb05fcuUj47Kl\nDVLSwVH2JJbTSEtCAJDFAa2l3C5kQ9UqtdA+N5dFRQVuuzurJsrUFyk/6LC2\n/5kXxMi719M9yu/2/yk3y19P8adflyk3XQBEFEZEhTQT3AqMPOxIlJ9MhG5X\nnT9qcZIMo7Z+b0tCX3Y+INvR0X9KTpr7qmiCf5k0oDxHSfRurOj6VegmIwPc\nXPiwbntkU8ArtNHsaL8maRuP9/PtyuEWQo0aS5Qi2hmeqVNZXtgRnSKa2CPG\n1AXw\r\n=TPHf\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCfOXqqrFNThHXL4AUXwrLD2gLgXSryzn61M5ks4v4FKwIhAKWMtKtg8vJfRWbjeavb1eDrQeMhLzcFgYkuwlq/wOAf"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.10.5_1644238591527_0.6690176199935798"},"_hasShrinkwrap":false},"0.11.0-next.3":{"name":"hardhat-deploy","version":"0.11.0-next.3","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.8","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.6.8"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"readme":"<h1> hardhat-deploy</h1>\n\n_A [Hardhat](https://hardhat.org) Plugin For Replicable Deployments And Easy Testing_\n\n> **A complete dev template using hardhat-deploy is available here** : https://github.com/wighawag/template-ethereum-contracts\n> It also contains various branches examplifying the capability of hardhat-deploy. Check it out.\n\n- [What is it for ?](#what-is-it-for-)\n- [hardhat-deploy in a nutshell](#hardhat-deploy-in-a-nutshell)\n- [Installation](#installation)\n  - [npm install hardhat-deploy](#npm-install-hardhat-deploy)\n  - [TypeScript support](#typescript-support)\n  - [Migrating existing deployment to hardhat-deploy](#migrating-existing-deployment-to-hardhat-deploy)\n- [Hardhat Tasks Available/Updated](#hardhat-tasks-availableupdated)\n  - [1. hardhat deploy](#1-hardhat-deploy)\n    - [**Options**](#options)\n    - [**Flags**](#flags)\n  - [2. hardhat node](#2-hardhat-node)\n    - [**Options**](#options-1)\n    - [**Flags**](#flags-1)\n  - [3. hardhat test](#3-hardhat-test)\n  - [4. hardhat etherscan-verify](#4-hardhat-etherscan-verify)\n    - [**Options**](#options-2)\n  - [5. hardhat sourcify](#5-hardhat-sourcify)\n    - [**Options**](#options-3)\n  - [6. hardhat export](#6-hardhat-export)\n    - [**Options**](#options-4)\n- [Hardhat Environment Extensions](#hardhat-environment-extensions)\n- [Configuration](#configuration)\n  - [**1. namedAccounts (ability to name addresses)**](#1-namedaccounts-ability-to-name-addresses)\n  - [**2. extra hardhat.config networks' options**](#2-extra-hardhatconfig-networks-options)\n    - [`live`](#live)\n    - [`saveDeployments`](#savedeployments)\n    - [`tags`](#tags)\n    - [`deploy`](#deploy)\n    - [`companionNetworks`](#companionnetworks)\n  - [**3. extra hardhat.config paths' options**](#3-extra-hardhatconfig-paths-options)\n  - [**4. deterministicDeployment (ability to specify a deployment factory)**](#4-deterministicdeployment-ability-to-specify-a-deployment-factory)\n  - [Importing deployment from other projects (with truffle support)](#importing-deployment-from-other-projects-with-truffle-support)\n  - [Access to Artifacts (non-deployed contract code and abi)](#access-to-artifacts-non-deployed-contract-code-and-abi)\n- [How to Deploy Contracts](#how-to-deploy-contracts)\n  - [The `deploy` Task](#the-deploy-task)\n  - [Deploy Scripts](#deploy-scripts)\n    - [An example of a deploy script :](#an-example-of-a-deploy-script-)\n  - [The `deployments` field](#the-deployments-field)\n    - [`deployments.deploy(<name>, options)`](#deploymentsdeployname-options)\n- [Handling contract using libraries](#handling-contract-using-libraries)\n- [Exporting Deployments](#exporting-deployments)\n- [Deploying and Upgrading Proxies](#deploying-and-upgrading-proxies)\n- [Builtin-In Support For Diamonds (EIP2535)](#builtin-in-support-for-diamonds-eip2535)\n- [Testing Deployed Contracts](#testing-deployed-contracts)\n  - [Creating Fixtures](#creating-fixtures)\n- [More Information On Hardhat Tasks](#more-information-on-hardhat-tasks)\n  - [**1. node task**](#1-node-task)\n  - [**2. test task**](#2-test-task)\n  - [**3. run task**](#3-run-task)\n  - [**4. console task**](#4-console-task)\n- [Deploy Scripts: Tags And Dependencies](#deploy-scripts-tags-and-dependencies)\n\n## What is it for ?\n\nThis [hardhat](https://hardhat.org) plugin adds a mechanism to deploy contracts to any network, keeping track of them and replicating the same environment for testing.\n\nIt also adds a mechanism to associate names to addresses, so test and deployment scripts can be reconfigured by simply changing the address a name points to, allowing different configurations per network. This also results in much clearer tests and deployment scripts (no more `accounts[0]` in your code).\n\nThis plugin contains a lot more features too, all geared toward a better developer experience :\n\n- chain configuration export\n- listing deployed contracts' addresses and their abis (useful for webapps)\n- library linking at time of deployment.\n- deterministic deployment across networks.\n- support for specific deploy script per network (L1 vs L2 for example)\n- ability to access deployment from \"companion\" networks\n- deployment dependency system (allowing you to only deploy what is needed).\n- deployment retrying (by saving pending tx): so you can feel confident when making a deployment that you can always recover.\n- deployments as test fixture using `evm_snapshot` to speed up testing.\n- ability to create your own test fixture that automatically benefits from `evm_snapshot`'s tests speed-up boost\n- combined with [hardhat-deploy-ethers](https://github.com/wighawag/hardhat-deploy-ethers) it has the ability to get ethers contract instance by name (like `await ethers.getContract(\"ContractName\")`).\n- importing artifact from external sources (like npm packages), including [truffle](https://www.trufflesuite.com/truffle) support.\n- importing deployments from external sources (like npm packages)\n- ability to log information in `deploy` mode only (while in test the console remains clean).\n- contains helpers to read and execute transaction on deployed contract referring to them by name.\n- These helpers contains options to auto mine on dev network (to speed up test deployments).\n- save metadata of deployed contract so they can always be fully verified, via [sourcify](https://sourcify.dev) or [etherscan](https://etherscan.io).\n- ability to submit contract source to etherscan and sourcify for verification at any time. (Because **hardhat-deploy** will save all the necessary info, it can be executed at any time.)\n- support harhdat's fork feature so deployment can be accessed even when run through fork.\n- named accounts are automatically impersonnated too, so you can perform tx as if you had their private key.\n- proxy deployment with ability to upgrade them transparently, only if code changes.\n- this include support for [openzeppelin](https://openzeppelin.com) transparent proxies\n- diamond deployment with facets, allowing you to focus on what the new version will be. It will generate the diamondCut necessary to reach the new state.\n- watch and deploy: **hardhat-deploy** can watch both your deploy script and contract code and redeploy on changes.\n- HCR (Hot Contract Replacement): the watch feature combined with proxy or diamond, gives you an experience akin to frontend Hot Module Replacement: once your contract changes, the deployment is executed and your contract retains the same address and same state, allowing you to tweak your contracts while debugging your front-end.\n\n## hardhat-deploy in a nutshell\n\nBefore going into the details, here is a very simple summary of the basic feature of **hardhat-deploy**.\n\n**hardhat-deploy** allows you to write [`deploy scripts`](#deploy-scripts) in the `deploy` folder. Each of these files that look as follows will be executed in turn when you execute the following task: `hardhat --network <networkName> deploy`\n\n```js\n// deploy/00_deploy_my_contract.js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('MyContract', {\n    from: deployer,\n    args: ['Hello'],\n    log: true,\n  });\n};\nmodule.exports.tags = ['MyContract'];\n```\n\nFurthermore you can also ensure these scripts are executed in test too by calling `await deployments.fixture(['MyContract'])` in your test.\nThis is optimized, so if multiple tests use the same contract, the deployment will be executed once and each test will start with the exact same state.\n\nThis is a huge benefit for testing since you are not required to replicate the deployment procedure in your tests. The tag feature (as seen in the script above) and [dependencies](#deploy-scripts-tags-and-dependencies) will also make your life easier when writing complex deployment procedures.\n\nYou can even group deploy scripts in different sub folder and ensure they are executed in their logical order.\n\nFurthermore hardhat-deploy can also support a multi-chain settings like L1, L2 with multiple deploy folder specific to each network.\n\n**All of this can also be bundled in a npm package so user of hardhat-deploy can reuse your deployment procedure and get started integrating with your project locally.**\n\nThere is a tutorial covering the basics here : https://github.com/wighawag/tutorial-hardhat-deploy\n\n## Installation\n\n### npm install hardhat-deploy\n\n```bash\nnpm install -D hardhat-deploy\n```\n\nAnd add the following statement to your `hardhat.config.js`:\n\n```js\nrequire('hardhat-deploy');\n```\n\nif you use `ethers.js` we recommend you also install `hardhat-deploy-ethers` which add extra features to access deployments as ethers contract.\n\nSince `hardhat-deploy-ethers` is a fork of `@nomiclabs/hardhat-ethers` and that other plugin might have an hardcoded dependency on `@nomiclabs/hardhat-ethers` the best way to install `hardhat-deploy-ethers` and ensure compatibility is the following:\n\n```bash\nnpm install --save-dev  @nomiclabs/hardhat-ethers@npm:hardhat-deploy-ethers ethers\n```\n\nWhich means you then need to do `require(\"@nomiclabs/hardhat-ethers\")` instead of `require(\"hardhat-deploy-ethers\")` in your `hardhat.config.js` file.\n\nMore details on `hardhat-deploy-ethers` repo : https://github.com/wighawag/hardhat-deploy-ethers#readme\n\n### TypeScript support\n\nWith hardhat the tsconfig.json is optional.\n\nBut if you add folders to the `include` field in `tsconfig.json`, you ll also need to include `hardhat.config.ts` like :\n\n`include\": [\"./hardhat.config.ts\", \"./scripts\", \"./deploy\", \"./test\"]`\n\nfor deploy script (see below) you can write them this way to benefit from typing :\n\n```ts\nimport {HardhatRuntimeEnvironment} from 'hardhat/types';\nimport {DeployFunction} from 'hardhat-deploy/types';\n\nconst func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {\n  // code here\n};\nexport default func;\n```\n\nSee a template that uses **hardhat-deploy** here : https://github.com/wighawag/template-ethereum-contracts\n\nThis repo has also some examples branch that exemplify specific features, like the forking testing here : https://github.com/wighawag/template-ethereum-contracts/tree/examples/fork-test\n\n### Migrating existing deployment to hardhat-deploy\n\n> Only needed for existing project that already deployed contracts and has the deployment information available **(at minimum, address and abi)**\n\nYou might want to switch your current deployment process to use **hardhat-deploy**. In that case you probably have some deployments saved elsewhere.\n\nIn order to port them to **hardhat-deploy**, you'll need to create one `.json` file per contract in the `deployments/<network>` folder (configurable via [paths config](#extra-paths-config)).\n\nThe network folder is simply the hardhat network name (as configured in hardhat.config.js) (accessible at runtime via `hre.network.name`).\nSuch folder need to have a file named `.chainId` containing the chainId as decimal.\n\nFor example for network named \"rinkeby\" (for the corresponding network) the file `deployments/rinkeby/.chainId` would be\n\n```\n4\n```\n\nNote, prior to hardhat 0.6 the chainId was appended to the folder name (expect for some known network name). This has changed and upgrading to 0.6 will require you to change the folder name and add the '.chainId' file.\n\nEach contract file must follow this type (as defined in [types.ts](types.ts)) :\n\n```ts\nexport interface Deployment {\n  address: Address;\n  abi: ABI;\n  receipt?: Receipt;\n  transactionHash?: string;\n  history?: Deployment[];\n  numDeployments?: number;\n  implementation?: string;\n  args?: any[];\n  linkedData?: any;\n  solcInputHash?: string;\n  metadata?: string;\n  bytecode?: string;\n  deployedBytecode?: string;\n  libraries?: Libraries;\n  userdoc?: any;\n  devdoc?: any;\n  methodIdentifiers?: any;\n  diamondCut?: FacetCut[];\n  facets?: Facet[];\n  storageLayout?: any;\n  gasEstimates?: any;\n}\n```\n\nAs you can see, only abi and address are mandatory. But having the other fields allow more feature. For example, metadata and args allow you to benefit from contract code verification.\n\nFor Receipt, the following type is expected:\n\n```ts\nexport type Receipt = {\n  from: string;\n  transactionHash: string;\n  blockHash: string;\n  blockNumber: number;\n  transactionIndex: number;\n  cumulativeGasUsed: string;\n  gasUsed: string;\n  contractAddress?: string;\n  to?: string;\n  logs?: Log[];\n  events?: any[];\n  logsBloom?: string;\n  byzantium?: boolean;\n  status?: number;\n  confirmations?: number;\n};\n```\n\nHere is an example:\n\nLet's say you have:\n\n- 2 Contract named Greeter and Registry deployed on rinkeby\n- 1 contract named Greeter on mainnet\n- 2 Contract named Greeter and Registry deployed on a network named rinkeby2\n\nYou would get the following folder structure:\n\n```\ndeployments/\n  mainnet/\n    .chainId\n    Greeter.json\n  rinkeby/\n    .chainId\n    Greeter.json\n    Registry.json\n  rinkeby2/\n    .chainId\n    Greeter.json\n    Registry.json\n```\n\nThe reason why **hardhat-deploy** save chainId in the `.chainId` file is both for\n\n- safety: so that if you were to change the network name to point to a different chain, it would not attempt to read the wrong folder and assume that a contract has been deployed while it has not.\n- ability to know the chainId without requring to be connected to a node (and so not dependent on hardhat.config.js settings). Useful for `export` task.\n\n---\n\n## Hardhat Tasks Available/Updated\n\nhardhat deploy add several task to hardhat. It also modify existing one, adding new options and new behavior. All of these are described here:\n\n---\n\n### 1. hardhat deploy\n\n---\n\nThis plugin adds the _deploy_ task to Hardhat.\n\nThis task will execute the scripts in the `deploy` folder and save the contract deployments to disk. These deployments are supposed to be saved for example in a git repository. This way they can be accessed later. But you are free to save them elsewhere and get them back via your mechanism of choice.\n\nWith the deployment saved, it allows you to deploy a contract only if changes were made.\n\nDeploy scripts (also called Deploy functions) can also perform aribtrary logic.\n\nFor further details on how to use it and write deploy script, see [section](#deploy-scripts) below.\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployments, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice (in wei) to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--reset`: This flag resets the deployments from scratch. Previously deployed contract are not considered and deleted from disk.\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n---\n\n### 2. hardhat node\n\n---\n\nThis plugin modify the _node_ task so that it also execute the deployment script before exposing the server http RPC interface\n\nIt add similar options than the `deploy` task :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--no-reset`: This flag prevent the reseting of the existing deployments. This is usually not desired when running the `node` task as a network is created from scratch and previous deployemnt are irrelevant.\n\n`--show-accounts`: this flag will output the account private keys\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n`--no-deploy` that discard all other options to revert to normal `hardhat node` behavior without any deployment being performed.\n\n> :warning: Note that the deployments are saved as if the network name is `localhost`. This is because `hardhat node` is expected to be used as localhost: You can for example execute `hardhat --network localhost console` after `node` is running. Doing `hardhat --network hardhat console` would indeed not do anything useful. It still take the configuration from `hardhat` in the hardhat.config.js file though.\n\n---\n\n### 3. hardhat test\n\n---\n\nThis plugin adds a flag argument `--deploy-fixture` to the _test_ task which if enabled will run the global deployments fixture before the tests and snapshots it. This will generaly speed up the tests as further test will be able to revert back to the full deployment.\n\n> :warning: Note though that if your test behave differently whether that option is on or not, this most likely mean that your deploy scripts' tags and dependencies are not configured correctly. This is because the global fixture will ensure all contract are deployed while test will usually (for efficiency) ask for a particular tag.\n\n---\n\n### 4. hardhat etherscan-verify\n\n---\n\nThis plugin adds the _etherscan-verify_ task to Hardhat.\n\nThis task will submit the contract source and other info of all deployed contracts to allow etherscan to verify and record the sources.\n\nInstead of using the full solc input, this task will first attempt to send the minimal sources from the metadata.\nBut Etherscan sometime fails due to a bug in solidity compiler (<https://github.com/ethereum/solidity/issues/9573>). As such this task can fallback on full solc input (see option --solc-input). Note that if your contract was deployed with a previous version of **hardhat-deploy**, it might not contains the full information. The issue seems to be fully resolved since solc version 0.8.\n\nThis task will also attempt to automatically find the SPDX license in the source.\n\nTo execute that task, you need to specifiy the network to run against :\n\n```bash\nhardhat --network mainnet etherscan-verify [--api-key <apikey>] [--apiurl <url>]\n```\n\n#### **Options**\n\nNote that harhdat-deploy now use a different config format to not conflict with `hardhat-etherscan`\n\n`--api-key <api key>`: let you specify your etherscan api key. Alternatively, you can provide it via the env variable `ETHERSCAN_API_KEY` or through the hardhat.config.ts verify field:\n\n```js\n{\n  ...\n  verify: {\n    etherscan: {\n      apiKey: '<API key>'\n    }\n  }\n}\n```\n\n`--api-url <url>`: let you specify your etherscan url to submit the source to. Can also be configured per network in `hardhat.config.js`:\n\n```js\n{\n  ...\n  networks: {\n    mynetwork: {\n      ...\n      verify: {\n        etherscan: {\n          apiUrl: 'http://mynetwork.xyz'\n        }\n      }\n    }\n  }\n}\n```\n\n`--license <SPDX license id>`: SPDX license (useful if SPDX is not listed in the sources), need to be supported by etherscan: https://etherscan.io/contract-license-types\n\n`--force-license`: if set, will force the use of the license specified by --license option, ignoring the one in the source (useful for license not supported by etherscan)\n\n`--solc-input`: fallback on solc-input id needed (useful when etherscan fails on the minimum sources, see https://github.com/ethereum/solidity/issues/9573)\n\n`--sleep`: sleep 500ms between each verification, so API rate limit is not exceeded\n\n---\n\n### 5. hardhat sourcify\n\n---\n\nThis plugin adds the _sourcify_ task to Hardhat.\n\nSimilar to `hardhat etherscan-verify` this task will submit the contract source and other info of all deployed contracts to sourcify.\n\n```bash\nhardhat --network mainnet sourcify\n```\n\nLater this task might instead pin the metadata to ipfs, so sourcify can automatically verify them.\n\n#### **Options**\n\n`--endpoint <endpoint>`: specify the sourcify endpoint, default to https://sourcify.dev/server/\n\n`--write-failing-metadata`: if set and the sourcify task fails to verify, the metadata file will be written to disk, so you can more easily figure out what has gone wrong.\n\n---\n\n### 6. hardhat export\n\n---\n\nThis plugin adds the _export_ task to Hardhat.\n\nThis task will export the contract deployed (saved in `deployments` folder) to a file with a simple format containing only contract addresses and abi, useful for web apps.\n\nOne of the following options need to be set for this task to have any effects :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\nThis last option has some limitations, when combined with the use of external deployments (see [Configuration](#configuration)). If such external deployments were using older version of **hardhat-deploy** or truffle, the chainId might be missing. In order for these to be exported, the hardhat network config need to explicity state the chainId in the `networks` config of `hardhat.config.js`.\n\nWith both `--export` and `--export-all`, using the special `<filepath>` value of `-` will output to `STDOUT` rather than writing a normal file.\n\n---\n\n---\n\n## Hardhat Environment Extensions\n\nThis plugin extends the Hardhat Runtime Environment by adding 4 fields:\n\n- `getNamedAccounts: () => Promise<{ [name: string]: string }>`: a function returning an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [Configuration](#configuration)).\n\n- `getUnnamedAccounts: () => Promise<string[]}>`: accounts which has no names, useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`: contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId(): Promise<string>`: offer an easy way to fetch the current chainId.\n\n---\n\n---\n\n## Configuration\n\n---\n\n### **1. namedAccounts (ability to name addresses)**\n\n---\n\nThis plugin extends the `HardhatConfig`'s object with an optional `namedAccounts` field.\n\n`namedAccounts` allows you to associate names to addresses and have them configured per chain.\nThis allows you to have meaningful names in your tests while the addresses match to multi sig in real network for example.\n\n```js\n{\n    namedAccounts: {\n        deployer: {\n            default: 0, // here this will by default take the first account as deployer\n            1: 0, // similarly on mainnet it will take the first account as deployer. Note though that depending on how hardhat network are configured, the account 0 on one network can be different than on another\n            4: '0xA296a3d5F026953e17F472B497eC29a5631FB51B', // but for rinkeby it will be a specific address\n            \"goerli\": '0x84b9514E013710b9dD0811c9Fe46b837a4A0d8E0', //it can also specify a specific netwotk name (specified in hardhat.config.js)\n        },\n        feeCollector:{\n            default: 1, // here this will by default take the second account as feeCollector (so in the test this will be a different account than the deployer)\n            1: '0xa5610E1f289DbDe94F3428A9df22E8B518f65751', // on the mainnet the feeCollector could be a multi sig\n            4: '0xa250ac77360d4e837a13628bC828a2aDf7BabfB3', // on rinkeby it could be another account\n        }\n    }\n}\n```\n\n<!-- You can also specify addresses with the `ledger://` prefix. In which case the account fetched will still be the corresponding address, but behind the scene, the transaction will be created via the hardware waller. Currently the feature is not working very well though and better support is needed. -->\n\n---\n\n### **2. extra hardhat.config networks' options**\n\n---\n\n**hardhat-deploy** add 5 new fields to `networks` configuration\n\n#### `live`\n\nthis is not used internally but is useful to perform action on a network whether it is a live network (rinkeby, mainnet, etc) or a temporary one (localhost, hardhat). The default is true (except for localhost and hardhat where the default is false).\n\n#### `saveDeployments`\n\nthis tell whether **hardhat-deploy** should save the deployments to disk or not. Default to true, except for the hardhat network.\n\n#### `tags`\n\nnetwork can have tags to represent them. The config is an array and at runtime the hre.network.tags is an object whose fields (the tags) are set to true.\n\nThis is useful to conidtionaly operate on network based on their use case.\n\nExample:\n\n```js\n{\n  networks: {\n    localhost: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"local\"]\n    },\n    hardhat: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"test\", \"local\"]\n    },\n    rinkeby: {\n      live: true,\n      saveDeployments: true,\n      tags: [\"staging\"]\n    }\n  }\n}\n```\n\n#### `deploy`\n\nthe deploy field override the paths.deploy option and let you define a set of folder containing the deploy scripts to be executed for this network.\n\nYou can thus have one network that will be executing L1 deployment and other L2 deployments, etc...\n\nYou could also have a folder that deploy contracts that are live on mainnet but that you need to replicate for your test or local network.\n\n#### `companionNetworks`\n\nthe companionNetworks field is an object whose key is any name you desire and the value is the name of a network that will be accessible inside the deploy script. For example:\n\n```js\n{\n  ...\n  networks: {\n    optimism: {\n      url: 'http://127.0.0.1:8545',\n      ovm: true,\n      companionNetworks: {\n        l1: 'localhost',\n      },\n    }\n  }\n  ...\n}\n```\n\nBy using name you can have the same deploy script used in different set of network.\n\nFor your test you could have the companion networks pointing to the same hardhat network, for test deployment, you could have rinkeby acting like your l2 while goerli act as your l1.\n\nAn example repo that show case a multi-network setup with optimism can be found here : https://github.com/wighawag/template-ethereum-contracts/tree/examples/optimism\n\ndeploy script can then access the network and its deployment as follow :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  const OVM_L1ERC20Gateway = await hre.companionNetworks['l1'].deployments.get(\n    'OVM_L1ERC20Gateway'\n  ); // layer 1\n\n  await execute(\n    'SimpleERC20_OVM',\n    {from: deployer, log: true},\n    'init',\n    OVM_L1ERC20Gateway.address\n  );\n};\n```\n\n---\n\n### **3. extra hardhat.config paths' options**\n\n---\n\n`hardhat-deploy` also adds fields to `HardhatConfig`'s `ProjectPaths` object.\n\nHere is an example showing the default values :\n\n```js\n{\n    paths: {\n        deploy: 'deploy',\n        deployments: 'deployments',\n        imports: 'imports'\n    }\n}\n```\n\nThe `deploy` folder is expected to contains the deploy script that are executed upon invocation of `hardhat deploy` or `hardhat node`.\nIt can also be an array of folder path.\n\nThe `deployments` folder will contains the resulting deployments (contract addresses along their abi, bytecode, metadata...). One folder per network and one file per contract.\n\nThe `imports` folder is expected to contains artifacts that were pre-compiled. Useful if you want to upgrade to a new solidity version but want to keep using previously compiled contracts. The artifact is the same format as normal hardhat artifact, so you can easily copy them over, before switching to a new compiler version.\n\n> This is less useful now that hardhat support multiple solidity compiler at once.\n\n---\n\n---\n\n### **4. deterministicDeployment (ability to specify a deployment factory)**\n\n---\n\nThis plugin extends the `HardhatConfig`'s object with an optional `deterministicDeployment` field.\n\n`deterministicDeployment` allows you to associate information that are used on each network for deterministic deployment. The information for each deterministic deployment consist out of a `factory`, a `deployer`, the required `funding` and a `signedTx` to deploy the factory. The default deterministic deployment used is the [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy). The factory expects a 32 bytes `salt` concatenated with the deployment data (see [EIP-1014](https://eips.ethereum.org/EIPS/eip-1014) for more information on these parameters).\n\nUsing the `deterministicDeployment` it is possible to define a different setup for the deterministic deployment. One use case for this is the deterministic deployment on networks that required replay protection (such as Celo or Avalanche). The [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy) can only be deployed on networks that don't enforce replay protection, therefore on other networks an alternative library has to be used. An example for this would be the [Safe Singleton Factory](https://github.com/gnosis/safe-singleton-factory) that is an adjusted version of the [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy) that contains signed transactions that include replay protection.\n\nThe information can be defined either as an object\n\n```js\n{\n    deterministicDeployment: {\n      \"4\": {\n        factory: \"<factory_address>\",\n        deployer: \"<deployer_address>\",\n        funding: \"<required_funding_in_wei>\",\n        signedTx: \"<raw_signed_tx>\",\n      }\n    }\n}\n```\n\nor as an function that returns the information for the deterministic deployment\n\n```js\n{\n  deterministicDeployment: (network: string) => {\n    return {\n      factory: '<factory_address>',\n      deployer: '<deployer_address>',\n      funding: '<required_funding_in_wei>',\n      signedTx: '<raw_signed_tx>',\n    };\n  };\n}\n```\n\n### Importing deployment from other projects (with truffle support)\n\n`hardhat-deploy` also add the `external` field to `HardhatConfig`\n\nSuch field allows to specify paths for external artifacts or **deployments**.\n\nThe external object has 2 fields:\n\n```js\n{\n    external: {\n        contracts: [\n          {\n            artifacts: \"node_modules/@cartesi/arbitration/export/artifacts\",\n            deploy: \"node_modules/@cartesi/arbitration/export/deploy\"\n          },\n          {\n            artifacts: \"node_modules/someotherpackage/artifacts\",\n          }\n        ],\n        deployments: {\n          rinkeby: [\"node_modules/@cartesi/arbitration/build/contracts\"],\n        },\n    }\n}\n```\n\nThe `contracts` field specify an array of object which itself have 2 fields.\n\n- `artifacts`: (mandatory) it is a path to an artifact folder. This support both hardhat and truffle artifacts.\n- `deploy`: (optional) it specifies a path to a folder where reside deploy script. The deploy scripts have only access to the artifact specified in the artifacts field. This allow project to share their deployment procedure. A boon for developer aiming at integrating it as they can get the contracts to be deployed for testing locally.\n\nThe `deployments` fields specify an object whose field nasme are the hardhat network and the value is an array of path to look for deployments. It supports both **hardhat-deploy** and truffle formats.\n\n---\n\n### Access to Artifacts (non-deployed contract code and abi)\n\nArtifacts in hardhat terminology represent a compiled contract (not yet deployed) with at least its bytecode and abi.\n\n`hardhat-deploy` gives can access to these artifact via the `deployments.getArtifact` function :\n\n```js\nconst {deployments} = require('hardhat');\nconst artifact = await deployments.getArtifact(artifactName);\n```\n\nWith the `hardhat-deploy-ethers` plugin you can get an artifact as an ethers contract factory, ready to be deployed, via the following:\n\n```js\nconst {deployments, ethers} = require('hardhat');\nconst factory = await ethers.getContractFactory(artifactName);\n```\n\n> Note that the artifact's files need to be either in `artifacts` folder that hardhat generate on compilation or in the `imports` folder where you can store contracts compiled elsewhere. They can also be present in the folder specified in `external.artifacts` see [Importing deployment from other projects](#importing-deployment-from-other-projects-with-truffle-support)\n\n---\n\n---\n\n## How to Deploy Contracts\n\n---\n\n### The `deploy` Task\n\n`hardhat --network <networkName> deploy [options and flags]`\n\nThis is a new task that the `hardhat-deploy` adds. As the name suggests it deploys contracts.\nTo be exact it will look for files in the folder `deploy` or whatever was configured in `paths.deploy`, see [paths config](#extra-paths-config)\n\nIt will scan for files in alphabetical order and execute them in turn.\n\n- it will `require` each of these files and execute the exported function with the HRE as argument\n\nTo specify the network, you can use the builtin hardhat argument `--network <network name>` or set the env variable `HARDHAT_NETWORK`\n\n> :warning: Note that running `hardhat deploy` without specifying a network will use the default network. If the default network is hardhat (the default's default) then nothing will happen as a result as everything happens in memory, but this can be used to ensure the deployment is without issues.\n\n---\n\n### Deploy Scripts\n\nThe deploy scripts need to be of the following type :\n\n```ts\nexport interface DeployFunction {\n  (env: HardhatRuntimeEnvironment): Promise<void | boolean>;\n  skip?: (env: HardhatRuntimeEnvironment) => Promise<boolean>;\n  tags?: string[];\n  dependencies?: string[];\n  runAtTheEnd?: boolean;\n  id?: string;\n}\n```\n\nThe skip function can be used to skip executing the script under whatever condition. It simply need to resolve a promise to true.\n\nThe tags is a list of string that when the _deploy_ task is executed with, the script will be executed (unless it skips). In other word if the deploy task is executed with a tag that does not belong to that script, that script will not be executed unless it is a dependency of a script that does get executed.\n\nThe dependencies is a list of tag that will be executed if that script is executed. So if the script is executed, every script whose tag match any of the dependencies will be executed first.\n\nThe `runAtTheEnd` is a boolean that if set to true, will queue that script to be executed after all other scripts are executed.\n\nThese set of fields allow more flexibility to organize the scripts. You are not limited to alphabetical order and you can even organise deploy script in sub folders.\n\nFinally the function can return true if it wishes to never be executed again. This can be usfeul to emulate migration scripts that are meant to be executed only once. Once such script return true (async), the `id` field is used to track execution and if that field is not present when the script return true, it will fails.\n\nIn other words, if you want a particular deploy script to run only once, it needs to both return true (async) and have an `id` set.\n\nIn any case, as a general advice every deploy function should be idempotent. This is so they can always recover from failure or pending transaction. This is what underpin most of hardhat-deploy philosophy.\n\nThis is why the `hre.deployments.deploy` function will by default only deploy if the contract code has changed, making it easier to write idempotent script.\n\n#### An example of a deploy script :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  // the following will only deploy \"GenericMetaTxProcessor\" if the contract was never deployed or if the code changed since last deployment\n  await deploy('GenericMetaTxProcessor', {\n    from: deployer,\n    gasLimit: 4000000,\n    args: [],\n  });\n};\n```\n\nAs you can see the HRE passed in has 4 new fields :\n\n- `getNamedAccounts` is a function that returns a promise to an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [`namedAccounts`](#namedaccounts)).\n\n- `getUnnamedAccounts` is a function that return a promise to an array of accounts which were not named (see [`namedAccounts`](#namedaccounts)). It is useful for tests where you want to be sure that the account has no speicifc role in the system (no token given, no admin access, etc...).\n\n- `getChainId` is a function which return a promise for the chainId, as convenience\n\n- `deployments` is an object which contains functions to access past deployments or to save new ones, as well as helpers functions.\n\nThat latter field contains for example the `deploy` function that allows you to deploy contract and save them. It contains a lot more functions though :\n\n---\n\n### The `deployments` field\n\nThe deployments field contains several helpers function to deploy contract but also execute transaction.\n\n```ts\nexport interface DeploymentsExtension {\n  deploy(name: string, options: DeployOptions): Promise<DeployResult>; // deploy a contract\n  diamond: {\n    // deploy diamond based contract (see section below)\n    deploy(name: string, options: DiamondOptions): Promise<DeployResult>;\n  };\n  deterministic( // return the determinsitic address as well as a function to deploy the contract, can pass the `salt` field in the option to use different salt\n    name: string,\n    options: Create2DeployOptions\n  ): Promise<{\n    address: Address;\n    implementationAddress?: Address;\n    deploy(): Promise<DeployResult>;\n  }>;\n  fetchIfDifferent( // return true if new compiled code is different than deployed contract\n    name: string,\n    options: DeployOptions\n  ): Promise<{differences: boolean; address?: string}>;\n  save(name: string, deployment: DeploymentSubmission): Promise<void>; // low level save of deployment\n  get(name: string): Promise<Deployment>; // fetch a deployment by name, throw if not existing\n  getOrNull(name: string): Promise<Deployment | null>; // fetch deployment by name, return null if not existing\n  getDeploymentsFromAddress(address: string): Promise<Deployment[]>;\n  all(): Promise<{[name: string]: Deployment}>; // return all deployments\n  getArtifact(name: string): Promise<Artifact>; // return a hardhat artifact (compiled contract without deployment)\n  getExtendedArtifact(name: string): Promise<ExtendedArtifact>; // return a extended artifact (with more info) (compiled contract without deployment)\n  run( // execute deployment scripts\n    tags?: string | string[],\n    options?: {\n      resetMemory?: boolean;\n      deletePreviousDeployments?: boolean;\n      writeDeploymentsToFiles?: boolean;\n      export?: string;\n      exportAll?: string;\n    }\n  ): Promise<{[name: string]: Deployment}>;\n  fixture( // execute deployment as fixture for test // use evm_snapshot to revert back\n    tags?: string | string[],\n    options?: {fallbackToGlobal?: boolean; keepExistingDeployments?: boolean}\n  ): Promise<{[name: string]: Deployment}>;\n  createFixture<T, O>( // execute a function as fixture using evm_snaphost to revert back each time\n    func: FixtureFunc<T, O>,\n    id?: string\n  ): (options?: O) => Promise<T>;\n  log(...args: any[]): void; // log data only ig log enabled (disabled in test fixture)\n\n  execute( // execute function call on contract\n    name: string,\n    options: TxOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<Receipt>;\n  rawTx(tx: SimpleTx): Promise<Receipt>; // execute a simple transaction\n  catchUnknownSigner( // you can wrap other function with this function and it will catch failure due to missing signer with the details of the tx to be executed\n    action: Promise<any> | (() => Promise<any>),\n    options?: {log?: boolean}\n  ): Promise<null | {\n    from: string;\n    to?: string;\n    value?: string;\n    data?: string;\n  }>;\n  read( // make a read-only call to a contract\n    name: string,\n    options: CallOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<any>;\n  read(name: string, methodName: string, ...args: any[]): Promise<any>;\n  // rawCall(to: Address, data: string): Promise<any>; // TODO ?\n}\n```\n\n---\n\n#### `deployments.deploy(<name>, options)`\n\n---\n\nThe `deploy` function, as mentioned above, allows you to deploy a contract and save it under a specific name.\n\nThe deploy function expect 2 parameters: one for the name and one for the options\n\nSee below the full list of fields that the option parameter allows and requires:\n\n```ts\nexport interface DeployOptions = {\n  from: string; // address (or private key) that will perform the transaction. you can use `getNamedAccounts` to retrived the address you want by name.\n  contract?: // this is an optional field. If not specified it defaults to the contract with the same name as the first parameter\n    | string // this field can be either a string for the name of the contract\n    | { // or abi and bytecode\n        abi: ABI;\n        bytecode: string;\n        deployedBytecode?: string;\n      };\n  args?: any[]; // the list of argument for the constructor (or the upgrade function in case of proxy)\n  skipIfAlreadyDeployed?: boolean; // if set it to true, will not attempt to deploy even if the contract deployed under the same name is different\n  log?: boolean; // if true, it will log the result of the deployment (tx hash, address and gas used)\n  linkedData?: any; // This allow to associate any JSON data to the deployment. Useful for merkle tree data for example\n  libraries?: { [libraryName: string]: Address }; // This let you associate libraries to the deployed contract\n  proxy?: boolean | string | ProxyOptions; // This options allow to consider your contract as a proxy (see below for more details)\n\n  // here some common tx options :\n  gasLimit?: string | number | BigNumber;\n  gasPrice?: string | BigNumber;\n  value?: string | BigNumber;\n  nonce?: string | number | BigNumber;\n\n  estimatedGasLimit?: string | number | BigNumber; // to speed up the estimation, it is possible to provide an upper gasLimit\n  estimateGasExtra?: string | number | BigNumber; // this option allow you to add a gas buffer on top of the estimation\n\n  autoMine?: boolean; // this force a evm_mine to be executed. this is useful to speed deployment on test network that allow to specify a block delay (ganache for example). This option basically skip the delay by force mining.\n  deterministicDeployment? boolean | string; // if true, it will deploy the contract at a deterministic address based on bytecode and constructor arguments. The address will be the same across all network. It use create2 opcode for that, if it is a string, the string will be used as the salt.\n  waitConfirmations?: number; // number of the confirmations to wait after the transactions is included in the chain\n};\n```\n\n---\n\n---\n\n## Handling contract using libraries\n\nIn the deploy function, one of the `DeployOptions` field is the `libraries` field. It allows you to associate external contract as libraries at the time of deployment.\n\nFirst, you have deploy the library using the `deploy` function, then when we deploy a contract that needs the linked library, we can pass the deployed library name and address in as an argument to the `libraries` object.\n\nFirst step: deploy the library:\n\n```js\nconst exampleLibrary = await deploy(\"ExampleLibary\", {\n    from: <deployer>\n});\n\n```\n\nExampleLibrary is now deployed to whatever network was chosen (`hardhat deploy --network <networkName>`)\n\nFor example, if we are deploying on Rinkeby, this library will get deployed on rinkeby, and the `exampleLibrary` variable will be a deployment object that contains the abi as well as the deployed address for the contract.\n\nNow that the library is deployed, we can link it in our next deployed contract.\n\n```js\nconst example = await deploy(\"Example\", {\n    from: <deployer>\n    args: [\"example string argument for the 'Example' contract constructor\"],\n    libraries: {\n        ExampleLibrary: exampleLibrary.address\n    }\n});\n\n```\n\nThis `libraries` object takes the name of the library, and its deployed address on the network. Multiple libraries can be passed into the `libraries` object.\n\n---\n\n---\n\n## Exporting Deployments\n\nApart from deployments saved in the `deployments` folder which contains all information available about the contract (compile time data + deployment data), `hardhat-deploy` allows you to export lightweight files.\n\nThese can be used for example to power your frontend with contract's address and abi.\n\nThis come into 2 flavors.\n\nThe first one is exported via the `--export <file>` option and follow the following format :\n\n```ts\nexport interface Export {\n  chainId: string;\n  name: string;\n  contracts: {[name: string]: ContractExport};\n}\n```\n\nwhere name is the name of the network configuration chosen (see hardhat option `--network`)\n\nThe second one is exported via the `--export-all <file>` option and follow the following format :\n\n```ts\nexport type MultiExport = {\n  [chainId: string]: Export[];\n};\n```\n\nAs you see the second format include the previous. While in most case you'll need the single export where your application will support only one network, there are case where your app would want to support multiple networks at nonce. This second format allow for that.\n\nFurthermore as hardhat support multiple network configuration for the same network (rinkeby, mainnet...), the export-all format will contains each of them grouped by their chainId.\n\n\nNote: from v0.10.4 the old multi-export down is no more:\n\n```\nexport type MultiExport = {\n  [chainId: string]: {[name: string]: Export};\n};\n```\n\n---\n\n---\n\n## Deploying and Upgrading Proxies\n\nAs mentioned above, the deploy function can also deploy a contract through a proxy. It can be done without modification of the contract as long as its number of constructor arguments matches the proxy initialization/update function.\n\nThe default Proxy is both ERC-1967 and ERC-173 Compliant, but other proxy can be specified, like openzeppelin transparent proxies.\n\nCode for the default Proxy can be found [here](solc_0.7/proxy/EIP173Proxy.sol).\n\nTo perform such proxy deployment, you just need to invoke the deploy function with the following options : `{..., proxy: true}`\n\nSee example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: true,\n  });\n};\n```\n\nYou can also set it to `proxy: \"<upgradeMethodName>\"` in which case the function `<upgradeMethodName>` will be executed upon upgrade.\nthe `args` field will be then used for that function instead of the contructor. It is also possible to then have a constructor with the same arguments and have the proxy be disabled. It can be useful if you want to have your contract as upgradeable in a test network but be non-upgradeable on the mainnet.\n\nSee example :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  network,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: network.live ? false : 'postUpgrade',\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nThe proxy option can also be an object which can set the specific owner that the proxy is going to be managed by.\n\nSee example:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: {\n      owner: greeterOwner,\n      methodName: 'postUpgrade',\n    },\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nNote that for the second invokation, this deployment will not be executed from the specified `from: deployer` as otherwise these tx will always fails. It will instead be automatically executed from the proxy's current owner (in that case : `greeterOwner`)\n\nNow, it is likely you do not want to locally handle the private key / mnemonic of the account that manage the proxy or it could even be that the `greeterOwner` in question is a multi sig. As such that second invocation will throw an error as it cannot find a local signer for it.\n\nThe error will output the necessary information to upgrade the contract but `hardhat-deploy` comes also with a utility function for such case: `deployments.catchUnknwonSigner` which will catch the error and output to the console the necessary information while continuing to next step.\n\nHere is the full example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy, catchUnknownSigner} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await catchUnknownSigner(\n    deploy('Greeter', {\n      from: deployer,\n      proxy: {\n        owner: greeterOwner,\n        methodName: 'postUpgrade',\n      },\n      args: ['arg1', 2, 3],\n    })\n  );\n  // you could pause the deployment here and wait for input to continue\n};\n```\n\nThe full proxy options is as follow:\n\n```ts\ntype ProxyOptionsBase = {\n  owner?: Address; // this set the owner of the proxy. further upgrade will need to be executed from that owner\n  upgradeIndex?: number; // allow you to breakdown your upgrades into separate deploy scriot, each with their own index. A deploy call with a specific upgradeIndex will be executed only once, only if the current upgradeIndex is one less.\n  proxyContract?: // default to \"EIP173Proxy\". See below for more details\n  string | ArtifactData;\n  viaAdminContract?: // allow to specify a contract that act as a middle man to perform upgrades. Useful and Recommended for Transparent Proxies\n  | string\n    | {\n        name: string;\n        artifact?: string | ArtifactData;\n      };\n};\n\nexport type ProxyOptions =\n  | (ProxyOptionsBase & {\n      methodName?: string; // method to be executed when the proxy is deployed for the first time or when the implementation is modified. Use the deployOptions args field for arguments\n    })\n  | (ProxyOptionsBase & {\n      execute?:\n        | {\n            methodName: string; // method to be executed when the proxy is deployed for the first time or when the implementation is modified.\n            args: any[];\n          }\n        | {\n            init: {\n              methodName: string; // method to be executed when the proxy is deployed\n              args: any[];\n            };\n            onUpgrade?: {\n              methodName: string; // method to be executed when the proxy is upgraded (not first deployment)\n              args: any[];\n            };\n          };\n    });\n```\n\nThe `proxyContract` field allow you to specify your own Proxy contract. If it is a string, it will first attempt to get an artifact with that name. If not found it will fallback on the following if\n\nit matches:\n\n- `EIP173Proxy`: use the default Proxy that is EIP-173 compliant\n\n- `EIP173ProxyWithReceive`: Same as above except that the proxy contains a receive hook to accept empty ETH payment.\n\n- `OpenZeppelinTransparentProxy`: Use Openzeppelin Transparent Proxy (copied from openzeppelin repo, see code [here](solc_0.7/openzeppelin/proxy/TransparentUpgradeableProxy.sol))\n  When this option is chosen, the `DefaultProxyAdmin` is also used as admin since Transparent Proxy kind of need an intermediarry contract for administration. This can be configured via the `viaAdminContract` option. Note that the DefaultProxyAdmin is slightly different than the one used by openzeppelin as it allow you to set a different owner than msg.sender on first deploy, something openzeppelin version do not allow, see : https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2639\n\n- `OptimizedTransparentProxy`: This contract is similar to above, except that it is optimized to not require storage read for the admin on every call.\n\n## Builtin-In Support For Diamonds (EIP2535)\n\nThe deployments field also expose the diamond field: `hre.deployments.diamond` that let you deploy [Diamonds](https://eips.ethereum.org/EIPS/eip-2535) in an easy way.\n\nInstead of specifying the facets to cut out or cut in, which the diamond contract expects, you specify the facets you want to end up having on the deployed contract.\n\n`diamond.deploy` expect the facet as names. The names represent contract to be deployed as facet. In future version you ll be able to specify deployed contract or artifact object as facet.\n\nTo deploy a contract with 3 facet you can do as follow :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: deployer,\n    owner: diamondAdmin,\n    facets: ['Facet1', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nif you then later execute the following script:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: diamondAdmin, // this need to be the diamondAdmin for upgrade\n    owner: diamondAdmin,\n    facets: ['NewFacet', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nThen the NewFacet will be deployed automatically if needed and then the diamondCut will cut Facet1 out and add NewFacet.\n\nNote that if the code for Facet2 and Facet3 changes, they will also be redeployed automatically and the diamondCuts will replace the existing facets with these new ones.\n\nNote that The Diamond contract's code is part of `hardhat-deploy` and contains 3 built-in facet that can be removed manually if desired.\nThese facets are used for ownership, diamondCut and diamond loupe.\n\nThe implementation is the [reference implementation by Nick Mudge](https://github.com/mudgen/diamond-3)\n\nLike normal proxies you can also execute a function at the time of an upgrade.\n\nThis is done by specifying the execute field in the diamond deploy options :\n\n```js\ndiamond.deploy('ADiamondContract', {\n  from: deployer,\n  owner: diamondAdmin,\n  facets: ['NewFacet', 'Facet2', 'Facet3'],\n  execute: {\n    methodName: 'postUpgrade',\n    args: ['one', 2, '0x3'],\n  },\n});\n```\n\nSince the diamond standard has no builtin mechanism to make the deployment of Diamond with function execution, the Diamond when deployed is actually deployed through a special contract, the `Diamantaire` (see code [here](solc_0.7/diamond/Diamantaire.sol)) that act as factory to build Diamond. It uses deterministic deployment for that so, it is transparently managed by `hardhat-deploy`. It also embed the implementation of the builtin facet, removing the need to have different instances of each live.\n\n<!-- The Diamantaire also support the deterministic deployment of Diamonds.\nAn extra field can be passed to the Diamond deployment options : `deterministicSalt`. It has to be a non-zero 32bytes string (in hex format).\nNote that if you want to deploy 2 diamonds with same owner, you'll need 2 different deterministicSalt for them to be 2 separate contracts. -->\n\n## Testing Deployed Contracts\n\nYou can continue using the usual test task:\n\n`hardhat test`\n\nTests can use the `hre.deployments.fixture` function to run the deployment and snapshot it so that tests don't need to perform all the deployment transactions every time. They can simply reuse the snapshot for every test (this leverages `evm_snapshot` and `evm_revert` provided by both `hardhat` and `ganache`). You can for example set them in a `beforeEach`.\n\nHere is an example of a test :\n\n```js\nconst {deployments} = require('hardhat');\n\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    await deployments.fixture(['Token']);\n    const Token = await deployments.get('Token'); // Token is available because the fixture was executed\n    console.log(Token.address);\n    const ERC721BidSale = await deployments.get('ERC721BidSale');\n    console.log({ERC721BidSale});\n  });\n});\n```\n\nTests can also leverage named accounts for clearer test. Combined with `hardhat-deploy-ethers` plugin, you can write succint test :\n\n```js\nconst {ethers, getNamedAccounts} = require('hardhat');\n\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    await deployments.fixture(['Token']);\n    const {tokenOwner} = await getNamedAccounts();\n    const TokenContract = await ethers.getContract('Token', tokenOwner);\n    await TokenContract.mint(2).then((tx) => tx.wait());\n  });\n});\n```\n\n---\n\n### Creating Fixtures\n\nFurthermore, tests can easily create efficient fixture using `deployments.createFixture`\n\nSee example :\n\n```js\nconst setupTest = deployments.createFixture(\n  async ({deployments, getNamedAccounts, ethers}, options) => {\n    await deployments.fixture(); // ensure you start from a fresh deployments\n    const {tokenOwner} = await getNamedAccounts();\n    const TokenContract = await ethers.getContract('Token', tokenOwner);\n    await TokenContract.mint(10).then((tx) => tx.wait()); //this mint is executed once and then `createFixture` will ensure it is snapshotted\n    return {\n      tokenOwner: {\n        address: tokenOwner,\n        TokenContract,\n      },\n    };\n  }\n);\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    const {tokenOwner} = await setupTest();\n    await tokenOwner.TokenContract.mint(2);\n  });\n});\n```\n\nWhile this example is trivial, some fixture can requires several transaction and the ability to snapshot them automatically speed up the tests greatly.\n\n---\n\n---\n\n## More Information On Hardhat Tasks\n\n---\n\n### **1. node task**\n\nas mentioned above, the node task is slighly modified and augmented with various flags and options\n\n`hardhat node`\n\nIn particular it adds an argument `--export` that allows you to specify a destination file where the info about the contracts deployed is written.\nYour webapp can then access all contracts information.\n\n---\n\n### **2. test task**\n\n`hardhat test`\n\nthe test task is augmented with one flag argument `--deploy-fixture` that allows to run all deployments in a fixture snapshot before executing the tests. This can speed up the tests that use specific tags as the global fixture take precedence (unless specified).\n\nIn other word tests can use `deployments.fixture(<specific tag>)` where specific tag only deploys the minimal contracts for tests, while still benefiting from global deployment snapshot if used.\n\nIf a test needs the deployments to only include the specific deployment specified by the tag, it can use the following :\n\n```js\ndeployments.fixture('<specific tag>', {fallbackToGlobal: false});\n```\n\nDue to how snapshot/revert works in hardhat, this means that these tests will not benefit from the global fixture snapshot and will have to deploy their contracts as part of the fixture call. This is automatic but means that these tests will run slower.\n\n---\n\n### **3. run task**\n\n`hardhat --network <networkName> run <script>`\n\nThe run task act as before but thanks to the `hre.deployments` field it can access deployed contract :\n\n```js\nconst hre = require('hardhat');\nconst {deployments, getNamedAccounts} = hre;\n\n(async () => {\n  console.log(await deployments.all());\n  console.log({namedAccounts: await getNamedAccounts()});\n})();\n```\n\nYou can also run it directly from the command line as usual.\n\n`HARDHAT_NETWORK=rinkeby node <script>` is the equivalent except it does not load the hardhat environment twice (which the run task does)\n\n---\n\n### **4. console task**\n\n`hardhat console`\n\nThe same applies to the `console` task.\n\n---\n\n## Deploy Scripts: Tags And Dependencies\n\n---\n\nIt is possible to execute only specific parts of the deployments with `hardhat deploy --tags <tags>`\n\nTags represent what the deploy script acts on. In general it will be a single string value, the name of the contract it deploys or modifies.\n\nThen if another deploy script has such tag as a dependency, then when this latter deploy script has a specific tag and that tag is requested, the dependency will be executed first.\n\nHere is an example of two deploy scripts :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const deployResult = await deploy('Token', {\n    from: deployer,\n    args: ['hello', 100],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Token deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Token'];\n```\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const Token = await deployments.get('Token');\n  const deployResult = await deploy('Sale', {\n    from: deployer,\n    contract: 'ERC721BidSale',\n    args: [Token.address, 1, 3600],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Sale deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.dependencies = ['Token']; // this ensure the Token script above is executed first, so `deployments.get('Token')` succeeds\n```\n\nAs you can see the second one depends on the first. This is because the second script depends on a tag that the first script registers as using.\n\nWith that when `hardhat deploy --tags Sale` is executed\n\nthen both scripts will be run, ensuring Sale is ready.\n\nYou can also define the script to run after another script is run by setting `runAtTheEnd` to be true. For example:\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, execute, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer, admin} = namedAccounts;\n  await execute('Sale', {from: deployer}, 'setAdmin', admin);\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.runAtTheEnd = true;\n```\n\nTags can also be used in test with `deployments.fixture`. This allow you to test a subset of the deploy script.\n","readmeFilename":"README.md","gitHead":"5602a4467748ff803eadd0050b573b149432fec6","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.0-next.3","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-8eePSt13lQ0dUSuP9n7cNstKHW0fs1G4COl60kf3ogcQDkd2jprS3BzRgdfDISQ7ZUq4Q8P/Co7u9Ml9VxTsbw==","shasum":"0e1fdb841938035309cdb361dedcd98576b6ae74","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.0-next.3.tgz","fileCount":149,"unpackedSize":12105756,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiHIa3ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmryTg/5AZDhpvAPKRreJ8WIBSHVehEBa+gYz7dNAeUj1sVKXr8nfZCB\r\nk0xwCeCDu+sUdJdC2WsiWWxsEbcifo2/eczcBQtD8aY81Nt/CX60I5lAnLZR\r\nR/p3oqdgADJh32VPzV1VD3DIbJt/6B6a3/VL2CbDUSw6KBqqdR6NuedU3JKE\r\nj1ltX/GqbX11K84g21aiEGa7DUcFfkJvxI1CYQ7iJvsKtyyfixG0OtNNnWvJ\r\n/dKUZRiS/UVpzytg5x46FDqy2vT5yIzvy22m7mnEYGE27Ub97SbFAiKCLPdO\r\nb0ccrgtuI6kTZiK7Z/qAB89YaquC0H26Kz/T4ipDGEtnPnpyBIOGHobbNnJk\r\nMRKo+MccN6ekWINUJRa8LsspYwRLqpd+v6XkEI8sd1GmPjeySZ69a0UpgJrI\r\nj4foiHJk8WdU6QUz5JMpzN5HdTyTBxJ1WhPV4skBStNdz0n6dTtZQuKpjF5o\r\n6ascSnrth+mme4KQDeqXyHtgye4hd641Hb6IQW35IJ1GWLA5yYgH/n9GyI76\r\nj7aEi6iYIaI/FenDmicBn4aw7Uq3OJP40WBWytfoMl1dRHoWMZRDDu4BQcEv\r\nSAtlr5HN31J/nkqof9Ro7F7MFBKWrI9LTJ35ujvQj+aLDODLWNhVgUJGyp3T\r\nZ/m9FnCWOhWUK64LyvPlluE2p8viIkQuXC8=\r\n=96FR\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCYYozmHJ/n1kdKfcLADvmeexB+zXtz1/6RIubOiDg6PgIhAJ4d6oqRP6hTGNHYpJZ+LeJTBaYd2fyXH05nIxz3oCvx"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.0-next.3_1646036663662_0.33187292697365"},"_hasShrinkwrap":false},"0.11.0-next.4":{"name":"hardhat-deploy","version":"0.11.0-next.4","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.8","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.6.8"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"readme":"<h1> hardhat-deploy</h1>\n\n_A [Hardhat](https://hardhat.org) Plugin For Replicable Deployments And Easy Testing_\n\n> **A complete dev template using hardhat-deploy is available here** : https://github.com/wighawag/template-ethereum-contracts\n> It also contains various branches examplifying the capability of hardhat-deploy. Check it out.\n\n- [What is it for ?](#what-is-it-for-)\n- [hardhat-deploy in a nutshell](#hardhat-deploy-in-a-nutshell)\n- [Installation](#installation)\n  - [npm install hardhat-deploy](#npm-install-hardhat-deploy)\n  - [TypeScript support](#typescript-support)\n  - [Migrating existing deployment to hardhat-deploy](#migrating-existing-deployment-to-hardhat-deploy)\n- [Hardhat Tasks Available/Updated](#hardhat-tasks-availableupdated)\n  - [1. hardhat deploy](#1-hardhat-deploy)\n    - [**Options**](#options)\n    - [**Flags**](#flags)\n  - [2. hardhat node](#2-hardhat-node)\n    - [**Options**](#options-1)\n    - [**Flags**](#flags-1)\n  - [3. hardhat test](#3-hardhat-test)\n  - [4. hardhat etherscan-verify](#4-hardhat-etherscan-verify)\n    - [**Options**](#options-2)\n  - [5. hardhat sourcify](#5-hardhat-sourcify)\n    - [**Options**](#options-3)\n  - [6. hardhat export](#6-hardhat-export)\n    - [**Options**](#options-4)\n- [Hardhat Environment Extensions](#hardhat-environment-extensions)\n- [Configuration](#configuration)\n  - [**1. namedAccounts (ability to name addresses)**](#1-namedaccounts-ability-to-name-addresses)\n  - [**2. extra hardhat.config networks' options**](#2-extra-hardhatconfig-networks-options)\n    - [`live`](#live)\n    - [`saveDeployments`](#savedeployments)\n    - [`tags`](#tags)\n    - [`deploy`](#deploy)\n    - [`companionNetworks`](#companionnetworks)\n  - [**3. extra hardhat.config paths' options**](#3-extra-hardhatconfig-paths-options)\n  - [**4. deterministicDeployment (ability to specify a deployment factory)**](#4-deterministicdeployment-ability-to-specify-a-deployment-factory)\n  - [Importing deployment from other projects (with truffle support)](#importing-deployment-from-other-projects-with-truffle-support)\n  - [Access to Artifacts (non-deployed contract code and abi)](#access-to-artifacts-non-deployed-contract-code-and-abi)\n- [How to Deploy Contracts](#how-to-deploy-contracts)\n  - [The `deploy` Task](#the-deploy-task)\n  - [Deploy Scripts](#deploy-scripts)\n    - [An example of a deploy script :](#an-example-of-a-deploy-script-)\n  - [The `deployments` field](#the-deployments-field)\n    - [`deployments.deploy(<name>, options)`](#deploymentsdeployname-options)\n- [Handling contract using libraries](#handling-contract-using-libraries)\n- [Exporting Deployments](#exporting-deployments)\n- [Deploying and Upgrading Proxies](#deploying-and-upgrading-proxies)\n- [Builtin-In Support For Diamonds (EIP2535)](#builtin-in-support-for-diamonds-eip2535)\n- [Testing Deployed Contracts](#testing-deployed-contracts)\n  - [Creating Fixtures](#creating-fixtures)\n- [More Information On Hardhat Tasks](#more-information-on-hardhat-tasks)\n  - [**1. node task**](#1-node-task)\n  - [**2. test task**](#2-test-task)\n  - [**3. run task**](#3-run-task)\n  - [**4. console task**](#4-console-task)\n- [Deploy Scripts: Tags And Dependencies](#deploy-scripts-tags-and-dependencies)\n\n## What is it for ?\n\nThis [hardhat](https://hardhat.org) plugin adds a mechanism to deploy contracts to any network, keeping track of them and replicating the same environment for testing.\n\nIt also adds a mechanism to associate names to addresses, so test and deployment scripts can be reconfigured by simply changing the address a name points to, allowing different configurations per network. This also results in much clearer tests and deployment scripts (no more `accounts[0]` in your code).\n\nThis plugin contains a lot more features too, all geared toward a better developer experience :\n\n- chain configuration export\n- listing deployed contracts' addresses and their abis (useful for webapps)\n- library linking at time of deployment.\n- deterministic deployment across networks.\n- support for specific deploy script per network (L1 vs L2 for example)\n- ability to access deployment from \"companion\" networks\n- deployment dependency system (allowing you to only deploy what is needed).\n- deployment retrying (by saving pending tx): so you can feel confident when making a deployment that you can always recover.\n- deployments as test fixture using `evm_snapshot` to speed up testing.\n- ability to create your own test fixture that automatically benefits from `evm_snapshot`'s tests speed-up boost\n- combined with [hardhat-deploy-ethers](https://github.com/wighawag/hardhat-deploy-ethers) it has the ability to get ethers contract instance by name (like `await ethers.getContract(\"ContractName\")`).\n- importing artifact from external sources (like npm packages), including [truffle](https://www.trufflesuite.com/truffle) support.\n- importing deployments from external sources (like npm packages)\n- ability to log information in `deploy` mode only (while in test the console remains clean).\n- contains helpers to read and execute transaction on deployed contract referring to them by name.\n- These helpers contains options to auto mine on dev network (to speed up test deployments).\n- save metadata of deployed contract so they can always be fully verified, via [sourcify](https://sourcify.dev) or [etherscan](https://etherscan.io).\n- ability to submit contract source to etherscan and sourcify for verification at any time. (Because **hardhat-deploy** will save all the necessary info, it can be executed at any time.)\n- support harhdat's fork feature so deployment can be accessed even when run through fork.\n- named accounts are automatically impersonnated too, so you can perform tx as if you had their private key.\n- proxy deployment with ability to upgrade them transparently, only if code changes.\n- this include support for [openzeppelin](https://openzeppelin.com) transparent proxies\n- diamond deployment with facets, allowing you to focus on what the new version will be. It will generate the diamondCut necessary to reach the new state.\n- watch and deploy: **hardhat-deploy** can watch both your deploy script and contract code and redeploy on changes.\n- HCR (Hot Contract Replacement): the watch feature combined with proxy or diamond, gives you an experience akin to frontend Hot Module Replacement: once your contract changes, the deployment is executed and your contract retains the same address and same state, allowing you to tweak your contracts while debugging your front-end.\n\n## hardhat-deploy in a nutshell\n\nBefore going into the details, here is a very simple summary of the basic feature of **hardhat-deploy**.\n\n**hardhat-deploy** allows you to write [`deploy scripts`](#deploy-scripts) in the `deploy` folder. Each of these files that look as follows will be executed in turn when you execute the following task: `hardhat --network <networkName> deploy`\n\n```js\n// deploy/00_deploy_my_contract.js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('MyContract', {\n    from: deployer,\n    args: ['Hello'],\n    log: true,\n  });\n};\nmodule.exports.tags = ['MyContract'];\n```\n\nFurthermore you can also ensure these scripts are executed in test too by calling `await deployments.fixture(['MyContract'])` in your test.\nThis is optimized, so if multiple tests use the same contract, the deployment will be executed once and each test will start with the exact same state.\n\nThis is a huge benefit for testing since you are not required to replicate the deployment procedure in your tests. The tag feature (as seen in the script above) and [dependencies](#deploy-scripts-tags-and-dependencies) will also make your life easier when writing complex deployment procedures.\n\nYou can even group deploy scripts in different sub folder and ensure they are executed in their logical order.\n\nFurthermore hardhat-deploy can also support a multi-chain settings like L1, L2 with multiple deploy folder specific to each network.\n\n**All of this can also be bundled in a npm package so user of hardhat-deploy can reuse your deployment procedure and get started integrating with your project locally.**\n\nThere is a tutorial covering the basics here : https://github.com/wighawag/tutorial-hardhat-deploy\n\n## Installation\n\n### npm install hardhat-deploy\n\n```bash\nnpm install -D hardhat-deploy\n```\n\nAnd add the following statement to your `hardhat.config.js`:\n\n```js\nrequire('hardhat-deploy');\n```\n\nif you use `ethers.js` we recommend you also install `hardhat-deploy-ethers` which add extra features to access deployments as ethers contract.\n\nSince `hardhat-deploy-ethers` is a fork of `@nomiclabs/hardhat-ethers` and that other plugin might have an hardcoded dependency on `@nomiclabs/hardhat-ethers` the best way to install `hardhat-deploy-ethers` and ensure compatibility is the following:\n\n```bash\nnpm install --save-dev  @nomiclabs/hardhat-ethers@npm:hardhat-deploy-ethers ethers\n```\n\nWhich means you then need to do `require(\"@nomiclabs/hardhat-ethers\")` instead of `require(\"hardhat-deploy-ethers\")` in your `hardhat.config.js` file.\n\nMore details on `hardhat-deploy-ethers` repo : https://github.com/wighawag/hardhat-deploy-ethers#readme\n\n### TypeScript support\n\nWith hardhat the tsconfig.json is optional.\n\nBut if you add folders to the `include` field in `tsconfig.json`, you ll also need to include `hardhat.config.ts` like :\n\n`include\": [\"./hardhat.config.ts\", \"./scripts\", \"./deploy\", \"./test\"]`\n\nfor deploy script (see below) you can write them this way to benefit from typing :\n\n```ts\nimport {HardhatRuntimeEnvironment} from 'hardhat/types';\nimport {DeployFunction} from 'hardhat-deploy/types';\n\nconst func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {\n  // code here\n};\nexport default func;\n```\n\nSee a template that uses **hardhat-deploy** here : https://github.com/wighawag/template-ethereum-contracts\n\nThis repo has also some examples branch that exemplify specific features, like the forking testing here : https://github.com/wighawag/template-ethereum-contracts/tree/examples/fork-test\n\n### Migrating existing deployment to hardhat-deploy\n\n> Only needed for existing project that already deployed contracts and has the deployment information available **(at minimum, address and abi)**\n\nYou might want to switch your current deployment process to use **hardhat-deploy**. In that case you probably have some deployments saved elsewhere.\n\nIn order to port them to **hardhat-deploy**, you'll need to create one `.json` file per contract in the `deployments/<network>` folder (configurable via [paths config](#extra-paths-config)).\n\nThe network folder is simply the hardhat network name (as configured in hardhat.config.js) (accessible at runtime via `hre.network.name`).\nSuch folder need to have a file named `.chainId` containing the chainId as decimal.\n\nFor example for network named \"rinkeby\" (for the corresponding network) the file `deployments/rinkeby/.chainId` would be\n\n```\n4\n```\n\nNote, prior to hardhat 0.6 the chainId was appended to the folder name (expect for some known network name). This has changed and upgrading to 0.6 will require you to change the folder name and add the '.chainId' file.\n\nEach contract file must follow this type (as defined in [types.ts](types.ts)) :\n\n```ts\nexport interface Deployment {\n  address: Address;\n  abi: ABI;\n  receipt?: Receipt;\n  transactionHash?: string;\n  history?: Deployment[];\n  numDeployments?: number;\n  implementation?: string;\n  args?: any[];\n  linkedData?: any;\n  solcInputHash?: string;\n  metadata?: string;\n  bytecode?: string;\n  deployedBytecode?: string;\n  libraries?: Libraries;\n  userdoc?: any;\n  devdoc?: any;\n  methodIdentifiers?: any;\n  diamondCut?: FacetCut[];\n  facets?: Facet[];\n  storageLayout?: any;\n  gasEstimates?: any;\n}\n```\n\nAs you can see, only abi and address are mandatory. But having the other fields allow more feature. For example, metadata and args allow you to benefit from contract code verification.\n\nFor Receipt, the following type is expected:\n\n```ts\nexport type Receipt = {\n  from: string;\n  transactionHash: string;\n  blockHash: string;\n  blockNumber: number;\n  transactionIndex: number;\n  cumulativeGasUsed: string;\n  gasUsed: string;\n  contractAddress?: string;\n  to?: string;\n  logs?: Log[];\n  events?: any[];\n  logsBloom?: string;\n  byzantium?: boolean;\n  status?: number;\n  confirmations?: number;\n};\n```\n\nHere is an example:\n\nLet's say you have:\n\n- 2 Contract named Greeter and Registry deployed on rinkeby\n- 1 contract named Greeter on mainnet\n- 2 Contract named Greeter and Registry deployed on a network named rinkeby2\n\nYou would get the following folder structure:\n\n```\ndeployments/\n  mainnet/\n    .chainId\n    Greeter.json\n  rinkeby/\n    .chainId\n    Greeter.json\n    Registry.json\n  rinkeby2/\n    .chainId\n    Greeter.json\n    Registry.json\n```\n\nThe reason why **hardhat-deploy** save chainId in the `.chainId` file is both for\n\n- safety: so that if you were to change the network name to point to a different chain, it would not attempt to read the wrong folder and assume that a contract has been deployed while it has not.\n- ability to know the chainId without requring to be connected to a node (and so not dependent on hardhat.config.js settings). Useful for `export` task.\n\n---\n\n## Hardhat Tasks Available/Updated\n\nhardhat deploy add several task to hardhat. It also modify existing one, adding new options and new behavior. All of these are described here:\n\n---\n\n### 1. hardhat deploy\n\n---\n\nThis plugin adds the _deploy_ task to Hardhat.\n\nThis task will execute the scripts in the `deploy` folder and save the contract deployments to disk. These deployments are supposed to be saved for example in a git repository. This way they can be accessed later. But you are free to save them elsewhere and get them back via your mechanism of choice.\n\nWith the deployment saved, it allows you to deploy a contract only if changes were made.\n\nDeploy scripts (also called Deploy functions) can also perform aribtrary logic.\n\nFor further details on how to use it and write deploy script, see [section](#deploy-scripts) below.\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployments, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice (in wei) to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--reset`: This flag resets the deployments from scratch. Previously deployed contract are not considered and deleted from disk.\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n---\n\n### 2. hardhat node\n\n---\n\nThis plugin modify the _node_ task so that it also execute the deployment script before exposing the server http RPC interface\n\nIt add similar options than the `deploy` task :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--no-reset`: This flag prevent the reseting of the existing deployments. This is usually not desired when running the `node` task as a network is created from scratch and previous deployemnt are irrelevant.\n\n`--show-accounts`: this flag will output the account private keys\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n`--no-deploy` that discard all other options to revert to normal `hardhat node` behavior without any deployment being performed.\n\n> :warning: Note that the deployments are saved as if the network name is `localhost`. This is because `hardhat node` is expected to be used as localhost: You can for example execute `hardhat --network localhost console` after `node` is running. Doing `hardhat --network hardhat console` would indeed not do anything useful. It still take the configuration from `hardhat` in the hardhat.config.js file though.\n\n---\n\n### 3. hardhat test\n\n---\n\nThis plugin adds a flag argument `--deploy-fixture` to the _test_ task which if enabled will run the global deployments fixture before the tests and snapshots it. This will generaly speed up the tests as further test will be able to revert back to the full deployment.\n\n> :warning: Note though that if your test behave differently whether that option is on or not, this most likely mean that your deploy scripts' tags and dependencies are not configured correctly. This is because the global fixture will ensure all contract are deployed while test will usually (for efficiency) ask for a particular tag.\n\n---\n\n### 4. hardhat etherscan-verify\n\n---\n\nThis plugin adds the _etherscan-verify_ task to Hardhat.\n\nThis task will submit the contract source and other info of all deployed contracts to allow etherscan to verify and record the sources.\n\nInstead of using the full solc input, this task will first attempt to send the minimal sources from the metadata.\nBut Etherscan sometime fails due to a bug in solidity compiler (<https://github.com/ethereum/solidity/issues/9573>). As such this task can fallback on full solc input (see option --solc-input). Note that if your contract was deployed with a previous version of **hardhat-deploy**, it might not contains the full information. The issue seems to be fully resolved since solc version 0.8.\n\nThis task will also attempt to automatically find the SPDX license in the source.\n\nTo execute that task, you need to specifiy the network to run against :\n\n```bash\nhardhat --network mainnet etherscan-verify [--api-key <apikey>] [--apiurl <url>]\n```\n\n#### **Options**\n\nNote that harhdat-deploy now use a different config format to not conflict with `hardhat-etherscan`\n\n`--api-key <api key>`: let you specify your etherscan api key. Alternatively, you can provide it via the env variable `ETHERSCAN_API_KEY` or through the hardhat.config.ts verify field:\n\n```js\n{\n  ...\n  verify: {\n    etherscan: {\n      apiKey: '<API key>'\n    }\n  }\n}\n```\n\n`--api-url <url>`: let you specify your etherscan url to submit the source to. Can also be configured per network in `hardhat.config.js`:\n\n```js\n{\n  ...\n  networks: {\n    mynetwork: {\n      ...\n      verify: {\n        etherscan: {\n          apiUrl: 'http://mynetwork.xyz'\n        }\n      }\n    }\n  }\n}\n```\n\n`--license <SPDX license id>`: SPDX license (useful if SPDX is not listed in the sources), need to be supported by etherscan: https://etherscan.io/contract-license-types\n\n`--force-license`: if set, will force the use of the license specified by --license option, ignoring the one in the source (useful for license not supported by etherscan)\n\n`--solc-input`: fallback on solc-input id needed (useful when etherscan fails on the minimum sources, see https://github.com/ethereum/solidity/issues/9573)\n\n`--sleep`: sleep 500ms between each verification, so API rate limit is not exceeded\n\n---\n\n### 5. hardhat sourcify\n\n---\n\nThis plugin adds the _sourcify_ task to Hardhat.\n\nSimilar to `hardhat etherscan-verify` this task will submit the contract source and other info of all deployed contracts to sourcify.\n\n```bash\nhardhat --network mainnet sourcify\n```\n\nLater this task might instead pin the metadata to ipfs, so sourcify can automatically verify them.\n\n#### **Options**\n\n`--endpoint <endpoint>`: specify the sourcify endpoint, default to https://sourcify.dev/server/\n\n`--write-failing-metadata`: if set and the sourcify task fails to verify, the metadata file will be written to disk, so you can more easily figure out what has gone wrong.\n\n---\n\n### 6. hardhat export\n\n---\n\nThis plugin adds the _export_ task to Hardhat.\n\nThis task will export the contract deployed (saved in `deployments` folder) to a file with a simple format containing only contract addresses and abi, useful for web apps.\n\nOne of the following options need to be set for this task to have any effects :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\nThis last option has some limitations, when combined with the use of external deployments (see [Configuration](#configuration)). If such external deployments were using older version of **hardhat-deploy** or truffle, the chainId might be missing. In order for these to be exported, the hardhat network config need to explicity state the chainId in the `networks` config of `hardhat.config.js`.\n\nWith both `--export` and `--export-all`, using the special `<filepath>` value of `-` will output to `STDOUT` rather than writing a normal file.\n\n---\n\n---\n\n## Hardhat Environment Extensions\n\nThis plugin extends the Hardhat Runtime Environment by adding 4 fields:\n\n- `getNamedAccounts: () => Promise<{ [name: string]: string }>`: a function returning an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [Configuration](#configuration)).\n\n- `getUnnamedAccounts: () => Promise<string[]}>`: accounts which has no names, useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`: contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId(): Promise<string>`: offer an easy way to fetch the current chainId.\n\n---\n\n---\n\n## Configuration\n\n---\n\n### **1. namedAccounts (ability to name addresses)**\n\n---\n\nThis plugin extends the `HardhatConfig`'s object with an optional `namedAccounts` field.\n\n`namedAccounts` allows you to associate names to addresses and have them configured per chain.\nThis allows you to have meaningful names in your tests while the addresses match to multi sig in real network for example.\n\n```js\n{\n    namedAccounts: {\n        deployer: {\n            default: 0, // here this will by default take the first account as deployer\n            1: 0, // similarly on mainnet it will take the first account as deployer. Note though that depending on how hardhat network are configured, the account 0 on one network can be different than on another\n            4: '0xA296a3d5F026953e17F472B497eC29a5631FB51B', // but for rinkeby it will be a specific address\n            \"goerli\": '0x84b9514E013710b9dD0811c9Fe46b837a4A0d8E0', //it can also specify a specific netwotk name (specified in hardhat.config.js)\n        },\n        feeCollector:{\n            default: 1, // here this will by default take the second account as feeCollector (so in the test this will be a different account than the deployer)\n            1: '0xa5610E1f289DbDe94F3428A9df22E8B518f65751', // on the mainnet the feeCollector could be a multi sig\n            4: '0xa250ac77360d4e837a13628bC828a2aDf7BabfB3', // on rinkeby it could be another account\n        }\n    }\n}\n```\n\n<!-- You can also specify addresses with the `ledger://` prefix. In which case the account fetched will still be the corresponding address, but behind the scene, the transaction will be created via the hardware waller. Currently the feature is not working very well though and better support is needed. -->\n\n---\n\n### **2. extra hardhat.config networks' options**\n\n---\n\n**hardhat-deploy** add 5 new fields to `networks` configuration\n\n#### `live`\n\nthis is not used internally but is useful to perform action on a network whether it is a live network (rinkeby, mainnet, etc) or a temporary one (localhost, hardhat). The default is true (except for localhost and hardhat where the default is false).\n\n#### `saveDeployments`\n\nthis tell whether **hardhat-deploy** should save the deployments to disk or not. Default to true, except for the hardhat network.\n\n#### `tags`\n\nnetwork can have tags to represent them. The config is an array and at runtime the hre.network.tags is an object whose fields (the tags) are set to true.\n\nThis is useful to conidtionaly operate on network based on their use case.\n\nExample:\n\n```js\n{\n  networks: {\n    localhost: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"local\"]\n    },\n    hardhat: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"test\", \"local\"]\n    },\n    rinkeby: {\n      live: true,\n      saveDeployments: true,\n      tags: [\"staging\"]\n    }\n  }\n}\n```\n\n#### `deploy`\n\nthe deploy field override the paths.deploy option and let you define a set of folder containing the deploy scripts to be executed for this network.\n\nYou can thus have one network that will be executing L1 deployment and other L2 deployments, etc...\n\nYou could also have a folder that deploy contracts that are live on mainnet but that you need to replicate for your test or local network.\n\n#### `companionNetworks`\n\nthe companionNetworks field is an object whose key is any name you desire and the value is the name of a network that will be accessible inside the deploy script. For example:\n\n```js\n{\n  ...\n  networks: {\n    optimism: {\n      url: 'http://127.0.0.1:8545',\n      ovm: true,\n      companionNetworks: {\n        l1: 'localhost',\n      },\n    }\n  }\n  ...\n}\n```\n\nBy using name you can have the same deploy script used in different set of network.\n\nFor your test you could have the companion networks pointing to the same hardhat network, for test deployment, you could have rinkeby acting like your l2 while goerli act as your l1.\n\nAn example repo that show case a multi-network setup with optimism can be found here : https://github.com/wighawag/template-ethereum-contracts/tree/examples/optimism\n\ndeploy script can then access the network and its deployment as follow :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  const OVM_L1ERC20Gateway = await hre.companionNetworks['l1'].deployments.get(\n    'OVM_L1ERC20Gateway'\n  ); // layer 1\n\n  await execute(\n    'SimpleERC20_OVM',\n    {from: deployer, log: true},\n    'init',\n    OVM_L1ERC20Gateway.address\n  );\n};\n```\n\n---\n\n### **3. extra hardhat.config paths' options**\n\n---\n\n`hardhat-deploy` also adds fields to `HardhatConfig`'s `ProjectPaths` object.\n\nHere is an example showing the default values :\n\n```js\n{\n    paths: {\n        deploy: 'deploy',\n        deployments: 'deployments',\n        imports: 'imports'\n    }\n}\n```\n\nThe `deploy` folder is expected to contains the deploy script that are executed upon invocation of `hardhat deploy` or `hardhat node`.\nIt can also be an array of folder path.\n\nThe `deployments` folder will contains the resulting deployments (contract addresses along their abi, bytecode, metadata...). One folder per network and one file per contract.\n\nThe `imports` folder is expected to contains artifacts that were pre-compiled. Useful if you want to upgrade to a new solidity version but want to keep using previously compiled contracts. The artifact is the same format as normal hardhat artifact, so you can easily copy them over, before switching to a new compiler version.\n\n> This is less useful now that hardhat support multiple solidity compiler at once.\n\n---\n\n---\n\n### **4. deterministicDeployment (ability to specify a deployment factory)**\n\n---\n\nThis plugin extends the `HardhatConfig`'s object with an optional `deterministicDeployment` field.\n\n`deterministicDeployment` allows you to associate information that are used on each network for deterministic deployment. The information for each deterministic deployment consist out of a `factory`, a `deployer`, the required `funding` and a `signedTx` to deploy the factory. The default deterministic deployment used is the [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy). The factory expects a 32 bytes `salt` concatenated with the deployment data (see [EIP-1014](https://eips.ethereum.org/EIPS/eip-1014) for more information on these parameters).\n\nUsing the `deterministicDeployment` it is possible to define a different setup for the deterministic deployment. One use case for this is the deterministic deployment on networks that required replay protection (such as Celo or Avalanche). The [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy) can only be deployed on networks that don't enforce replay protection, therefore on other networks an alternative library has to be used. An example for this would be the [Safe Singleton Factory](https://github.com/gnosis/safe-singleton-factory) that is an adjusted version of the [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy) that contains signed transactions that include replay protection.\n\nThe information can be defined either as an object\n\n```js\n{\n    deterministicDeployment: {\n      \"4\": {\n        factory: \"<factory_address>\",\n        deployer: \"<deployer_address>\",\n        funding: \"<required_funding_in_wei>\",\n        signedTx: \"<raw_signed_tx>\",\n      }\n    }\n}\n```\n\nor as an function that returns the information for the deterministic deployment\n\n```js\n{\n  deterministicDeployment: (network: string) => {\n    return {\n      factory: '<factory_address>',\n      deployer: '<deployer_address>',\n      funding: '<required_funding_in_wei>',\n      signedTx: '<raw_signed_tx>',\n    };\n  };\n}\n```\n\n### Importing deployment from other projects (with truffle support)\n\n`hardhat-deploy` also add the `external` field to `HardhatConfig`\n\nSuch field allows to specify paths for external artifacts or **deployments**.\n\nThe external object has 2 fields:\n\n```js\n{\n    external: {\n        contracts: [\n          {\n            artifacts: \"node_modules/@cartesi/arbitration/export/artifacts\",\n            deploy: \"node_modules/@cartesi/arbitration/export/deploy\"\n          },\n          {\n            artifacts: \"node_modules/someotherpackage/artifacts\",\n          }\n        ],\n        deployments: {\n          rinkeby: [\"node_modules/@cartesi/arbitration/build/contracts\"],\n        },\n    }\n}\n```\n\nThe `contracts` field specify an array of object which itself have 2 fields.\n\n- `artifacts`: (mandatory) it is a path to an artifact folder. This support both hardhat and truffle artifacts.\n- `deploy`: (optional) it specifies a path to a folder where reside deploy script. The deploy scripts have only access to the artifact specified in the artifacts field. This allow project to share their deployment procedure. A boon for developer aiming at integrating it as they can get the contracts to be deployed for testing locally.\n\nThe `deployments` fields specify an object whose field nasme are the hardhat network and the value is an array of path to look for deployments. It supports both **hardhat-deploy** and truffle formats.\n\n---\n\n### Access to Artifacts (non-deployed contract code and abi)\n\nArtifacts in hardhat terminology represent a compiled contract (not yet deployed) with at least its bytecode and abi.\n\n`hardhat-deploy` gives can access to these artifact via the `deployments.getArtifact` function :\n\n```js\nconst {deployments} = require('hardhat');\nconst artifact = await deployments.getArtifact(artifactName);\n```\n\nWith the `hardhat-deploy-ethers` plugin you can get an artifact as an ethers contract factory, ready to be deployed, via the following:\n\n```js\nconst {deployments, ethers} = require('hardhat');\nconst factory = await ethers.getContractFactory(artifactName);\n```\n\n> Note that the artifact's files need to be either in `artifacts` folder that hardhat generate on compilation or in the `imports` folder where you can store contracts compiled elsewhere. They can also be present in the folder specified in `external.artifacts` see [Importing deployment from other projects](#importing-deployment-from-other-projects-with-truffle-support)\n\n---\n\n---\n\n## How to Deploy Contracts\n\n---\n\n### The `deploy` Task\n\n`hardhat --network <networkName> deploy [options and flags]`\n\nThis is a new task that the `hardhat-deploy` adds. As the name suggests it deploys contracts.\nTo be exact it will look for files in the folder `deploy` or whatever was configured in `paths.deploy`, see [paths config](#extra-paths-config)\n\nIt will scan for files in alphabetical order and execute them in turn.\n\n- it will `require` each of these files and execute the exported function with the HRE as argument\n\nTo specify the network, you can use the builtin hardhat argument `--network <network name>` or set the env variable `HARDHAT_NETWORK`\n\n> :warning: Note that running `hardhat deploy` without specifying a network will use the default network. If the default network is hardhat (the default's default) then nothing will happen as a result as everything happens in memory, but this can be used to ensure the deployment is without issues.\n\n---\n\n### Deploy Scripts\n\nThe deploy scripts need to be of the following type :\n\n```ts\nexport interface DeployFunction {\n  (env: HardhatRuntimeEnvironment): Promise<void | boolean>;\n  skip?: (env: HardhatRuntimeEnvironment) => Promise<boolean>;\n  tags?: string[];\n  dependencies?: string[];\n  runAtTheEnd?: boolean;\n  id?: string;\n}\n```\n\nThe skip function can be used to skip executing the script under whatever condition. It simply need to resolve a promise to true.\n\nThe tags is a list of string that when the _deploy_ task is executed with, the script will be executed (unless it skips). In other word if the deploy task is executed with a tag that does not belong to that script, that script will not be executed unless it is a dependency of a script that does get executed.\n\nThe dependencies is a list of tag that will be executed if that script is executed. So if the script is executed, every script whose tag match any of the dependencies will be executed first.\n\nThe `runAtTheEnd` is a boolean that if set to true, will queue that script to be executed after all other scripts are executed.\n\nThese set of fields allow more flexibility to organize the scripts. You are not limited to alphabetical order and you can even organise deploy script in sub folders.\n\nFinally the function can return true if it wishes to never be executed again. This can be usfeul to emulate migration scripts that are meant to be executed only once. Once such script return true (async), the `id` field is used to track execution and if that field is not present when the script return true, it will fails.\n\nIn other words, if you want a particular deploy script to run only once, it needs to both return true (async) and have an `id` set.\n\nIn any case, as a general advice every deploy function should be idempotent. This is so they can always recover from failure or pending transaction. This is what underpin most of hardhat-deploy philosophy.\n\nThis is why the `hre.deployments.deploy` function will by default only deploy if the contract code has changed, making it easier to write idempotent script.\n\n#### An example of a deploy script :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  // the following will only deploy \"GenericMetaTxProcessor\" if the contract was never deployed or if the code changed since last deployment\n  await deploy('GenericMetaTxProcessor', {\n    from: deployer,\n    gasLimit: 4000000,\n    args: [],\n  });\n};\n```\n\nAs you can see the HRE passed in has 4 new fields :\n\n- `getNamedAccounts` is a function that returns a promise to an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [`namedAccounts`](#namedaccounts)).\n\n- `getUnnamedAccounts` is a function that return a promise to an array of accounts which were not named (see [`namedAccounts`](#namedaccounts)). It is useful for tests where you want to be sure that the account has no speicifc role in the system (no token given, no admin access, etc...).\n\n- `getChainId` is a function which return a promise for the chainId, as convenience\n\n- `deployments` is an object which contains functions to access past deployments or to save new ones, as well as helpers functions.\n\nThat latter field contains for example the `deploy` function that allows you to deploy contract and save them. It contains a lot more functions though :\n\n---\n\n### The `deployments` field\n\nThe deployments field contains several helpers function to deploy contract but also execute transaction.\n\n```ts\nexport interface DeploymentsExtension {\n  deploy(name: string, options: DeployOptions): Promise<DeployResult>; // deploy a contract\n  diamond: {\n    // deploy diamond based contract (see section below)\n    deploy(name: string, options: DiamondOptions): Promise<DeployResult>;\n  };\n  deterministic( // return the determinsitic address as well as a function to deploy the contract, can pass the `salt` field in the option to use different salt\n    name: string,\n    options: Create2DeployOptions\n  ): Promise<{\n    address: Address;\n    implementationAddress?: Address;\n    deploy(): Promise<DeployResult>;\n  }>;\n  fetchIfDifferent( // return true if new compiled code is different than deployed contract\n    name: string,\n    options: DeployOptions\n  ): Promise<{differences: boolean; address?: string}>;\n  save(name: string, deployment: DeploymentSubmission): Promise<void>; // low level save of deployment\n  get(name: string): Promise<Deployment>; // fetch a deployment by name, throw if not existing\n  getOrNull(name: string): Promise<Deployment | null>; // fetch deployment by name, return null if not existing\n  getDeploymentsFromAddress(address: string): Promise<Deployment[]>;\n  all(): Promise<{[name: string]: Deployment}>; // return all deployments\n  getArtifact(name: string): Promise<Artifact>; // return a hardhat artifact (compiled contract without deployment)\n  getExtendedArtifact(name: string): Promise<ExtendedArtifact>; // return a extended artifact (with more info) (compiled contract without deployment)\n  run( // execute deployment scripts\n    tags?: string | string[],\n    options?: {\n      resetMemory?: boolean;\n      deletePreviousDeployments?: boolean;\n      writeDeploymentsToFiles?: boolean;\n      export?: string;\n      exportAll?: string;\n    }\n  ): Promise<{[name: string]: Deployment}>;\n  fixture( // execute deployment as fixture for test // use evm_snapshot to revert back\n    tags?: string | string[],\n    options?: {fallbackToGlobal?: boolean; keepExistingDeployments?: boolean}\n  ): Promise<{[name: string]: Deployment}>;\n  createFixture<T, O>( // execute a function as fixture using evm_snaphost to revert back each time\n    func: FixtureFunc<T, O>,\n    id?: string\n  ): (options?: O) => Promise<T>;\n  log(...args: any[]): void; // log data only ig log enabled (disabled in test fixture)\n\n  execute( // execute function call on contract\n    name: string,\n    options: TxOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<Receipt>;\n  rawTx(tx: SimpleTx): Promise<Receipt>; // execute a simple transaction\n  catchUnknownSigner( // you can wrap other function with this function and it will catch failure due to missing signer with the details of the tx to be executed\n    action: Promise<any> | (() => Promise<any>),\n    options?: {log?: boolean}\n  ): Promise<null | {\n    from: string;\n    to?: string;\n    value?: string;\n    data?: string;\n  }>;\n  read( // make a read-only call to a contract\n    name: string,\n    options: CallOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<any>;\n  read(name: string, methodName: string, ...args: any[]): Promise<any>;\n  // rawCall(to: Address, data: string): Promise<any>; // TODO ?\n}\n```\n\n---\n\n#### `deployments.deploy(<name>, options)`\n\n---\n\nThe `deploy` function, as mentioned above, allows you to deploy a contract and save it under a specific name.\n\nThe deploy function expect 2 parameters: one for the name and one for the options\n\nSee below the full list of fields that the option parameter allows and requires:\n\n```ts\nexport interface DeployOptions = {\n  from: string; // address (or private key) that will perform the transaction. you can use `getNamedAccounts` to retrived the address you want by name.\n  contract?: // this is an optional field. If not specified it defaults to the contract with the same name as the first parameter\n    | string // this field can be either a string for the name of the contract\n    | { // or abi and bytecode\n        abi: ABI;\n        bytecode: string;\n        deployedBytecode?: string;\n      };\n  args?: any[]; // the list of argument for the constructor (or the upgrade function in case of proxy)\n  skipIfAlreadyDeployed?: boolean; // if set it to true, will not attempt to deploy even if the contract deployed under the same name is different\n  log?: boolean; // if true, it will log the result of the deployment (tx hash, address and gas used)\n  linkedData?: any; // This allow to associate any JSON data to the deployment. Useful for merkle tree data for example\n  libraries?: { [libraryName: string]: Address }; // This let you associate libraries to the deployed contract\n  proxy?: boolean | string | ProxyOptions; // This options allow to consider your contract as a proxy (see below for more details)\n\n  // here some common tx options :\n  gasLimit?: string | number | BigNumber;\n  gasPrice?: string | BigNumber;\n  value?: string | BigNumber;\n  nonce?: string | number | BigNumber;\n\n  estimatedGasLimit?: string | number | BigNumber; // to speed up the estimation, it is possible to provide an upper gasLimit\n  estimateGasExtra?: string | number | BigNumber; // this option allow you to add a gas buffer on top of the estimation\n\n  autoMine?: boolean; // this force a evm_mine to be executed. this is useful to speed deployment on test network that allow to specify a block delay (ganache for example). This option basically skip the delay by force mining.\n  deterministicDeployment? boolean | string; // if true, it will deploy the contract at a deterministic address based on bytecode and constructor arguments. The address will be the same across all network. It use create2 opcode for that, if it is a string, the string will be used as the salt.\n  waitConfirmations?: number; // number of the confirmations to wait after the transactions is included in the chain\n};\n```\n\n---\n\n---\n\n## Handling contract using libraries\n\nIn the deploy function, one of the `DeployOptions` field is the `libraries` field. It allows you to associate external contract as libraries at the time of deployment.\n\nFirst, you have deploy the library using the `deploy` function, then when we deploy a contract that needs the linked library, we can pass the deployed library name and address in as an argument to the `libraries` object.\n\nFirst step: deploy the library:\n\n```js\nconst exampleLibrary = await deploy(\"ExampleLibary\", {\n    from: <deployer>\n});\n\n```\n\nExampleLibrary is now deployed to whatever network was chosen (`hardhat deploy --network <networkName>`)\n\nFor example, if we are deploying on Rinkeby, this library will get deployed on rinkeby, and the `exampleLibrary` variable will be a deployment object that contains the abi as well as the deployed address for the contract.\n\nNow that the library is deployed, we can link it in our next deployed contract.\n\n```js\nconst example = await deploy(\"Example\", {\n    from: <deployer>\n    args: [\"example string argument for the 'Example' contract constructor\"],\n    libraries: {\n        ExampleLibrary: exampleLibrary.address\n    }\n});\n\n```\n\nThis `libraries` object takes the name of the library, and its deployed address on the network. Multiple libraries can be passed into the `libraries` object.\n\n---\n\n---\n\n## Exporting Deployments\n\nApart from deployments saved in the `deployments` folder which contains all information available about the contract (compile time data + deployment data), `hardhat-deploy` allows you to export lightweight files.\n\nThese can be used for example to power your frontend with contract's address and abi.\n\nThis come into 2 flavors.\n\nThe first one is exported via the `--export <file>` option and follow the following format :\n\n```ts\nexport interface Export {\n  chainId: string;\n  name: string;\n  contracts: {[name: string]: ContractExport};\n}\n```\n\nwhere name is the name of the network configuration chosen (see hardhat option `--network`)\n\nThe second one is exported via the `--export-all <file>` option and follow the following format :\n\n```ts\nexport type MultiExport = {\n  [chainId: string]: Export[];\n};\n```\n\nAs you see the second format include the previous. While in most case you'll need the single export where your application will support only one network, there are case where your app would want to support multiple networks at nonce. This second format allow for that.\n\nFurthermore as hardhat support multiple network configuration for the same network (rinkeby, mainnet...), the export-all format will contains each of them grouped by their chainId.\n\n\nNote: from v0.10.4 the old multi-export down is no more:\n\n```\nexport type MultiExport = {\n  [chainId: string]: {[name: string]: Export};\n};\n```\n\n---\n\n---\n\n## Deploying and Upgrading Proxies\n\nAs mentioned above, the deploy function can also deploy a contract through a proxy. It can be done without modification of the contract as long as its number of constructor arguments matches the proxy initialization/update function.\n\nThe default Proxy is both ERC-1967 and ERC-173 Compliant, but other proxy can be specified, like openzeppelin transparent proxies.\n\nCode for the default Proxy can be found [here](solc_0.7/proxy/EIP173Proxy.sol).\n\nTo perform such proxy deployment, you just need to invoke the deploy function with the following options : `{..., proxy: true}`\n\nSee example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: true,\n  });\n};\n```\n\nYou can also set it to `proxy: \"<upgradeMethodName>\"` in which case the function `<upgradeMethodName>` will be executed upon upgrade.\nthe `args` field will be then used for that function instead of the contructor. It is also possible to then have a constructor with the same arguments and have the proxy be disabled. It can be useful if you want to have your contract as upgradeable in a test network but be non-upgradeable on the mainnet.\n\nSee example :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  network,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: network.live ? false : 'postUpgrade',\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nThe proxy option can also be an object which can set the specific owner that the proxy is going to be managed by.\n\nSee example:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: {\n      owner: greeterOwner,\n      methodName: 'postUpgrade',\n    },\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nNote that for the second invokation, this deployment will not be executed from the specified `from: deployer` as otherwise these tx will always fails. It will instead be automatically executed from the proxy's current owner (in that case : `greeterOwner`)\n\nNow, it is likely you do not want to locally handle the private key / mnemonic of the account that manage the proxy or it could even be that the `greeterOwner` in question is a multi sig. As such that second invocation will throw an error as it cannot find a local signer for it.\n\nThe error will output the necessary information to upgrade the contract but `hardhat-deploy` comes also with a utility function for such case: `deployments.catchUnknwonSigner` which will catch the error and output to the console the necessary information while continuing to next step.\n\nHere is the full example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy, catchUnknownSigner} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await catchUnknownSigner(\n    deploy('Greeter', {\n      from: deployer,\n      proxy: {\n        owner: greeterOwner,\n        methodName: 'postUpgrade',\n      },\n      args: ['arg1', 2, 3],\n    })\n  );\n  // you could pause the deployment here and wait for input to continue\n};\n```\n\nThe full proxy options is as follow:\n\n```ts\ntype ProxyOptionsBase = {\n  owner?: Address; // this set the owner of the proxy. further upgrade will need to be executed from that owner\n  upgradeIndex?: number; // allow you to breakdown your upgrades into separate deploy scriot, each with their own index. A deploy call with a specific upgradeIndex will be executed only once, only if the current upgradeIndex is one less.\n  proxyContract?: // default to \"EIP173Proxy\". See below for more details\n  string | ArtifactData;\n  viaAdminContract?: // allow to specify a contract that act as a middle man to perform upgrades. Useful and Recommended for Transparent Proxies\n  | string\n    | {\n        name: string;\n        artifact?: string | ArtifactData;\n      };\n};\n\nexport type ProxyOptions =\n  | (ProxyOptionsBase & {\n      methodName?: string; // method to be executed when the proxy is deployed for the first time or when the implementation is modified. Use the deployOptions args field for arguments\n    })\n  | (ProxyOptionsBase & {\n      execute?:\n        | {\n            methodName: string; // method to be executed when the proxy is deployed for the first time or when the implementation is modified.\n            args: any[];\n          }\n        | {\n            init: {\n              methodName: string; // method to be executed when the proxy is deployed\n              args: any[];\n            };\n            onUpgrade?: {\n              methodName: string; // method to be executed when the proxy is upgraded (not first deployment)\n              args: any[];\n            };\n          };\n    });\n```\n\nThe `proxyContract` field allow you to specify your own Proxy contract. If it is a string, it will first attempt to get an artifact with that name. If not found it will fallback on the following if\n\nit matches:\n\n- `EIP173Proxy`: use the default Proxy that is EIP-173 compliant\n\n- `EIP173ProxyWithReceive`: Same as above except that the proxy contains a receive hook to accept empty ETH payment.\n\n- `OpenZeppelinTransparentProxy`: Use Openzeppelin Transparent Proxy (copied from openzeppelin repo, see code [here](solc_0.7/openzeppelin/proxy/TransparentUpgradeableProxy.sol))\n  When this option is chosen, the `DefaultProxyAdmin` is also used as admin since Transparent Proxy kind of need an intermediarry contract for administration. This can be configured via the `viaAdminContract` option. Note that the DefaultProxyAdmin is slightly different than the one used by openzeppelin as it allow you to set a different owner than msg.sender on first deploy, something openzeppelin version do not allow, see : https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2639\n\n- `OptimizedTransparentProxy`: This contract is similar to above, except that it is optimized to not require storage read for the admin on every call.\n\n## Builtin-In Support For Diamonds (EIP2535)\n\nThe deployments field also expose the diamond field: `hre.deployments.diamond` that let you deploy [Diamonds](https://eips.ethereum.org/EIPS/eip-2535) in an easy way.\n\nInstead of specifying the facets to cut out or cut in, which the diamond contract expects, you specify the facets you want to end up having on the deployed contract.\n\n`diamond.deploy` expect the facet as names. The names represent contract to be deployed as facet. In future version you ll be able to specify deployed contract or artifact object as facet.\n\nTo deploy a contract with 3 facet you can do as follow :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: deployer,\n    owner: diamondAdmin,\n    facets: ['Facet1', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nif you then later execute the following script:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: diamondAdmin, // this need to be the diamondAdmin for upgrade\n    owner: diamondAdmin,\n    facets: ['NewFacet', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nThen the NewFacet will be deployed automatically if needed and then the diamondCut will cut Facet1 out and add NewFacet.\n\nNote that if the code for Facet2 and Facet3 changes, they will also be redeployed automatically and the diamondCuts will replace the existing facets with these new ones.\n\nNote that The Diamond contract's code is part of `hardhat-deploy` and contains 3 built-in facet that can be removed manually if desired.\nThese facets are used for ownership, diamondCut and diamond loupe.\n\nThe implementation is the [reference implementation by Nick Mudge](https://github.com/mudgen/diamond-3)\n\nLike normal proxies you can also execute a function at the time of an upgrade.\n\nThis is done by specifying the execute field in the diamond deploy options :\n\n```js\ndiamond.deploy('ADiamondContract', {\n  from: deployer,\n  owner: diamondAdmin,\n  facets: ['NewFacet', 'Facet2', 'Facet3'],\n  execute: {\n    methodName: 'postUpgrade',\n    args: ['one', 2, '0x3'],\n  },\n});\n```\n\nSince the diamond standard has no builtin mechanism to make the deployment of Diamond with function execution, the Diamond when deployed is actually deployed through a special contract, the `Diamantaire` (see code [here](solc_0.7/diamond/Diamantaire.sol)) that act as factory to build Diamond. It uses deterministic deployment for that so, it is transparently managed by `hardhat-deploy`. It also embed the implementation of the builtin facet, removing the need to have different instances of each live.\n\n<!-- The Diamantaire also support the deterministic deployment of Diamonds.\nAn extra field can be passed to the Diamond deployment options : `deterministicSalt`. It has to be a non-zero 32bytes string (in hex format).\nNote that if you want to deploy 2 diamonds with same owner, you'll need 2 different deterministicSalt for them to be 2 separate contracts. -->\n\n## Testing Deployed Contracts\n\nYou can continue using the usual test task:\n\n`hardhat test`\n\nTests can use the `hre.deployments.fixture` function to run the deployment and snapshot it so that tests don't need to perform all the deployment transactions every time. They can simply reuse the snapshot for every test (this leverages `evm_snapshot` and `evm_revert` provided by both `hardhat` and `ganache`). You can for example set them in a `beforeEach`.\n\nHere is an example of a test :\n\n```js\nconst {deployments} = require('hardhat');\n\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    await deployments.fixture(['Token']);\n    const Token = await deployments.get('Token'); // Token is available because the fixture was executed\n    console.log(Token.address);\n    const ERC721BidSale = await deployments.get('ERC721BidSale');\n    console.log({ERC721BidSale});\n  });\n});\n```\n\nTests can also leverage named accounts for clearer test. Combined with `hardhat-deploy-ethers` plugin, you can write succint test :\n\n```js\nconst {ethers, getNamedAccounts} = require('hardhat');\n\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    await deployments.fixture(['Token']);\n    const {tokenOwner} = await getNamedAccounts();\n    const TokenContract = await ethers.getContract('Token', tokenOwner);\n    await TokenContract.mint(2).then((tx) => tx.wait());\n  });\n});\n```\n\n---\n\n### Creating Fixtures\n\nFurthermore, tests can easily create efficient fixture using `deployments.createFixture`\n\nSee example :\n\n```js\nconst setupTest = deployments.createFixture(\n  async ({deployments, getNamedAccounts, ethers}, options) => {\n    await deployments.fixture(); // ensure you start from a fresh deployments\n    const {tokenOwner} = await getNamedAccounts();\n    const TokenContract = await ethers.getContract('Token', tokenOwner);\n    await TokenContract.mint(10).then((tx) => tx.wait()); //this mint is executed once and then `createFixture` will ensure it is snapshotted\n    return {\n      tokenOwner: {\n        address: tokenOwner,\n        TokenContract,\n      },\n    };\n  }\n);\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    const {tokenOwner} = await setupTest();\n    await tokenOwner.TokenContract.mint(2);\n  });\n});\n```\n\nWhile this example is trivial, some fixture can requires several transaction and the ability to snapshot them automatically speed up the tests greatly.\n\n---\n\n---\n\n## More Information On Hardhat Tasks\n\n---\n\n### **1. node task**\n\nas mentioned above, the node task is slighly modified and augmented with various flags and options\n\n`hardhat node`\n\nIn particular it adds an argument `--export` that allows you to specify a destination file where the info about the contracts deployed is written.\nYour webapp can then access all contracts information.\n\n---\n\n### **2. test task**\n\n`hardhat test`\n\nthe test task is augmented with one flag argument `--deploy-fixture` that allows to run all deployments in a fixture snapshot before executing the tests. This can speed up the tests that use specific tags as the global fixture take precedence (unless specified).\n\nIn other word tests can use `deployments.fixture(<specific tag>)` where specific tag only deploys the minimal contracts for tests, while still benefiting from global deployment snapshot if used.\n\nIf a test needs the deployments to only include the specific deployment specified by the tag, it can use the following :\n\n```js\ndeployments.fixture('<specific tag>', {fallbackToGlobal: false});\n```\n\nDue to how snapshot/revert works in hardhat, this means that these tests will not benefit from the global fixture snapshot and will have to deploy their contracts as part of the fixture call. This is automatic but means that these tests will run slower.\n\n---\n\n### **3. run task**\n\n`hardhat --network <networkName> run <script>`\n\nThe run task act as before but thanks to the `hre.deployments` field it can access deployed contract :\n\n```js\nconst hre = require('hardhat');\nconst {deployments, getNamedAccounts} = hre;\n\n(async () => {\n  console.log(await deployments.all());\n  console.log({namedAccounts: await getNamedAccounts()});\n})();\n```\n\nYou can also run it directly from the command line as usual.\n\n`HARDHAT_NETWORK=rinkeby node <script>` is the equivalent except it does not load the hardhat environment twice (which the run task does)\n\n---\n\n### **4. console task**\n\n`hardhat console`\n\nThe same applies to the `console` task.\n\n---\n\n## Deploy Scripts: Tags And Dependencies\n\n---\n\nIt is possible to execute only specific parts of the deployments with `hardhat deploy --tags <tags>`\n\nTags represent what the deploy script acts on. In general it will be a single string value, the name of the contract it deploys or modifies.\n\nThen if another deploy script has such tag as a dependency, then when this latter deploy script has a specific tag and that tag is requested, the dependency will be executed first.\n\nHere is an example of two deploy scripts :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const deployResult = await deploy('Token', {\n    from: deployer,\n    args: ['hello', 100],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Token deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Token'];\n```\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const Token = await deployments.get('Token');\n  const deployResult = await deploy('Sale', {\n    from: deployer,\n    contract: 'ERC721BidSale',\n    args: [Token.address, 1, 3600],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Sale deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.dependencies = ['Token']; // this ensure the Token script above is executed first, so `deployments.get('Token')` succeeds\n```\n\nAs you can see the second one depends on the first. This is because the second script depends on a tag that the first script registers as using.\n\nWith that when `hardhat deploy --tags Sale` is executed\n\nthen both scripts will be run, ensuring Sale is ready.\n\nYou can also define the script to run after another script is run by setting `runAtTheEnd` to be true. For example:\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, execute, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer, admin} = namedAccounts;\n  await execute('Sale', {from: deployer}, 'setAdmin', admin);\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.runAtTheEnd = true;\n```\n\nTags can also be used in test with `deployments.fixture`. This allow you to test a subset of the deploy script.\n","readmeFilename":"README.md","gitHead":"3216a3110cf6ba0878dc613733a50dfb98e3ca03","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.0-next.4","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-dC4NiXm6kPCfp7Zg/ffr5/cnR+zfNImt10B2xdCXZ6lS3xb2Zdm2WsEklH60eu3z21NNaFa0VqQzabN//p1Ojg==","shasum":"0e93bd47602c165b94917111aab6507599865cc3","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.0-next.4.tgz","fileCount":149,"unpackedSize":12105891,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiHJN3ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmpTow//SMR0fDrNi1vQhLJGj+Ud9D2yQrNflZ1nYiHZyJZ2cWUXoZyl\r\nE/ok4pFzVGZ3QqJqEkn4q1aOwjtUF/2H1lLaMiVkuxaynK8B//I7kTldFjV+\r\ngiMlq2bQKq4EZvHcOonqibKsrSQkp0YfASCy1Hl7QVQ4/LBuHIpmNZB70sWh\r\n8xK8u5tUaxbSqXVmh59xHmcSo5QALCDcmgPbdEo4OatGwukVmHMSQ4BKImjm\r\n2ir1wDspWqeOr+aof6z+nx4+iCVqmlpPCWkOwjL1vUQJkI+AJrozhSDZeyeq\r\n+uEHnzcRgoa3dde6na5opXjYF8n55yrmT8IQNCpQtdvSOW08xRdUdru+Onp7\r\ne3cVjA8hOQimoL+wkwdRscJLxvD73QGmx2zdvFBYomvg1mndVLFBCwS71v21\r\nbiId+WL+FaBDzlUa0ryWugD78P6+DbA+bCgiKXsmhd5C1ZsN6sT27/aACwf/\r\nu7SB/VclzJJL8uvP9yHw6gxjiFXlRRvsWsWLQPTfstEdhVI8fS1SfOQ90s04\r\n84Lp/7ZP6LtKRRscrJsaRTbZyF32bFdcvsbXIbL8yHvQM35fFGeqKi7ebgMu\r\nLbpdfZlQjF/tuvB1NU5KRsBQ6aN//1lI+yiNOts9EyLI0kVtZ+1qlnXFA1A3\r\ntcWFMzlzWJFnhMKk3BLVzp3spU535quHIZA=\r\n=Af7x\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCSdfj1INnRAMJpdizGcwpviUayiUsOrFoyYaccWV4exwIgd1Gtd9CPf1jxCqUv0LseW3yM6NYSq7DTSoy8jnSte5Q="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.0-next.4_1646039927187_0.41463463713328297"},"_hasShrinkwrap":false},"0.11.0-next.5":{"name":"hardhat-deploy","version":"0.11.0-next.5","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.8","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.6.8"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"081004268e4a1055e892d35fc422275b1788d794","readme":"<h1> hardhat-deploy</h1>\n\n_A [Hardhat](https://hardhat.org) Plugin For Replicable Deployments And Easy Testing_\n\n> **A complete dev template using hardhat-deploy is available here** : https://github.com/wighawag/template-ethereum-contracts\n> It also contains various branches examplifying the capability of hardhat-deploy. Check it out.\n\n- [What is it for ?](#what-is-it-for-)\n- [hardhat-deploy in a nutshell](#hardhat-deploy-in-a-nutshell)\n- [Installation](#installation)\n  - [npm install hardhat-deploy](#npm-install-hardhat-deploy)\n  - [TypeScript support](#typescript-support)\n  - [Migrating existing deployment to hardhat-deploy](#migrating-existing-deployment-to-hardhat-deploy)\n- [Hardhat Tasks Available/Updated](#hardhat-tasks-availableupdated)\n  - [1. hardhat deploy](#1-hardhat-deploy)\n    - [**Options**](#options)\n    - [**Flags**](#flags)\n  - [2. hardhat node](#2-hardhat-node)\n    - [**Options**](#options-1)\n    - [**Flags**](#flags-1)\n  - [3. hardhat test](#3-hardhat-test)\n  - [4. hardhat etherscan-verify](#4-hardhat-etherscan-verify)\n    - [**Options**](#options-2)\n  - [5. hardhat sourcify](#5-hardhat-sourcify)\n    - [**Options**](#options-3)\n  - [6. hardhat export](#6-hardhat-export)\n    - [**Options**](#options-4)\n- [Hardhat Environment Extensions](#hardhat-environment-extensions)\n- [Configuration](#configuration)\n  - [**1. namedAccounts (ability to name addresses)**](#1-namedaccounts-ability-to-name-addresses)\n  - [**2. extra hardhat.config networks' options**](#2-extra-hardhatconfig-networks-options)\n    - [`live`](#live)\n    - [`saveDeployments`](#savedeployments)\n    - [`tags`](#tags)\n    - [`deploy`](#deploy)\n    - [`companionNetworks`](#companionnetworks)\n  - [**3. extra hardhat.config paths' options**](#3-extra-hardhatconfig-paths-options)\n  - [**4. deterministicDeployment (ability to specify a deployment factory)**](#4-deterministicdeployment-ability-to-specify-a-deployment-factory)\n  - [Importing deployment from other projects (with truffle support)](#importing-deployment-from-other-projects-with-truffle-support)\n  - [Access to Artifacts (non-deployed contract code and abi)](#access-to-artifacts-non-deployed-contract-code-and-abi)\n- [How to Deploy Contracts](#how-to-deploy-contracts)\n  - [The `deploy` Task](#the-deploy-task)\n  - [Deploy Scripts](#deploy-scripts)\n    - [An example of a deploy script :](#an-example-of-a-deploy-script-)\n  - [The `deployments` field](#the-deployments-field)\n    - [`deployments.deploy(<name>, options)`](#deploymentsdeployname-options)\n- [Handling contract using libraries](#handling-contract-using-libraries)\n- [Exporting Deployments](#exporting-deployments)\n- [Deploying and Upgrading Proxies](#deploying-and-upgrading-proxies)\n- [Builtin-In Support For Diamonds (EIP2535)](#builtin-in-support-for-diamonds-eip2535)\n- [Testing Deployed Contracts](#testing-deployed-contracts)\n  - [Creating Fixtures](#creating-fixtures)\n- [More Information On Hardhat Tasks](#more-information-on-hardhat-tasks)\n  - [**1. node task**](#1-node-task)\n  - [**2. test task**](#2-test-task)\n  - [**3. run task**](#3-run-task)\n  - [**4. console task**](#4-console-task)\n- [Deploy Scripts: Tags And Dependencies](#deploy-scripts-tags-and-dependencies)\n\n## What is it for ?\n\nThis [hardhat](https://hardhat.org) plugin adds a mechanism to deploy contracts to any network, keeping track of them and replicating the same environment for testing.\n\nIt also adds a mechanism to associate names to addresses, so test and deployment scripts can be reconfigured by simply changing the address a name points to, allowing different configurations per network. This also results in much clearer tests and deployment scripts (no more `accounts[0]` in your code).\n\nThis plugin contains a lot more features too, all geared toward a better developer experience :\n\n- chain configuration export\n- listing deployed contracts' addresses and their abis (useful for webapps)\n- library linking at time of deployment.\n- deterministic deployment across networks.\n- support for specific deploy script per network (L1 vs L2 for example)\n- ability to access deployment from \"companion\" networks\n- deployment dependency system (allowing you to only deploy what is needed).\n- deployment retrying (by saving pending tx): so you can feel confident when making a deployment that you can always recover.\n- deployments as test fixture using `evm_snapshot` to speed up testing.\n- ability to create your own test fixture that automatically benefits from `evm_snapshot`'s tests speed-up boost\n- combined with [hardhat-deploy-ethers](https://github.com/wighawag/hardhat-deploy-ethers) it has the ability to get ethers contract instance by name (like `await ethers.getContract(\"ContractName\")`).\n- importing artifact from external sources (like npm packages), including [truffle](https://www.trufflesuite.com/truffle) support.\n- importing deployments from external sources (like npm packages)\n- ability to log information in `deploy` mode only (while in test the console remains clean).\n- contains helpers to read and execute transaction on deployed contract referring to them by name.\n- These helpers contains options to auto mine on dev network (to speed up test deployments).\n- save metadata of deployed contract so they can always be fully verified, via [sourcify](https://sourcify.dev) or [etherscan](https://etherscan.io).\n- ability to submit contract source to etherscan and sourcify for verification at any time. (Because **hardhat-deploy** will save all the necessary info, it can be executed at any time.)\n- support harhdat's fork feature so deployment can be accessed even when run through fork.\n- named accounts are automatically impersonnated too, so you can perform tx as if you had their private key.\n- proxy deployment with ability to upgrade them transparently, only if code changes.\n- this include support for [openzeppelin](https://openzeppelin.com) transparent proxies\n- diamond deployment with facets, allowing you to focus on what the new version will be. It will generate the diamondCut necessary to reach the new state.\n- watch and deploy: **hardhat-deploy** can watch both your deploy script and contract code and redeploy on changes.\n- HCR (Hot Contract Replacement): the watch feature combined with proxy or diamond, gives you an experience akin to frontend Hot Module Replacement: once your contract changes, the deployment is executed and your contract retains the same address and same state, allowing you to tweak your contracts while debugging your front-end.\n\n## hardhat-deploy in a nutshell\n\nBefore going into the details, here is a very simple summary of the basic feature of **hardhat-deploy**.\n\n**hardhat-deploy** allows you to write [`deploy scripts`](#deploy-scripts) in the `deploy` folder. Each of these files that look as follows will be executed in turn when you execute the following task: `hardhat --network <networkName> deploy`\n\n```js\n// deploy/00_deploy_my_contract.js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('MyContract', {\n    from: deployer,\n    args: ['Hello'],\n    log: true,\n  });\n};\nmodule.exports.tags = ['MyContract'];\n```\n\nFurthermore you can also ensure these scripts are executed in test too by calling `await deployments.fixture(['MyContract'])` in your test.\nThis is optimized, so if multiple tests use the same contract, the deployment will be executed once and each test will start with the exact same state.\n\nThis is a huge benefit for testing since you are not required to replicate the deployment procedure in your tests. The tag feature (as seen in the script above) and [dependencies](#deploy-scripts-tags-and-dependencies) will also make your life easier when writing complex deployment procedures.\n\nYou can even group deploy scripts in different sub folder and ensure they are executed in their logical order.\n\nFurthermore hardhat-deploy can also support a multi-chain settings like L1, L2 with multiple deploy folder specific to each network.\n\n**All of this can also be bundled in a npm package so user of hardhat-deploy can reuse your deployment procedure and get started integrating with your project locally.**\n\nThere is a tutorial covering the basics here : https://github.com/wighawag/tutorial-hardhat-deploy\n\n## Installation\n\n### npm install hardhat-deploy\n\n```bash\nnpm install -D hardhat-deploy\n```\n\nAnd add the following statement to your `hardhat.config.js`:\n\n```js\nrequire('hardhat-deploy');\n```\n\nif you use `ethers.js` we recommend you also install `hardhat-deploy-ethers` which add extra features to access deployments as ethers contract.\n\nSince `hardhat-deploy-ethers` is a fork of `@nomiclabs/hardhat-ethers` and that other plugin might have an hardcoded dependency on `@nomiclabs/hardhat-ethers` the best way to install `hardhat-deploy-ethers` and ensure compatibility is the following:\n\n```bash\nnpm install --save-dev  @nomiclabs/hardhat-ethers@npm:hardhat-deploy-ethers ethers\n```\n\nWhich means you then need to do `require(\"@nomiclabs/hardhat-ethers\")` instead of `require(\"hardhat-deploy-ethers\")` in your `hardhat.config.js` file.\n\nMore details on `hardhat-deploy-ethers` repo : https://github.com/wighawag/hardhat-deploy-ethers#readme\n\n### TypeScript support\n\nWith hardhat the tsconfig.json is optional.\n\nBut if you add folders to the `include` field in `tsconfig.json`, you ll also need to include `hardhat.config.ts` like :\n\n`include\": [\"./hardhat.config.ts\", \"./scripts\", \"./deploy\", \"./test\"]`\n\nfor deploy script (see below) you can write them this way to benefit from typing :\n\n```ts\nimport {HardhatRuntimeEnvironment} from 'hardhat/types';\nimport {DeployFunction} from 'hardhat-deploy/types';\n\nconst func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {\n  // code here\n};\nexport default func;\n```\n\nSee a template that uses **hardhat-deploy** here : https://github.com/wighawag/template-ethereum-contracts\n\nThis repo has also some examples branch that exemplify specific features, like the forking testing here : https://github.com/wighawag/template-ethereum-contracts/tree/examples/fork-test\n\n### Migrating existing deployment to hardhat-deploy\n\n> Only needed for existing project that already deployed contracts and has the deployment information available **(at minimum, address and abi)**\n\nYou might want to switch your current deployment process to use **hardhat-deploy**. In that case you probably have some deployments saved elsewhere.\n\nIn order to port them to **hardhat-deploy**, you'll need to create one `.json` file per contract in the `deployments/<network>` folder (configurable via [paths config](#extra-paths-config)).\n\nThe network folder is simply the hardhat network name (as configured in hardhat.config.js) (accessible at runtime via `hre.network.name`).\nSuch folder need to have a file named `.chainId` containing the chainId as decimal.\n\nFor example for network named \"rinkeby\" (for the corresponding network) the file `deployments/rinkeby/.chainId` would be\n\n```\n4\n```\n\nNote, prior to hardhat 0.6 the chainId was appended to the folder name (expect for some known network name). This has changed and upgrading to 0.6 will require you to change the folder name and add the '.chainId' file.\n\nEach contract file must follow this type (as defined in [types.ts](types.ts)) :\n\n```ts\nexport interface Deployment {\n  address: Address;\n  abi: ABI;\n  receipt?: Receipt;\n  transactionHash?: string;\n  history?: Deployment[];\n  numDeployments?: number;\n  implementation?: string;\n  args?: any[];\n  linkedData?: any;\n  solcInputHash?: string;\n  metadata?: string;\n  bytecode?: string;\n  deployedBytecode?: string;\n  libraries?: Libraries;\n  userdoc?: any;\n  devdoc?: any;\n  methodIdentifiers?: any;\n  diamondCut?: FacetCut[];\n  facets?: Facet[];\n  storageLayout?: any;\n  gasEstimates?: any;\n}\n```\n\nAs you can see, only abi and address are mandatory. But having the other fields allow more feature. For example, metadata and args allow you to benefit from contract code verification.\n\nFor Receipt, the following type is expected:\n\n```ts\nexport type Receipt = {\n  from: string;\n  transactionHash: string;\n  blockHash: string;\n  blockNumber: number;\n  transactionIndex: number;\n  cumulativeGasUsed: string;\n  gasUsed: string;\n  contractAddress?: string;\n  to?: string;\n  logs?: Log[];\n  events?: any[];\n  logsBloom?: string;\n  byzantium?: boolean;\n  status?: number;\n  confirmations?: number;\n};\n```\n\nHere is an example:\n\nLet's say you have:\n\n- 2 Contract named Greeter and Registry deployed on rinkeby\n- 1 contract named Greeter on mainnet\n- 2 Contract named Greeter and Registry deployed on a network named rinkeby2\n\nYou would get the following folder structure:\n\n```\ndeployments/\n  mainnet/\n    .chainId\n    Greeter.json\n  rinkeby/\n    .chainId\n    Greeter.json\n    Registry.json\n  rinkeby2/\n    .chainId\n    Greeter.json\n    Registry.json\n```\n\nThe reason why **hardhat-deploy** save chainId in the `.chainId` file is both for\n\n- safety: so that if you were to change the network name to point to a different chain, it would not attempt to read the wrong folder and assume that a contract has been deployed while it has not.\n- ability to know the chainId without requring to be connected to a node (and so not dependent on hardhat.config.js settings). Useful for `export` task.\n\n---\n\n## Hardhat Tasks Available/Updated\n\nhardhat deploy add several task to hardhat. It also modify existing one, adding new options and new behavior. All of these are described here:\n\n---\n\n### 1. hardhat deploy\n\n---\n\nThis plugin adds the _deploy_ task to Hardhat.\n\nThis task will execute the scripts in the `deploy` folder and save the contract deployments to disk. These deployments are supposed to be saved for example in a git repository. This way they can be accessed later. But you are free to save them elsewhere and get them back via your mechanism of choice.\n\nWith the deployment saved, it allows you to deploy a contract only if changes were made.\n\nDeploy scripts (also called Deploy functions) can also perform aribtrary logic.\n\nFor further details on how to use it and write deploy script, see [section](#deploy-scripts) below.\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployments, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice (in wei) to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--reset`: This flag resets the deployments from scratch. Previously deployed contract are not considered and deleted from disk.\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n---\n\n### 2. hardhat node\n\n---\n\nThis plugin modify the _node_ task so that it also execute the deployment script before exposing the server http RPC interface\n\nIt add similar options than the `deploy` task :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--no-reset`: This flag prevent the reseting of the existing deployments. This is usually not desired when running the `node` task as a network is created from scratch and previous deployemnt are irrelevant.\n\n`--show-accounts`: this flag will output the account private keys\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n`--no-deploy` that discard all other options to revert to normal `hardhat node` behavior without any deployment being performed.\n\n> :warning: Note that the deployments are saved as if the network name is `localhost`. This is because `hardhat node` is expected to be used as localhost: You can for example execute `hardhat --network localhost console` after `node` is running. Doing `hardhat --network hardhat console` would indeed not do anything useful. It still take the configuration from `hardhat` in the hardhat.config.js file though.\n\n---\n\n### 3. hardhat test\n\n---\n\nThis plugin adds a flag argument `--deploy-fixture` to the _test_ task which if enabled will run the global deployments fixture before the tests and snapshots it. This will generaly speed up the tests as further test will be able to revert back to the full deployment.\n\n> :warning: Note though that if your test behave differently whether that option is on or not, this most likely mean that your deploy scripts' tags and dependencies are not configured correctly. This is because the global fixture will ensure all contract are deployed while test will usually (for efficiency) ask for a particular tag.\n\n---\n\n### 4. hardhat etherscan-verify\n\n---\n\nThis plugin adds the _etherscan-verify_ task to Hardhat.\n\nThis task will submit the contract source and other info of all deployed contracts to allow etherscan to verify and record the sources.\n\nInstead of using the full solc input, this task will first attempt to send the minimal sources from the metadata.\nBut Etherscan sometime fails due to a bug in solidity compiler (<https://github.com/ethereum/solidity/issues/9573>). As such this task can fallback on full solc input (see option --solc-input). Note that if your contract was deployed with a previous version of **hardhat-deploy**, it might not contains the full information. The issue seems to be fully resolved since solc version 0.8.\n\nThis task will also attempt to automatically find the SPDX license in the source.\n\nTo execute that task, you need to specifiy the network to run against :\n\n```bash\nhardhat --network mainnet etherscan-verify [--api-key <apikey>] [--apiurl <url>]\n```\n\n#### **Options**\n\nNote that harhdat-deploy now use a different config format to not conflict with `hardhat-etherscan`\n\n`--api-key <api key>`: let you specify your etherscan api key. Alternatively, you can provide it via the env variable `ETHERSCAN_API_KEY` or through the hardhat.config.ts verify field:\n\n```js\n{\n  ...\n  verify: {\n    etherscan: {\n      apiKey: '<API key>'\n    }\n  }\n}\n```\n\n`--api-url <url>`: let you specify your etherscan url to submit the source to. Can also be configured per network in `hardhat.config.js`:\n\n```js\n{\n  ...\n  networks: {\n    mynetwork: {\n      ...\n      verify: {\n        etherscan: {\n          apiUrl: 'http://mynetwork.xyz'\n        }\n      }\n    }\n  }\n}\n```\n\n`--license <SPDX license id>`: SPDX license (useful if SPDX is not listed in the sources), need to be supported by etherscan: https://etherscan.io/contract-license-types\n\n`--force-license`: if set, will force the use of the license specified by --license option, ignoring the one in the source (useful for license not supported by etherscan)\n\n`--solc-input`: fallback on solc-input id needed (useful when etherscan fails on the minimum sources, see https://github.com/ethereum/solidity/issues/9573)\n\n`--sleep`: sleep 500ms between each verification, so API rate limit is not exceeded\n\n---\n\n### 5. hardhat sourcify\n\n---\n\nThis plugin adds the _sourcify_ task to Hardhat.\n\nSimilar to `hardhat etherscan-verify` this task will submit the contract source and other info of all deployed contracts to sourcify.\n\n```bash\nhardhat --network mainnet sourcify\n```\n\nLater this task might instead pin the metadata to ipfs, so sourcify can automatically verify them.\n\n#### **Options**\n\n`--endpoint <endpoint>`: specify the sourcify endpoint, default to https://sourcify.dev/server/\n\n`--write-failing-metadata`: if set and the sourcify task fails to verify, the metadata file will be written to disk, so you can more easily figure out what has gone wrong.\n\n---\n\n### 6. hardhat export\n\n---\n\nThis plugin adds the _export_ task to Hardhat.\n\nThis task will export the contract deployed (saved in `deployments` folder) to a file with a simple format containing only contract addresses and abi, useful for web apps.\n\nOne of the following options need to be set for this task to have any effects :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\nThis last option has some limitations, when combined with the use of external deployments (see [Configuration](#configuration)). If such external deployments were using older version of **hardhat-deploy** or truffle, the chainId might be missing. In order for these to be exported, the hardhat network config need to explicity state the chainId in the `networks` config of `hardhat.config.js`.\n\nWith both `--export` and `--export-all`, using the special `<filepath>` value of `-` will output to `STDOUT` rather than writing a normal file.\n\n---\n\n---\n\n## Hardhat Environment Extensions\n\nThis plugin extends the Hardhat Runtime Environment by adding 4 fields:\n\n- `getNamedAccounts: () => Promise<{ [name: string]: string }>`: a function returning an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [Configuration](#configuration)).\n\n- `getUnnamedAccounts: () => Promise<string[]}>`: accounts which has no names, useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`: contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId(): Promise<string>`: offer an easy way to fetch the current chainId.\n\n---\n\n---\n\n## Configuration\n\n---\n\n### **1. namedAccounts (ability to name addresses)**\n\n---\n\nThis plugin extends the `HardhatConfig`'s object with an optional `namedAccounts` field.\n\n`namedAccounts` allows you to associate names to addresses and have them configured per chain.\nThis allows you to have meaningful names in your tests while the addresses match to multi sig in real network for example.\n\n```js\n{\n    namedAccounts: {\n        deployer: {\n            default: 0, // here this will by default take the first account as deployer\n            1: 0, // similarly on mainnet it will take the first account as deployer. Note though that depending on how hardhat network are configured, the account 0 on one network can be different than on another\n            4: '0xA296a3d5F026953e17F472B497eC29a5631FB51B', // but for rinkeby it will be a specific address\n            \"goerli\": '0x84b9514E013710b9dD0811c9Fe46b837a4A0d8E0', //it can also specify a specific netwotk name (specified in hardhat.config.js)\n        },\n        feeCollector:{\n            default: 1, // here this will by default take the second account as feeCollector (so in the test this will be a different account than the deployer)\n            1: '0xa5610E1f289DbDe94F3428A9df22E8B518f65751', // on the mainnet the feeCollector could be a multi sig\n            4: '0xa250ac77360d4e837a13628bC828a2aDf7BabfB3', // on rinkeby it could be another account\n        }\n    }\n}\n```\n\n<!-- You can also specify addresses with the `ledger://` prefix. In which case the account fetched will still be the corresponding address, but behind the scene, the transaction will be created via the hardware waller. Currently the feature is not working very well though and better support is needed. -->\n\n---\n\n### **2. extra hardhat.config networks' options**\n\n---\n\n**hardhat-deploy** add 5 new fields to `networks` configuration\n\n#### `live`\n\nthis is not used internally but is useful to perform action on a network whether it is a live network (rinkeby, mainnet, etc) or a temporary one (localhost, hardhat). The default is true (except for localhost and hardhat where the default is false).\n\n#### `saveDeployments`\n\nthis tell whether **hardhat-deploy** should save the deployments to disk or not. Default to true, except for the hardhat network.\n\n#### `tags`\n\nnetwork can have tags to represent them. The config is an array and at runtime the hre.network.tags is an object whose fields (the tags) are set to true.\n\nThis is useful to conidtionaly operate on network based on their use case.\n\nExample:\n\n```js\n{\n  networks: {\n    localhost: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"local\"]\n    },\n    hardhat: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"test\", \"local\"]\n    },\n    rinkeby: {\n      live: true,\n      saveDeployments: true,\n      tags: [\"staging\"]\n    }\n  }\n}\n```\n\n#### `deploy`\n\nthe deploy field override the paths.deploy option and let you define a set of folder containing the deploy scripts to be executed for this network.\n\nYou can thus have one network that will be executing L1 deployment and other L2 deployments, etc...\n\nYou could also have a folder that deploy contracts that are live on mainnet but that you need to replicate for your test or local network.\n\n#### `companionNetworks`\n\nthe companionNetworks field is an object whose key is any name you desire and the value is the name of a network that will be accessible inside the deploy script. For example:\n\n```js\n{\n  ...\n  networks: {\n    optimism: {\n      url: 'http://127.0.0.1:8545',\n      ovm: true,\n      companionNetworks: {\n        l1: 'localhost',\n      },\n    }\n  }\n  ...\n}\n```\n\nBy using name you can have the same deploy script used in different set of network.\n\nFor your test you could have the companion networks pointing to the same hardhat network, for test deployment, you could have rinkeby acting like your l2 while goerli act as your l1.\n\nAn example repo that show case a multi-network setup with optimism can be found here : https://github.com/wighawag/template-ethereum-contracts/tree/examples/optimism\n\ndeploy script can then access the network and its deployment as follow :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  const OVM_L1ERC20Gateway = await hre.companionNetworks['l1'].deployments.get(\n    'OVM_L1ERC20Gateway'\n  ); // layer 1\n\n  await execute(\n    'SimpleERC20_OVM',\n    {from: deployer, log: true},\n    'init',\n    OVM_L1ERC20Gateway.address\n  );\n};\n```\n\n---\n\n### **3. extra hardhat.config paths' options**\n\n---\n\n`hardhat-deploy` also adds fields to `HardhatConfig`'s `ProjectPaths` object.\n\nHere is an example showing the default values :\n\n```js\n{\n    paths: {\n        deploy: 'deploy',\n        deployments: 'deployments',\n        imports: 'imports'\n    }\n}\n```\n\nThe `deploy` folder is expected to contains the deploy script that are executed upon invocation of `hardhat deploy` or `hardhat node`.\nIt can also be an array of folder path.\n\nThe `deployments` folder will contains the resulting deployments (contract addresses along their abi, bytecode, metadata...). One folder per network and one file per contract.\n\nThe `imports` folder is expected to contains artifacts that were pre-compiled. Useful if you want to upgrade to a new solidity version but want to keep using previously compiled contracts. The artifact is the same format as normal hardhat artifact, so you can easily copy them over, before switching to a new compiler version.\n\n> This is less useful now that hardhat support multiple solidity compiler at once.\n\n---\n\n---\n\n### **4. deterministicDeployment (ability to specify a deployment factory)**\n\n---\n\nThis plugin extends the `HardhatConfig`'s object with an optional `deterministicDeployment` field.\n\n`deterministicDeployment` allows you to associate information that are used on each network for deterministic deployment. The information for each deterministic deployment consist out of a `factory`, a `deployer`, the required `funding` and a `signedTx` to deploy the factory. The default deterministic deployment used is the [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy). The factory expects a 32 bytes `salt` concatenated with the deployment data (see [EIP-1014](https://eips.ethereum.org/EIPS/eip-1014) for more information on these parameters).\n\nUsing the `deterministicDeployment` it is possible to define a different setup for the deterministic deployment. One use case for this is the deterministic deployment on networks that required replay protection (such as Celo or Avalanche). The [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy) can only be deployed on networks that don't enforce replay protection, therefore on other networks an alternative library has to be used. An example for this would be the [Safe Singleton Factory](https://github.com/gnosis/safe-singleton-factory) that is an adjusted version of the [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy) that contains signed transactions that include replay protection.\n\nThe information can be defined either as an object\n\n```js\n{\n    deterministicDeployment: {\n      \"4\": {\n        factory: \"<factory_address>\",\n        deployer: \"<deployer_address>\",\n        funding: \"<required_funding_in_wei>\",\n        signedTx: \"<raw_signed_tx>\",\n      }\n    }\n}\n```\n\nor as an function that returns the information for the deterministic deployment\n\n```js\n{\n  deterministicDeployment: (network: string) => {\n    return {\n      factory: '<factory_address>',\n      deployer: '<deployer_address>',\n      funding: '<required_funding_in_wei>',\n      signedTx: '<raw_signed_tx>',\n    };\n  };\n}\n```\n\n### Importing deployment from other projects (with truffle support)\n\n`hardhat-deploy` also add the `external` field to `HardhatConfig`\n\nSuch field allows to specify paths for external artifacts or **deployments**.\n\nThe external object has 2 fields:\n\n```js\n{\n    external: {\n        contracts: [\n          {\n            artifacts: \"node_modules/@cartesi/arbitration/export/artifacts\",\n            deploy: \"node_modules/@cartesi/arbitration/export/deploy\"\n          },\n          {\n            artifacts: \"node_modules/someotherpackage/artifacts\",\n          }\n        ],\n        deployments: {\n          rinkeby: [\"node_modules/@cartesi/arbitration/build/contracts\"],\n        },\n    }\n}\n```\n\nThe `contracts` field specify an array of object which itself have 2 fields.\n\n- `artifacts`: (mandatory) it is a path to an artifact folder. This support both hardhat and truffle artifacts.\n- `deploy`: (optional) it specifies a path to a folder where reside deploy script. The deploy scripts have only access to the artifact specified in the artifacts field. This allow project to share their deployment procedure. A boon for developer aiming at integrating it as they can get the contracts to be deployed for testing locally.\n\nThe `deployments` fields specify an object whose field nasme are the hardhat network and the value is an array of path to look for deployments. It supports both **hardhat-deploy** and truffle formats.\n\n---\n\n### Access to Artifacts (non-deployed contract code and abi)\n\nArtifacts in hardhat terminology represent a compiled contract (not yet deployed) with at least its bytecode and abi.\n\n`hardhat-deploy` gives can access to these artifact via the `deployments.getArtifact` function :\n\n```js\nconst {deployments} = require('hardhat');\nconst artifact = await deployments.getArtifact(artifactName);\n```\n\nWith the `hardhat-deploy-ethers` plugin you can get an artifact as an ethers contract factory, ready to be deployed, via the following:\n\n```js\nconst {deployments, ethers} = require('hardhat');\nconst factory = await ethers.getContractFactory(artifactName);\n```\n\n> Note that the artifact's files need to be either in `artifacts` folder that hardhat generate on compilation or in the `imports` folder where you can store contracts compiled elsewhere. They can also be present in the folder specified in `external.artifacts` see [Importing deployment from other projects](#importing-deployment-from-other-projects-with-truffle-support)\n\n---\n\n---\n\n## How to Deploy Contracts\n\n---\n\n### The `deploy` Task\n\n`hardhat --network <networkName> deploy [options and flags]`\n\nThis is a new task that the `hardhat-deploy` adds. As the name suggests it deploys contracts.\nTo be exact it will look for files in the folder `deploy` or whatever was configured in `paths.deploy`, see [paths config](#extra-paths-config)\n\nIt will scan for files in alphabetical order and execute them in turn.\n\n- it will `require` each of these files and execute the exported function with the HRE as argument\n\nTo specify the network, you can use the builtin hardhat argument `--network <network name>` or set the env variable `HARDHAT_NETWORK`\n\n> :warning: Note that running `hardhat deploy` without specifying a network will use the default network. If the default network is hardhat (the default's default) then nothing will happen as a result as everything happens in memory, but this can be used to ensure the deployment is without issues.\n\n---\n\n### Deploy Scripts\n\nThe deploy scripts need to be of the following type :\n\n```ts\nexport interface DeployFunction {\n  (env: HardhatRuntimeEnvironment): Promise<void | boolean>;\n  skip?: (env: HardhatRuntimeEnvironment) => Promise<boolean>;\n  tags?: string[];\n  dependencies?: string[];\n  runAtTheEnd?: boolean;\n  id?: string;\n}\n```\n\nThe skip function can be used to skip executing the script under whatever condition. It simply need to resolve a promise to true.\n\nThe tags is a list of string that when the _deploy_ task is executed with, the script will be executed (unless it skips). In other word if the deploy task is executed with a tag that does not belong to that script, that script will not be executed unless it is a dependency of a script that does get executed.\n\nThe dependencies is a list of tag that will be executed if that script is executed. So if the script is executed, every script whose tag match any of the dependencies will be executed first.\n\nThe `runAtTheEnd` is a boolean that if set to true, will queue that script to be executed after all other scripts are executed.\n\nThese set of fields allow more flexibility to organize the scripts. You are not limited to alphabetical order and you can even organise deploy script in sub folders.\n\nFinally the function can return true if it wishes to never be executed again. This can be usfeul to emulate migration scripts that are meant to be executed only once. Once such script return true (async), the `id` field is used to track execution and if that field is not present when the script return true, it will fails.\n\nIn other words, if you want a particular deploy script to run only once, it needs to both return true (async) and have an `id` set.\n\nIn any case, as a general advice every deploy function should be idempotent. This is so they can always recover from failure or pending transaction. This is what underpin most of hardhat-deploy philosophy.\n\nThis is why the `hre.deployments.deploy` function will by default only deploy if the contract code has changed, making it easier to write idempotent script.\n\n#### An example of a deploy script :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  // the following will only deploy \"GenericMetaTxProcessor\" if the contract was never deployed or if the code changed since last deployment\n  await deploy('GenericMetaTxProcessor', {\n    from: deployer,\n    gasLimit: 4000000,\n    args: [],\n  });\n};\n```\n\nAs you can see the HRE passed in has 4 new fields :\n\n- `getNamedAccounts` is a function that returns a promise to an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [`namedAccounts`](#namedaccounts)).\n\n- `getUnnamedAccounts` is a function that return a promise to an array of accounts which were not named (see [`namedAccounts`](#namedaccounts)). It is useful for tests where you want to be sure that the account has no speicifc role in the system (no token given, no admin access, etc...).\n\n- `getChainId` is a function which return a promise for the chainId, as convenience\n\n- `deployments` is an object which contains functions to access past deployments or to save new ones, as well as helpers functions.\n\nThat latter field contains for example the `deploy` function that allows you to deploy contract and save them. It contains a lot more functions though :\n\n---\n\n### The `deployments` field\n\nThe deployments field contains several helpers function to deploy contract but also execute transaction.\n\n```ts\nexport interface DeploymentsExtension {\n  deploy(name: string, options: DeployOptions): Promise<DeployResult>; // deploy a contract\n  diamond: {\n    // deploy diamond based contract (see section below)\n    deploy(name: string, options: DiamondOptions): Promise<DeployResult>;\n  };\n  deterministic( // return the determinsitic address as well as a function to deploy the contract, can pass the `salt` field in the option to use different salt\n    name: string,\n    options: Create2DeployOptions\n  ): Promise<{\n    address: Address;\n    implementationAddress?: Address;\n    deploy(): Promise<DeployResult>;\n  }>;\n  fetchIfDifferent( // return true if new compiled code is different than deployed contract\n    name: string,\n    options: DeployOptions\n  ): Promise<{differences: boolean; address?: string}>;\n  save(name: string, deployment: DeploymentSubmission): Promise<void>; // low level save of deployment\n  get(name: string): Promise<Deployment>; // fetch a deployment by name, throw if not existing\n  getOrNull(name: string): Promise<Deployment | null>; // fetch deployment by name, return null if not existing\n  getDeploymentsFromAddress(address: string): Promise<Deployment[]>;\n  all(): Promise<{[name: string]: Deployment}>; // return all deployments\n  getArtifact(name: string): Promise<Artifact>; // return a hardhat artifact (compiled contract without deployment)\n  getExtendedArtifact(name: string): Promise<ExtendedArtifact>; // return a extended artifact (with more info) (compiled contract without deployment)\n  run( // execute deployment scripts\n    tags?: string | string[],\n    options?: {\n      resetMemory?: boolean;\n      deletePreviousDeployments?: boolean;\n      writeDeploymentsToFiles?: boolean;\n      export?: string;\n      exportAll?: string;\n    }\n  ): Promise<{[name: string]: Deployment}>;\n  fixture( // execute deployment as fixture for test // use evm_snapshot to revert back\n    tags?: string | string[],\n    options?: {fallbackToGlobal?: boolean; keepExistingDeployments?: boolean}\n  ): Promise<{[name: string]: Deployment}>;\n  createFixture<T, O>( // execute a function as fixture using evm_snaphost to revert back each time\n    func: FixtureFunc<T, O>,\n    id?: string\n  ): (options?: O) => Promise<T>;\n  log(...args: any[]): void; // log data only ig log enabled (disabled in test fixture)\n\n  execute( // execute function call on contract\n    name: string,\n    options: TxOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<Receipt>;\n  rawTx(tx: SimpleTx): Promise<Receipt>; // execute a simple transaction\n  catchUnknownSigner( // you can wrap other function with this function and it will catch failure due to missing signer with the details of the tx to be executed\n    action: Promise<any> | (() => Promise<any>),\n    options?: {log?: boolean}\n  ): Promise<null | {\n    from: string;\n    to?: string;\n    value?: string;\n    data?: string;\n  }>;\n  read( // make a read-only call to a contract\n    name: string,\n    options: CallOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<any>;\n  read(name: string, methodName: string, ...args: any[]): Promise<any>;\n  // rawCall(to: Address, data: string): Promise<any>; // TODO ?\n}\n```\n\n---\n\n#### `deployments.deploy(<name>, options)`\n\n---\n\nThe `deploy` function, as mentioned above, allows you to deploy a contract and save it under a specific name.\n\nThe deploy function expect 2 parameters: one for the name and one for the options\n\nSee below the full list of fields that the option parameter allows and requires:\n\n```ts\nexport interface DeployOptions = {\n  from: string; // address (or private key) that will perform the transaction. you can use `getNamedAccounts` to retrived the address you want by name.\n  contract?: // this is an optional field. If not specified it defaults to the contract with the same name as the first parameter\n    | string // this field can be either a string for the name of the contract\n    | { // or abi and bytecode\n        abi: ABI;\n        bytecode: string;\n        deployedBytecode?: string;\n      };\n  args?: any[]; // the list of argument for the constructor (or the upgrade function in case of proxy)\n  skipIfAlreadyDeployed?: boolean; // if set it to true, will not attempt to deploy even if the contract deployed under the same name is different\n  log?: boolean; // if true, it will log the result of the deployment (tx hash, address and gas used)\n  linkedData?: any; // This allow to associate any JSON data to the deployment. Useful for merkle tree data for example\n  libraries?: { [libraryName: string]: Address }; // This let you associate libraries to the deployed contract\n  proxy?: boolean | string | ProxyOptions; // This options allow to consider your contract as a proxy (see below for more details)\n\n  // here some common tx options :\n  gasLimit?: string | number | BigNumber;\n  gasPrice?: string | BigNumber;\n  value?: string | BigNumber;\n  nonce?: string | number | BigNumber;\n\n  estimatedGasLimit?: string | number | BigNumber; // to speed up the estimation, it is possible to provide an upper gasLimit\n  estimateGasExtra?: string | number | BigNumber; // this option allow you to add a gas buffer on top of the estimation\n\n  autoMine?: boolean; // this force a evm_mine to be executed. this is useful to speed deployment on test network that allow to specify a block delay (ganache for example). This option basically skip the delay by force mining.\n  deterministicDeployment? boolean | string; // if true, it will deploy the contract at a deterministic address based on bytecode and constructor arguments. The address will be the same across all network. It use create2 opcode for that, if it is a string, the string will be used as the salt.\n  waitConfirmations?: number; // number of the confirmations to wait after the transactions is included in the chain\n};\n```\n\n---\n\n---\n\n## Handling contract using libraries\n\nIn the deploy function, one of the `DeployOptions` field is the `libraries` field. It allows you to associate external contract as libraries at the time of deployment.\n\nFirst, you have deploy the library using the `deploy` function, then when we deploy a contract that needs the linked library, we can pass the deployed library name and address in as an argument to the `libraries` object.\n\nFirst step: deploy the library:\n\n```js\nconst exampleLibrary = await deploy(\"ExampleLibary\", {\n    from: <deployer>\n});\n\n```\n\nExampleLibrary is now deployed to whatever network was chosen (`hardhat deploy --network <networkName>`)\n\nFor example, if we are deploying on Rinkeby, this library will get deployed on rinkeby, and the `exampleLibrary` variable will be a deployment object that contains the abi as well as the deployed address for the contract.\n\nNow that the library is deployed, we can link it in our next deployed contract.\n\n```js\nconst example = await deploy(\"Example\", {\n    from: <deployer>\n    args: [\"example string argument for the 'Example' contract constructor\"],\n    libraries: {\n        ExampleLibrary: exampleLibrary.address\n    }\n});\n\n```\n\nThis `libraries` object takes the name of the library, and its deployed address on the network. Multiple libraries can be passed into the `libraries` object.\n\n---\n\n---\n\n## Exporting Deployments\n\nApart from deployments saved in the `deployments` folder which contains all information available about the contract (compile time data + deployment data), `hardhat-deploy` allows you to export lightweight files.\n\nThese can be used for example to power your frontend with contract's address and abi.\n\nThis come into 2 flavors.\n\nThe first one is exported via the `--export <file>` option and follow the following format :\n\n```ts\nexport interface Export {\n  chainId: string;\n  name: string;\n  contracts: {[name: string]: ContractExport};\n}\n```\n\nwhere name is the name of the network configuration chosen (see hardhat option `--network`)\n\nThe second one is exported via the `--export-all <file>` option and follow the following format :\n\n```ts\nexport type MultiExport = {\n  [chainId: string]: Export[];\n};\n```\n\nAs you see the second format include the previous. While in most case you'll need the single export where your application will support only one network, there are case where your app would want to support multiple networks at nonce. This second format allow for that.\n\nFurthermore as hardhat support multiple network configuration for the same network (rinkeby, mainnet...), the export-all format will contains each of them grouped by their chainId.\n\n\nNote: from v0.10.4 the old multi-export down is no more:\n\n```\nexport type MultiExport = {\n  [chainId: string]: {[name: string]: Export};\n};\n```\n\n---\n\n---\n\n## Deploying and Upgrading Proxies\n\nAs mentioned above, the deploy function can also deploy a contract through a proxy. It can be done without modification of the contract as long as its number of constructor arguments matches the proxy initialization/update function.\n\nThe default Proxy is both ERC-1967 and ERC-173 Compliant, but other proxy can be specified, like openzeppelin transparent proxies.\n\nCode for the default Proxy can be found [here](solc_0.7/proxy/EIP173Proxy.sol).\n\nTo perform such proxy deployment, you just need to invoke the deploy function with the following options : `{..., proxy: true}`\n\nSee example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: true,\n  });\n};\n```\n\nYou can also set it to `proxy: \"<upgradeMethodName>\"` in which case the function `<upgradeMethodName>` will be executed upon upgrade.\nthe `args` field will be then used for that function instead of the contructor. It is also possible to then have a constructor with the same arguments and have the proxy be disabled. It can be useful if you want to have your contract as upgradeable in a test network but be non-upgradeable on the mainnet.\n\nSee example :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  network,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: network.live ? false : 'postUpgrade',\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nThe proxy option can also be an object which can set the specific owner that the proxy is going to be managed by.\n\nSee example:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: {\n      owner: greeterOwner,\n      methodName: 'postUpgrade',\n    },\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nNote that for the second invokation, this deployment will not be executed from the specified `from: deployer` as otherwise these tx will always fails. It will instead be automatically executed from the proxy's current owner (in that case : `greeterOwner`)\n\nNow, it is likely you do not want to locally handle the private key / mnemonic of the account that manage the proxy or it could even be that the `greeterOwner` in question is a multi sig. As such that second invocation will throw an error as it cannot find a local signer for it.\n\nThe error will output the necessary information to upgrade the contract but `hardhat-deploy` comes also with a utility function for such case: `deployments.catchUnknwonSigner` which will catch the error and output to the console the necessary information while continuing to next step.\n\nHere is the full example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy, catchUnknownSigner} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await catchUnknownSigner(\n    deploy('Greeter', {\n      from: deployer,\n      proxy: {\n        owner: greeterOwner,\n        methodName: 'postUpgrade',\n      },\n      args: ['arg1', 2, 3],\n    })\n  );\n  // you could pause the deployment here and wait for input to continue\n};\n```\n\nThe full proxy options is as follow:\n\n```ts\ntype ProxyOptionsBase = {\n  owner?: Address; // this set the owner of the proxy. further upgrade will need to be executed from that owner\n  upgradeIndex?: number; // allow you to breakdown your upgrades into separate deploy scriot, each with their own index. A deploy call with a specific upgradeIndex will be executed only once, only if the current upgradeIndex is one less.\n  proxyContract?: // default to \"EIP173Proxy\". See below for more details\n  string | ArtifactData;\n  viaAdminContract?: // allow to specify a contract that act as a middle man to perform upgrades. Useful and Recommended for Transparent Proxies\n  | string\n    | {\n        name: string;\n        artifact?: string | ArtifactData;\n      };\n};\n\nexport type ProxyOptions =\n  | (ProxyOptionsBase & {\n      methodName?: string; // method to be executed when the proxy is deployed for the first time or when the implementation is modified. Use the deployOptions args field for arguments\n    })\n  | (ProxyOptionsBase & {\n      execute?:\n        | {\n            methodName: string; // method to be executed when the proxy is deployed for the first time or when the implementation is modified.\n            args: any[];\n          }\n        | {\n            init: {\n              methodName: string; // method to be executed when the proxy is deployed\n              args: any[];\n            };\n            onUpgrade?: {\n              methodName: string; // method to be executed when the proxy is upgraded (not first deployment)\n              args: any[];\n            };\n          };\n    });\n```\n\nThe `proxyContract` field allow you to specify your own Proxy contract. If it is a string, it will first attempt to get an artifact with that name. If not found it will fallback on the following if\n\nit matches:\n\n- `EIP173Proxy`: use the default Proxy that is EIP-173 compliant\n\n- `EIP173ProxyWithReceive`: Same as above except that the proxy contains a receive hook to accept empty ETH payment.\n\n- `OpenZeppelinTransparentProxy`: Use Openzeppelin Transparent Proxy (copied from openzeppelin repo, see code [here](solc_0.7/openzeppelin/proxy/TransparentUpgradeableProxy.sol))\n  When this option is chosen, the `DefaultProxyAdmin` is also used as admin since Transparent Proxy kind of need an intermediarry contract for administration. This can be configured via the `viaAdminContract` option. Note that the DefaultProxyAdmin is slightly different than the one used by openzeppelin as it allow you to set a different owner than msg.sender on first deploy, something openzeppelin version do not allow, see : https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2639\n\n- `OptimizedTransparentProxy`: This contract is similar to above, except that it is optimized to not require storage read for the admin on every call.\n\n## Builtin-In Support For Diamonds (EIP2535)\n\nThe deployments field also expose the diamond field: `hre.deployments.diamond` that let you deploy [Diamonds](https://eips.ethereum.org/EIPS/eip-2535) in an easy way.\n\nInstead of specifying the facets to cut out or cut in, which the diamond contract expects, you specify the facets you want to end up having on the deployed contract.\n\n`diamond.deploy` expect the facet as names. The names represent contract to be deployed as facet. In future version you ll be able to specify deployed contract or artifact object as facet.\n\nTo deploy a contract with 3 facet you can do as follow :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: deployer,\n    owner: diamondAdmin,\n    facets: ['Facet1', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nif you then later execute the following script:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: diamondAdmin, // this need to be the diamondAdmin for upgrade\n    owner: diamondAdmin,\n    facets: ['NewFacet', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nThen the NewFacet will be deployed automatically if needed and then the diamondCut will cut Facet1 out and add NewFacet.\n\nNote that if the code for Facet2 and Facet3 changes, they will also be redeployed automatically and the diamondCuts will replace the existing facets with these new ones.\n\nNote that The Diamond contract's code is part of `hardhat-deploy` and contains 3 built-in facet that can be removed manually if desired.\nThese facets are used for ownership, diamondCut and diamond loupe.\n\nThe implementation is the [reference implementation by Nick Mudge](https://github.com/mudgen/diamond-3)\n\nLike normal proxies you can also execute a function at the time of an upgrade.\n\nThis is done by specifying the execute field in the diamond deploy options :\n\n```js\ndiamond.deploy('ADiamondContract', {\n  from: deployer,\n  owner: diamondAdmin,\n  facets: ['NewFacet', 'Facet2', 'Facet3'],\n  execute: {\n    methodName: 'postUpgrade',\n    args: ['one', 2, '0x3'],\n  },\n});\n```\n\nSince the diamond standard has no builtin mechanism to make the deployment of Diamond with function execution, the Diamond when deployed is actually deployed through a special contract, the `Diamantaire` (see code [here](solc_0.7/diamond/Diamantaire.sol)) that act as factory to build Diamond. It uses deterministic deployment for that so, it is transparently managed by `hardhat-deploy`. It also embed the implementation of the builtin facet, removing the need to have different instances of each live.\n\n<!-- The Diamantaire also support the deterministic deployment of Diamonds.\nAn extra field can be passed to the Diamond deployment options : `deterministicSalt`. It has to be a non-zero 32bytes string (in hex format).\nNote that if you want to deploy 2 diamonds with same owner, you'll need 2 different deterministicSalt for them to be 2 separate contracts. -->\n\n## Testing Deployed Contracts\n\nYou can continue using the usual test task:\n\n`hardhat test`\n\nTests can use the `hre.deployments.fixture` function to run the deployment and snapshot it so that tests don't need to perform all the deployment transactions every time. They can simply reuse the snapshot for every test (this leverages `evm_snapshot` and `evm_revert` provided by both `hardhat` and `ganache`). You can for example set them in a `beforeEach`.\n\nHere is an example of a test :\n\n```js\nconst {deployments} = require('hardhat');\n\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    await deployments.fixture(['Token']);\n    const Token = await deployments.get('Token'); // Token is available because the fixture was executed\n    console.log(Token.address);\n    const ERC721BidSale = await deployments.get('ERC721BidSale');\n    console.log({ERC721BidSale});\n  });\n});\n```\n\nTests can also leverage named accounts for clearer test. Combined with `hardhat-deploy-ethers` plugin, you can write succint test :\n\n```js\nconst {ethers, getNamedAccounts} = require('hardhat');\n\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    await deployments.fixture(['Token']);\n    const {tokenOwner} = await getNamedAccounts();\n    const TokenContract = await ethers.getContract('Token', tokenOwner);\n    await TokenContract.mint(2).then((tx) => tx.wait());\n  });\n});\n```\n\n---\n\n### Creating Fixtures\n\nFurthermore, tests can easily create efficient fixture using `deployments.createFixture`\n\nSee example :\n\n```js\nconst setupTest = deployments.createFixture(\n  async ({deployments, getNamedAccounts, ethers}, options) => {\n    await deployments.fixture(); // ensure you start from a fresh deployments\n    const {tokenOwner} = await getNamedAccounts();\n    const TokenContract = await ethers.getContract('Token', tokenOwner);\n    await TokenContract.mint(10).then((tx) => tx.wait()); //this mint is executed once and then `createFixture` will ensure it is snapshotted\n    return {\n      tokenOwner: {\n        address: tokenOwner,\n        TokenContract,\n      },\n    };\n  }\n);\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    const {tokenOwner} = await setupTest();\n    await tokenOwner.TokenContract.mint(2);\n  });\n});\n```\n\nWhile this example is trivial, some fixture can requires several transaction and the ability to snapshot them automatically speed up the tests greatly.\n\n---\n\n---\n\n## More Information On Hardhat Tasks\n\n---\n\n### **1. node task**\n\nas mentioned above, the node task is slighly modified and augmented with various flags and options\n\n`hardhat node`\n\nIn particular it adds an argument `--export` that allows you to specify a destination file where the info about the contracts deployed is written.\nYour webapp can then access all contracts information.\n\n---\n\n### **2. test task**\n\n`hardhat test`\n\nthe test task is augmented with one flag argument `--deploy-fixture` that allows to run all deployments in a fixture snapshot before executing the tests. This can speed up the tests that use specific tags as the global fixture take precedence (unless specified).\n\nIn other word tests can use `deployments.fixture(<specific tag>)` where specific tag only deploys the minimal contracts for tests, while still benefiting from global deployment snapshot if used.\n\nIf a test needs the deployments to only include the specific deployment specified by the tag, it can use the following :\n\n```js\ndeployments.fixture('<specific tag>', {fallbackToGlobal: false});\n```\n\nDue to how snapshot/revert works in hardhat, this means that these tests will not benefit from the global fixture snapshot and will have to deploy their contracts as part of the fixture call. This is automatic but means that these tests will run slower.\n\n---\n\n### **3. run task**\n\n`hardhat --network <networkName> run <script>`\n\nThe run task act as before but thanks to the `hre.deployments` field it can access deployed contract :\n\n```js\nconst hre = require('hardhat');\nconst {deployments, getNamedAccounts} = hre;\n\n(async () => {\n  console.log(await deployments.all());\n  console.log({namedAccounts: await getNamedAccounts()});\n})();\n```\n\nYou can also run it directly from the command line as usual.\n\n`HARDHAT_NETWORK=rinkeby node <script>` is the equivalent except it does not load the hardhat environment twice (which the run task does)\n\n---\n\n### **4. console task**\n\n`hardhat console`\n\nThe same applies to the `console` task.\n\n---\n\n## Deploy Scripts: Tags And Dependencies\n\n---\n\nIt is possible to execute only specific parts of the deployments with `hardhat deploy --tags <tags>`\n\nTags represent what the deploy script acts on. In general it will be a single string value, the name of the contract it deploys or modifies.\n\nThen if another deploy script has such tag as a dependency, then when this latter deploy script has a specific tag and that tag is requested, the dependency will be executed first.\n\nHere is an example of two deploy scripts :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const deployResult = await deploy('Token', {\n    from: deployer,\n    args: ['hello', 100],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Token deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Token'];\n```\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const Token = await deployments.get('Token');\n  const deployResult = await deploy('Sale', {\n    from: deployer,\n    contract: 'ERC721BidSale',\n    args: [Token.address, 1, 3600],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Sale deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.dependencies = ['Token']; // this ensure the Token script above is executed first, so `deployments.get('Token')` succeeds\n```\n\nAs you can see the second one depends on the first. This is because the second script depends on a tag that the first script registers as using.\n\nWith that when `hardhat deploy --tags Sale` is executed\n\nthen both scripts will be run, ensuring Sale is ready.\n\nYou can also define the script to run after another script is run by setting `runAtTheEnd` to be true. For example:\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, execute, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer, admin} = namedAccounts;\n  await execute('Sale', {from: deployer}, 'setAdmin', admin);\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.runAtTheEnd = true;\n```\n\nTags can also be used in test with `deployments.fixture`. This allow you to test a subset of the deploy script.\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.0-next.5","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-xK1T+ERh1XsiL9VLLCLfT+rrOyCTorqvbH08re+ARsNnxXoMSZ6aw3bl1hHj9j2Z5iA2UBZizFiBXiqTZic8IA==","shasum":"8ca12c80771e2f2a98f74bec07b723d477df98cb","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.0-next.5.tgz","fileCount":149,"unpackedSize":12104456,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiHcY4ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmo5EQ//VImYlPKAZnVDHmJJdV63N3h8BPJt3XhOztY9c/r7rXjW7sL6\r\n1fFapvU1HsInXDkplkPcYNAztFrukEVlkD2s0gAPzAjOSyBFha58M5v0HaPQ\r\nQ5OzN3RqgGfqFMNc3d2r75jSjR6LxrT/Xg7C8DUpnidGX0D0Bc4HAFyJt8u1\r\nVOZrpe7WWtwViJhrEv6uY3KdxWaGYedF1DjG2OkGPiMTSHTe4YYX376WVEcH\r\nd6Q8ZK/bTri/Jh+k+/BkVFOMHqqjLgD7XWZUjLwEk8fbVe3XG8WkMM/ZqwA/\r\n1FRAgJQ08i+ur+YkSm9t52XVWIJJS9vzgI2f/kqdYWhOMP+ZOgjdWPccjk3I\r\n0ugphcbkFNL17FDDHXhuWxXmeudcXQRbSxJg5gK1ygoIHZYZ9krkdrnJvuOB\r\nsZgCQhh9DaG+G3bQIXqTNkfMx7v+dxvNPRIbw0bkk+i2g92XKP1sk5glDLF7\r\nPXldyNghJ9cNaLUIl4z/HfsYlv3HwHzd0nxSa1kCU7qYeRdBpvZANfxBCh96\r\n5ZuVrwDWdN9DAe7nFG1b4T+GIE/30V3YI5vs4GGpMwysViTfh3mYnvk3HDxY\r\nZSE8+c2Zmt4svB0XIHr4cPb/pPyFRxFVlcg+ujUNBjYmR0jNdkgze374TtFW\r\n7OOFNtdEyZ8mRwVE4+58NU4x3m76ojAzSWQ=\r\n=DeFP\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCVX1hOy11b/FxVBABtUeGj1Av28ptdWR0XVc0po1Ph7AIgDNzLV5F0w43lBoAqls9+3FUdLYhlWUBQIEhBq7+ubPg="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.0-next.5_1646118456661_0.9487005450152188"},"_hasShrinkwrap":false},"0.10.6":{"name":"hardhat-deploy","version":"0.10.6","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.8","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.6.8"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"f122a4b1272d8681670b7a2c0651c88f57b33c56","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.10.6","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-/v/HI8QRa72Xl7+/D0kIZmYjSIwaghFkizZ/hmfYS0YtsYCrh5atxKl0dNkGhCVOWsbmWZQF9O4RrweozxjfEw==","shasum":"007d9c51484ffcf6187425a4288de9dd7d0a5999","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.10.6.tgz","fileCount":121,"unpackedSize":7468351,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiKv9PACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmq7jA/9GPXinRhMYOw6jb7zbJC4JndZg3UOlk1ea7q4ufe6Blr01/n6\r\n7jBxN2d2UsmnS2F5OQe4Qyi6Ryt1MOAu0uEWcibYgNZyYTdHtut0fvtx2yMZ\r\n+Cx26eYHsudFQqyT8yVoIU2FUzDesnFk/eL4VPTGC3gM4sueDxXquf2iuMvD\r\nLkqMmanYX4ga8qyHcjyQJ43gRbfzOpAAtCXjNd4VkssPYdcg84NLZ541jwDc\r\n4RFucTfoLgMBTORLM/NGSYMLuloNsHTCdJuLScuy4vCmVNOHlgE4ZuYLXIcG\r\nRxvz0WTAkh60isIJ4d8VK7iK6Gx88A7p2KbLySGLpa3/EVUs9vISuxDGo09J\r\n1PXR9g6DiGKXelkdGWgX9hioFnz/LCpsBXq4vm5wZFPN9QUAAKeCBuL7A6fg\r\nDb9oD2M1yCVvZrgMGuw3BOc/fR6fTliLXhEhla9lGD7uypi+fn4RZk4i5zrD\r\n9vPt90uhdn1Vj4huYQIeTxH71aLxaD1biWLK4cZ2DRxIy7WMp/6qd8HCV8Q8\r\npCuBtdJ36ER6WzQUHC9prceZ+NnzORqJArfYLlliWHFM20h0/CdLkXe8tu6H\r\n4S/HQTeZywdLxfbFLdaR2s2Pqxv7mqsZrfP0N+/Ppn+1QKU0sIU4+k7W0oaY\r\n3QmfU1AsdiAk/NZkjD2zAtnaWi65Z3E1zJM=\r\n=JNJ0\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCsOGEw9tVFr42Se6vPgJIAZVfxIfpRdwe9q8e4SB8lJAIgA5PlU4/B78yDWfs56goo/03pBglC/oy0sEaaCXNZ9EY="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.10.6_1646985039083_0.862329021804471"},"_hasShrinkwrap":false},"0.11.0":{"name":"hardhat-deploy","version":"0.11.0","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.8","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.6.8"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"99f132f0b154321546488f6e7bf47c05dee10d5f","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.0","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-ub1p2O4OF7GIl+Tji4cr5ZYgpMPhrHfhQOQIy3exIWCaQBQWnUQ3VCRqfhkzp3PJ5V8XEo1T2WS/och2OpGdxQ==","shasum":"3be89afdde507fd58e73a91597b3a477a2d6bbaf","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.0.tgz","fileCount":149,"unpackedSize":12105128,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiMQhXACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqsfBAAj6tZfY6TofBIgJIxUYjnqJl1ERGuvlVvim/V95pKga0AiAL/\r\nGxE1MAIywTA/e5VesJ/7UqJ2rfLOSFYhUVsbc4pzhmd0Rnr9fh55oh70HrtW\r\nkrbHsfczM8AD8L7TP8U64bfN+Yih/jnpaStywOJa7bywDpzcS67PQXVrrFDb\r\nY4PR8EYPG3Mii83Guojg8JnEZFmaCaGgISfH7QDmN4Pe6YVdVQrI8mGBrkNf\r\n623C44seEuN2Ebd342Uc7kA50o5E6YgTz0zQpq6XZBVA4/2J4w6z6sOLE9/o\r\nEr/gHhhdoiEc3OdnMvH19S9fLLZZLP4Is0svSJoDV/BQxxVUm70iL6aGo1oK\r\nSMWR+w9SXTxhum47gxV3C0mqzhri++fQIvS9rHzQ8jd6rXq2NIavwgfwe+Ep\r\n//BhUzKFOG9MrJCy0IEEctQQJb/9GBLCzrtDOVLv4rNvKRDhgX48aVuaTrrX\r\nNicd74OCwjdIe2uDk6Xo69w/tsspKzqRIMtaODMP+185mMSXbZfjlFZP0HMr\r\nkXQn+6XQDPQ79eOgFrt/1AfRyHcVOJH4Zivo14fgWANZKYlmN3MNiLG/s04v\r\nuJ5ZVp+Nppk+6K2A01aL0QDHjcdnKDKqefHSJPudd3suGjgzRbS3iVdfdncj\r\nbW9KGGS7PzNrlYHQycvKA0P6EOWWe2Er5nY=\r\n=cjar\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDBDTRCZFuPLf3CXLBzT6mf+puoMTmOoecOyIfEW5Te+wIhAIlvuSlSG/s8KpLUcACxFZXmKrMjRMo68hk+lbyUUloM"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.0_1647380567524_0.41183718583821927"},"_hasShrinkwrap":false},"0.11.1":{"name":"hardhat-deploy","version":"0.11.1","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.8","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.6.8"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"0ec2f93eb5b3cd2272670a25f681a4583a89306a","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.1","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-nftj5LaeTkg4o4ZsookBGICJGKylJqhTNEyCTTkwefZvA92fvhyUsoLIbSCuVfRqAUUsrQsw7OcEJoUPs/Wiqg==","shasum":"abf90fb7692b41c5f0465ca09ae72347b2a51012","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.1.tgz","fileCount":149,"unpackedSize":12105244,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiOKYBACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmosBA/9HbStKtyYPOiUbA8+Co6fyn2zysvlkq7D2Tqx5UD0Sm2UWhzF\r\nOz1VCE6FfwOCm+H/oDDeQDAVeoQvlxXeIipbShc7m5xuL++n4IJjE5VAON20\r\nuf/FiqdcRSO/V7bHYB79J1Jcw9FKp1sCUtFrkd7NGiS/xupsRVeA6yjfIIt9\r\nZ5FwPWFBKUKvA3orquUSWiRlEBwWz6lp5TupFOFaEf8x5Sx5GYZJF9+fDAbg\r\n94QMOhLxxWgvVpPbo907F4sib+WYkYiDPvUyuMEQ5CXN16NnW7WevoZ2AwSG\r\nrh2WG8iCSCAUctivreuzoWAz2UzglG4hUksrE/EXY3xXtaShbAH6eD0ck0EV\r\nh5tvNp3xShChbrzM6e4yKuBtbYMxBaNaZRekV8n0NbUhf15cgNxHj1Zn/cIz\r\n9sa7vh0o6NaWmtIDGiDLmg4mmjG+/bIYHbbb3jJ5uwAmn9a0V5XfWIiZXBKX\r\n4e2oqyl7OvHo9sWydmnKExz6R5ictYq9rVkEZk9Tt2V9EGh/3a/nfx0KGegd\r\nsrDUmU+bvsSkI3Vu3GPKC1foDKBk2OE91/kHcLHgqjaDaFZA4/C/GR+Y40vJ\r\nUCV0rRpQyONmCn5PJze6J6eJj4F9FhPbAveUGUVtMt4INfYd+Wa34hqjzwo+\r\nvkRvTILS+9Guv2ZrojHo6w4NyESOrUUV8vE=\r\n=GxsF\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCFvVZ6KNs4pWjVWaqyhRCGJYpDidQzmxiK+ZLclp9W3wIhAOnr8spMOJyPn5f2NgybUev16YLj5157JnYFtqigznxV"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.1_1647879681359_0.4721474561290171"},"_hasShrinkwrap":false},"0.11.2":{"name":"hardhat-deploy","version":"0.11.2","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.8","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.6.8"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"2575620e5491d91b15a491e21b47df757a8917ae","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.2","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-7J6dhm3Y3ix63HU+oJJWwpcusdXZvs4fskyyU2YbNxPKBXFwfNl22dN5ckxTDWIoWpUeovI3HxUybps5VSsrCg==","shasum":"b47411bb171e4418d425c5ff2c9548baf7bfd434","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.2.tgz","fileCount":149,"unpackedSize":12106124,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiOQcdACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmpnlg/6AkV/56GmY4wV0aeb+9EVdYIaAMjrmr61YN4kHMXHKaYqSsEg\r\nkWy8YMbNTocFP49Aa4761PeoyYG+51adg3YhtvGkiYV52LQ69X0n5txLB4wo\r\niA0hWhLNVjFEx8MJwrJHH+zs01bZBcG1w/AleEeG4oHcVO425aAdOl8gyFUo\r\nJIGtoyOdtF6YckYQT2VVLYT2WLMUrqTV1xiJuGp/8l+065wvpXjffWofEqQx\r\n0ysWUSgbR6DfARxFZNg76fTxw3Bb7Mouy73LYrBoPMOg3vO3hjmvVi+ChkDo\r\nKWODtWsRgwF4B1AK43nfxCMt/3mpVizwP/rhWCyOByNoGzKzG61PJkl0938T\r\nqPT8xGcivGnCjthpsrAAc3O5ExZC7UZjWm2JNhg2KfcIvt9ALgimbVDDEAxU\r\nod8xvcyet/+lt0R2N5XXtl3ebp7+mzx/uRpfKh9/tgfb5mpwx8sosVRv8Y/s\r\n9NoiAthloB2CkgiNMAnOfQ0YPDU+s2ZxWZ8eqD7sQiVZMvWYRnQeb5XNsYLu\r\niqHAEWNPjgBJLC6munPyUJCJ82PjChEhsEBX6RpCD1Aw4J1l9ksyZA8cyZrF\r\n0CUUX1qvbc493gn64rQMLiANtXCwIXlscM5+4b3u0uih+3fI8fWOq8oRCmHl\r\nS5rbAKsc3AIW7mBOuMAegqmV9M0HOLbCjSE=\r\n=mGig\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIHHHr5pwNxvbsjr9+9HbErfOD94UeAigtBr8bP3+1ZpXAiEA8WGWA1VVrd2ktMRDF+FKbbe8cmZtoOch2Dsdg+rqIQY="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.2_1647904541144_0.6190948701365833"},"_hasShrinkwrap":false},"0.11.3-experimental.0":{"name":"hardhat-deploy","version":"0.11.3-experimental.0","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.8","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.6.8"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"readme":"<h1> hardhat-deploy</h1>\n\n_A [Hardhat](https://hardhat.org) Plugin For Replicable Deployments And Easy Testing_\n\n> **A complete dev template using hardhat-deploy is available here** : https://github.com/wighawag/template-ethereum-contracts\n> It also contains various branches examplifying the capability of hardhat-deploy. Check it out.\n\n- [What is it for ?](#what-is-it-for-)\n- [hardhat-deploy in a nutshell](#hardhat-deploy-in-a-nutshell)\n- [Installation](#installation)\n  - [npm install hardhat-deploy](#npm-install-hardhat-deploy)\n  - [TypeScript support](#typescript-support)\n  - [Migrating existing deployment to hardhat-deploy](#migrating-existing-deployment-to-hardhat-deploy)\n- [Hardhat Tasks Available/Updated](#hardhat-tasks-availableupdated)\n  - [1. hardhat deploy](#1-hardhat-deploy)\n    - [**Options**](#options)\n    - [**Flags**](#flags)\n  - [2. hardhat node](#2-hardhat-node)\n    - [**Options**](#options-1)\n    - [**Flags**](#flags-1)\n  - [3. hardhat test](#3-hardhat-test)\n  - [4. hardhat etherscan-verify](#4-hardhat-etherscan-verify)\n    - [**Options**](#options-2)\n  - [5. hardhat sourcify](#5-hardhat-sourcify)\n    - [**Options**](#options-3)\n  - [6. hardhat export](#6-hardhat-export)\n    - [**Options**](#options-4)\n- [Hardhat Environment Extensions](#hardhat-environment-extensions)\n- [Configuration](#configuration)\n  - [**1. namedAccounts (ability to name addresses)**](#1-namedaccounts-ability-to-name-addresses)\n  - [**2. extra hardhat.config networks' options**](#2-extra-hardhatconfig-networks-options)\n    - [`live`](#live)\n    - [`saveDeployments`](#savedeployments)\n    - [`tags`](#tags)\n    - [`deploy`](#deploy)\n    - [`companionNetworks`](#companionnetworks)\n  - [**3. extra hardhat.config paths' options**](#3-extra-hardhatconfig-paths-options)\n  - [**4. deterministicDeployment (ability to specify a deployment factory)**](#4-deterministicdeployment-ability-to-specify-a-deployment-factory)\n  - [Importing deployment from other projects (with truffle support)](#importing-deployment-from-other-projects-with-truffle-support)\n  - [Access to Artifacts (non-deployed contract code and abi)](#access-to-artifacts-non-deployed-contract-code-and-abi)\n- [How to Deploy Contracts](#how-to-deploy-contracts)\n  - [The `deploy` Task](#the-deploy-task)\n  - [Deploy Scripts](#deploy-scripts)\n    - [An example of a deploy script :](#an-example-of-a-deploy-script-)\n  - [The `deployments` field](#the-deployments-field)\n    - [`deployments.deploy(<name>, options)`](#deploymentsdeployname-options)\n- [Handling contract using libraries](#handling-contract-using-libraries)\n- [Exporting Deployments](#exporting-deployments)\n- [Deploying and Upgrading Proxies](#deploying-and-upgrading-proxies)\n- [Builtin-In Support For Diamonds (EIP2535)](#builtin-in-support-for-diamonds-eip2535)\n  - [deployment / upgrade](#deployment--upgrade)\n  - [onUpgrade calls](#onupgrade-calls)\n  - [more...](#more)\n- [Testing Deployed Contracts](#testing-deployed-contracts)\n  - [Creating Fixtures](#creating-fixtures)\n- [More Information On Hardhat Tasks](#more-information-on-hardhat-tasks)\n  - [**1. node task**](#1-node-task)\n  - [**2. test task**](#2-test-task)\n  - [**3. run task**](#3-run-task)\n  - [**4. console task**](#4-console-task)\n- [Deploy Scripts: Tags And Dependencies](#deploy-scripts-tags-and-dependencies)\n\n## What is it for ?\n\nThis [hardhat](https://hardhat.org) plugin adds a mechanism to deploy contracts to any network, keeping track of them and replicating the same environment for testing.\n\nIt also adds a mechanism to associate names to addresses, so test and deployment scripts can be reconfigured by simply changing the address a name points to, allowing different configurations per network. This also results in much clearer tests and deployment scripts (no more `accounts[0]` in your code).\n\nThis plugin contains a lot more features too, all geared toward a better developer experience :\n\n- chain configuration export\n- listing deployed contracts' addresses and their abis (useful for webapps)\n- library linking at time of deployment.\n- deterministic deployment across networks.\n- support for specific deploy script per network (L1 vs L2 for example)\n- ability to access deployment from \"companion\" networks\n- deployment dependency system (allowing you to only deploy what is needed).\n- deployment retrying (by saving pending tx): so you can feel confident when making a deployment that you can always recover.\n- deployments as test fixture using `evm_snapshot` to speed up testing.\n- ability to create your own test fixture that automatically benefits from `evm_snapshot`'s tests speed-up boost\n- combined with [hardhat-deploy-ethers](https://github.com/wighawag/hardhat-deploy-ethers) it has the ability to get ethers contract instance by name (like `await ethers.getContract(\"ContractName\")`).\n- importing artifact from external sources (like npm packages), including [truffle](https://www.trufflesuite.com/truffle) support.\n- importing deployments from external sources (like npm packages)\n- ability to log information in `deploy` mode only (while in test the console remains clean).\n- contains helpers to read and execute transaction on deployed contract referring to them by name.\n- These helpers contains options to auto mine on dev network (to speed up test deployments).\n- save metadata of deployed contract so they can always be fully verified, via [sourcify](https://sourcify.dev) or [etherscan](https://etherscan.io).\n- ability to submit contract source to etherscan and sourcify for verification at any time. (Because **hardhat-deploy** will save all the necessary info, it can be executed at any time.)\n- support harhdat's fork feature so deployment can be accessed even when run through fork.\n- named accounts are automatically impersonnated too, so you can perform tx as if you had their private key.\n- proxy deployment with ability to upgrade them transparently, only if code changes.\n- this include support for [openzeppelin](https://openzeppelin.com) transparent proxies\n- diamond deployment with facets, allowing you to focus on what the new version will be. It will generate the diamondCut necessary to reach the new state.\n- watch and deploy: **hardhat-deploy** can watch both your deploy script and contract code and redeploy on changes.\n- HCR (Hot Contract Replacement): the watch feature combined with proxy or diamond, gives you an experience akin to frontend Hot Module Replacement: once your contract changes, the deployment is executed and your contract retains the same address and same state, allowing you to tweak your contracts while debugging your front-end.\n\n## hardhat-deploy in a nutshell\n\nBefore going into the details, here is a very simple summary of the basic feature of **hardhat-deploy**.\n\n**hardhat-deploy** allows you to write [`deploy scripts`](#deploy-scripts) in the `deploy` folder. Each of these files that look as follows will be executed in turn when you execute the following task: `hardhat --network <networkName> deploy`\n\n```js\n// deploy/00_deploy_my_contract.js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('MyContract', {\n    from: deployer,\n    args: ['Hello'],\n    log: true,\n  });\n};\nmodule.exports.tags = ['MyContract'];\n```\n\nFurthermore you can also ensure these scripts are executed in test too by calling `await deployments.fixture(['MyContract'])` in your test.\nThis is optimized, so if multiple tests use the same contract, the deployment will be executed once and each test will start with the exact same state.\n\nThis is a huge benefit for testing since you are not required to replicate the deployment procedure in your tests. The tag feature (as seen in the script above) and [dependencies](#deploy-scripts-tags-and-dependencies) will also make your life easier when writing complex deployment procedures.\n\nYou can even group deploy scripts in different sub folder and ensure they are executed in their logical order.\n\nFurthermore hardhat-deploy can also support a multi-chain settings like L1, L2 with multiple deploy folder specific to each network.\n\n**All of this can also be bundled in a npm package so user of hardhat-deploy can reuse your deployment procedure and get started integrating with your project locally.**\n\nThere is a tutorial covering the basics here : https://github.com/wighawag/tutorial-hardhat-deploy\n\n## Installation\n\n### npm install hardhat-deploy\n\n```bash\nnpm install -D hardhat-deploy\n```\n\nAnd add the following statement to your `hardhat.config.js`:\n\n```js\nrequire('hardhat-deploy');\n```\n\nif you use `ethers.js` we recommend you also install `hardhat-deploy-ethers` which add extra features to access deployments as ethers contract.\n\nSince `hardhat-deploy-ethers` is a fork of `@nomiclabs/hardhat-ethers` and that other plugin might have an hardcoded dependency on `@nomiclabs/hardhat-ethers` the best way to install `hardhat-deploy-ethers` and ensure compatibility is the following:\n\n```bash\nnpm install --save-dev  @nomiclabs/hardhat-ethers@npm:hardhat-deploy-ethers ethers\n```\n\nWhich means you then need to do `require(\"@nomiclabs/hardhat-ethers\")` instead of `require(\"hardhat-deploy-ethers\")` in your `hardhat.config.js` file.\n\nMore details on `hardhat-deploy-ethers` repo : https://github.com/wighawag/hardhat-deploy-ethers#readme\n\n### TypeScript support\n\nWith hardhat the tsconfig.json is optional.\n\nBut if you add folders to the `include` field in `tsconfig.json`, you ll also need to include `hardhat.config.ts` like :\n\n`include\": [\"./hardhat.config.ts\", \"./scripts\", \"./deploy\", \"./test\"]`\n\nfor deploy script (see below) you can write them this way to benefit from typing :\n\n```ts\nimport {HardhatRuntimeEnvironment} from 'hardhat/types';\nimport {DeployFunction} from 'hardhat-deploy/types';\n\nconst func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {\n  // code here\n};\nexport default func;\n```\n\nSee a template that uses **hardhat-deploy** here : https://github.com/wighawag/template-ethereum-contracts\n\nThis repo has also some examples branch that exemplify specific features, like the forking testing here : https://github.com/wighawag/template-ethereum-contracts/tree/examples/fork-test\n\n### Migrating existing deployment to hardhat-deploy\n\n> Only needed for existing project that already deployed contracts and has the deployment information available **(at minimum, address and abi)**\n\nYou might want to switch your current deployment process to use **hardhat-deploy**. In that case you probably have some deployments saved elsewhere.\n\nIn order to port them to **hardhat-deploy**, you'll need to create one `.json` file per contract in the `deployments/<network>` folder (configurable via [paths config](#extra-paths-config)).\n\nThe network folder is simply the hardhat network name (as configured in hardhat.config.js) (accessible at runtime via `hre.network.name`).\nSuch folder need to have a file named `.chainId` containing the chainId as decimal.\n\nFor example for network named \"rinkeby\" (for the corresponding network) the file `deployments/rinkeby/.chainId` would be\n\n```\n4\n```\n\nNote, prior to hardhat 0.6 the chainId was appended to the folder name (expect for some known network name). This has changed and upgrading to 0.6 will require you to change the folder name and add the '.chainId' file.\n\nEach contract file must follow this type (as defined in [types.ts](types.ts)) :\n\n```ts\nexport interface Deployment {\n  address: Address;\n  abi: ABI;\n  receipt?: Receipt;\n  transactionHash?: string;\n  history?: Deployment[];\n  numDeployments?: number;\n  implementation?: string;\n  args?: any[];\n  linkedData?: any;\n  solcInputHash?: string;\n  metadata?: string;\n  bytecode?: string;\n  deployedBytecode?: string;\n  libraries?: Libraries;\n  userdoc?: any;\n  devdoc?: any;\n  methodIdentifiers?: any;\n  diamondCut?: FacetCut[];\n  facets?: Facet[];\n  storageLayout?: any;\n  gasEstimates?: any;\n}\n```\n\nAs you can see, only abi and address are mandatory. But having the other fields allow more feature. For example, metadata and args allow you to benefit from contract code verification.\n\nFor Receipt, the following type is expected:\n\n```ts\nexport type Receipt = {\n  from: string;\n  transactionHash: string;\n  blockHash: string;\n  blockNumber: number;\n  transactionIndex: number;\n  cumulativeGasUsed: string;\n  gasUsed: string;\n  contractAddress?: string;\n  to?: string;\n  logs?: Log[];\n  events?: any[];\n  logsBloom?: string;\n  byzantium?: boolean;\n  status?: number;\n  confirmations?: number;\n};\n```\n\nHere is an example:\n\nLet's say you have:\n\n- 2 Contract named Greeter and Registry deployed on rinkeby\n- 1 contract named Greeter on mainnet\n- 2 Contract named Greeter and Registry deployed on a network named rinkeby2\n\nYou would get the following folder structure:\n\n```\ndeployments/\n  mainnet/\n    .chainId\n    Greeter.json\n  rinkeby/\n    .chainId\n    Greeter.json\n    Registry.json\n  rinkeby2/\n    .chainId\n    Greeter.json\n    Registry.json\n```\n\nThe reason why **hardhat-deploy** save chainId in the `.chainId` file is both for\n\n- safety: so that if you were to change the network name to point to a different chain, it would not attempt to read the wrong folder and assume that a contract has been deployed while it has not.\n- ability to know the chainId without requring to be connected to a node (and so not dependent on hardhat.config.js settings). Useful for `export` task.\n\n---\n\n## Hardhat Tasks Available/Updated\n\nhardhat deploy add several task to hardhat. It also modify existing one, adding new options and new behavior. All of these are described here:\n\n---\n\n### 1. hardhat deploy\n\n---\n\nThis plugin adds the _deploy_ task to Hardhat.\n\nThis task will execute the scripts in the `deploy` folder and save the contract deployments to disk. These deployments are supposed to be saved for example in a git repository. This way they can be accessed later. But you are free to save them elsewhere and get them back via your mechanism of choice.\n\nWith the deployment saved, it allows you to deploy a contract only if changes were made.\n\nDeploy scripts (also called Deploy functions) can also perform aribtrary logic.\n\nFor further details on how to use it and write deploy script, see [section](#deploy-scripts) below.\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployments, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice (in wei) to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--reset`: This flag resets the deployments from scratch. Previously deployed contract are not considered and deleted from disk.\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n---\n\n### 2. hardhat node\n\n---\n\nThis plugin modify the _node_ task so that it also execute the deployment script before exposing the server http RPC interface\n\nIt add similar options than the `deploy` task :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--no-reset`: This flag prevent the reseting of the existing deployments. This is usually not desired when running the `node` task as a network is created from scratch and previous deployemnt are irrelevant.\n\n`--show-accounts`: this flag will output the account private keys\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n`--no-deploy` that discard all other options to revert to normal `hardhat node` behavior without any deployment being performed.\n\n> :warning: Note that the deployments are saved as if the network name is `localhost`. This is because `hardhat node` is expected to be used as localhost: You can for example execute `hardhat --network localhost console` after `node` is running. Doing `hardhat --network hardhat console` would indeed not do anything useful. It still take the configuration from `hardhat` in the hardhat.config.js file though.\n\n---\n\n### 3. hardhat test\n\n---\n\nThis plugin adds a flag argument `--deploy-fixture` to the _test_ task which if enabled will run the global deployments fixture before the tests and snapshots it. This will generaly speed up the tests as further test will be able to revert back to the full deployment.\n\n> :warning: Note though that if your test behave differently whether that option is on or not, this most likely mean that your deploy scripts' tags and dependencies are not configured correctly. This is because the global fixture will ensure all contract are deployed while test will usually (for efficiency) ask for a particular tag.\n\n---\n\n### 4. hardhat etherscan-verify\n\n---\n\nThis plugin adds the _etherscan-verify_ task to Hardhat.\n\nThis task will submit the contract source and other info of all deployed contracts to allow etherscan to verify and record the sources.\n\nInstead of using the full solc input, this task will first attempt to send the minimal sources from the metadata.\nBut Etherscan sometime fails due to a bug in solidity compiler (<https://github.com/ethereum/solidity/issues/9573>). As such this task can fallback on full solc input (see option --solc-input). Note that if your contract was deployed with a previous version of **hardhat-deploy**, it might not contains the full information. The issue seems to be fully resolved since solc version 0.8.\n\nThis task will also attempt to automatically find the SPDX license in the source.\n\nTo execute that task, you need to specifiy the network to run against :\n\n```bash\nhardhat --network mainnet etherscan-verify [--api-key <apikey>] [--apiurl <url>]\n```\n\n#### **Options**\n\nNote that harhdat-deploy now use a different config format to not conflict with `hardhat-etherscan`\n\n`--api-key <api key>`: let you specify your etherscan api key. Alternatively, you can provide it via the env variable `ETHERSCAN_API_KEY` or through the hardhat.config.ts verify field:\n\n```js\n{\n  ...\n  verify: {\n    etherscan: {\n      apiKey: '<API key>'\n    }\n  }\n}\n```\n\n`--api-url <url>`: let you specify your etherscan url to submit the source to. Can also be configured per network in `hardhat.config.js`:\n\n```js\n{\n  ...\n  networks: {\n    mynetwork: {\n      ...\n      verify: {\n        etherscan: {\n          apiUrl: 'http://mynetwork.xyz'\n        }\n      }\n    }\n  }\n}\n```\n\n`--license <SPDX license id>`: SPDX license (useful if SPDX is not listed in the sources), need to be supported by etherscan: https://etherscan.io/contract-license-types\n\n`--force-license`: if set, will force the use of the license specified by --license option, ignoring the one in the source (useful for license not supported by etherscan)\n\n`--solc-input`: fallback on solc-input id needed (useful when etherscan fails on the minimum sources, see https://github.com/ethereum/solidity/issues/9573)\n\n`--sleep`: sleep 500ms between each verification, so API rate limit is not exceeded\n\n---\n\n### 5. hardhat sourcify\n\n---\n\nThis plugin adds the _sourcify_ task to Hardhat.\n\nSimilar to `hardhat etherscan-verify` this task will submit the contract source and other info of all deployed contracts to sourcify.\n\n```bash\nhardhat --network mainnet sourcify\n```\n\nLater this task might instead pin the metadata to ipfs, so sourcify can automatically verify them.\n\n#### **Options**\n\n`--contract-name <contract name>`: specify the contract's name you want to verify\n  \n`--endpoint <endpoint>`: specify the sourcify endpoint, default to https://sourcify.dev/server/\n\n`--write-failing-metadata`: if set and the sourcify task fails to verify, the metadata file will be written to disk, so you can more easily figure out what has gone wrong.\n\n---\n\n### 6. hardhat export\n\n---\n\nThis plugin adds the _export_ task to Hardhat.\n\nThis task will export the contract deployed (saved in `deployments` folder) to a file with a simple format containing only contract addresses and abi, useful for web apps.\n\nOne of the following options need to be set for this task to have any effects :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\nThis last option has some limitations, when combined with the use of external deployments (see [Configuration](#configuration)). If such external deployments were using older version of **hardhat-deploy** or truffle, the chainId might be missing. In order for these to be exported, the hardhat network config need to explicity state the chainId in the `networks` config of `hardhat.config.js`.\n\nWith both `--export` and `--export-all`, using the special `<filepath>` value of `-` will output to `STDOUT` rather than writing a normal file.\n\n---\n\n---\n\n## Hardhat Environment Extensions\n\nThis plugin extends the Hardhat Runtime Environment by adding 4 fields:\n\n- `getNamedAccounts: () => Promise<{ [name: string]: string }>`: a function returning an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [Configuration](#configuration)).\n\n- `getUnnamedAccounts: () => Promise<string[]}>`: accounts which has no names, useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`: contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId(): Promise<string>`: offer an easy way to fetch the current chainId.\n\n---\n\n---\n\n## Configuration\n\n---\n\n### **1. namedAccounts (ability to name addresses)**\n\n---\n\nThis plugin extends the `HardhatConfig`'s object with an optional `namedAccounts` field.\n\n`namedAccounts` allows you to associate names to addresses and have them configured per chain.\nThis allows you to have meaningful names in your tests while the addresses match to multi sig in real network for example.\n\n```js\n{\n    namedAccounts: {\n        deployer: {\n            default: 0, // here this will by default take the first account as deployer\n            1: 0, // similarly on mainnet it will take the first account as deployer. Note though that depending on how hardhat network are configured, the account 0 on one network can be different than on another\n            4: '0xA296a3d5F026953e17F472B497eC29a5631FB51B', // but for rinkeby it will be a specific address\n            \"goerli\": '0x84b9514E013710b9dD0811c9Fe46b837a4A0d8E0', //it can also specify a specific netwotk name (specified in hardhat.config.js)\n        },\n        feeCollector:{\n            default: 1, // here this will by default take the second account as feeCollector (so in the test this will be a different account than the deployer)\n            1: '0xa5610E1f289DbDe94F3428A9df22E8B518f65751', // on the mainnet the feeCollector could be a multi sig\n            4: '0xa250ac77360d4e837a13628bC828a2aDf7BabfB3', // on rinkeby it could be another account\n        }\n    }\n}\n```\n\n<!-- You can also specify addresses with the `ledger://` prefix. In which case the account fetched will still be the corresponding address, but behind the scene, the transaction will be created via the hardware waller. Currently the feature is not working very well though and better support is needed. -->\n\n---\n\n### **2. extra hardhat.config networks' options**\n\n---\n\n**hardhat-deploy** add 5 new fields to `networks` configuration\n\n#### `live`\n\nthis is not used internally but is useful to perform action on a network whether it is a live network (rinkeby, mainnet, etc) or a temporary one (localhost, hardhat). The default is true (except for localhost and hardhat where the default is false).\n\n#### `saveDeployments`\n\nthis tell whether **hardhat-deploy** should save the deployments to disk or not. Default to true, except for the hardhat network.\n\n#### `tags`\n\nnetwork can have tags to represent them. The config is an array and at runtime the hre.network.tags is an object whose fields (the tags) are set to true.\n\nThis is useful to conidtionaly operate on network based on their use case.\n\nExample:\n\n```js\n{\n  networks: {\n    localhost: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"local\"]\n    },\n    hardhat: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"test\", \"local\"]\n    },\n    rinkeby: {\n      live: true,\n      saveDeployments: true,\n      tags: [\"staging\"]\n    }\n  }\n}\n```\n\n#### `deploy`\n\nthe deploy field override the paths.deploy option and let you define a set of folder containing the deploy scripts to be executed for this network.\n\nYou can thus have one network that will be executing L1 deployment and other L2 deployments, etc...\n\nYou could also have a folder that deploy contracts that are live on mainnet but that you need to replicate for your test or local network.\n\n#### `companionNetworks`\n\nthe companionNetworks field is an object whose key is any name you desire and the value is the name of a network that will be accessible inside the deploy script. For example:\n\n```js\n{\n  ...\n  networks: {\n    optimism: {\n      url: 'http://127.0.0.1:8545',\n      ovm: true,\n      companionNetworks: {\n        l1: 'localhost',\n      },\n    }\n  }\n  ...\n}\n```\n\nBy using name you can have the same deploy script used in different set of network.\n\nFor your test you could have the companion networks pointing to the same hardhat network, for test deployment, you could have rinkeby acting like your l2 while goerli act as your l1.\n\nAn example repo that show case a multi-network setup with optimism can be found here : https://github.com/wighawag/template-ethereum-contracts/tree/examples/optimism\n\ndeploy script can then access the network and its deployment as follow :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  const OVM_L1ERC20Gateway = await hre.companionNetworks['l1'].deployments.get(\n    'OVM_L1ERC20Gateway'\n  ); // layer 1\n\n  await execute(\n    'SimpleERC20_OVM',\n    {from: deployer, log: true},\n    'init',\n    OVM_L1ERC20Gateway.address\n  );\n};\n```\n\n---\n\n### **3. extra hardhat.config paths' options**\n\n---\n\n`hardhat-deploy` also adds fields to `HardhatConfig`'s `ProjectPaths` object.\n\nHere is an example showing the default values :\n\n```js\n{\n    paths: {\n        deploy: 'deploy',\n        deployments: 'deployments',\n        imports: 'imports'\n    }\n}\n```\n\nThe `deploy` folder is expected to contains the deploy script that are executed upon invocation of `hardhat deploy` or `hardhat node`.\nIt can also be an array of folder path.\n\nThe `deployments` folder will contains the resulting deployments (contract addresses along their abi, bytecode, metadata...). One folder per network and one file per contract.\n\nThe `imports` folder is expected to contains artifacts that were pre-compiled. Useful if you want to upgrade to a new solidity version but want to keep using previously compiled contracts. The artifact is the same format as normal hardhat artifact, so you can easily copy them over, before switching to a new compiler version.\n\n> This is less useful now that hardhat support multiple solidity compiler at once.\n\n---\n\n---\n\n### **4. deterministicDeployment (ability to specify a deployment factory)**\n\n---\n\nThis plugin extends the `HardhatConfig`'s object with an optional `deterministicDeployment` field.\n\n`deterministicDeployment` allows you to associate information that are used on each network for deterministic deployment. The information for each deterministic deployment consist out of a `factory`, a `deployer`, the required `funding` and a `signedTx` to deploy the factory. The default deterministic deployment used is the [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy). The factory expects a 32 bytes `salt` concatenated with the deployment data (see [EIP-1014](https://eips.ethereum.org/EIPS/eip-1014) for more information on these parameters).\n\nUsing the `deterministicDeployment` it is possible to define a different setup for the deterministic deployment. One use case for this is the deterministic deployment on networks that required replay protection (such as Celo or Avalanche). The [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy) can only be deployed on networks that don't enforce replay protection, therefore on other networks an alternative library has to be used. An example for this would be the [Safe Singleton Factory](https://github.com/gnosis/safe-singleton-factory) that is an adjusted version of the [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy) that contains signed transactions that include replay protection.\n\nThe information can be defined either as an object\n\n```js\n{\n    deterministicDeployment: {\n      \"4\": {\n        factory: \"<factory_address>\",\n        deployer: \"<deployer_address>\",\n        funding: \"<required_funding_in_wei>\",\n        signedTx: \"<raw_signed_tx>\",\n      }\n    }\n}\n```\n\nor as an function that returns the information for the deterministic deployment\n\n```js\n{\n  deterministicDeployment: (network: string) => {\n    return {\n      factory: '<factory_address>',\n      deployer: '<deployer_address>',\n      funding: '<required_funding_in_wei>',\n      signedTx: '<raw_signed_tx>',\n    };\n  };\n}\n```\n\n### Importing deployment from other projects (with truffle support)\n\n`hardhat-deploy` also add the `external` field to `HardhatConfig`\n\nSuch field allows to specify paths for external artifacts or **deployments**.\n\nThe external object has 2 fields:\n\n```js\n{\n    external: {\n        contracts: [\n          {\n            artifacts: \"node_modules/@cartesi/arbitration/export/artifacts\",\n            deploy: \"node_modules/@cartesi/arbitration/export/deploy\"\n          },\n          {\n            artifacts: \"node_modules/someotherpackage/artifacts\",\n          }\n        ],\n        deployments: {\n          rinkeby: [\"node_modules/@cartesi/arbitration/build/contracts\"],\n        },\n    }\n}\n```\n\nThe `contracts` field specify an array of object which itself have 2 fields.\n\n- `artifacts`: (mandatory) it is a path to an artifact folder. This support both hardhat and truffle artifacts.\n- `deploy`: (optional) it specifies a path to a folder where reside deploy script. The deploy scripts have only access to the artifact specified in the artifacts field. This allow project to share their deployment procedure. A boon for developer aiming at integrating it as they can get the contracts to be deployed for testing locally.\n\nThe `deployments` fields specify an object whose field nasme are the hardhat network and the value is an array of path to look for deployments. It supports both **hardhat-deploy** and truffle formats.\n\n---\n\n### Access to Artifacts (non-deployed contract code and abi)\n\nArtifacts in hardhat terminology represent a compiled contract (not yet deployed) with at least its bytecode and abi.\n\n`hardhat-deploy` gives can access to these artifact via the `deployments.getArtifact` function :\n\n```js\nconst {deployments} = require('hardhat');\nconst artifact = await deployments.getArtifact(artifactName);\n```\n\nWith the `hardhat-deploy-ethers` plugin you can get an artifact as an ethers contract factory, ready to be deployed, via the following:\n\n```js\nconst {deployments, ethers} = require('hardhat');\nconst factory = await ethers.getContractFactory(artifactName);\n```\n\n> Note that the artifact's files need to be either in `artifacts` folder that hardhat generate on compilation or in the `imports` folder where you can store contracts compiled elsewhere. They can also be present in the folder specified in `external.artifacts` see [Importing deployment from other projects](#importing-deployment-from-other-projects-with-truffle-support)\n\n---\n\n---\n\n## How to Deploy Contracts\n\n---\n\n### The `deploy` Task\n\n`hardhat --network <networkName> deploy [options and flags]`\n\nThis is a new task that the `hardhat-deploy` adds. As the name suggests it deploys contracts.\nTo be exact it will look for files in the folder `deploy` or whatever was configured in `paths.deploy`, see [paths config](#extra-paths-config)\n\nIt will scan for files in alphabetical order and execute them in turn.\n\n- it will `require` each of these files and execute the exported function with the HRE as argument\n\nTo specify the network, you can use the builtin hardhat argument `--network <network name>` or set the env variable `HARDHAT_NETWORK`\n\n> :warning: Note that running `hardhat deploy` without specifying a network will use the default network. If the default network is hardhat (the default's default) then nothing will happen as a result as everything happens in memory, but this can be used to ensure the deployment is without issues.\n\n---\n\n### Deploy Scripts\n\nThe deploy scripts need to be of the following type :\n\n```ts\nexport interface DeployFunction {\n  (env: HardhatRuntimeEnvironment): Promise<void | boolean>;\n  skip?: (env: HardhatRuntimeEnvironment) => Promise<boolean>;\n  tags?: string[];\n  dependencies?: string[];\n  runAtTheEnd?: boolean;\n  id?: string;\n}\n```\n\nThe skip function can be used to skip executing the script under whatever condition. It simply need to resolve a promise to true.\n\nThe tags is a list of string that when the _deploy_ task is executed with, the script will be executed (unless it skips). In other word if the deploy task is executed with a tag that does not belong to that script, that script will not be executed unless it is a dependency of a script that does get executed.\n\nThe dependencies is a list of tag that will be executed if that script is executed. So if the script is executed, every script whose tag match any of the dependencies will be executed first.\n\nThe `runAtTheEnd` is a boolean that if set to true, will queue that script to be executed after all other scripts are executed.\n\nThese set of fields allow more flexibility to organize the scripts. You are not limited to alphabetical order and you can even organise deploy script in sub folders.\n\nFinally the function can return true if it wishes to never be executed again. This can be usfeul to emulate migration scripts that are meant to be executed only once. Once such script return true (async), the `id` field is used to track execution and if that field is not present when the script return true, it will fails.\n\nIn other words, if you want a particular deploy script to run only once, it needs to both return true (async) and have an `id` set.\n\nIn any case, as a general advice every deploy function should be idempotent. This is so they can always recover from failure or pending transaction. This is what underpin most of hardhat-deploy philosophy.\n\nThis is why the `hre.deployments.deploy` function will by default only deploy if the contract code has changed, making it easier to write idempotent script.\n\n#### An example of a deploy script :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  // the following will only deploy \"GenericMetaTxProcessor\" if the contract was never deployed or if the code changed since last deployment\n  await deploy('GenericMetaTxProcessor', {\n    from: deployer,\n    gasLimit: 4000000,\n    args: [],\n  });\n};\n```\n\nAs you can see the HRE passed in has 4 new fields :\n\n- `getNamedAccounts` is a function that returns a promise to an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [`namedAccounts`](#namedaccounts)).\n\n- `getUnnamedAccounts` is a function that return a promise to an array of accounts which were not named (see [`namedAccounts`](#namedaccounts)). It is useful for tests where you want to be sure that the account has no speicifc role in the system (no token given, no admin access, etc...).\n\n- `getChainId` is a function which return a promise for the chainId, as convenience\n\n- `deployments` is an object which contains functions to access past deployments or to save new ones, as well as helpers functions.\n\nThat latter field contains for example the `deploy` function that allows you to deploy contract and save them. It contains a lot more functions though :\n\n---\n\n### The `deployments` field\n\nThe deployments field contains several helpers function to deploy contract but also execute transaction.\n\n```ts\nexport interface DeploymentsExtension {\n  deploy(name: string, options: DeployOptions): Promise<DeployResult>; // deploy a contract\n  diamond: {\n    // deploy diamond based contract (see section below)\n    deploy(name: string, options: DiamondOptions): Promise<DeployResult>;\n  };\n  deterministic( // return the determinsitic address as well as a function to deploy the contract, can pass the `salt` field in the option to use different salt\n    name: string,\n    options: Create2DeployOptions\n  ): Promise<{\n    address: Address;\n    implementationAddress?: Address;\n    deploy(): Promise<DeployResult>;\n  }>;\n  fetchIfDifferent( // return true if new compiled code is different than deployed contract\n    name: string,\n    options: DeployOptions\n  ): Promise<{differences: boolean; address?: string}>;\n  save(name: string, deployment: DeploymentSubmission): Promise<void>; // low level save of deployment\n  get(name: string): Promise<Deployment>; // fetch a deployment by name, throw if not existing\n  getOrNull(name: string): Promise<Deployment | null>; // fetch deployment by name, return null if not existing\n  getDeploymentsFromAddress(address: string): Promise<Deployment[]>;\n  all(): Promise<{[name: string]: Deployment}>; // return all deployments\n  getArtifact(name: string): Promise<Artifact>; // return a hardhat artifact (compiled contract without deployment)\n  getExtendedArtifact(name: string): Promise<ExtendedArtifact>; // return a extended artifact (with more info) (compiled contract without deployment)\n  run( // execute deployment scripts\n    tags?: string | string[],\n    options?: {\n      resetMemory?: boolean;\n      deletePreviousDeployments?: boolean;\n      writeDeploymentsToFiles?: boolean;\n      export?: string;\n      exportAll?: string;\n    }\n  ): Promise<{[name: string]: Deployment}>;\n  fixture( // execute deployment as fixture for test // use evm_snapshot to revert back\n    tags?: string | string[],\n    options?: {fallbackToGlobal?: boolean; keepExistingDeployments?: boolean}\n  ): Promise<{[name: string]: Deployment}>;\n  createFixture<T, O>( // execute a function as fixture using evm_snaphost to revert back each time\n    func: FixtureFunc<T, O>,\n    id?: string\n  ): (options?: O) => Promise<T>;\n  log(...args: any[]): void; // log data only ig log enabled (disabled in test fixture)\n\n  execute( // execute function call on contract\n    name: string,\n    options: TxOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<Receipt>;\n  rawTx(tx: SimpleTx): Promise<Receipt>; // execute a simple transaction\n  catchUnknownSigner( // you can wrap other function with this function and it will catch failure due to missing signer with the details of the tx to be executed\n    action: Promise<any> | (() => Promise<any>),\n    options?: {log?: boolean}\n  ): Promise<null | {\n    from: string;\n    to?: string;\n    value?: string;\n    data?: string;\n  }>;\n  read( // make a read-only call to a contract\n    name: string,\n    options: CallOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<any>;\n  read(name: string, methodName: string, ...args: any[]): Promise<any>;\n  // rawCall(to: Address, data: string): Promise<any>; // TODO ?\n}\n```\n\n---\n\n#### `deployments.deploy(<name>, options)`\n\n---\n\nThe `deploy` function, as mentioned above, allows you to deploy a contract and save it under a specific name.\n\nThe deploy function expect 2 parameters: one for the name and one for the options\n\nSee below the full list of fields that the option parameter allows and requires:\n\n```ts\nexport interface DeployOptions = {\n  from: string; // address (or private key) that will perform the transaction. you can use `getNamedAccounts` to retrived the address you want by name.\n  contract?: // this is an optional field. If not specified it defaults to the contract with the same name as the first parameter\n    | string // this field can be either a string for the name of the contract\n    | { // or abi and bytecode\n        abi: ABI;\n        bytecode: string;\n        deployedBytecode?: string;\n      };\n  args?: any[]; // the list of argument for the constructor (or the upgrade function in case of proxy)\n  skipIfAlreadyDeployed?: boolean; // if set it to true, will not attempt to deploy even if the contract deployed under the same name is different\n  log?: boolean; // if true, it will log the result of the deployment (tx hash, address and gas used)\n  linkedData?: any; // This allow to associate any JSON data to the deployment. Useful for merkle tree data for example\n  libraries?: { [libraryName: string]: Address }; // This let you associate libraries to the deployed contract\n  proxy?: boolean | string | ProxyOptions; // This options allow to consider your contract as a proxy (see below for more details)\n\n  // here some common tx options :\n  gasLimit?: string | number | BigNumber;\n  gasPrice?: string | BigNumber;\n  value?: string | BigNumber;\n  nonce?: string | number | BigNumber;\n\n  estimatedGasLimit?: string | number | BigNumber; // to speed up the estimation, it is possible to provide an upper gasLimit\n  estimateGasExtra?: string | number | BigNumber; // this option allow you to add a gas buffer on top of the estimation\n\n  autoMine?: boolean; // this force a evm_mine to be executed. this is useful to speed deployment on test network that allow to specify a block delay (ganache for example). This option basically skip the delay by force mining.\n  deterministicDeployment? boolean | string; // if true, it will deploy the contract at a deterministic address based on bytecode and constructor arguments. The address will be the same across all network. It use create2 opcode for that, if it is a string, the string will be used as the salt.\n  waitConfirmations?: number; // number of the confirmations to wait after the transactions is included in the chain\n};\n```\n\n---\n\n---\n\n## Handling contract using libraries\n\nIn the deploy function, one of the `DeployOptions` field is the `libraries` field. It allows you to associate external contract as libraries at the time of deployment.\n\nFirst, you have deploy the library using the `deploy` function, then when we deploy a contract that needs the linked library, we can pass the deployed library name and address in as an argument to the `libraries` object.\n\nFirst step: deploy the library:\n\n```js\nconst exampleLibrary = await deploy(\"ExampleLibary\", {\n    from: <deployer>\n});\n\n```\n\nExampleLibrary is now deployed to whatever network was chosen (`hardhat deploy --network <networkName>`)\n\nFor example, if we are deploying on Rinkeby, this library will get deployed on rinkeby, and the `exampleLibrary` variable will be a deployment object that contains the abi as well as the deployed address for the contract.\n\nNow that the library is deployed, we can link it in our next deployed contract.\n\n```js\nconst example = await deploy(\"Example\", {\n    from: <deployer>\n    args: [\"example string argument for the 'Example' contract constructor\"],\n    libraries: {\n        ExampleLibrary: exampleLibrary.address\n    }\n});\n\n```\n\nThis `libraries` object takes the name of the library, and its deployed address on the network. Multiple libraries can be passed into the `libraries` object.\n\n---\n\n---\n\n## Exporting Deployments\n\nApart from deployments saved in the `deployments` folder which contains all information available about the contract (compile time data + deployment data), `hardhat-deploy` allows you to export lightweight files.\n\nThese can be used for example to power your frontend with contract's address and abi.\n\nThis come into 2 flavors.\n\nThe first one is exported via the `--export <file>` option and follow the following format :\n\n```ts\nexport interface Export {\n  chainId: string;\n  name: string;\n  contracts: {[name: string]: ContractExport};\n}\n```\n\nwhere name is the name of the network configuration chosen (see hardhat option `--network`)\n\nThe second one is exported via the `--export-all <file>` option and follow the following format :\n\n```ts\nexport type MultiExport = {\n  [chainId: string]: Export[];\n};\n```\n\nAs you see the second format include the previous. While in most case you'll need the single export where your application will support only one network, there are case where your app would want to support multiple networks at nonce. This second format allow for that.\n\nFurthermore as hardhat support multiple network configuration for the same network (rinkeby, mainnet...), the export-all format will contains each of them grouped by their chainId.\n\nNote: from v0.10.4 the old multi-export down is no more:\n\n```\nexport type MultiExport = {\n  [chainId: string]: {[name: string]: Export};\n};\n```\n\n---\n\n---\n\n## Deploying and Upgrading Proxies\n\nAs mentioned above, the deploy function can also deploy a contract through a proxy. It can be done without modification of the contract as long as its number of constructor arguments matches the proxy initialization/update function.\n\nThe default Proxy is both ERC-1967 and ERC-173 Compliant, but other proxy can be specified, like openzeppelin transparent proxies.\n\nCode for the default Proxy can be found [here](solc_0.7/proxy/EIP173Proxy.sol).\n\nTo perform such proxy deployment, you just need to invoke the deploy function with the following options : `{..., proxy: true}`\n\nSee example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: true,\n  });\n};\n```\n\nYou can also set it to `proxy: \"<upgradeMethodName>\"` in which case the function `<upgradeMethodName>` will be executed upon upgrade.\nthe `args` field will be then used for that function instead of the contructor. It is also possible to then have a constructor with the same arguments and have the proxy be disabled. It can be useful if you want to have your contract as upgradeable in a test network but be non-upgradeable on the mainnet.\n\nSee example :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  network,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: network.live ? false : 'postUpgrade',\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nThe proxy option can also be an object which can set the specific owner that the proxy is going to be managed by.\n\nSee example:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: {\n      owner: greeterOwner,\n      methodName: 'postUpgrade',\n    },\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nNote that for the second invokation, this deployment will not be executed from the specified `from: deployer` as otherwise these tx will always fails. It will instead be automatically executed from the proxy's current owner (in that case : `greeterOwner`)\n\nNow, it is likely you do not want to locally handle the private key / mnemonic of the account that manage the proxy or it could even be that the `greeterOwner` in question is a multi sig. As such that second invocation will throw an error as it cannot find a local signer for it.\n\nThe error will output the necessary information to upgrade the contract but `hardhat-deploy` comes also with a utility function for such case: `deployments.catchUnknwonSigner` which will catch the error and output to the console the necessary information while continuing to next step.\n\nHere is the full example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy, catchUnknownSigner} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await catchUnknownSigner(\n    deploy('Greeter', {\n      from: deployer,\n      proxy: {\n        owner: greeterOwner,\n        methodName: 'postUpgrade',\n      },\n      args: ['arg1', 2, 3],\n    })\n  );\n  // you could pause the deployment here and wait for input to continue\n};\n```\n\nThe full proxy options is as follow:\n\n```ts\ntype ProxyOptionsBase = {\n  owner?: Address; // this set the owner of the proxy. further upgrade will need to be executed from that owner\n  upgradeIndex?: number; // allow you to breakdown your upgrades into separate deploy scriot, each with their own index. A deploy call with a specific upgradeIndex will be executed only once, only if the current upgradeIndex is one less.\n  proxyContract?: // default to \"EIP173Proxy\". See below for more details\n  string | ArtifactData;\n  viaAdminContract?: // allow to specify a contract that act as a middle man to perform upgrades. Useful and Recommended for Transparent Proxies\n  | string\n    | {\n        name: string;\n        artifact?: string | ArtifactData;\n      };\n};\n\nexport type ProxyOptions =\n  | (ProxyOptionsBase & {\n      methodName?: string; // method to be executed when the proxy is deployed for the first time or when the implementation is modified. Use the deployOptions args field for arguments\n    })\n  | (ProxyOptionsBase & {\n      execute?:\n        | {\n            methodName: string; // method to be executed when the proxy is deployed for the first time or when the implementation is modified.\n            args: any[];\n          }\n        | {\n            init: {\n              methodName: string; // method to be executed when the proxy is deployed\n              args: any[];\n            };\n            onUpgrade?: {\n              methodName: string; // method to be executed when the proxy is upgraded (not first deployment)\n              args: any[];\n            };\n          };\n    });\n```\n\nThe `proxyContract` field allow you to specify your own Proxy contract. If it is a string, it will first attempt to get an artifact with that name. If not found it will fallback on the following if\n\nit matches:\n\n- `EIP173Proxy`: use the default Proxy that is EIP-173 compliant\n\n- `EIP173ProxyWithReceive`: Same as above except that the proxy contains a receive hook to accept empty ETH payment.\n\n- `OpenZeppelinTransparentProxy`: Use Openzeppelin Transparent Proxy (copied from openzeppelin repo, see code [here](solc_0.7/openzeppelin/proxy/TransparentUpgradeableProxy.sol))\n  When this option is chosen, the `DefaultProxyAdmin` is also used as admin since Transparent Proxy kind of need an intermediarry contract for administration. This can be configured via the `viaAdminContract` option. Note that the DefaultProxyAdmin is slightly different than the one used by openzeppelin as it allow you to set a different owner than msg.sender on first deploy, something openzeppelin version do not allow, see : https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2639\n\n- `OptimizedTransparentProxy`: This contract is similar to above, except that it is optimized to not require storage read for the admin on every call.\n\n## Builtin-In Support For Diamonds (EIP2535)\n\nThe deployments field also expose the diamond field: `hre.deployments.diamond` that let you deploy [Diamonds](https://eips.ethereum.org/EIPS/eip-2535) in an easy way.\n\n### deployment / upgrade\n\nInstead of specifying the facets to cut out or cut in, which the diamond contract expects, you specify the facets you want to end up having on the deployed contract.\n\nThis declarative approach allow you to focus on what you want instead of how to do it.\n\n`diamond.deploy` expect the facet as names. The names represent contract to be deployed as facet. In future version you ll be able to specify deployed contract or artifact object as facet.\n\nTo deploy a contract with 3 facet you can do as follow :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: deployer,\n    owner: diamondAdmin,\n    facets: ['Facet1', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nif you then later execute the following script:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: diamondAdmin, // this need to be the diamondAdmin for upgrade\n    owner: diamondAdmin,\n    facets: ['NewFacet', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nThen the NewFacet will be deployed automatically if needed and then the diamondCut will cut Facet1 out and add NewFacet.\n\nNote that if the code for Facet2 and Facet3 changes, they will also be redeployed automatically and the diamondCuts will replace the existing facets with these new ones.\n\nNote that the diamond has 3 facet added by default. These facets are used for ownership, diamondCut and diamond loupe.\n\nThe implementation is a sligthly modified version of the [reference implementation by Nick Mudge](https://github.com/mudgen/diamond-3).\nTHe only difference is the custom constructor that allow multiple initialization, used to allow the default ERC165 facet to be initialised along your custom initialization function.\n\n### onUpgrade calls\n\nLike normal proxies you can also execute a function at the time of an upgrade.\n\nThis is done by specifying the execute field in the diamond deploy options :\n\n```js\ndiamond.deploy('ADiamondContract', {\n  from: deployer,\n  owner: diamondAdmin,\n  facets: ['NewFacet', 'Facet2', 'Facet3'],\n  execute: {\n    methodName: 'postUpgrade',\n    args: ['one', 2, '0x3'],\n  },\n});\n```\n\n### more...\n\nThere are more options, to be described later...\n\n## Testing Deployed Contracts\n\nYou can continue using the usual test task:\n\n`hardhat test`\n\nTests can use the `hre.deployments.fixture` function to run the deployment and snapshot it so that tests don't need to perform all the deployment transactions every time. They can simply reuse the snapshot for every test (this leverages `evm_snapshot` and `evm_revert` provided by both `hardhat` and `ganache`). You can for example set them in a `beforeEach`.\n\nHere is an example of a test :\n\n```js\nconst {deployments} = require('hardhat');\n\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    await deployments.fixture(['Token']);\n    const Token = await deployments.get('Token'); // Token is available because the fixture was executed\n    console.log(Token.address);\n    const ERC721BidSale = await deployments.get('ERC721BidSale');\n    console.log({ERC721BidSale});\n  });\n});\n```\n\nTests can also leverage named accounts for clearer test. Combined with `hardhat-deploy-ethers` plugin, you can write succint test :\n\n```js\nconst {ethers, getNamedAccounts} = require('hardhat');\n\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    await deployments.fixture(['Token']);\n    const {tokenOwner} = await getNamedAccounts();\n    const TokenContract = await ethers.getContract('Token', tokenOwner);\n    await TokenContract.mint(2).then((tx) => tx.wait());\n  });\n});\n```\n\n---\n\n### Creating Fixtures\n\nFurthermore, tests can easily create efficient fixture using `deployments.createFixture`\n\nSee example :\n\n```js\nconst setupTest = deployments.createFixture(\n  async ({deployments, getNamedAccounts, ethers}, options) => {\n    await deployments.fixture(); // ensure you start from a fresh deployments\n    const {tokenOwner} = await getNamedAccounts();\n    const TokenContract = await ethers.getContract('Token', tokenOwner);\n    await TokenContract.mint(10).then((tx) => tx.wait()); //this mint is executed once and then `createFixture` will ensure it is snapshotted\n    return {\n      tokenOwner: {\n        address: tokenOwner,\n        TokenContract,\n      },\n    };\n  }\n);\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    const {tokenOwner} = await setupTest();\n    await tokenOwner.TokenContract.mint(2);\n  });\n});\n```\n\nWhile this example is trivial, some fixture can requires several transaction and the ability to snapshot them automatically speed up the tests greatly.\n\n---\n\n---\n\n## More Information On Hardhat Tasks\n\n---\n\n### **1. node task**\n\nas mentioned above, the node task is slighly modified and augmented with various flags and options\n\n`hardhat node`\n\nIn particular it adds an argument `--export` that allows you to specify a destination file where the info about the contracts deployed is written.\nYour webapp can then access all contracts information.\n\n---\n\n### **2. test task**\n\n`hardhat test`\n\nthe test task is augmented with one flag argument `--deploy-fixture` that allows to run all deployments in a fixture snapshot before executing the tests. This can speed up the tests that use specific tags as the global fixture take precedence (unless specified).\n\nIn other word tests can use `deployments.fixture(<specific tag>)` where specific tag only deploys the minimal contracts for tests, while still benefiting from global deployment snapshot if used.\n\nIf a test needs the deployments to only include the specific deployment specified by the tag, it can use the following :\n\n```js\ndeployments.fixture('<specific tag>', {fallbackToGlobal: false});\n```\n\nDue to how snapshot/revert works in hardhat, this means that these tests will not benefit from the global fixture snapshot and will have to deploy their contracts as part of the fixture call. This is automatic but means that these tests will run slower.\n\n---\n\n### **3. run task**\n\n`hardhat --network <networkName> run <script>`\n\nThe run task act as before but thanks to the `hre.deployments` field it can access deployed contract :\n\n```js\nconst hre = require('hardhat');\nconst {deployments, getNamedAccounts} = hre;\n\n(async () => {\n  console.log(await deployments.all());\n  console.log({namedAccounts: await getNamedAccounts()});\n})();\n```\n\nYou can also run it directly from the command line as usual.\n\n`HARDHAT_NETWORK=rinkeby node <script>` is the equivalent except it does not load the hardhat environment twice (which the run task does)\n\n---\n\n### **4. console task**\n\n`hardhat console`\n\nThe same applies to the `console` task.\n\n---\n\n## Deploy Scripts: Tags And Dependencies\n\n---\n\nIt is possible to execute only specific parts of the deployments with `hardhat deploy --tags <tags>`\n\nTags represent what the deploy script acts on. In general it will be a single string value, the name of the contract it deploys or modifies.\n\nThen if another deploy script has such tag as a dependency, then when this latter deploy script has a specific tag and that tag is requested, the dependency will be executed first.\n\nHere is an example of two deploy scripts :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const deployResult = await deploy('Token', {\n    from: deployer,\n    args: ['hello', 100],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Token deployed at ${deployResult.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Token'];\n```\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const Token = await deployments.get('Token');\n  const deployResult = await deploy('Sale', {\n    from: deployer,\n    contract: 'ERC721BidSale',\n    args: [Token.address, 1, 3600],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Sale deployed at ${deployResult.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.dependencies = ['Token']; // this ensure the Token script above is executed first, so `deployments.get('Token')` succeeds\n```\n\nAs you can see the second one depends on the first. This is because the second script depends on a tag that the first script registers as using.\n\nWith that when `hardhat deploy --tags Sale` is executed\n\nthen both scripts will be run, ensuring Sale is ready.\n\nYou can also define the script to run after another script is run by setting `runAtTheEnd` to be true. For example:\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, execute, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer, admin} = namedAccounts;\n  await execute('Sale', {from: deployer}, 'setAdmin', admin);\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.runAtTheEnd = true;\n```\n\nTags can also be used in test with `deployments.fixture`. This allow you to test a subset of the deploy script.\n","readmeFilename":"README.md","gitHead":"bb4bc136e297079de5f6cb50e95deee591b71a1b","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.3-experimental.0","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-3MBTXADr7vKfRAGgmHpsrfz0HD+4Yy7ta/8R+vzeO+Sx2hpA6NZo/y0UZQOCHN6/ySHk6rh7QzM4vyD0iCtu0A==","shasum":"c4f8689af38f4658805aedbf871045c40fdedc01","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.3-experimental.0.tgz","fileCount":149,"unpackedSize":12107073,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiPBFVACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmpiFg//THsdkoY/xH30HQHfJ2L4bGw3LvUT3hxdBRccA4SdJDo3xWvB\r\ngqqxaAaZRxuZ+/I/hM4Y8gdoc2ccXLU8ENqEeOeTU0hZwwR5FzEToQiLScrq\r\n7hC/SuAZkRQWi621saQORJrGcfCJ8YKpey28whY1VFLBfDtJ01sl3UoXnjsZ\r\nZRCR8675kJsA7aDU1Y4RZR0wf8AZdD+H7vqiVkkfxHn0kp0/dwuSjqy7mWEB\r\ndwLdZKu6jnM8eLOGeD3fi62UrfNi0KDTriu9jvaCuaN7KNIiIQMZP3QMHt/A\r\n91Jec7xWAPP0Gzn4qJdoN0LjCDHoq2f+v7z7zojOibrplra4HOsc2+qXozfT\r\nvifKMC9n+gqhLa+wwU9vf4uxz2dBDq5SL+ImIfCdhFTL6YVCsqEp7rj7a+xf\r\nh7XC5uTJR+FS1hy629vq0BBWAh1UjmGk6N6hjeJzw2FfTo1t8paEF/OIZiEq\r\nnRW/gwCseclOOxnB93EbsVmYFJb3t14zWKoZ3kdPc4CIYcLoSFCmFjUyrUmG\r\nMA8cuzi/wIzXEaOL0mlF5ztXRMcOZ6SevYEVuFb07mawOr6HIzYjrUsOUMH4\r\n0vdz4wGhtxZaoOuCfBGn8GX7ZIUeLVi6GelQ1SbdQo5xMABaqMEYXrUKF/Il\r\nJ2Pvlqe4Bi0PMfg+rBHFX67aS2w7NARPg6A=\r\n=1jOa\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIEarqqUH5KaD05g4oE7TX/LFLlhQ1evEYg5zC3zYPC9GAiEA73DupOxbtOvj2tZCRNTwnra2Pf4r8afdeh1po3Rf4to="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.3-experimental.0_1648103765123_0.15864514812982167"},"_hasShrinkwrap":false},"0.11.3-experimental.1":{"name":"hardhat-deploy","version":"0.11.3-experimental.1","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.8","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.6.8"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"readme":"<h1> hardhat-deploy</h1>\n\n_A [Hardhat](https://hardhat.org) Plugin For Replicable Deployments And Easy Testing_\n\n> **A complete dev template using hardhat-deploy is available here** : https://github.com/wighawag/template-ethereum-contracts\n> It also contains various branches examplifying the capability of hardhat-deploy. Check it out.\n\n- [What is it for ?](#what-is-it-for-)\n- [hardhat-deploy in a nutshell](#hardhat-deploy-in-a-nutshell)\n- [Installation](#installation)\n  - [npm install hardhat-deploy](#npm-install-hardhat-deploy)\n  - [TypeScript support](#typescript-support)\n  - [Migrating existing deployment to hardhat-deploy](#migrating-existing-deployment-to-hardhat-deploy)\n- [Hardhat Tasks Available/Updated](#hardhat-tasks-availableupdated)\n  - [1. hardhat deploy](#1-hardhat-deploy)\n    - [**Options**](#options)\n    - [**Flags**](#flags)\n  - [2. hardhat node](#2-hardhat-node)\n    - [**Options**](#options-1)\n    - [**Flags**](#flags-1)\n  - [3. hardhat test](#3-hardhat-test)\n  - [4. hardhat etherscan-verify](#4-hardhat-etherscan-verify)\n    - [**Options**](#options-2)\n  - [5. hardhat sourcify](#5-hardhat-sourcify)\n    - [**Options**](#options-3)\n  - [6. hardhat export](#6-hardhat-export)\n    - [**Options**](#options-4)\n- [Hardhat Environment Extensions](#hardhat-environment-extensions)\n- [Configuration](#configuration)\n  - [**1. namedAccounts (ability to name addresses)**](#1-namedaccounts-ability-to-name-addresses)\n  - [**2. extra hardhat.config networks' options**](#2-extra-hardhatconfig-networks-options)\n    - [`live`](#live)\n    - [`saveDeployments`](#savedeployments)\n    - [`tags`](#tags)\n    - [`deploy`](#deploy)\n    - [`companionNetworks`](#companionnetworks)\n  - [**3. extra hardhat.config paths' options**](#3-extra-hardhatconfig-paths-options)\n  - [**4. deterministicDeployment (ability to specify a deployment factory)**](#4-deterministicdeployment-ability-to-specify-a-deployment-factory)\n  - [Importing deployment from other projects (with truffle support)](#importing-deployment-from-other-projects-with-truffle-support)\n  - [Access to Artifacts (non-deployed contract code and abi)](#access-to-artifacts-non-deployed-contract-code-and-abi)\n- [How to Deploy Contracts](#how-to-deploy-contracts)\n  - [The `deploy` Task](#the-deploy-task)\n  - [Deploy Scripts](#deploy-scripts)\n    - [An example of a deploy script :](#an-example-of-a-deploy-script-)\n  - [The `deployments` field](#the-deployments-field)\n    - [`deployments.deploy(<name>, options)`](#deploymentsdeployname-options)\n- [Handling contract using libraries](#handling-contract-using-libraries)\n- [Exporting Deployments](#exporting-deployments)\n- [Deploying and Upgrading Proxies](#deploying-and-upgrading-proxies)\n- [Builtin-In Support For Diamonds (EIP2535)](#builtin-in-support-for-diamonds-eip2535)\n  - [deployment / upgrade](#deployment--upgrade)\n  - [onUpgrade calls](#onupgrade-calls)\n  - [more...](#more)\n- [Testing Deployed Contracts](#testing-deployed-contracts)\n  - [Creating Fixtures](#creating-fixtures)\n- [More Information On Hardhat Tasks](#more-information-on-hardhat-tasks)\n  - [**1. node task**](#1-node-task)\n  - [**2. test task**](#2-test-task)\n  - [**3. run task**](#3-run-task)\n  - [**4. console task**](#4-console-task)\n- [Deploy Scripts: Tags And Dependencies](#deploy-scripts-tags-and-dependencies)\n\n## What is it for ?\n\nThis [hardhat](https://hardhat.org) plugin adds a mechanism to deploy contracts to any network, keeping track of them and replicating the same environment for testing.\n\nIt also adds a mechanism to associate names to addresses, so test and deployment scripts can be reconfigured by simply changing the address a name points to, allowing different configurations per network. This also results in much clearer tests and deployment scripts (no more `accounts[0]` in your code).\n\nThis plugin contains a lot more features too, all geared toward a better developer experience :\n\n- chain configuration export\n- listing deployed contracts' addresses and their abis (useful for webapps)\n- library linking at time of deployment.\n- deterministic deployment across networks.\n- support for specific deploy script per network (L1 vs L2 for example)\n- ability to access deployment from \"companion\" networks\n- deployment dependency system (allowing you to only deploy what is needed).\n- deployment retrying (by saving pending tx): so you can feel confident when making a deployment that you can always recover.\n- deployments as test fixture using `evm_snapshot` to speed up testing.\n- ability to create your own test fixture that automatically benefits from `evm_snapshot`'s tests speed-up boost\n- combined with [hardhat-deploy-ethers](https://github.com/wighawag/hardhat-deploy-ethers) it has the ability to get ethers contract instance by name (like `await ethers.getContract(\"ContractName\")`).\n- importing artifact from external sources (like npm packages), including [truffle](https://www.trufflesuite.com/truffle) support.\n- importing deployments from external sources (like npm packages)\n- ability to log information in `deploy` mode only (while in test the console remains clean).\n- contains helpers to read and execute transaction on deployed contract referring to them by name.\n- These helpers contains options to auto mine on dev network (to speed up test deployments).\n- save metadata of deployed contract so they can always be fully verified, via [sourcify](https://sourcify.dev) or [etherscan](https://etherscan.io).\n- ability to submit contract source to etherscan and sourcify for verification at any time. (Because **hardhat-deploy** will save all the necessary info, it can be executed at any time.)\n- support harhdat's fork feature so deployment can be accessed even when run through fork.\n- named accounts are automatically impersonnated too, so you can perform tx as if you had their private key.\n- proxy deployment with ability to upgrade them transparently, only if code changes.\n- this include support for [openzeppelin](https://openzeppelin.com) transparent proxies\n- diamond deployment with facets, allowing you to focus on what the new version will be. It will generate the diamondCut necessary to reach the new state.\n- watch and deploy: **hardhat-deploy** can watch both your deploy script and contract code and redeploy on changes.\n- HCR (Hot Contract Replacement): the watch feature combined with proxy or diamond, gives you an experience akin to frontend Hot Module Replacement: once your contract changes, the deployment is executed and your contract retains the same address and same state, allowing you to tweak your contracts while debugging your front-end.\n\n## hardhat-deploy in a nutshell\n\nBefore going into the details, here is a very simple summary of the basic feature of **hardhat-deploy**.\n\n**hardhat-deploy** allows you to write [`deploy scripts`](#deploy-scripts) in the `deploy` folder. Each of these files that look as follows will be executed in turn when you execute the following task: `hardhat --network <networkName> deploy`\n\n```js\n// deploy/00_deploy_my_contract.js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('MyContract', {\n    from: deployer,\n    args: ['Hello'],\n    log: true,\n  });\n};\nmodule.exports.tags = ['MyContract'];\n```\n\nFurthermore you can also ensure these scripts are executed in test too by calling `await deployments.fixture(['MyContract'])` in your test.\nThis is optimized, so if multiple tests use the same contract, the deployment will be executed once and each test will start with the exact same state.\n\nThis is a huge benefit for testing since you are not required to replicate the deployment procedure in your tests. The tag feature (as seen in the script above) and [dependencies](#deploy-scripts-tags-and-dependencies) will also make your life easier when writing complex deployment procedures.\n\nYou can even group deploy scripts in different sub folder and ensure they are executed in their logical order.\n\nFurthermore hardhat-deploy can also support a multi-chain settings like L1, L2 with multiple deploy folder specific to each network.\n\n**All of this can also be bundled in a npm package so user of hardhat-deploy can reuse your deployment procedure and get started integrating with your project locally.**\n\nThere is a tutorial covering the basics here : https://github.com/wighawag/tutorial-hardhat-deploy\n\n## Installation\n\n### npm install hardhat-deploy\n\n```bash\nnpm install -D hardhat-deploy\n```\n\nAnd add the following statement to your `hardhat.config.js`:\n\n```js\nrequire('hardhat-deploy');\n```\n\nif you use `ethers.js` we recommend you also install `hardhat-deploy-ethers` which add extra features to access deployments as ethers contract.\n\nSince `hardhat-deploy-ethers` is a fork of `@nomiclabs/hardhat-ethers` and that other plugin might have an hardcoded dependency on `@nomiclabs/hardhat-ethers` the best way to install `hardhat-deploy-ethers` and ensure compatibility is the following:\n\n```bash\nnpm install --save-dev  @nomiclabs/hardhat-ethers@npm:hardhat-deploy-ethers ethers\n```\n\nWhich means you then need to do `require(\"@nomiclabs/hardhat-ethers\")` instead of `require(\"hardhat-deploy-ethers\")` in your `hardhat.config.js` file.\n\nMore details on `hardhat-deploy-ethers` repo : https://github.com/wighawag/hardhat-deploy-ethers#readme\n\n### TypeScript support\n\nWith hardhat the tsconfig.json is optional.\n\nBut if you add folders to the `include` field in `tsconfig.json`, you ll also need to include `hardhat.config.ts` like :\n\n`include\": [\"./hardhat.config.ts\", \"./scripts\", \"./deploy\", \"./test\"]`\n\nfor deploy script (see below) you can write them this way to benefit from typing :\n\n```ts\nimport {HardhatRuntimeEnvironment} from 'hardhat/types';\nimport {DeployFunction} from 'hardhat-deploy/types';\n\nconst func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {\n  // code here\n};\nexport default func;\n```\n\nSee a template that uses **hardhat-deploy** here : https://github.com/wighawag/template-ethereum-contracts\n\nThis repo has also some examples branch that exemplify specific features, like the forking testing here : https://github.com/wighawag/template-ethereum-contracts/tree/examples/fork-test\n\n### Migrating existing deployment to hardhat-deploy\n\n> Only needed for existing project that already deployed contracts and has the deployment information available **(at minimum, address and abi)**\n\nYou might want to switch your current deployment process to use **hardhat-deploy**. In that case you probably have some deployments saved elsewhere.\n\nIn order to port them to **hardhat-deploy**, you'll need to create one `.json` file per contract in the `deployments/<network>` folder (configurable via [paths config](#extra-paths-config)).\n\nThe network folder is simply the hardhat network name (as configured in hardhat.config.js) (accessible at runtime via `hre.network.name`).\nSuch folder need to have a file named `.chainId` containing the chainId as decimal.\n\nFor example for network named \"rinkeby\" (for the corresponding network) the file `deployments/rinkeby/.chainId` would be\n\n```\n4\n```\n\nNote, prior to hardhat 0.6 the chainId was appended to the folder name (expect for some known network name). This has changed and upgrading to 0.6 will require you to change the folder name and add the '.chainId' file.\n\nEach contract file must follow this type (as defined in [types.ts](types.ts)) :\n\n```ts\nexport interface Deployment {\n  address: Address;\n  abi: ABI;\n  receipt?: Receipt;\n  transactionHash?: string;\n  history?: Deployment[];\n  numDeployments?: number;\n  implementation?: string;\n  args?: any[];\n  linkedData?: any;\n  solcInputHash?: string;\n  metadata?: string;\n  bytecode?: string;\n  deployedBytecode?: string;\n  libraries?: Libraries;\n  userdoc?: any;\n  devdoc?: any;\n  methodIdentifiers?: any;\n  diamondCut?: FacetCut[];\n  facets?: Facet[];\n  storageLayout?: any;\n  gasEstimates?: any;\n}\n```\n\nAs you can see, only abi and address are mandatory. But having the other fields allow more feature. For example, metadata and args allow you to benefit from contract code verification.\n\nFor Receipt, the following type is expected:\n\n```ts\nexport type Receipt = {\n  from: string;\n  transactionHash: string;\n  blockHash: string;\n  blockNumber: number;\n  transactionIndex: number;\n  cumulativeGasUsed: string;\n  gasUsed: string;\n  contractAddress?: string;\n  to?: string;\n  logs?: Log[];\n  events?: any[];\n  logsBloom?: string;\n  byzantium?: boolean;\n  status?: number;\n  confirmations?: number;\n};\n```\n\nHere is an example:\n\nLet's say you have:\n\n- 2 Contract named Greeter and Registry deployed on rinkeby\n- 1 contract named Greeter on mainnet\n- 2 Contract named Greeter and Registry deployed on a network named rinkeby2\n\nYou would get the following folder structure:\n\n```\ndeployments/\n  mainnet/\n    .chainId\n    Greeter.json\n  rinkeby/\n    .chainId\n    Greeter.json\n    Registry.json\n  rinkeby2/\n    .chainId\n    Greeter.json\n    Registry.json\n```\n\nThe reason why **hardhat-deploy** save chainId in the `.chainId` file is both for\n\n- safety: so that if you were to change the network name to point to a different chain, it would not attempt to read the wrong folder and assume that a contract has been deployed while it has not.\n- ability to know the chainId without requring to be connected to a node (and so not dependent on hardhat.config.js settings). Useful for `export` task.\n\n---\n\n## Hardhat Tasks Available/Updated\n\nhardhat deploy add several task to hardhat. It also modify existing one, adding new options and new behavior. All of these are described here:\n\n---\n\n### 1. hardhat deploy\n\n---\n\nThis plugin adds the _deploy_ task to Hardhat.\n\nThis task will execute the scripts in the `deploy` folder and save the contract deployments to disk. These deployments are supposed to be saved for example in a git repository. This way they can be accessed later. But you are free to save them elsewhere and get them back via your mechanism of choice.\n\nWith the deployment saved, it allows you to deploy a contract only if changes were made.\n\nDeploy scripts (also called Deploy functions) can also perform aribtrary logic.\n\nFor further details on how to use it and write deploy script, see [section](#deploy-scripts) below.\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployments, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice (in wei) to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--reset`: This flag resets the deployments from scratch. Previously deployed contract are not considered and deleted from disk.\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n---\n\n### 2. hardhat node\n\n---\n\nThis plugin modify the _node_ task so that it also execute the deployment script before exposing the server http RPC interface\n\nIt add similar options than the `deploy` task :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--no-reset`: This flag prevent the reseting of the existing deployments. This is usually not desired when running the `node` task as a network is created from scratch and previous deployemnt are irrelevant.\n\n`--show-accounts`: this flag will output the account private keys\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n`--no-deploy` that discard all other options to revert to normal `hardhat node` behavior without any deployment being performed.\n\n> :warning: Note that the deployments are saved as if the network name is `localhost`. This is because `hardhat node` is expected to be used as localhost: You can for example execute `hardhat --network localhost console` after `node` is running. Doing `hardhat --network hardhat console` would indeed not do anything useful. It still take the configuration from `hardhat` in the hardhat.config.js file though.\n\n---\n\n### 3. hardhat test\n\n---\n\nThis plugin adds a flag argument `--deploy-fixture` to the _test_ task which if enabled will run the global deployments fixture before the tests and snapshots it. This will generaly speed up the tests as further test will be able to revert back to the full deployment.\n\n> :warning: Note though that if your test behave differently whether that option is on or not, this most likely mean that your deploy scripts' tags and dependencies are not configured correctly. This is because the global fixture will ensure all contract are deployed while test will usually (for efficiency) ask for a particular tag.\n\n---\n\n### 4. hardhat etherscan-verify\n\n---\n\nThis plugin adds the _etherscan-verify_ task to Hardhat.\n\nThis task will submit the contract source and other info of all deployed contracts to allow etherscan to verify and record the sources.\n\nInstead of using the full solc input, this task will first attempt to send the minimal sources from the metadata.\nBut Etherscan sometime fails due to a bug in solidity compiler (<https://github.com/ethereum/solidity/issues/9573>). As such this task can fallback on full solc input (see option --solc-input). Note that if your contract was deployed with a previous version of **hardhat-deploy**, it might not contains the full information. The issue seems to be fully resolved since solc version 0.8.\n\nThis task will also attempt to automatically find the SPDX license in the source.\n\nTo execute that task, you need to specifiy the network to run against :\n\n```bash\nhardhat --network mainnet etherscan-verify [--api-key <apikey>] [--apiurl <url>]\n```\n\n#### **Options**\n\nNote that harhdat-deploy now use a different config format to not conflict with `hardhat-etherscan`\n\n`--api-key <api key>`: let you specify your etherscan api key. Alternatively, you can provide it via the env variable `ETHERSCAN_API_KEY` or through the hardhat.config.ts verify field:\n\n```js\n{\n  ...\n  verify: {\n    etherscan: {\n      apiKey: '<API key>'\n    }\n  }\n}\n```\n\n`--api-url <url>`: let you specify your etherscan url to submit the source to. Can also be configured per network in `hardhat.config.js`:\n\n```js\n{\n  ...\n  networks: {\n    mynetwork: {\n      ...\n      verify: {\n        etherscan: {\n          apiUrl: 'http://mynetwork.xyz'\n        }\n      }\n    }\n  }\n}\n```\n\n`--license <SPDX license id>`: SPDX license (useful if SPDX is not listed in the sources), need to be supported by etherscan: https://etherscan.io/contract-license-types\n\n`--force-license`: if set, will force the use of the license specified by --license option, ignoring the one in the source (useful for license not supported by etherscan)\n\n`--solc-input`: fallback on solc-input id needed (useful when etherscan fails on the minimum sources, see https://github.com/ethereum/solidity/issues/9573)\n\n`--sleep`: sleep 500ms between each verification, so API rate limit is not exceeded\n\n---\n\n### 5. hardhat sourcify\n\n---\n\nThis plugin adds the _sourcify_ task to Hardhat.\n\nSimilar to `hardhat etherscan-verify` this task will submit the contract source and other info of all deployed contracts to sourcify.\n\n```bash\nhardhat --network mainnet sourcify\n```\n\nLater this task might instead pin the metadata to ipfs, so sourcify can automatically verify them.\n\n#### **Options**\n\n`--contract-name <contract name>`: specify the contract's name you want to verify\n  \n`--endpoint <endpoint>`: specify the sourcify endpoint, default to https://sourcify.dev/server/\n\n`--write-failing-metadata`: if set and the sourcify task fails to verify, the metadata file will be written to disk, so you can more easily figure out what has gone wrong.\n\n---\n\n### 6. hardhat export\n\n---\n\nThis plugin adds the _export_ task to Hardhat.\n\nThis task will export the contract deployed (saved in `deployments` folder) to a file with a simple format containing only contract addresses and abi, useful for web apps.\n\nOne of the following options need to be set for this task to have any effects :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\nThis last option has some limitations, when combined with the use of external deployments (see [Configuration](#configuration)). If such external deployments were using older version of **hardhat-deploy** or truffle, the chainId might be missing. In order for these to be exported, the hardhat network config need to explicity state the chainId in the `networks` config of `hardhat.config.js`.\n\nWith both `--export` and `--export-all`, using the special `<filepath>` value of `-` will output to `STDOUT` rather than writing a normal file.\n\n---\n\n---\n\n## Hardhat Environment Extensions\n\nThis plugin extends the Hardhat Runtime Environment by adding 4 fields:\n\n- `getNamedAccounts: () => Promise<{ [name: string]: string }>`: a function returning an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [Configuration](#configuration)).\n\n- `getUnnamedAccounts: () => Promise<string[]}>`: accounts which has no names, useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`: contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId(): Promise<string>`: offer an easy way to fetch the current chainId.\n\n---\n\n---\n\n## Configuration\n\n---\n\n### **1. namedAccounts (ability to name addresses)**\n\n---\n\nThis plugin extends the `HardhatConfig`'s object with an optional `namedAccounts` field.\n\n`namedAccounts` allows you to associate names to addresses and have them configured per chain.\nThis allows you to have meaningful names in your tests while the addresses match to multi sig in real network for example.\n\n```js\n{\n    namedAccounts: {\n        deployer: {\n            default: 0, // here this will by default take the first account as deployer\n            1: 0, // similarly on mainnet it will take the first account as deployer. Note though that depending on how hardhat network are configured, the account 0 on one network can be different than on another\n            4: '0xA296a3d5F026953e17F472B497eC29a5631FB51B', // but for rinkeby it will be a specific address\n            \"goerli\": '0x84b9514E013710b9dD0811c9Fe46b837a4A0d8E0', //it can also specify a specific netwotk name (specified in hardhat.config.js)\n        },\n        feeCollector:{\n            default: 1, // here this will by default take the second account as feeCollector (so in the test this will be a different account than the deployer)\n            1: '0xa5610E1f289DbDe94F3428A9df22E8B518f65751', // on the mainnet the feeCollector could be a multi sig\n            4: '0xa250ac77360d4e837a13628bC828a2aDf7BabfB3', // on rinkeby it could be another account\n        }\n    }\n}\n```\n\n<!-- You can also specify addresses with the `ledger://` prefix. In which case the account fetched will still be the corresponding address, but behind the scene, the transaction will be created via the hardware waller. Currently the feature is not working very well though and better support is needed. -->\n\n---\n\n### **2. extra hardhat.config networks' options**\n\n---\n\n**hardhat-deploy** add 5 new fields to `networks` configuration\n\n#### `live`\n\nthis is not used internally but is useful to perform action on a network whether it is a live network (rinkeby, mainnet, etc) or a temporary one (localhost, hardhat). The default is true (except for localhost and hardhat where the default is false).\n\n#### `saveDeployments`\n\nthis tell whether **hardhat-deploy** should save the deployments to disk or not. Default to true, except for the hardhat network.\n\n#### `tags`\n\nnetwork can have tags to represent them. The config is an array and at runtime the hre.network.tags is an object whose fields (the tags) are set to true.\n\nThis is useful to conidtionaly operate on network based on their use case.\n\nExample:\n\n```js\n{\n  networks: {\n    localhost: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"local\"]\n    },\n    hardhat: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"test\", \"local\"]\n    },\n    rinkeby: {\n      live: true,\n      saveDeployments: true,\n      tags: [\"staging\"]\n    }\n  }\n}\n```\n\n#### `deploy`\n\nthe deploy field override the paths.deploy option and let you define a set of folder containing the deploy scripts to be executed for this network.\n\nYou can thus have one network that will be executing L1 deployment and other L2 deployments, etc...\n\nYou could also have a folder that deploy contracts that are live on mainnet but that you need to replicate for your test or local network.\n\n#### `companionNetworks`\n\nthe companionNetworks field is an object whose key is any name you desire and the value is the name of a network that will be accessible inside the deploy script. For example:\n\n```js\n{\n  ...\n  networks: {\n    optimism: {\n      url: 'http://127.0.0.1:8545',\n      ovm: true,\n      companionNetworks: {\n        l1: 'localhost',\n      },\n    }\n  }\n  ...\n}\n```\n\nBy using name you can have the same deploy script used in different set of network.\n\nFor your test you could have the companion networks pointing to the same hardhat network, for test deployment, you could have rinkeby acting like your l2 while goerli act as your l1.\n\nAn example repo that show case a multi-network setup with optimism can be found here : https://github.com/wighawag/template-ethereum-contracts/tree/examples/optimism\n\ndeploy script can then access the network and its deployment as follow :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  const OVM_L1ERC20Gateway = await hre.companionNetworks['l1'].deployments.get(\n    'OVM_L1ERC20Gateway'\n  ); // layer 1\n\n  await execute(\n    'SimpleERC20_OVM',\n    {from: deployer, log: true},\n    'init',\n    OVM_L1ERC20Gateway.address\n  );\n};\n```\n\n---\n\n### **3. extra hardhat.config paths' options**\n\n---\n\n`hardhat-deploy` also adds fields to `HardhatConfig`'s `ProjectPaths` object.\n\nHere is an example showing the default values :\n\n```js\n{\n    paths: {\n        deploy: 'deploy',\n        deployments: 'deployments',\n        imports: 'imports'\n    }\n}\n```\n\nThe `deploy` folder is expected to contains the deploy script that are executed upon invocation of `hardhat deploy` or `hardhat node`.\nIt can also be an array of folder path.\n\nThe `deployments` folder will contains the resulting deployments (contract addresses along their abi, bytecode, metadata...). One folder per network and one file per contract.\n\nThe `imports` folder is expected to contains artifacts that were pre-compiled. Useful if you want to upgrade to a new solidity version but want to keep using previously compiled contracts. The artifact is the same format as normal hardhat artifact, so you can easily copy them over, before switching to a new compiler version.\n\n> This is less useful now that hardhat support multiple solidity compiler at once.\n\n---\n\n---\n\n### **4. deterministicDeployment (ability to specify a deployment factory)**\n\n---\n\nThis plugin extends the `HardhatConfig`'s object with an optional `deterministicDeployment` field.\n\n`deterministicDeployment` allows you to associate information that are used on each network for deterministic deployment. The information for each deterministic deployment consist out of a `factory`, a `deployer`, the required `funding` and a `signedTx` to deploy the factory. The default deterministic deployment used is the [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy). The factory expects a 32 bytes `salt` concatenated with the deployment data (see [EIP-1014](https://eips.ethereum.org/EIPS/eip-1014) for more information on these parameters).\n\nUsing the `deterministicDeployment` it is possible to define a different setup for the deterministic deployment. One use case for this is the deterministic deployment on networks that required replay protection (such as Celo or Avalanche). The [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy) can only be deployed on networks that don't enforce replay protection, therefore on other networks an alternative library has to be used. An example for this would be the [Safe Singleton Factory](https://github.com/gnosis/safe-singleton-factory) that is an adjusted version of the [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy) that contains signed transactions that include replay protection.\n\nThe information can be defined either as an object\n\n```js\n{\n    deterministicDeployment: {\n      \"4\": {\n        factory: \"<factory_address>\",\n        deployer: \"<deployer_address>\",\n        funding: \"<required_funding_in_wei>\",\n        signedTx: \"<raw_signed_tx>\",\n      }\n    }\n}\n```\n\nor as an function that returns the information for the deterministic deployment\n\n```js\n{\n  deterministicDeployment: (network: string) => {\n    return {\n      factory: '<factory_address>',\n      deployer: '<deployer_address>',\n      funding: '<required_funding_in_wei>',\n      signedTx: '<raw_signed_tx>',\n    };\n  };\n}\n```\n\n### Importing deployment from other projects (with truffle support)\n\n`hardhat-deploy` also add the `external` field to `HardhatConfig`\n\nSuch field allows to specify paths for external artifacts or **deployments**.\n\nThe external object has 2 fields:\n\n```js\n{\n    external: {\n        contracts: [\n          {\n            artifacts: \"node_modules/@cartesi/arbitration/export/artifacts\",\n            deploy: \"node_modules/@cartesi/arbitration/export/deploy\"\n          },\n          {\n            artifacts: \"node_modules/someotherpackage/artifacts\",\n          }\n        ],\n        deployments: {\n          rinkeby: [\"node_modules/@cartesi/arbitration/build/contracts\"],\n        },\n    }\n}\n```\n\nThe `contracts` field specify an array of object which itself have 2 fields.\n\n- `artifacts`: (mandatory) it is a path to an artifact folder. This support both hardhat and truffle artifacts.\n- `deploy`: (optional) it specifies a path to a folder where reside deploy script. The deploy scripts have only access to the artifact specified in the artifacts field. This allow project to share their deployment procedure. A boon for developer aiming at integrating it as they can get the contracts to be deployed for testing locally.\n\nThe `deployments` fields specify an object whose field nasme are the hardhat network and the value is an array of path to look for deployments. It supports both **hardhat-deploy** and truffle formats.\n\n---\n\n### Access to Artifacts (non-deployed contract code and abi)\n\nArtifacts in hardhat terminology represent a compiled contract (not yet deployed) with at least its bytecode and abi.\n\n`hardhat-deploy` gives can access to these artifact via the `deployments.getArtifact` function :\n\n```js\nconst {deployments} = require('hardhat');\nconst artifact = await deployments.getArtifact(artifactName);\n```\n\nWith the `hardhat-deploy-ethers` plugin you can get an artifact as an ethers contract factory, ready to be deployed, via the following:\n\n```js\nconst {deployments, ethers} = require('hardhat');\nconst factory = await ethers.getContractFactory(artifactName);\n```\n\n> Note that the artifact's files need to be either in `artifacts` folder that hardhat generate on compilation or in the `imports` folder where you can store contracts compiled elsewhere. They can also be present in the folder specified in `external.artifacts` see [Importing deployment from other projects](#importing-deployment-from-other-projects-with-truffle-support)\n\n---\n\n---\n\n## How to Deploy Contracts\n\n---\n\n### The `deploy` Task\n\n`hardhat --network <networkName> deploy [options and flags]`\n\nThis is a new task that the `hardhat-deploy` adds. As the name suggests it deploys contracts.\nTo be exact it will look for files in the folder `deploy` or whatever was configured in `paths.deploy`, see [paths config](#extra-paths-config)\n\nIt will scan for files in alphabetical order and execute them in turn.\n\n- it will `require` each of these files and execute the exported function with the HRE as argument\n\nTo specify the network, you can use the builtin hardhat argument `--network <network name>` or set the env variable `HARDHAT_NETWORK`\n\n> :warning: Note that running `hardhat deploy` without specifying a network will use the default network. If the default network is hardhat (the default's default) then nothing will happen as a result as everything happens in memory, but this can be used to ensure the deployment is without issues.\n\n---\n\n### Deploy Scripts\n\nThe deploy scripts need to be of the following type :\n\n```ts\nexport interface DeployFunction {\n  (env: HardhatRuntimeEnvironment): Promise<void | boolean>;\n  skip?: (env: HardhatRuntimeEnvironment) => Promise<boolean>;\n  tags?: string[];\n  dependencies?: string[];\n  runAtTheEnd?: boolean;\n  id?: string;\n}\n```\n\nThe skip function can be used to skip executing the script under whatever condition. It simply need to resolve a promise to true.\n\nThe tags is a list of string that when the _deploy_ task is executed with, the script will be executed (unless it skips). In other word if the deploy task is executed with a tag that does not belong to that script, that script will not be executed unless it is a dependency of a script that does get executed.\n\nThe dependencies is a list of tag that will be executed if that script is executed. So if the script is executed, every script whose tag match any of the dependencies will be executed first.\n\nThe `runAtTheEnd` is a boolean that if set to true, will queue that script to be executed after all other scripts are executed.\n\nThese set of fields allow more flexibility to organize the scripts. You are not limited to alphabetical order and you can even organise deploy script in sub folders.\n\nFinally the function can return true if it wishes to never be executed again. This can be usfeul to emulate migration scripts that are meant to be executed only once. Once such script return true (async), the `id` field is used to track execution and if that field is not present when the script return true, it will fails.\n\nIn other words, if you want a particular deploy script to run only once, it needs to both return true (async) and have an `id` set.\n\nIn any case, as a general advice every deploy function should be idempotent. This is so they can always recover from failure or pending transaction. This is what underpin most of hardhat-deploy philosophy.\n\nThis is why the `hre.deployments.deploy` function will by default only deploy if the contract code has changed, making it easier to write idempotent script.\n\n#### An example of a deploy script :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  // the following will only deploy \"GenericMetaTxProcessor\" if the contract was never deployed or if the code changed since last deployment\n  await deploy('GenericMetaTxProcessor', {\n    from: deployer,\n    gasLimit: 4000000,\n    args: [],\n  });\n};\n```\n\nAs you can see the HRE passed in has 4 new fields :\n\n- `getNamedAccounts` is a function that returns a promise to an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [`namedAccounts`](#namedaccounts)).\n\n- `getUnnamedAccounts` is a function that return a promise to an array of accounts which were not named (see [`namedAccounts`](#namedaccounts)). It is useful for tests where you want to be sure that the account has no speicifc role in the system (no token given, no admin access, etc...).\n\n- `getChainId` is a function which return a promise for the chainId, as convenience\n\n- `deployments` is an object which contains functions to access past deployments or to save new ones, as well as helpers functions.\n\nThat latter field contains for example the `deploy` function that allows you to deploy contract and save them. It contains a lot more functions though :\n\n---\n\n### The `deployments` field\n\nThe deployments field contains several helpers function to deploy contract but also execute transaction.\n\n```ts\nexport interface DeploymentsExtension {\n  deploy(name: string, options: DeployOptions): Promise<DeployResult>; // deploy a contract\n  diamond: {\n    // deploy diamond based contract (see section below)\n    deploy(name: string, options: DiamondOptions): Promise<DeployResult>;\n  };\n  deterministic( // return the determinsitic address as well as a function to deploy the contract, can pass the `salt` field in the option to use different salt\n    name: string,\n    options: Create2DeployOptions\n  ): Promise<{\n    address: Address;\n    implementationAddress?: Address;\n    deploy(): Promise<DeployResult>;\n  }>;\n  fetchIfDifferent( // return true if new compiled code is different than deployed contract\n    name: string,\n    options: DeployOptions\n  ): Promise<{differences: boolean; address?: string}>;\n  save(name: string, deployment: DeploymentSubmission): Promise<void>; // low level save of deployment\n  get(name: string): Promise<Deployment>; // fetch a deployment by name, throw if not existing\n  getOrNull(name: string): Promise<Deployment | null>; // fetch deployment by name, return null if not existing\n  getDeploymentsFromAddress(address: string): Promise<Deployment[]>;\n  all(): Promise<{[name: string]: Deployment}>; // return all deployments\n  getArtifact(name: string): Promise<Artifact>; // return a hardhat artifact (compiled contract without deployment)\n  getExtendedArtifact(name: string): Promise<ExtendedArtifact>; // return a extended artifact (with more info) (compiled contract without deployment)\n  run( // execute deployment scripts\n    tags?: string | string[],\n    options?: {\n      resetMemory?: boolean;\n      deletePreviousDeployments?: boolean;\n      writeDeploymentsToFiles?: boolean;\n      export?: string;\n      exportAll?: string;\n    }\n  ): Promise<{[name: string]: Deployment}>;\n  fixture( // execute deployment as fixture for test // use evm_snapshot to revert back\n    tags?: string | string[],\n    options?: {fallbackToGlobal?: boolean; keepExistingDeployments?: boolean}\n  ): Promise<{[name: string]: Deployment}>;\n  createFixture<T, O>( // execute a function as fixture using evm_snaphost to revert back each time\n    func: FixtureFunc<T, O>,\n    id?: string\n  ): (options?: O) => Promise<T>;\n  log(...args: any[]): void; // log data only ig log enabled (disabled in test fixture)\n\n  execute( // execute function call on contract\n    name: string,\n    options: TxOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<Receipt>;\n  rawTx(tx: SimpleTx): Promise<Receipt>; // execute a simple transaction\n  catchUnknownSigner( // you can wrap other function with this function and it will catch failure due to missing signer with the details of the tx to be executed\n    action: Promise<any> | (() => Promise<any>),\n    options?: {log?: boolean}\n  ): Promise<null | {\n    from: string;\n    to?: string;\n    value?: string;\n    data?: string;\n  }>;\n  read( // make a read-only call to a contract\n    name: string,\n    options: CallOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<any>;\n  read(name: string, methodName: string, ...args: any[]): Promise<any>;\n  // rawCall(to: Address, data: string): Promise<any>; // TODO ?\n}\n```\n\n---\n\n#### `deployments.deploy(<name>, options)`\n\n---\n\nThe `deploy` function, as mentioned above, allows you to deploy a contract and save it under a specific name.\n\nThe deploy function expect 2 parameters: one for the name and one for the options\n\nSee below the full list of fields that the option parameter allows and requires:\n\n```ts\nexport interface DeployOptions = {\n  from: string; // address (or private key) that will perform the transaction. you can use `getNamedAccounts` to retrived the address you want by name.\n  contract?: // this is an optional field. If not specified it defaults to the contract with the same name as the first parameter\n    | string // this field can be either a string for the name of the contract\n    | { // or abi and bytecode\n        abi: ABI;\n        bytecode: string;\n        deployedBytecode?: string;\n      };\n  args?: any[]; // the list of argument for the constructor (or the upgrade function in case of proxy)\n  skipIfAlreadyDeployed?: boolean; // if set it to true, will not attempt to deploy even if the contract deployed under the same name is different\n  log?: boolean; // if true, it will log the result of the deployment (tx hash, address and gas used)\n  linkedData?: any; // This allow to associate any JSON data to the deployment. Useful for merkle tree data for example\n  libraries?: { [libraryName: string]: Address }; // This let you associate libraries to the deployed contract\n  proxy?: boolean | string | ProxyOptions; // This options allow to consider your contract as a proxy (see below for more details)\n\n  // here some common tx options :\n  gasLimit?: string | number | BigNumber;\n  gasPrice?: string | BigNumber;\n  value?: string | BigNumber;\n  nonce?: string | number | BigNumber;\n\n  estimatedGasLimit?: string | number | BigNumber; // to speed up the estimation, it is possible to provide an upper gasLimit\n  estimateGasExtra?: string | number | BigNumber; // this option allow you to add a gas buffer on top of the estimation\n\n  autoMine?: boolean; // this force a evm_mine to be executed. this is useful to speed deployment on test network that allow to specify a block delay (ganache for example). This option basically skip the delay by force mining.\n  deterministicDeployment? boolean | string; // if true, it will deploy the contract at a deterministic address based on bytecode and constructor arguments. The address will be the same across all network. It use create2 opcode for that, if it is a string, the string will be used as the salt.\n  waitConfirmations?: number; // number of the confirmations to wait after the transactions is included in the chain\n};\n```\n\n---\n\n---\n\n## Handling contract using libraries\n\nIn the deploy function, one of the `DeployOptions` field is the `libraries` field. It allows you to associate external contract as libraries at the time of deployment.\n\nFirst, you have deploy the library using the `deploy` function, then when we deploy a contract that needs the linked library, we can pass the deployed library name and address in as an argument to the `libraries` object.\n\nFirst step: deploy the library:\n\n```js\nconst exampleLibrary = await deploy(\"ExampleLibary\", {\n    from: <deployer>\n});\n\n```\n\nExampleLibrary is now deployed to whatever network was chosen (`hardhat deploy --network <networkName>`)\n\nFor example, if we are deploying on Rinkeby, this library will get deployed on rinkeby, and the `exampleLibrary` variable will be a deployment object that contains the abi as well as the deployed address for the contract.\n\nNow that the library is deployed, we can link it in our next deployed contract.\n\n```js\nconst example = await deploy(\"Example\", {\n    from: <deployer>\n    args: [\"example string argument for the 'Example' contract constructor\"],\n    libraries: {\n        ExampleLibrary: exampleLibrary.address\n    }\n});\n\n```\n\nThis `libraries` object takes the name of the library, and its deployed address on the network. Multiple libraries can be passed into the `libraries` object.\n\n---\n\n---\n\n## Exporting Deployments\n\nApart from deployments saved in the `deployments` folder which contains all information available about the contract (compile time data + deployment data), `hardhat-deploy` allows you to export lightweight files.\n\nThese can be used for example to power your frontend with contract's address and abi.\n\nThis come into 2 flavors.\n\nThe first one is exported via the `--export <file>` option and follow the following format :\n\n```ts\nexport interface Export {\n  chainId: string;\n  name: string;\n  contracts: {[name: string]: ContractExport};\n}\n```\n\nwhere name is the name of the network configuration chosen (see hardhat option `--network`)\n\nThe second one is exported via the `--export-all <file>` option and follow the following format :\n\n```ts\nexport type MultiExport = {\n  [chainId: string]: Export[];\n};\n```\n\nAs you see the second format include the previous. While in most case you'll need the single export where your application will support only one network, there are case where your app would want to support multiple networks at nonce. This second format allow for that.\n\nFurthermore as hardhat support multiple network configuration for the same network (rinkeby, mainnet...), the export-all format will contains each of them grouped by their chainId.\n\nNote: from v0.10.4 the old multi-export down is no more:\n\n```\nexport type MultiExport = {\n  [chainId: string]: {[name: string]: Export};\n};\n```\n\n---\n\n---\n\n## Deploying and Upgrading Proxies\n\nAs mentioned above, the deploy function can also deploy a contract through a proxy. It can be done without modification of the contract as long as its number of constructor arguments matches the proxy initialization/update function.\n\nThe default Proxy is both ERC-1967 and ERC-173 Compliant, but other proxy can be specified, like openzeppelin transparent proxies.\n\nCode for the default Proxy can be found [here](solc_0.7/proxy/EIP173Proxy.sol).\n\nTo perform such proxy deployment, you just need to invoke the deploy function with the following options : `{..., proxy: true}`\n\nSee example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: true,\n  });\n};\n```\n\nYou can also set it to `proxy: \"<upgradeMethodName>\"` in which case the function `<upgradeMethodName>` will be executed upon upgrade.\nthe `args` field will be then used for that function instead of the contructor. It is also possible to then have a constructor with the same arguments and have the proxy be disabled. It can be useful if you want to have your contract as upgradeable in a test network but be non-upgradeable on the mainnet.\n\nSee example :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  network,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: network.live ? false : 'postUpgrade',\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nThe proxy option can also be an object which can set the specific owner that the proxy is going to be managed by.\n\nSee example:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: {\n      owner: greeterOwner,\n      methodName: 'postUpgrade',\n    },\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nNote that for the second invokation, this deployment will not be executed from the specified `from: deployer` as otherwise these tx will always fails. It will instead be automatically executed from the proxy's current owner (in that case : `greeterOwner`)\n\nNow, it is likely you do not want to locally handle the private key / mnemonic of the account that manage the proxy or it could even be that the `greeterOwner` in question is a multi sig. As such that second invocation will throw an error as it cannot find a local signer for it.\n\nThe error will output the necessary information to upgrade the contract but `hardhat-deploy` comes also with a utility function for such case: `deployments.catchUnknwonSigner` which will catch the error and output to the console the necessary information while continuing to next step.\n\nHere is the full example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy, catchUnknownSigner} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await catchUnknownSigner(\n    deploy('Greeter', {\n      from: deployer,\n      proxy: {\n        owner: greeterOwner,\n        methodName: 'postUpgrade',\n      },\n      args: ['arg1', 2, 3],\n    })\n  );\n  // you could pause the deployment here and wait for input to continue\n};\n```\n\nThe full proxy options is as follow:\n\n```ts\ntype ProxyOptionsBase = {\n  owner?: Address; // this set the owner of the proxy. further upgrade will need to be executed from that owner\n  upgradeIndex?: number; // allow you to breakdown your upgrades into separate deploy scriot, each with their own index. A deploy call with a specific upgradeIndex will be executed only once, only if the current upgradeIndex is one less.\n  proxyContract?: // default to \"EIP173Proxy\". See below for more details\n  string | ArtifactData;\n  viaAdminContract?: // allow to specify a contract that act as a middle man to perform upgrades. Useful and Recommended for Transparent Proxies\n  | string\n    | {\n        name: string;\n        artifact?: string | ArtifactData;\n      };\n};\n\nexport type ProxyOptions =\n  | (ProxyOptionsBase & {\n      methodName?: string; // method to be executed when the proxy is deployed for the first time or when the implementation is modified. Use the deployOptions args field for arguments\n    })\n  | (ProxyOptionsBase & {\n      execute?:\n        | {\n            methodName: string; // method to be executed when the proxy is deployed for the first time or when the implementation is modified.\n            args: any[];\n          }\n        | {\n            init: {\n              methodName: string; // method to be executed when the proxy is deployed\n              args: any[];\n            };\n            onUpgrade?: {\n              methodName: string; // method to be executed when the proxy is upgraded (not first deployment)\n              args: any[];\n            };\n          };\n    });\n```\n\nThe `proxyContract` field allow you to specify your own Proxy contract. If it is a string, it will first attempt to get an artifact with that name. If not found it will fallback on the following if\n\nit matches:\n\n- `EIP173Proxy`: use the default Proxy that is EIP-173 compliant\n\n- `EIP173ProxyWithReceive`: Same as above except that the proxy contains a receive hook to accept empty ETH payment.\n\n- `OpenZeppelinTransparentProxy`: Use Openzeppelin Transparent Proxy (copied from openzeppelin repo, see code [here](solc_0.7/openzeppelin/proxy/TransparentUpgradeableProxy.sol))\n  When this option is chosen, the `DefaultProxyAdmin` is also used as admin since Transparent Proxy kind of need an intermediarry contract for administration. This can be configured via the `viaAdminContract` option. Note that the DefaultProxyAdmin is slightly different than the one used by openzeppelin as it allow you to set a different owner than msg.sender on first deploy, something openzeppelin version do not allow, see : https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2639\n\n- `OptimizedTransparentProxy`: This contract is similar to above, except that it is optimized to not require storage read for the admin on every call.\n\n## Builtin-In Support For Diamonds (EIP2535)\n\nThe deployments field also expose the diamond field: `hre.deployments.diamond` that let you deploy [Diamonds](https://eips.ethereum.org/EIPS/eip-2535) in an easy way.\n\n### deployment / upgrade\n\nInstead of specifying the facets to cut out or cut in, which the diamond contract expects, you specify the facets you want to end up having on the deployed contract.\n\nThis declarative approach allow you to focus on what you want instead of how to do it.\n\n`diamond.deploy` expect the facet as names. The names represent contract to be deployed as facet. In future version you ll be able to specify deployed contract or artifact object as facet.\n\nTo deploy a contract with 3 facet you can do as follow :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: deployer,\n    owner: diamondAdmin,\n    facets: ['Facet1', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nif you then later execute the following script:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: diamondAdmin, // this need to be the diamondAdmin for upgrade\n    owner: diamondAdmin,\n    facets: ['NewFacet', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nThen the NewFacet will be deployed automatically if needed and then the diamondCut will cut Facet1 out and add NewFacet.\n\nNote that if the code for Facet2 and Facet3 changes, they will also be redeployed automatically and the diamondCuts will replace the existing facets with these new ones.\n\nNote that the diamond has 3 facet added by default. These facets are used for ownership, diamondCut and diamond loupe.\n\nThe implementation is a sligthly modified version of the [reference implementation by Nick Mudge](https://github.com/mudgen/diamond-3).\nTHe only difference is the custom constructor that allow multiple initialization, used to allow the default ERC165 facet to be initialised along your custom initialization function.\n\n### onUpgrade calls\n\nLike normal proxies you can also execute a function at the time of an upgrade.\n\nThis is done by specifying the execute field in the diamond deploy options :\n\n```js\ndiamond.deploy('ADiamondContract', {\n  from: deployer,\n  owner: diamondAdmin,\n  facets: ['NewFacet', 'Facet2', 'Facet3'],\n  execute: {\n    methodName: 'postUpgrade',\n    args: ['one', 2, '0x3'],\n  },\n});\n```\n\n### more...\n\nThere are more options, to be described later...\n\n## Testing Deployed Contracts\n\nYou can continue using the usual test task:\n\n`hardhat test`\n\nTests can use the `hre.deployments.fixture` function to run the deployment and snapshot it so that tests don't need to perform all the deployment transactions every time. They can simply reuse the snapshot for every test (this leverages `evm_snapshot` and `evm_revert` provided by both `hardhat` and `ganache`). You can for example set them in a `beforeEach`.\n\nHere is an example of a test :\n\n```js\nconst {deployments} = require('hardhat');\n\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    await deployments.fixture(['Token']);\n    const Token = await deployments.get('Token'); // Token is available because the fixture was executed\n    console.log(Token.address);\n    const ERC721BidSale = await deployments.get('ERC721BidSale');\n    console.log({ERC721BidSale});\n  });\n});\n```\n\nTests can also leverage named accounts for clearer test. Combined with `hardhat-deploy-ethers` plugin, you can write succint test :\n\n```js\nconst {ethers, getNamedAccounts} = require('hardhat');\n\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    await deployments.fixture(['Token']);\n    const {tokenOwner} = await getNamedAccounts();\n    const TokenContract = await ethers.getContract('Token', tokenOwner);\n    await TokenContract.mint(2).then((tx) => tx.wait());\n  });\n});\n```\n\n---\n\n### Creating Fixtures\n\nFurthermore, tests can easily create efficient fixture using `deployments.createFixture`\n\nSee example :\n\n```js\nconst setupTest = deployments.createFixture(\n  async ({deployments, getNamedAccounts, ethers}, options) => {\n    await deployments.fixture(); // ensure you start from a fresh deployments\n    const {tokenOwner} = await getNamedAccounts();\n    const TokenContract = await ethers.getContract('Token', tokenOwner);\n    await TokenContract.mint(10).then((tx) => tx.wait()); //this mint is executed once and then `createFixture` will ensure it is snapshotted\n    return {\n      tokenOwner: {\n        address: tokenOwner,\n        TokenContract,\n      },\n    };\n  }\n);\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    const {tokenOwner} = await setupTest();\n    await tokenOwner.TokenContract.mint(2);\n  });\n});\n```\n\nWhile this example is trivial, some fixture can requires several transaction and the ability to snapshot them automatically speed up the tests greatly.\n\n---\n\n---\n\n## More Information On Hardhat Tasks\n\n---\n\n### **1. node task**\n\nas mentioned above, the node task is slighly modified and augmented with various flags and options\n\n`hardhat node`\n\nIn particular it adds an argument `--export` that allows you to specify a destination file where the info about the contracts deployed is written.\nYour webapp can then access all contracts information.\n\n---\n\n### **2. test task**\n\n`hardhat test`\n\nthe test task is augmented with one flag argument `--deploy-fixture` that allows to run all deployments in a fixture snapshot before executing the tests. This can speed up the tests that use specific tags as the global fixture take precedence (unless specified).\n\nIn other word tests can use `deployments.fixture(<specific tag>)` where specific tag only deploys the minimal contracts for tests, while still benefiting from global deployment snapshot if used.\n\nIf a test needs the deployments to only include the specific deployment specified by the tag, it can use the following :\n\n```js\ndeployments.fixture('<specific tag>', {fallbackToGlobal: false});\n```\n\nDue to how snapshot/revert works in hardhat, this means that these tests will not benefit from the global fixture snapshot and will have to deploy their contracts as part of the fixture call. This is automatic but means that these tests will run slower.\n\n---\n\n### **3. run task**\n\n`hardhat --network <networkName> run <script>`\n\nThe run task act as before but thanks to the `hre.deployments` field it can access deployed contract :\n\n```js\nconst hre = require('hardhat');\nconst {deployments, getNamedAccounts} = hre;\n\n(async () => {\n  console.log(await deployments.all());\n  console.log({namedAccounts: await getNamedAccounts()});\n})();\n```\n\nYou can also run it directly from the command line as usual.\n\n`HARDHAT_NETWORK=rinkeby node <script>` is the equivalent except it does not load the hardhat environment twice (which the run task does)\n\n---\n\n### **4. console task**\n\n`hardhat console`\n\nThe same applies to the `console` task.\n\n---\n\n## Deploy Scripts: Tags And Dependencies\n\n---\n\nIt is possible to execute only specific parts of the deployments with `hardhat deploy --tags <tags>`\n\nTags represent what the deploy script acts on. In general it will be a single string value, the name of the contract it deploys or modifies.\n\nThen if another deploy script has such tag as a dependency, then when this latter deploy script has a specific tag and that tag is requested, the dependency will be executed first.\n\nHere is an example of two deploy scripts :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const deployResult = await deploy('Token', {\n    from: deployer,\n    args: ['hello', 100],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Token deployed at ${deployResult.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Token'];\n```\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const Token = await deployments.get('Token');\n  const deployResult = await deploy('Sale', {\n    from: deployer,\n    contract: 'ERC721BidSale',\n    args: [Token.address, 1, 3600],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Sale deployed at ${deployResult.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.dependencies = ['Token']; // this ensure the Token script above is executed first, so `deployments.get('Token')` succeeds\n```\n\nAs you can see the second one depends on the first. This is because the second script depends on a tag that the first script registers as using.\n\nWith that when `hardhat deploy --tags Sale` is executed\n\nthen both scripts will be run, ensuring Sale is ready.\n\nYou can also define the script to run after another script is run by setting `runAtTheEnd` to be true. For example:\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, execute, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer, admin} = namedAccounts;\n  await execute('Sale', {from: deployer}, 'setAdmin', admin);\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.runAtTheEnd = true;\n```\n\nTags can also be used in test with `deployments.fixture`. This allow you to test a subset of the deploy script.\n","readmeFilename":"README.md","gitHead":"418da2e530cbf91a1fe1f296d3a3980fe0361b79","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.3-experimental.1","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-+Qv4XvdXSxtE9Pyti5xJ0Fp1jkRpahdi8V/lQRcSavwhbFkegRAlW0tVxtTMzygHSHHqBrgibaaBEZgZrkqguA==","shasum":"99ca6ea09e061d36afc4677fd63c420832b78741","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.3-experimental.1.tgz","fileCount":149,"unpackedSize":12107609,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiPBJUACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmoGHxAAh14OjrcYokbQkhpYuZnpDH+S8iKC/7RG4v0i/AEnBXhbOpuh\r\n3ia7VwKGAxZKJy1QjN/wwnxJFdzlsQtc/Vt2riyPuWXMJzgSU54+ZEBccm2X\r\nxIEZNaGLXs80VU1zNvz8eP2WlfReVn8rRDP1dbZTts86WIaYJsDSdc8lR/59\r\njWX43kHtymjYJQqDn6eHYe9YBPgu2sYc7TA/he73PCIOsodeFY8V4YFj+ygK\r\nD9A50PemsxiY5Kh+Husrc72P4PzIgLaHOm5NXjxhJIgRfjQEALMwuGGFfgoy\r\n6vsk4PudwI/5emU8Yl1ihBOUj5HEPFrROVM9GHTH7K2sR78QKILe1NETdWYb\r\nHHn1v7pHVGCnlAKNpYE5CUPirFklH9sALiLnsTkMHtXC36LR9WDljkS9MOBI\r\n5qfaN5zRo+DRd93tMobo1wWexl1eNw0c5hWiNvezX8/0lOisTl52FlRITctR\r\n0AtSiWVXA8+iDQsk7hS0KACD7170RfVZfuqEDZ86ymUi+L0Nu8mf7Hbiujgk\r\nfTQ/ruAqs7i3C29n3QQ2lpfRksFQhyWSEfJf0pi9Qxjq8CXx1ISwlZEUc8PV\r\nVhJnx3xOU4xdx1rTY1m8Omxis5AwufEpDSJL6HREq32SdBgZYBXNlL+skROF\r\nuvzwFg0q2PkdHQg9r7HieH3MKLgNPbaOw00=\r\n=A3VZ\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQD9P5dUnhH+to/bgRO7IuuwFOw84CzE6qhVX3pze0y4zQIgSGwh2vmkkAJETTKIKKNiYxVGmCmQ5XTHTetTzmyd11E="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.3-experimental.1_1648104020338_0.5358149736835494"},"_hasShrinkwrap":false},"0.11.3-experimental.2":{"name":"hardhat-deploy","version":"0.11.3-experimental.2","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.8","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.6.8"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"readme":"<h1> hardhat-deploy</h1>\n\n_A [Hardhat](https://hardhat.org) Plugin For Replicable Deployments And Easy Testing_\n\n> **A complete dev template using hardhat-deploy is available here** : https://github.com/wighawag/template-ethereum-contracts\n> It also contains various branches examplifying the capability of hardhat-deploy. Check it out.\n\n- [What is it for ?](#what-is-it-for-)\n- [hardhat-deploy in a nutshell](#hardhat-deploy-in-a-nutshell)\n- [Installation](#installation)\n  - [npm install hardhat-deploy](#npm-install-hardhat-deploy)\n  - [TypeScript support](#typescript-support)\n  - [Migrating existing deployment to hardhat-deploy](#migrating-existing-deployment-to-hardhat-deploy)\n- [Hardhat Tasks Available/Updated](#hardhat-tasks-availableupdated)\n  - [1. hardhat deploy](#1-hardhat-deploy)\n    - [**Options**](#options)\n    - [**Flags**](#flags)\n  - [2. hardhat node](#2-hardhat-node)\n    - [**Options**](#options-1)\n    - [**Flags**](#flags-1)\n  - [3. hardhat test](#3-hardhat-test)\n  - [4. hardhat etherscan-verify](#4-hardhat-etherscan-verify)\n    - [**Options**](#options-2)\n  - [5. hardhat sourcify](#5-hardhat-sourcify)\n    - [**Options**](#options-3)\n  - [6. hardhat export](#6-hardhat-export)\n    - [**Options**](#options-4)\n- [Hardhat Environment Extensions](#hardhat-environment-extensions)\n- [Configuration](#configuration)\n  - [**1. namedAccounts (ability to name addresses)**](#1-namedaccounts-ability-to-name-addresses)\n  - [**2. extra hardhat.config networks' options**](#2-extra-hardhatconfig-networks-options)\n    - [`live`](#live)\n    - [`saveDeployments`](#savedeployments)\n    - [`tags`](#tags)\n    - [`deploy`](#deploy)\n    - [`companionNetworks`](#companionnetworks)\n  - [**3. extra hardhat.config paths' options**](#3-extra-hardhatconfig-paths-options)\n  - [**4. deterministicDeployment (ability to specify a deployment factory)**](#4-deterministicdeployment-ability-to-specify-a-deployment-factory)\n  - [Importing deployment from other projects (with truffle support)](#importing-deployment-from-other-projects-with-truffle-support)\n  - [Access to Artifacts (non-deployed contract code and abi)](#access-to-artifacts-non-deployed-contract-code-and-abi)\n- [How to Deploy Contracts](#how-to-deploy-contracts)\n  - [The `deploy` Task](#the-deploy-task)\n  - [Deploy Scripts](#deploy-scripts)\n    - [An example of a deploy script :](#an-example-of-a-deploy-script-)\n  - [The `deployments` field](#the-deployments-field)\n    - [`deployments.deploy(<name>, options)`](#deploymentsdeployname-options)\n- [Handling contract using libraries](#handling-contract-using-libraries)\n- [Exporting Deployments](#exporting-deployments)\n- [Deploying and Upgrading Proxies](#deploying-and-upgrading-proxies)\n- [Builtin-In Support For Diamonds (EIP2535)](#builtin-in-support-for-diamonds-eip2535)\n  - [deployment / upgrade](#deployment--upgrade)\n  - [onUpgrade calls](#onupgrade-calls)\n  - [more...](#more)\n- [Testing Deployed Contracts](#testing-deployed-contracts)\n  - [Creating Fixtures](#creating-fixtures)\n- [More Information On Hardhat Tasks](#more-information-on-hardhat-tasks)\n  - [**1. node task**](#1-node-task)\n  - [**2. test task**](#2-test-task)\n  - [**3. run task**](#3-run-task)\n  - [**4. console task**](#4-console-task)\n- [Deploy Scripts: Tags And Dependencies](#deploy-scripts-tags-and-dependencies)\n\n## What is it for ?\n\nThis [hardhat](https://hardhat.org) plugin adds a mechanism to deploy contracts to any network, keeping track of them and replicating the same environment for testing.\n\nIt also adds a mechanism to associate names to addresses, so test and deployment scripts can be reconfigured by simply changing the address a name points to, allowing different configurations per network. This also results in much clearer tests and deployment scripts (no more `accounts[0]` in your code).\n\nThis plugin contains a lot more features too, all geared toward a better developer experience :\n\n- chain configuration export\n- listing deployed contracts' addresses and their abis (useful for webapps)\n- library linking at time of deployment.\n- deterministic deployment across networks.\n- support for specific deploy script per network (L1 vs L2 for example)\n- ability to access deployment from \"companion\" networks\n- deployment dependency system (allowing you to only deploy what is needed).\n- deployment retrying (by saving pending tx): so you can feel confident when making a deployment that you can always recover.\n- deployments as test fixture using `evm_snapshot` to speed up testing.\n- ability to create your own test fixture that automatically benefits from `evm_snapshot`'s tests speed-up boost\n- combined with [hardhat-deploy-ethers](https://github.com/wighawag/hardhat-deploy-ethers) it has the ability to get ethers contract instance by name (like `await ethers.getContract(\"ContractName\")`).\n- importing artifact from external sources (like npm packages), including [truffle](https://www.trufflesuite.com/truffle) support.\n- importing deployments from external sources (like npm packages)\n- ability to log information in `deploy` mode only (while in test the console remains clean).\n- contains helpers to read and execute transaction on deployed contract referring to them by name.\n- These helpers contains options to auto mine on dev network (to speed up test deployments).\n- save metadata of deployed contract so they can always be fully verified, via [sourcify](https://sourcify.dev) or [etherscan](https://etherscan.io).\n- ability to submit contract source to etherscan and sourcify for verification at any time. (Because **hardhat-deploy** will save all the necessary info, it can be executed at any time.)\n- support harhdat's fork feature so deployment can be accessed even when run through fork.\n- named accounts are automatically impersonnated too, so you can perform tx as if you had their private key.\n- proxy deployment with ability to upgrade them transparently, only if code changes.\n- this include support for [openzeppelin](https://openzeppelin.com) transparent proxies\n- diamond deployment with facets, allowing you to focus on what the new version will be. It will generate the diamondCut necessary to reach the new state.\n- watch and deploy: **hardhat-deploy** can watch both your deploy script and contract code and redeploy on changes.\n- HCR (Hot Contract Replacement): the watch feature combined with proxy or diamond, gives you an experience akin to frontend Hot Module Replacement: once your contract changes, the deployment is executed and your contract retains the same address and same state, allowing you to tweak your contracts while debugging your front-end.\n\n## hardhat-deploy in a nutshell\n\nBefore going into the details, here is a very simple summary of the basic feature of **hardhat-deploy**.\n\n**hardhat-deploy** allows you to write [`deploy scripts`](#deploy-scripts) in the `deploy` folder. Each of these files that look as follows will be executed in turn when you execute the following task: `hardhat --network <networkName> deploy`\n\n```js\n// deploy/00_deploy_my_contract.js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('MyContract', {\n    from: deployer,\n    args: ['Hello'],\n    log: true,\n  });\n};\nmodule.exports.tags = ['MyContract'];\n```\n\nFurthermore you can also ensure these scripts are executed in test too by calling `await deployments.fixture(['MyContract'])` in your test.\nThis is optimized, so if multiple tests use the same contract, the deployment will be executed once and each test will start with the exact same state.\n\nThis is a huge benefit for testing since you are not required to replicate the deployment procedure in your tests. The tag feature (as seen in the script above) and [dependencies](#deploy-scripts-tags-and-dependencies) will also make your life easier when writing complex deployment procedures.\n\nYou can even group deploy scripts in different sub folder and ensure they are executed in their logical order.\n\nFurthermore hardhat-deploy can also support a multi-chain settings like L1, L2 with multiple deploy folder specific to each network.\n\n**All of this can also be bundled in a npm package so user of hardhat-deploy can reuse your deployment procedure and get started integrating with your project locally.**\n\nThere is a tutorial covering the basics here : https://github.com/wighawag/tutorial-hardhat-deploy\n\n## Installation\n\n### npm install hardhat-deploy\n\n```bash\nnpm install -D hardhat-deploy\n```\n\nAnd add the following statement to your `hardhat.config.js`:\n\n```js\nrequire('hardhat-deploy');\n```\n\nif you use `ethers.js` we recommend you also install `hardhat-deploy-ethers` which add extra features to access deployments as ethers contract.\n\nSince `hardhat-deploy-ethers` is a fork of `@nomiclabs/hardhat-ethers` and that other plugin might have an hardcoded dependency on `@nomiclabs/hardhat-ethers` the best way to install `hardhat-deploy-ethers` and ensure compatibility is the following:\n\n```bash\nnpm install --save-dev  @nomiclabs/hardhat-ethers@npm:hardhat-deploy-ethers ethers\n```\n\nWhich means you then need to do `require(\"@nomiclabs/hardhat-ethers\")` instead of `require(\"hardhat-deploy-ethers\")` in your `hardhat.config.js` file.\n\nMore details on `hardhat-deploy-ethers` repo : https://github.com/wighawag/hardhat-deploy-ethers#readme\n\n### TypeScript support\n\nWith hardhat the tsconfig.json is optional.\n\nBut if you add folders to the `include` field in `tsconfig.json`, you ll also need to include `hardhat.config.ts` like :\n\n`include\": [\"./hardhat.config.ts\", \"./scripts\", \"./deploy\", \"./test\"]`\n\nfor deploy script (see below) you can write them this way to benefit from typing :\n\n```ts\nimport {HardhatRuntimeEnvironment} from 'hardhat/types';\nimport {DeployFunction} from 'hardhat-deploy/types';\n\nconst func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {\n  // code here\n};\nexport default func;\n```\n\nSee a template that uses **hardhat-deploy** here : https://github.com/wighawag/template-ethereum-contracts\n\nThis repo has also some examples branch that exemplify specific features, like the forking testing here : https://github.com/wighawag/template-ethereum-contracts/tree/examples/fork-test\n\n### Migrating existing deployment to hardhat-deploy\n\n> Only needed for existing project that already deployed contracts and has the deployment information available **(at minimum, address and abi)**\n\nYou might want to switch your current deployment process to use **hardhat-deploy**. In that case you probably have some deployments saved elsewhere.\n\nIn order to port them to **hardhat-deploy**, you'll need to create one `.json` file per contract in the `deployments/<network>` folder (configurable via [paths config](#extra-paths-config)).\n\nThe network folder is simply the hardhat network name (as configured in hardhat.config.js) (accessible at runtime via `hre.network.name`).\nSuch folder need to have a file named `.chainId` containing the chainId as decimal.\n\nFor example for network named \"rinkeby\" (for the corresponding network) the file `deployments/rinkeby/.chainId` would be\n\n```\n4\n```\n\nNote, prior to hardhat 0.6 the chainId was appended to the folder name (expect for some known network name). This has changed and upgrading to 0.6 will require you to change the folder name and add the '.chainId' file.\n\nEach contract file must follow this type (as defined in [types.ts](types.ts)) :\n\n```ts\nexport interface Deployment {\n  address: Address;\n  abi: ABI;\n  receipt?: Receipt;\n  transactionHash?: string;\n  history?: Deployment[];\n  numDeployments?: number;\n  implementation?: string;\n  args?: any[];\n  linkedData?: any;\n  solcInputHash?: string;\n  metadata?: string;\n  bytecode?: string;\n  deployedBytecode?: string;\n  libraries?: Libraries;\n  userdoc?: any;\n  devdoc?: any;\n  methodIdentifiers?: any;\n  diamondCut?: FacetCut[];\n  facets?: Facet[];\n  storageLayout?: any;\n  gasEstimates?: any;\n}\n```\n\nAs you can see, only abi and address are mandatory. But having the other fields allow more feature. For example, metadata and args allow you to benefit from contract code verification.\n\nFor Receipt, the following type is expected:\n\n```ts\nexport type Receipt = {\n  from: string;\n  transactionHash: string;\n  blockHash: string;\n  blockNumber: number;\n  transactionIndex: number;\n  cumulativeGasUsed: string;\n  gasUsed: string;\n  contractAddress?: string;\n  to?: string;\n  logs?: Log[];\n  events?: any[];\n  logsBloom?: string;\n  byzantium?: boolean;\n  status?: number;\n  confirmations?: number;\n};\n```\n\nHere is an example:\n\nLet's say you have:\n\n- 2 Contract named Greeter and Registry deployed on rinkeby\n- 1 contract named Greeter on mainnet\n- 2 Contract named Greeter and Registry deployed on a network named rinkeby2\n\nYou would get the following folder structure:\n\n```\ndeployments/\n  mainnet/\n    .chainId\n    Greeter.json\n  rinkeby/\n    .chainId\n    Greeter.json\n    Registry.json\n  rinkeby2/\n    .chainId\n    Greeter.json\n    Registry.json\n```\n\nThe reason why **hardhat-deploy** save chainId in the `.chainId` file is both for\n\n- safety: so that if you were to change the network name to point to a different chain, it would not attempt to read the wrong folder and assume that a contract has been deployed while it has not.\n- ability to know the chainId without requring to be connected to a node (and so not dependent on hardhat.config.js settings). Useful for `export` task.\n\n---\n\n## Hardhat Tasks Available/Updated\n\nhardhat deploy add several task to hardhat. It also modify existing one, adding new options and new behavior. All of these are described here:\n\n---\n\n### 1. hardhat deploy\n\n---\n\nThis plugin adds the _deploy_ task to Hardhat.\n\nThis task will execute the scripts in the `deploy` folder and save the contract deployments to disk. These deployments are supposed to be saved for example in a git repository. This way they can be accessed later. But you are free to save them elsewhere and get them back via your mechanism of choice.\n\nWith the deployment saved, it allows you to deploy a contract only if changes were made.\n\nDeploy scripts (also called Deploy functions) can also perform aribtrary logic.\n\nFor further details on how to use it and write deploy script, see [section](#deploy-scripts) below.\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployments, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice (in wei) to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--reset`: This flag resets the deployments from scratch. Previously deployed contract are not considered and deleted from disk.\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n---\n\n### 2. hardhat node\n\n---\n\nThis plugin modify the _node_ task so that it also execute the deployment script before exposing the server http RPC interface\n\nIt add similar options than the `deploy` task :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--no-reset`: This flag prevent the reseting of the existing deployments. This is usually not desired when running the `node` task as a network is created from scratch and previous deployemnt are irrelevant.\n\n`--show-accounts`: this flag will output the account private keys\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n`--no-deploy` that discard all other options to revert to normal `hardhat node` behavior without any deployment being performed.\n\n> :warning: Note that the deployments are saved as if the network name is `localhost`. This is because `hardhat node` is expected to be used as localhost: You can for example execute `hardhat --network localhost console` after `node` is running. Doing `hardhat --network hardhat console` would indeed not do anything useful. It still take the configuration from `hardhat` in the hardhat.config.js file though.\n\n---\n\n### 3. hardhat test\n\n---\n\nThis plugin adds a flag argument `--deploy-fixture` to the _test_ task which if enabled will run the global deployments fixture before the tests and snapshots it. This will generaly speed up the tests as further test will be able to revert back to the full deployment.\n\n> :warning: Note though that if your test behave differently whether that option is on or not, this most likely mean that your deploy scripts' tags and dependencies are not configured correctly. This is because the global fixture will ensure all contract are deployed while test will usually (for efficiency) ask for a particular tag.\n\n---\n\n### 4. hardhat etherscan-verify\n\n---\n\nThis plugin adds the _etherscan-verify_ task to Hardhat.\n\nThis task will submit the contract source and other info of all deployed contracts to allow etherscan to verify and record the sources.\n\nInstead of using the full solc input, this task will first attempt to send the minimal sources from the metadata.\nBut Etherscan sometime fails due to a bug in solidity compiler (<https://github.com/ethereum/solidity/issues/9573>). As such this task can fallback on full solc input (see option --solc-input). Note that if your contract was deployed with a previous version of **hardhat-deploy**, it might not contains the full information. The issue seems to be fully resolved since solc version 0.8.\n\nThis task will also attempt to automatically find the SPDX license in the source.\n\nTo execute that task, you need to specifiy the network to run against :\n\n```bash\nhardhat --network mainnet etherscan-verify [--api-key <apikey>] [--apiurl <url>]\n```\n\n#### **Options**\n\nNote that harhdat-deploy now use a different config format to not conflict with `hardhat-etherscan`\n\n`--api-key <api key>`: let you specify your etherscan api key. Alternatively, you can provide it via the env variable `ETHERSCAN_API_KEY` or through the hardhat.config.ts verify field:\n\n```js\n{\n  ...\n  verify: {\n    etherscan: {\n      apiKey: '<API key>'\n    }\n  }\n}\n```\n\n`--api-url <url>`: let you specify your etherscan url to submit the source to. Can also be configured per network in `hardhat.config.js`:\n\n```js\n{\n  ...\n  networks: {\n    mynetwork: {\n      ...\n      verify: {\n        etherscan: {\n          apiUrl: 'http://mynetwork.xyz'\n        }\n      }\n    }\n  }\n}\n```\n\n`--license <SPDX license id>`: SPDX license (useful if SPDX is not listed in the sources), need to be supported by etherscan: https://etherscan.io/contract-license-types\n\n`--force-license`: if set, will force the use of the license specified by --license option, ignoring the one in the source (useful for license not supported by etherscan)\n\n`--solc-input`: fallback on solc-input id needed (useful when etherscan fails on the minimum sources, see https://github.com/ethereum/solidity/issues/9573)\n\n`--sleep`: sleep 500ms between each verification, so API rate limit is not exceeded\n\n---\n\n### 5. hardhat sourcify\n\n---\n\nThis plugin adds the _sourcify_ task to Hardhat.\n\nSimilar to `hardhat etherscan-verify` this task will submit the contract source and other info of all deployed contracts to sourcify.\n\n```bash\nhardhat --network mainnet sourcify\n```\n\nLater this task might instead pin the metadata to ipfs, so sourcify can automatically verify them.\n\n#### **Options**\n\n`--contract-name <contract name>`: specify the contract's name you want to verify\n  \n`--endpoint <endpoint>`: specify the sourcify endpoint, default to https://sourcify.dev/server/\n\n`--write-failing-metadata`: if set and the sourcify task fails to verify, the metadata file will be written to disk, so you can more easily figure out what has gone wrong.\n\n---\n\n### 6. hardhat export\n\n---\n\nThis plugin adds the _export_ task to Hardhat.\n\nThis task will export the contract deployed (saved in `deployments` folder) to a file with a simple format containing only contract addresses and abi, useful for web apps.\n\nOne of the following options need to be set for this task to have any effects :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\nThis last option has some limitations, when combined with the use of external deployments (see [Configuration](#configuration)). If such external deployments were using older version of **hardhat-deploy** or truffle, the chainId might be missing. In order for these to be exported, the hardhat network config need to explicity state the chainId in the `networks` config of `hardhat.config.js`.\n\nWith both `--export` and `--export-all`, using the special `<filepath>` value of `-` will output to `STDOUT` rather than writing a normal file.\n\n---\n\n---\n\n## Hardhat Environment Extensions\n\nThis plugin extends the Hardhat Runtime Environment by adding 4 fields:\n\n- `getNamedAccounts: () => Promise<{ [name: string]: string }>`: a function returning an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [Configuration](#configuration)).\n\n- `getUnnamedAccounts: () => Promise<string[]}>`: accounts which has no names, useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`: contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId(): Promise<string>`: offer an easy way to fetch the current chainId.\n\n---\n\n---\n\n## Configuration\n\n---\n\n### **1. namedAccounts (ability to name addresses)**\n\n---\n\nThis plugin extends the `HardhatConfig`'s object with an optional `namedAccounts` field.\n\n`namedAccounts` allows you to associate names to addresses and have them configured per chain.\nThis allows you to have meaningful names in your tests while the addresses match to multi sig in real network for example.\n\n```js\n{\n    namedAccounts: {\n        deployer: {\n            default: 0, // here this will by default take the first account as deployer\n            1: 0, // similarly on mainnet it will take the first account as deployer. Note though that depending on how hardhat network are configured, the account 0 on one network can be different than on another\n            4: '0xA296a3d5F026953e17F472B497eC29a5631FB51B', // but for rinkeby it will be a specific address\n            \"goerli\": '0x84b9514E013710b9dD0811c9Fe46b837a4A0d8E0', //it can also specify a specific netwotk name (specified in hardhat.config.js)\n        },\n        feeCollector:{\n            default: 1, // here this will by default take the second account as feeCollector (so in the test this will be a different account than the deployer)\n            1: '0xa5610E1f289DbDe94F3428A9df22E8B518f65751', // on the mainnet the feeCollector could be a multi sig\n            4: '0xa250ac77360d4e837a13628bC828a2aDf7BabfB3', // on rinkeby it could be another account\n        }\n    }\n}\n```\n\n<!-- You can also specify addresses with the `ledger://` prefix. In which case the account fetched will still be the corresponding address, but behind the scene, the transaction will be created via the hardware waller. Currently the feature is not working very well though and better support is needed. -->\n\n---\n\n### **2. extra hardhat.config networks' options**\n\n---\n\n**hardhat-deploy** add 5 new fields to `networks` configuration\n\n#### `live`\n\nthis is not used internally but is useful to perform action on a network whether it is a live network (rinkeby, mainnet, etc) or a temporary one (localhost, hardhat). The default is true (except for localhost and hardhat where the default is false).\n\n#### `saveDeployments`\n\nthis tell whether **hardhat-deploy** should save the deployments to disk or not. Default to true, except for the hardhat network.\n\n#### `tags`\n\nnetwork can have tags to represent them. The config is an array and at runtime the hre.network.tags is an object whose fields (the tags) are set to true.\n\nThis is useful to conidtionaly operate on network based on their use case.\n\nExample:\n\n```js\n{\n  networks: {\n    localhost: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"local\"]\n    },\n    hardhat: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"test\", \"local\"]\n    },\n    rinkeby: {\n      live: true,\n      saveDeployments: true,\n      tags: [\"staging\"]\n    }\n  }\n}\n```\n\n#### `deploy`\n\nthe deploy field override the paths.deploy option and let you define a set of folder containing the deploy scripts to be executed for this network.\n\nYou can thus have one network that will be executing L1 deployment and other L2 deployments, etc...\n\nYou could also have a folder that deploy contracts that are live on mainnet but that you need to replicate for your test or local network.\n\n#### `companionNetworks`\n\nthe companionNetworks field is an object whose key is any name you desire and the value is the name of a network that will be accessible inside the deploy script. For example:\n\n```js\n{\n  ...\n  networks: {\n    optimism: {\n      url: 'http://127.0.0.1:8545',\n      ovm: true,\n      companionNetworks: {\n        l1: 'localhost',\n      },\n    }\n  }\n  ...\n}\n```\n\nBy using name you can have the same deploy script used in different set of network.\n\nFor your test you could have the companion networks pointing to the same hardhat network, for test deployment, you could have rinkeby acting like your l2 while goerli act as your l1.\n\nAn example repo that show case a multi-network setup with optimism can be found here : https://github.com/wighawag/template-ethereum-contracts/tree/examples/optimism\n\ndeploy script can then access the network and its deployment as follow :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  const OVM_L1ERC20Gateway = await hre.companionNetworks['l1'].deployments.get(\n    'OVM_L1ERC20Gateway'\n  ); // layer 1\n\n  await execute(\n    'SimpleERC20_OVM',\n    {from: deployer, log: true},\n    'init',\n    OVM_L1ERC20Gateway.address\n  );\n};\n```\n\n---\n\n### **3. extra hardhat.config paths' options**\n\n---\n\n`hardhat-deploy` also adds fields to `HardhatConfig`'s `ProjectPaths` object.\n\nHere is an example showing the default values :\n\n```js\n{\n    paths: {\n        deploy: 'deploy',\n        deployments: 'deployments',\n        imports: 'imports'\n    }\n}\n```\n\nThe `deploy` folder is expected to contains the deploy script that are executed upon invocation of `hardhat deploy` or `hardhat node`.\nIt can also be an array of folder path.\n\nThe `deployments` folder will contains the resulting deployments (contract addresses along their abi, bytecode, metadata...). One folder per network and one file per contract.\n\nThe `imports` folder is expected to contains artifacts that were pre-compiled. Useful if you want to upgrade to a new solidity version but want to keep using previously compiled contracts. The artifact is the same format as normal hardhat artifact, so you can easily copy them over, before switching to a new compiler version.\n\n> This is less useful now that hardhat support multiple solidity compiler at once.\n\n---\n\n---\n\n### **4. deterministicDeployment (ability to specify a deployment factory)**\n\n---\n\nThis plugin extends the `HardhatConfig`'s object with an optional `deterministicDeployment` field.\n\n`deterministicDeployment` allows you to associate information that are used on each network for deterministic deployment. The information for each deterministic deployment consist out of a `factory`, a `deployer`, the required `funding` and a `signedTx` to deploy the factory. The default deterministic deployment used is the [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy). The factory expects a 32 bytes `salt` concatenated with the deployment data (see [EIP-1014](https://eips.ethereum.org/EIPS/eip-1014) for more information on these parameters).\n\nUsing the `deterministicDeployment` it is possible to define a different setup for the deterministic deployment. One use case for this is the deterministic deployment on networks that required replay protection (such as Celo or Avalanche). The [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy) can only be deployed on networks that don't enforce replay protection, therefore on other networks an alternative library has to be used. An example for this would be the [Safe Singleton Factory](https://github.com/gnosis/safe-singleton-factory) that is an adjusted version of the [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy) that contains signed transactions that include replay protection.\n\nThe information can be defined either as an object\n\n```js\n{\n    deterministicDeployment: {\n      \"4\": {\n        factory: \"<factory_address>\",\n        deployer: \"<deployer_address>\",\n        funding: \"<required_funding_in_wei>\",\n        signedTx: \"<raw_signed_tx>\",\n      }\n    }\n}\n```\n\nor as an function that returns the information for the deterministic deployment\n\n```js\n{\n  deterministicDeployment: (network: string) => {\n    return {\n      factory: '<factory_address>',\n      deployer: '<deployer_address>',\n      funding: '<required_funding_in_wei>',\n      signedTx: '<raw_signed_tx>',\n    };\n  };\n}\n```\n\n### Importing deployment from other projects (with truffle support)\n\n`hardhat-deploy` also add the `external` field to `HardhatConfig`\n\nSuch field allows to specify paths for external artifacts or **deployments**.\n\nThe external object has 2 fields:\n\n```js\n{\n    external: {\n        contracts: [\n          {\n            artifacts: \"node_modules/@cartesi/arbitration/export/artifacts\",\n            deploy: \"node_modules/@cartesi/arbitration/export/deploy\"\n          },\n          {\n            artifacts: \"node_modules/someotherpackage/artifacts\",\n          }\n        ],\n        deployments: {\n          rinkeby: [\"node_modules/@cartesi/arbitration/build/contracts\"],\n        },\n    }\n}\n```\n\nThe `contracts` field specify an array of object which itself have 2 fields.\n\n- `artifacts`: (mandatory) it is a path to an artifact folder. This support both hardhat and truffle artifacts.\n- `deploy`: (optional) it specifies a path to a folder where reside deploy script. The deploy scripts have only access to the artifact specified in the artifacts field. This allow project to share their deployment procedure. A boon for developer aiming at integrating it as they can get the contracts to be deployed for testing locally.\n\nThe `deployments` fields specify an object whose field nasme are the hardhat network and the value is an array of path to look for deployments. It supports both **hardhat-deploy** and truffle formats.\n\n---\n\n### Access to Artifacts (non-deployed contract code and abi)\n\nArtifacts in hardhat terminology represent a compiled contract (not yet deployed) with at least its bytecode and abi.\n\n`hardhat-deploy` gives can access to these artifact via the `deployments.getArtifact` function :\n\n```js\nconst {deployments} = require('hardhat');\nconst artifact = await deployments.getArtifact(artifactName);\n```\n\nWith the `hardhat-deploy-ethers` plugin you can get an artifact as an ethers contract factory, ready to be deployed, via the following:\n\n```js\nconst {deployments, ethers} = require('hardhat');\nconst factory = await ethers.getContractFactory(artifactName);\n```\n\n> Note that the artifact's files need to be either in `artifacts` folder that hardhat generate on compilation or in the `imports` folder where you can store contracts compiled elsewhere. They can also be present in the folder specified in `external.artifacts` see [Importing deployment from other projects](#importing-deployment-from-other-projects-with-truffle-support)\n\n---\n\n---\n\n## How to Deploy Contracts\n\n---\n\n### The `deploy` Task\n\n`hardhat --network <networkName> deploy [options and flags]`\n\nThis is a new task that the `hardhat-deploy` adds. As the name suggests it deploys contracts.\nTo be exact it will look for files in the folder `deploy` or whatever was configured in `paths.deploy`, see [paths config](#extra-paths-config)\n\nIt will scan for files in alphabetical order and execute them in turn.\n\n- it will `require` each of these files and execute the exported function with the HRE as argument\n\nTo specify the network, you can use the builtin hardhat argument `--network <network name>` or set the env variable `HARDHAT_NETWORK`\n\n> :warning: Note that running `hardhat deploy` without specifying a network will use the default network. If the default network is hardhat (the default's default) then nothing will happen as a result as everything happens in memory, but this can be used to ensure the deployment is without issues.\n\n---\n\n### Deploy Scripts\n\nThe deploy scripts need to be of the following type :\n\n```ts\nexport interface DeployFunction {\n  (env: HardhatRuntimeEnvironment): Promise<void | boolean>;\n  skip?: (env: HardhatRuntimeEnvironment) => Promise<boolean>;\n  tags?: string[];\n  dependencies?: string[];\n  runAtTheEnd?: boolean;\n  id?: string;\n}\n```\n\nThe skip function can be used to skip executing the script under whatever condition. It simply need to resolve a promise to true.\n\nThe tags is a list of string that when the _deploy_ task is executed with, the script will be executed (unless it skips). In other word if the deploy task is executed with a tag that does not belong to that script, that script will not be executed unless it is a dependency of a script that does get executed.\n\nThe dependencies is a list of tag that will be executed if that script is executed. So if the script is executed, every script whose tag match any of the dependencies will be executed first.\n\nThe `runAtTheEnd` is a boolean that if set to true, will queue that script to be executed after all other scripts are executed.\n\nThese set of fields allow more flexibility to organize the scripts. You are not limited to alphabetical order and you can even organise deploy script in sub folders.\n\nFinally the function can return true if it wishes to never be executed again. This can be usfeul to emulate migration scripts that are meant to be executed only once. Once such script return true (async), the `id` field is used to track execution and if that field is not present when the script return true, it will fails.\n\nIn other words, if you want a particular deploy script to run only once, it needs to both return true (async) and have an `id` set.\n\nIn any case, as a general advice every deploy function should be idempotent. This is so they can always recover from failure or pending transaction. This is what underpin most of hardhat-deploy philosophy.\n\nThis is why the `hre.deployments.deploy` function will by default only deploy if the contract code has changed, making it easier to write idempotent script.\n\n#### An example of a deploy script :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  // the following will only deploy \"GenericMetaTxProcessor\" if the contract was never deployed or if the code changed since last deployment\n  await deploy('GenericMetaTxProcessor', {\n    from: deployer,\n    gasLimit: 4000000,\n    args: [],\n  });\n};\n```\n\nAs you can see the HRE passed in has 4 new fields :\n\n- `getNamedAccounts` is a function that returns a promise to an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [`namedAccounts`](#namedaccounts)).\n\n- `getUnnamedAccounts` is a function that return a promise to an array of accounts which were not named (see [`namedAccounts`](#namedaccounts)). It is useful for tests where you want to be sure that the account has no speicifc role in the system (no token given, no admin access, etc...).\n\n- `getChainId` is a function which return a promise for the chainId, as convenience\n\n- `deployments` is an object which contains functions to access past deployments or to save new ones, as well as helpers functions.\n\nThat latter field contains for example the `deploy` function that allows you to deploy contract and save them. It contains a lot more functions though :\n\n---\n\n### The `deployments` field\n\nThe deployments field contains several helpers function to deploy contract but also execute transaction.\n\n```ts\nexport interface DeploymentsExtension {\n  deploy(name: string, options: DeployOptions): Promise<DeployResult>; // deploy a contract\n  diamond: {\n    // deploy diamond based contract (see section below)\n    deploy(name: string, options: DiamondOptions): Promise<DeployResult>;\n  };\n  deterministic( // return the determinsitic address as well as a function to deploy the contract, can pass the `salt` field in the option to use different salt\n    name: string,\n    options: Create2DeployOptions\n  ): Promise<{\n    address: Address;\n    implementationAddress?: Address;\n    deploy(): Promise<DeployResult>;\n  }>;\n  fetchIfDifferent( // return true if new compiled code is different than deployed contract\n    name: string,\n    options: DeployOptions\n  ): Promise<{differences: boolean; address?: string}>;\n  save(name: string, deployment: DeploymentSubmission): Promise<void>; // low level save of deployment\n  get(name: string): Promise<Deployment>; // fetch a deployment by name, throw if not existing\n  getOrNull(name: string): Promise<Deployment | null>; // fetch deployment by name, return null if not existing\n  getDeploymentsFromAddress(address: string): Promise<Deployment[]>;\n  all(): Promise<{[name: string]: Deployment}>; // return all deployments\n  getArtifact(name: string): Promise<Artifact>; // return a hardhat artifact (compiled contract without deployment)\n  getExtendedArtifact(name: string): Promise<ExtendedArtifact>; // return a extended artifact (with more info) (compiled contract without deployment)\n  run( // execute deployment scripts\n    tags?: string | string[],\n    options?: {\n      resetMemory?: boolean;\n      deletePreviousDeployments?: boolean;\n      writeDeploymentsToFiles?: boolean;\n      export?: string;\n      exportAll?: string;\n    }\n  ): Promise<{[name: string]: Deployment}>;\n  fixture( // execute deployment as fixture for test // use evm_snapshot to revert back\n    tags?: string | string[],\n    options?: {fallbackToGlobal?: boolean; keepExistingDeployments?: boolean}\n  ): Promise<{[name: string]: Deployment}>;\n  createFixture<T, O>( // execute a function as fixture using evm_snaphost to revert back each time\n    func: FixtureFunc<T, O>,\n    id?: string\n  ): (options?: O) => Promise<T>;\n  log(...args: any[]): void; // log data only ig log enabled (disabled in test fixture)\n\n  execute( // execute function call on contract\n    name: string,\n    options: TxOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<Receipt>;\n  rawTx(tx: SimpleTx): Promise<Receipt>; // execute a simple transaction\n  catchUnknownSigner( // you can wrap other function with this function and it will catch failure due to missing signer with the details of the tx to be executed\n    action: Promise<any> | (() => Promise<any>),\n    options?: {log?: boolean}\n  ): Promise<null | {\n    from: string;\n    to?: string;\n    value?: string;\n    data?: string;\n  }>;\n  read( // make a read-only call to a contract\n    name: string,\n    options: CallOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<any>;\n  read(name: string, methodName: string, ...args: any[]): Promise<any>;\n  // rawCall(to: Address, data: string): Promise<any>; // TODO ?\n}\n```\n\n---\n\n#### `deployments.deploy(<name>, options)`\n\n---\n\nThe `deploy` function, as mentioned above, allows you to deploy a contract and save it under a specific name.\n\nThe deploy function expect 2 parameters: one for the name and one for the options\n\nSee below the full list of fields that the option parameter allows and requires:\n\n```ts\nexport interface DeployOptions = {\n  from: string; // address (or private key) that will perform the transaction. you can use `getNamedAccounts` to retrived the address you want by name.\n  contract?: // this is an optional field. If not specified it defaults to the contract with the same name as the first parameter\n    | string // this field can be either a string for the name of the contract\n    | { // or abi and bytecode\n        abi: ABI;\n        bytecode: string;\n        deployedBytecode?: string;\n      };\n  args?: any[]; // the list of argument for the constructor (or the upgrade function in case of proxy)\n  skipIfAlreadyDeployed?: boolean; // if set it to true, will not attempt to deploy even if the contract deployed under the same name is different\n  log?: boolean; // if true, it will log the result of the deployment (tx hash, address and gas used)\n  linkedData?: any; // This allow to associate any JSON data to the deployment. Useful for merkle tree data for example\n  libraries?: { [libraryName: string]: Address }; // This let you associate libraries to the deployed contract\n  proxy?: boolean | string | ProxyOptions; // This options allow to consider your contract as a proxy (see below for more details)\n\n  // here some common tx options :\n  gasLimit?: string | number | BigNumber;\n  gasPrice?: string | BigNumber;\n  value?: string | BigNumber;\n  nonce?: string | number | BigNumber;\n\n  estimatedGasLimit?: string | number | BigNumber; // to speed up the estimation, it is possible to provide an upper gasLimit\n  estimateGasExtra?: string | number | BigNumber; // this option allow you to add a gas buffer on top of the estimation\n\n  autoMine?: boolean; // this force a evm_mine to be executed. this is useful to speed deployment on test network that allow to specify a block delay (ganache for example). This option basically skip the delay by force mining.\n  deterministicDeployment? boolean | string; // if true, it will deploy the contract at a deterministic address based on bytecode and constructor arguments. The address will be the same across all network. It use create2 opcode for that, if it is a string, the string will be used as the salt.\n  waitConfirmations?: number; // number of the confirmations to wait after the transactions is included in the chain\n};\n```\n\n---\n\n---\n\n## Handling contract using libraries\n\nIn the deploy function, one of the `DeployOptions` field is the `libraries` field. It allows you to associate external contract as libraries at the time of deployment.\n\nFirst, you have deploy the library using the `deploy` function, then when we deploy a contract that needs the linked library, we can pass the deployed library name and address in as an argument to the `libraries` object.\n\nFirst step: deploy the library:\n\n```js\nconst exampleLibrary = await deploy(\"ExampleLibary\", {\n    from: <deployer>\n});\n\n```\n\nExampleLibrary is now deployed to whatever network was chosen (`hardhat deploy --network <networkName>`)\n\nFor example, if we are deploying on Rinkeby, this library will get deployed on rinkeby, and the `exampleLibrary` variable will be a deployment object that contains the abi as well as the deployed address for the contract.\n\nNow that the library is deployed, we can link it in our next deployed contract.\n\n```js\nconst example = await deploy(\"Example\", {\n    from: <deployer>\n    args: [\"example string argument for the 'Example' contract constructor\"],\n    libraries: {\n        ExampleLibrary: exampleLibrary.address\n    }\n});\n\n```\n\nThis `libraries` object takes the name of the library, and its deployed address on the network. Multiple libraries can be passed into the `libraries` object.\n\n---\n\n---\n\n## Exporting Deployments\n\nApart from deployments saved in the `deployments` folder which contains all information available about the contract (compile time data + deployment data), `hardhat-deploy` allows you to export lightweight files.\n\nThese can be used for example to power your frontend with contract's address and abi.\n\nThis come into 2 flavors.\n\nThe first one is exported via the `--export <file>` option and follow the following format :\n\n```ts\nexport interface Export {\n  chainId: string;\n  name: string;\n  contracts: {[name: string]: ContractExport};\n}\n```\n\nwhere name is the name of the network configuration chosen (see hardhat option `--network`)\n\nThe second one is exported via the `--export-all <file>` option and follow the following format :\n\n```ts\nexport type MultiExport = {\n  [chainId: string]: Export[];\n};\n```\n\nAs you see the second format include the previous. While in most case you'll need the single export where your application will support only one network, there are case where your app would want to support multiple networks at nonce. This second format allow for that.\n\nFurthermore as hardhat support multiple network configuration for the same network (rinkeby, mainnet...), the export-all format will contains each of them grouped by their chainId.\n\nNote: from v0.10.4 the old multi-export down is no more:\n\n```\nexport type MultiExport = {\n  [chainId: string]: {[name: string]: Export};\n};\n```\n\n---\n\n---\n\n## Deploying and Upgrading Proxies\n\nAs mentioned above, the deploy function can also deploy a contract through a proxy. It can be done without modification of the contract as long as its number of constructor arguments matches the proxy initialization/update function.\n\nThe default Proxy is both ERC-1967 and ERC-173 Compliant, but other proxy can be specified, like openzeppelin transparent proxies.\n\nCode for the default Proxy can be found [here](solc_0.7/proxy/EIP173Proxy.sol).\n\nTo perform such proxy deployment, you just need to invoke the deploy function with the following options : `{..., proxy: true}`\n\nSee example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: true,\n  });\n};\n```\n\nYou can also set it to `proxy: \"<upgradeMethodName>\"` in which case the function `<upgradeMethodName>` will be executed upon upgrade.\nthe `args` field will be then used for that function instead of the contructor. It is also possible to then have a constructor with the same arguments and have the proxy be disabled. It can be useful if you want to have your contract as upgradeable in a test network but be non-upgradeable on the mainnet.\n\nSee example :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  network,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: network.live ? false : 'postUpgrade',\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nThe proxy option can also be an object which can set the specific owner that the proxy is going to be managed by.\n\nSee example:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: {\n      owner: greeterOwner,\n      methodName: 'postUpgrade',\n    },\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nNote that for the second invokation, this deployment will not be executed from the specified `from: deployer` as otherwise these tx will always fails. It will instead be automatically executed from the proxy's current owner (in that case : `greeterOwner`)\n\nNow, it is likely you do not want to locally handle the private key / mnemonic of the account that manage the proxy or it could even be that the `greeterOwner` in question is a multi sig. As such that second invocation will throw an error as it cannot find a local signer for it.\n\nThe error will output the necessary information to upgrade the contract but `hardhat-deploy` comes also with a utility function for such case: `deployments.catchUnknwonSigner` which will catch the error and output to the console the necessary information while continuing to next step.\n\nHere is the full example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy, catchUnknownSigner} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await catchUnknownSigner(\n    deploy('Greeter', {\n      from: deployer,\n      proxy: {\n        owner: greeterOwner,\n        methodName: 'postUpgrade',\n      },\n      args: ['arg1', 2, 3],\n    })\n  );\n  // you could pause the deployment here and wait for input to continue\n};\n```\n\nThe full proxy options is as follow:\n\n```ts\ntype ProxyOptionsBase = {\n  owner?: Address; // this set the owner of the proxy. further upgrade will need to be executed from that owner\n  upgradeIndex?: number; // allow you to breakdown your upgrades into separate deploy scriot, each with their own index. A deploy call with a specific upgradeIndex will be executed only once, only if the current upgradeIndex is one less.\n  proxyContract?: // default to \"EIP173Proxy\". See below for more details\n  string | ArtifactData;\n  viaAdminContract?: // allow to specify a contract that act as a middle man to perform upgrades. Useful and Recommended for Transparent Proxies\n  | string\n    | {\n        name: string;\n        artifact?: string | ArtifactData;\n      };\n};\n\nexport type ProxyOptions =\n  | (ProxyOptionsBase & {\n      methodName?: string; // method to be executed when the proxy is deployed for the first time or when the implementation is modified. Use the deployOptions args field for arguments\n    })\n  | (ProxyOptionsBase & {\n      execute?:\n        | {\n            methodName: string; // method to be executed when the proxy is deployed for the first time or when the implementation is modified.\n            args: any[];\n          }\n        | {\n            init: {\n              methodName: string; // method to be executed when the proxy is deployed\n              args: any[];\n            };\n            onUpgrade?: {\n              methodName: string; // method to be executed when the proxy is upgraded (not first deployment)\n              args: any[];\n            };\n          };\n    });\n```\n\nThe `proxyContract` field allow you to specify your own Proxy contract. If it is a string, it will first attempt to get an artifact with that name. If not found it will fallback on the following if\n\nit matches:\n\n- `EIP173Proxy`: use the default Proxy that is EIP-173 compliant\n\n- `EIP173ProxyWithReceive`: Same as above except that the proxy contains a receive hook to accept empty ETH payment.\n\n- `OpenZeppelinTransparentProxy`: Use Openzeppelin Transparent Proxy (copied from openzeppelin repo, see code [here](solc_0.7/openzeppelin/proxy/TransparentUpgradeableProxy.sol))\n  When this option is chosen, the `DefaultProxyAdmin` is also used as admin since Transparent Proxy kind of need an intermediarry contract for administration. This can be configured via the `viaAdminContract` option. Note that the DefaultProxyAdmin is slightly different than the one used by openzeppelin as it allow you to set a different owner than msg.sender on first deploy, something openzeppelin version do not allow, see : https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2639\n\n- `OptimizedTransparentProxy`: This contract is similar to above, except that it is optimized to not require storage read for the admin on every call.\n\n## Builtin-In Support For Diamonds (EIP2535)\n\nThe deployments field also expose the diamond field: `hre.deployments.diamond` that let you deploy [Diamonds](https://eips.ethereum.org/EIPS/eip-2535) in an easy way.\n\n### deployment / upgrade\n\nInstead of specifying the facets to cut out or cut in, which the diamond contract expects, you specify the facets you want to end up having on the deployed contract.\n\nThis declarative approach allow you to focus on what you want instead of how to do it.\n\n`diamond.deploy` expect the facet as names. The names represent contract to be deployed as facet. In future version you ll be able to specify deployed contract or artifact object as facet.\n\nTo deploy a contract with 3 facet you can do as follow :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: deployer,\n    owner: diamondAdmin,\n    facets: ['Facet1', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nif you then later execute the following script:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: diamondAdmin, // this need to be the diamondAdmin for upgrade\n    owner: diamondAdmin,\n    facets: ['NewFacet', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nThen the NewFacet will be deployed automatically if needed and then the diamondCut will cut Facet1 out and add NewFacet.\n\nNote that if the code for Facet2 and Facet3 changes, they will also be redeployed automatically and the diamondCuts will replace the existing facets with these new ones.\n\nNote that the diamond has 3 facet added by default. These facets are used for ownership, diamondCut and diamond loupe.\n\nThe implementation is a sligthly modified version of the [reference implementation by Nick Mudge](https://github.com/mudgen/diamond-3).\nTHe only difference is the custom constructor that allow multiple initialization, used to allow the default ERC165 facet to be initialised along your custom initialization function.\n\n### onUpgrade calls\n\nLike normal proxies you can also execute a function at the time of an upgrade.\n\nThis is done by specifying the execute field in the diamond deploy options :\n\n```js\ndiamond.deploy('ADiamondContract', {\n  from: deployer,\n  owner: diamondAdmin,\n  facets: ['NewFacet', 'Facet2', 'Facet3'],\n  execute: {\n    methodName: 'postUpgrade',\n    args: ['one', 2, '0x3'],\n  },\n});\n```\n\n### more...\n\nThere are more options, to be described later...\n\n## Testing Deployed Contracts\n\nYou can continue using the usual test task:\n\n`hardhat test`\n\nTests can use the `hre.deployments.fixture` function to run the deployment and snapshot it so that tests don't need to perform all the deployment transactions every time. They can simply reuse the snapshot for every test (this leverages `evm_snapshot` and `evm_revert` provided by both `hardhat` and `ganache`). You can for example set them in a `beforeEach`.\n\nHere is an example of a test :\n\n```js\nconst {deployments} = require('hardhat');\n\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    await deployments.fixture(['Token']);\n    const Token = await deployments.get('Token'); // Token is available because the fixture was executed\n    console.log(Token.address);\n    const ERC721BidSale = await deployments.get('ERC721BidSale');\n    console.log({ERC721BidSale});\n  });\n});\n```\n\nTests can also leverage named accounts for clearer test. Combined with `hardhat-deploy-ethers` plugin, you can write succint test :\n\n```js\nconst {ethers, getNamedAccounts} = require('hardhat');\n\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    await deployments.fixture(['Token']);\n    const {tokenOwner} = await getNamedAccounts();\n    const TokenContract = await ethers.getContract('Token', tokenOwner);\n    await TokenContract.mint(2).then((tx) => tx.wait());\n  });\n});\n```\n\n---\n\n### Creating Fixtures\n\nFurthermore, tests can easily create efficient fixture using `deployments.createFixture`\n\nSee example :\n\n```js\nconst setupTest = deployments.createFixture(\n  async ({deployments, getNamedAccounts, ethers}, options) => {\n    await deployments.fixture(); // ensure you start from a fresh deployments\n    const {tokenOwner} = await getNamedAccounts();\n    const TokenContract = await ethers.getContract('Token', tokenOwner);\n    await TokenContract.mint(10).then((tx) => tx.wait()); //this mint is executed once and then `createFixture` will ensure it is snapshotted\n    return {\n      tokenOwner: {\n        address: tokenOwner,\n        TokenContract,\n      },\n    };\n  }\n);\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    const {tokenOwner} = await setupTest();\n    await tokenOwner.TokenContract.mint(2);\n  });\n});\n```\n\nWhile this example is trivial, some fixture can requires several transaction and the ability to snapshot them automatically speed up the tests greatly.\n\n---\n\n---\n\n## More Information On Hardhat Tasks\n\n---\n\n### **1. node task**\n\nas mentioned above, the node task is slighly modified and augmented with various flags and options\n\n`hardhat node`\n\nIn particular it adds an argument `--export` that allows you to specify a destination file where the info about the contracts deployed is written.\nYour webapp can then access all contracts information.\n\n---\n\n### **2. test task**\n\n`hardhat test`\n\nthe test task is augmented with one flag argument `--deploy-fixture` that allows to run all deployments in a fixture snapshot before executing the tests. This can speed up the tests that use specific tags as the global fixture take precedence (unless specified).\n\nIn other word tests can use `deployments.fixture(<specific tag>)` where specific tag only deploys the minimal contracts for tests, while still benefiting from global deployment snapshot if used.\n\nIf a test needs the deployments to only include the specific deployment specified by the tag, it can use the following :\n\n```js\ndeployments.fixture('<specific tag>', {fallbackToGlobal: false});\n```\n\nDue to how snapshot/revert works in hardhat, this means that these tests will not benefit from the global fixture snapshot and will have to deploy their contracts as part of the fixture call. This is automatic but means that these tests will run slower.\n\n---\n\n### **3. run task**\n\n`hardhat --network <networkName> run <script>`\n\nThe run task act as before but thanks to the `hre.deployments` field it can access deployed contract :\n\n```js\nconst hre = require('hardhat');\nconst {deployments, getNamedAccounts} = hre;\n\n(async () => {\n  console.log(await deployments.all());\n  console.log({namedAccounts: await getNamedAccounts()});\n})();\n```\n\nYou can also run it directly from the command line as usual.\n\n`HARDHAT_NETWORK=rinkeby node <script>` is the equivalent except it does not load the hardhat environment twice (which the run task does)\n\n---\n\n### **4. console task**\n\n`hardhat console`\n\nThe same applies to the `console` task.\n\n---\n\n## Deploy Scripts: Tags And Dependencies\n\n---\n\nIt is possible to execute only specific parts of the deployments with `hardhat deploy --tags <tags>`\n\nTags represent what the deploy script acts on. In general it will be a single string value, the name of the contract it deploys or modifies.\n\nThen if another deploy script has such tag as a dependency, then when this latter deploy script has a specific tag and that tag is requested, the dependency will be executed first.\n\nHere is an example of two deploy scripts :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const deployResult = await deploy('Token', {\n    from: deployer,\n    args: ['hello', 100],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Token deployed at ${deployResult.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Token'];\n```\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const Token = await deployments.get('Token');\n  const deployResult = await deploy('Sale', {\n    from: deployer,\n    contract: 'ERC721BidSale',\n    args: [Token.address, 1, 3600],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Sale deployed at ${deployResult.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.dependencies = ['Token']; // this ensure the Token script above is executed first, so `deployments.get('Token')` succeeds\n```\n\nAs you can see the second one depends on the first. This is because the second script depends on a tag that the first script registers as using.\n\nWith that when `hardhat deploy --tags Sale` is executed\n\nthen both scripts will be run, ensuring Sale is ready.\n\nYou can also define the script to run after another script is run by setting `runAtTheEnd` to be true. For example:\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, execute, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer, admin} = namedAccounts;\n  await execute('Sale', {from: deployer}, 'setAdmin', admin);\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.runAtTheEnd = true;\n```\n\nTags can also be used in test with `deployments.fixture`. This allow you to test a subset of the deploy script.\n","readmeFilename":"README.md","gitHead":"48ffe96adc8b5d182bb2a43d633bf8d5be1bded7","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.3-experimental.2","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-PkzkqbToLylYyk0o3p1tHER8OmkiOPyz4vzREgg5Lmgbz8IrYFNvY+S253nItjJHjHDKEfZUQCXslETUgHK3uA==","shasum":"43666ca5eced759daa4afda2268cee6543c4ad87","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.3-experimental.2.tgz","fileCount":149,"unpackedSize":12107694,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiPBMCACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmpopQ/+IS41vOZwroSU0kM3S3HQhAkPWWWAorbRjMSXoH7vOcSLE7GA\r\n0GUNqM7pAfZt0K2QAILqQpsdDCL8xJ8abRkTeAaejdivZ6QiUDrdVMRe5jBS\r\nNUPn5+b4E+Lgub2TrRnMCAyqe0ccx5PFmPj3J0vgaA8F4KbJKHUJ/nXiYjfh\r\ndUnHpY+cqVH+EeZYq6fkfD3Nzgej3rJ922InQBKQaTngxy04bXK4g3gglCJ3\r\nxDo57brNRkZqTn0O+Yyzg4GFYT/l0EnVtgZ1prO0/f4c+f3fl8zFKEHkW4Mq\r\nx3SciamsZv3ZdkXB7nMN3fjulVrk2VpobWTKpamW3jI4doIJMywWpjKJKSM3\r\nSqdrL2Tl9z4Vnkx4anVKT6qzdXXnX2tm111RSYzDIREVc7I8iJrOIRN1mrcJ\r\nYQ9OWl+6jp0YXppJJeadsVQPjYeJMJPYUNs2Y53BJiNbDJCAYpI1fsQV6izn\r\nf0F9RGHYldfdJYeqf1A+bsBJjGjMUTAeWCIHqmXC+9OQ6OkokwXSjaml0/Rk\r\nrNZL5ZY/SgccDE9XrTWvA4y25CzLHurx+d/2MfoUQnn0McSxiC+oRaaHOzSM\r\nyce27/A1rpYdNB4yqIeyVCQJqiZekVYB9G5eac3gt8OXRTJiAe8J5D2kUsHP\r\nv7+z4U1J9IEY6w8whpuaLTL0eAdDuHIyCl4=\r\n=2Ziw\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQD6qL26j+teL4jZSBy4M4ZYePpxEApG2VsLuWN+qWR2GgIhAKJnq+rp0htEcGy7rBmzXQvgUOzJXRYiWumVdI/fHK2L"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.3-experimental.2_1648104194304_0.2954188228953849"},"_hasShrinkwrap":false},"0.11.3":{"name":"hardhat-deploy","version":"0.11.3","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.8","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.6.8"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"578d8a4115b50ec0a147c2fdc47a4652c90f45b6","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.3","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-RiHVvQJLL5dZWmCKXZz1bb6/XuBH11wM2h29nnayqOjjfWQuy+4fEVRkxt68GUSZENl65s3E7ZbmZw2QAqmipw==","shasum":"3519c04cce5f270a3d81d5671fdf2817336b9e8c","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.3.tgz","fileCount":149,"unpackedSize":12149957,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiQrVEACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmrIjg//f4RS/uKp7/XXnb09Zq0+gpxoclVj8IrRSvhH5kuWJxMoH4RL\r\neTuB84mZdpNW0SNFkPI+wCBeg/8iJx/WLiYuQUhrFgVes900g4trhdcDts1B\r\nu8hOmHa4TFi8GCuv7xgloKnkAjlzjCuzZVYWpgEVolF+xhz5ffkDhBOGwJL3\r\nLE2MIXWLtTE87BEKWf0w7bw+5+IX1M2FH7c5CcH762THLL1Q7szhmae8l2rz\r\nWpo+L+ekITMWwhit3wCkk17ohLnqhaSHfcR5HKX/rFnqQPLhRgecoQbjsxcP\r\n9c91Gp9rlm3TAb0B83Gu3mjw2c1yraXk5QlKOizyjl3JmciN9KZgNrV25aot\r\nI9wZcIlY0o8GectmbuRCB617QjxNt8N7Hnnzy19N20xinYVM265L7X2RDSU+\r\nZopDavarWKvMCDX0ISd4PPjypmCcpvVSUQZWy3nC9XDlE2M54FzW7spddu7l\r\n5cxPJJcsQ5uI9+QX3J4+doJ/AcAvBOITE67LlFqEGInoCa8PTy9MSbK/+hEO\r\n66it04JsCUcHnSJibq+x9XQmUhjsXlK54Ndw/qqHxMk1HSPGQ446johPvV76\r\ne4Fjue9j64DQzrB20c0shcSUhW7QEHnCGVvZKpDsokjtLGM0zuwVIEalQHkS\r\n8qA07eqwIMJwSMuAtBOUIs2t1bgENUUr4lY=\r\n=sxq+\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDDbEcc9N97gJLLM1vjcM9upz4nNloO05bAgfksdMP7QQIgYnHTtC21Sx+AS9LpvRQnJ0NAEJzaChVYLwSZyOLN5eQ="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.3_1648538948286_0.45935623786501645"},"_hasShrinkwrap":false},"0.11.4":{"name":"hardhat-deploy","version":"0.11.4","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.6.8","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"peerDependencies":{"@ethersproject/hardware-wallets":"^5.0.14","hardhat":"^2.6.8"},"dependencies":{"@ethersproject/abi":"^5.4.0","@ethersproject/abstract-signer":"^5.4.1","@ethersproject/address":"^5.4.0","@ethersproject/bignumber":"^5.4.1","@ethersproject/bytes":"^5.4.0","@ethersproject/constants":"^5.4.0","@ethersproject/contracts":"^5.4.1","@ethersproject/providers":"^5.4.4","@ethersproject/solidity":"^5.4.0","@ethersproject/transactions":"^5.4.0","@ethersproject/wallet":"^5.4.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"7995871ac852f934aecc829d75cfb513a0695d7a","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.4","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-BNMwWqaxrwb8XKrYzmCwnUzOSKzicUBk+fwd28doUNoAGFFh8kpoypkcHMzKDVdLhnamAardcfqJet73zrZoTA==","shasum":"39b06d3b0ad25195071cc1f2f71649b1f9f030d0","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.4.tgz","fileCount":149,"unpackedSize":12150517,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiQrWUACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqWsw//XaYnh4HFSsy/KNxoMTHUEKITCgcWkBh8h4edhmVuV6Fr7z4S\r\nbVcBWR2eb7+48MGE5/Xs8GQ7Urcscpc4WQcPnTm4wzZC3aa+YBAaGNxCkgfP\r\nNAesfV7sh+95m6WkiIv2HdYjXSeVOstf61/YHrU7CqpbrZ7dwYa01xyXdDgn\r\noTXTQetTkdVXMevNSVal2k2tJGlbbs2TJwXqNvqBfqkhMoPFTcVAtlY+G9y8\r\n7NOA/ZXLENXMtI6qIug38/xiiOSh98N8LMrkcMH6b0CpldkhPtMFZUgWtSi8\r\nip+d6pv4Q+WLllB03M3CW7u6g4xTVh0So7nIegmawNHzDKTXsSIoagZYSGli\r\nxQZU5Kp0d7fJ+CdqMJBvEASf60JOSaTlG+/1HB//Oyzawm6vWgV0Edd3SXuE\r\nEw4NQ1Izi3YjObWlsOlujunML1qukwTYXcPSp0J1vauoEDQ9/jeSrBjYm3ls\r\njyPDF/0bCZ0pUSCz/QvV54ZRTaTigl5ORKJ8jCOJq2ImRU3jHAE/lDvroxgx\r\noGfPpVnldf0d2HlgfcWp+Q7Qoz7beqUplN4tVnrBPzlW6zzZhTglrG8YESAY\r\nt76sis2mcDprCyAsalH0fR54V6+3gt5xkzia13ur2sOZSuS5BoPCexjJ9kK/\r\nLkYvkUw+7O80GRqvtkKad+qBIJs98R4kcY0=\r\n=1heH\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCh14ulaA4RWqOcTBgGU5DhSI2I7itmElE7mmn8Dx0YKQIhAJgmyN/vehIXaH+Y9Lie0vQW5U+/jARaIF444kA9o4e4"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.4_1648539028430_0.8230480665782056"},"_hasShrinkwrap":false},"0.10.5-zksync.0":{"name":"hardhat-deploy","version":"0.10.5-zksync.0","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.9.0","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"dependencies":{"@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","ethers":"^5.5.3","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","zksync-web3":"^0.4.0"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"readme":"<h1> hardhat-deploy</h1>\n\n_A [Hardhat](https://hardhat.org) Plugin For Replicable Deployments And Easy Testing_\n\n> **A complete dev template using hardhat-deploy is available here** : https://github.com/wighawag/template-ethereum-contracts\n> It also contains various branches examplifying the capability of hardhat-deploy. Check it out.\n\n- [What is it for ?](#what-is-it-for-)\n- [hardhat-deploy in a nutshell](#hardhat-deploy-in-a-nutshell)\n- [Installation](#installation)\n  - [npm install hardhat-deploy](#npm-install-hardhat-deploy)\n  - [TypeScript support](#typescript-support)\n  - [Migrating existing deployment to hardhat-deploy](#migrating-existing-deployment-to-hardhat-deploy)\n- [Hardhat Tasks Available/Updated](#hardhat-tasks-availableupdated)\n  - [1. hardhat deploy](#1-hardhat-deploy)\n    - [**Options**](#options)\n    - [**Flags**](#flags)\n  - [2. hardhat node](#2-hardhat-node)\n    - [**Options**](#options-1)\n    - [**Flags**](#flags-1)\n  - [3. hardhat test](#3-hardhat-test)\n  - [4. hardhat etherscan-verify](#4-hardhat-etherscan-verify)\n    - [**Options**](#options-2)\n  - [5. hardhat sourcify](#5-hardhat-sourcify)\n    - [**Options**](#options-3)\n  - [6. hardhat export](#6-hardhat-export)\n    - [**Options**](#options-4)\n- [Hardhat Environment Extensions](#hardhat-environment-extensions)\n- [Configuration](#configuration)\n  - [**1. namedAccounts (ability to name addresses)**](#1-namedaccounts-ability-to-name-addresses)\n  - [**2. extra hardhat.config networks' options**](#2-extra-hardhatconfig-networks-options)\n    - [`live`](#live)\n    - [`saveDeployments`](#savedeployments)\n    - [`tags`](#tags)\n    - [`deploy`](#deploy)\n    - [`companionNetworks`](#companionnetworks)\n  - [**3. extra hardhat.config paths' options**](#3-extra-hardhatconfig-paths-options)\n  - [**4. deterministicDeployment (ability to specify a deployment factory)**](#4-deterministicdeployment-ability-to-specify-a-deployment-factory)\n  - [Importing deployment from other projects (with truffle support)](#importing-deployment-from-other-projects-with-truffle-support)\n  - [Access to Artifacts (non-deployed contract code and abi)](#access-to-artifacts-non-deployed-contract-code-and-abi)\n- [How to Deploy Contracts](#how-to-deploy-contracts)\n  - [The `deploy` Task](#the-deploy-task)\n  - [Deploy Scripts](#deploy-scripts)\n    - [An example of a deploy script :](#an-example-of-a-deploy-script-)\n  - [The `deployments` field](#the-deployments-field)\n    - [`deployments.deploy(<name>, options)`](#deploymentsdeployname-options)\n- [Handling contract using libraries](#handling-contract-using-libraries)\n- [Exporting Deployments](#exporting-deployments)\n- [Deploying and Upgrading Proxies](#deploying-and-upgrading-proxies)\n- [Builtin-In Support For Diamonds (EIP2535)](#builtin-in-support-for-diamonds-eip2535)\n- [Testing Deployed Contracts](#testing-deployed-contracts)\n  - [Creating Fixtures](#creating-fixtures)\n- [More Information On Hardhat Tasks](#more-information-on-hardhat-tasks)\n  - [**1. node task**](#1-node-task)\n  - [**2. test task**](#2-test-task)\n  - [**3. run task**](#3-run-task)\n  - [**4. console task**](#4-console-task)\n- [Deploy Scripts: Tags And Dependencies](#deploy-scripts-tags-and-dependencies)\n\n## What is it for ?\n\nThis [hardhat](https://hardhat.org) plugin adds a mechanism to deploy contracts to any network, keeping track of them and replicating the same environment for testing.\n\nIt also adds a mechanism to associate names to addresses, so test and deployment scripts can be reconfigured by simply changing the address a name points to, allowing different configurations per network. This also results in much clearer tests and deployment scripts (no more `accounts[0]` in your code).\n\nThis plugin contains a lot more features too, all geared toward a better developer experience :\n\n- chain configuration export\n- listing deployed contracts' addresses and their abis (useful for webapps)\n- library linking at time of deployment.\n- deterministic deployment across networks.\n- support for specific deploy script per network (L1 vs L2 for example)\n- ability to access deployment from \"companion\" networks\n- deployment dependency system (allowing you to only deploy what is needed).\n- deployment retrying (by saving pending tx): so you can feel confident when making a deployment that you can always recover.\n- deployments as test fixture using `evm_snapshot` to speed up testing.\n- ability to create your own test fixture that automatically benefits from `evm_snapshot`'s tests speed-up boost\n- combined with [hardhat-deploy-ethers](https://github.com/wighawag/hardhat-deploy-ethers) it has the ability to get ethers contract instance by name (like `await ethers.getContract(\"ContractName\")`).\n- importing artifact from external sources (like npm packages), including [truffle](https://www.trufflesuite.com/truffle) support.\n- importing deployments from external sources (like npm packages)\n- ability to log information in `deploy` mode only (while in test the console remains clean).\n- contains helpers to read and execute transaction on deployed contract referring to them by name.\n- These helpers contains options to auto mine on dev network (to speed up test deployments).\n- save metadata of deployed contract so they can always be fully verified, via [sourcify](https://sourcify.dev) or [etherscan](https://etherscan.io).\n- ability to submit contract source to etherscan and sourcify for verification at any time. (Because **hardhat-deploy** will save all the necessary info, it can be executed at any time.)\n- support harhdat's fork feature so deployment can be accessed even when run through fork.\n- named accounts are automatically impersonnated too, so you can perform tx as if you had their private key.\n- proxy deployment with ability to upgrade them transparently, only if code changes.\n- this include support for [openzeppelin](https://openzeppelin.com) transparent proxies\n- diamond deployment with facets, allowing you to focus on what the new version will be. It will generate the diamondCut necessary to reach the new state.\n- watch and deploy: **hardhat-deploy** can watch both your deploy script and contract code and redeploy on changes.\n- HCR (Hot Contract Replacement): the watch feature combined with proxy or diamond, gives you an experience akin to frontend Hot Module Replacement: once your contract changes, the deployment is executed and your contract retains the same address and same state, allowing you to tweak your contracts while debugging your front-end.\n\n## hardhat-deploy in a nutshell\n\nBefore going into the details, here is a very simple summary of the basic feature of **hardhat-deploy**.\n\n**hardhat-deploy** allows you to write [`deploy scripts`](#deploy-scripts) in the `deploy` folder. Each of these files that look as follows will be executed in turn when you execute the following task: `hardhat --network <networkName> deploy`\n\n```js\n// deploy/00_deploy_my_contract.js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('MyContract', {\n    from: deployer,\n    args: ['Hello'],\n    log: true,\n  });\n};\nmodule.exports.tags = ['MyContract'];\n```\n\nFurthermore you can also ensure these scripts are executed in test too by calling `await deployments.fixture(['MyContract'])` in your test.\nThis is optimized, so if multiple tests use the same contract, the deployment will be executed once and each test will start with the exact same state.\n\nThis is a huge benefit for testing since you are not required to replicate the deployment procedure in your tests. The tag feature (as seen in the script above) and [dependencies](#deploy-scripts-tags-and-dependencies) will also make your life easier when writing complex deployment procedures.\n\nYou can even group deploy scripts in different sub folder and ensure they are executed in their logical order.\n\nFurthermore hardhat-deploy can also support a multi-chain settings like L1, L2 with multiple deploy folder specific to each network.\n\n**All of this can also be bundled in a npm package so user of hardhat-deploy can reuse your deployment procedure and get started integrating with your project locally.**\n\nThere is a tutorial covering the basics here : https://github.com/wighawag/tutorial-hardhat-deploy\n\n## Installation\n\n### npm install hardhat-deploy\n\n```bash\nnpm install -D hardhat-deploy\n```\n\nAnd add the following statement to your `hardhat.config.js`:\n\n```js\nrequire('hardhat-deploy');\n```\n\nif you use `ethers.js` we recommend you also install `hardhat-deploy-ethers` which add extra features to access deployments as ethers contract.\n\nSince `hardhat-deploy-ethers` is a fork of `@nomiclabs/hardhat-ethers` and that other plugin might have an hardcoded dependency on `@nomiclabs/hardhat-ethers` the best way to install `hardhat-deploy-ethers` and ensure compatibility is the following:\n\n```bash\nnpm install --save-dev  @nomiclabs/hardhat-ethers@npm:hardhat-deploy-ethers ethers\n```\n\nWhich means you then need to do `require(\"@nomiclabs/hardhat-ethers\")` instead of `require(\"hardhat-deploy-ethers\")` in your `hardhat.config.js` file.\n\nMore details on `hardhat-deploy-ethers` repo : https://github.com/wighawag/hardhat-deploy-ethers#readme\n\n### TypeScript support\n\nWith hardhat the tsconfig.json is optional.\n\nBut if you add folders to the `include` field in `tsconfig.json`, you ll also need to include `hardhat.config.ts` like :\n\n`include\": [\"./hardhat.config.ts\", \"./scripts\", \"./deploy\", \"./test\"]`\n\nfor deploy script (see below) you can write them this way to benefit from typing :\n\n```ts\nimport {HardhatRuntimeEnvironment} from 'hardhat/types';\nimport {DeployFunction} from 'hardhat-deploy/types';\n\nconst func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {\n  // code here\n};\nexport default func;\n```\n\nSee a template that uses **hardhat-deploy** here : https://github.com/wighawag/template-ethereum-contracts\n\nThis repo has also some examples branch that exemplify specific features, like the forking testing here : https://github.com/wighawag/template-ethereum-contracts/tree/examples/fork-test\n\n### Migrating existing deployment to hardhat-deploy\n\n> Only needed for existing project that already deployed contracts and has the deployment information available **(at minimum, address and abi)**\n\nYou might want to switch your current deployment process to use **hardhat-deploy**. In that case you probably have some deployments saved elsewhere.\n\nIn order to port them to **hardhat-deploy**, you'll need to create one `.json` file per contract in the `deployments/<network>` folder (configurable via [paths config](#extra-paths-config)).\n\nThe network folder is simply the hardhat network name (as configured in hardhat.config.js) (accessible at runtime via `hre.network.name`).\nSuch folder need to have a file named `.chainId` containing the chainId as decimal.\n\nFor example for network named \"rinkeby\" (for the corresponding network) the file `deployments/rinkeby/.chainId` would be\n\n```\n4\n```\n\nNote, prior to hardhat 0.6 the chainId was appended to the folder name (expect for some known network name). This has changed and upgrading to 0.6 will require you to change the folder name and add the '.chainId' file.\n\nEach contract file must follow this type (as defined in [types.ts](types.ts)) :\n\n```ts\nexport interface Deployment {\n  address: Address;\n  abi: ABI;\n  receipt?: Receipt;\n  transactionHash?: string;\n  history?: Deployment[];\n  numDeployments?: number;\n  implementation?: string;\n  args?: any[];\n  linkedData?: any;\n  solcInputHash?: string;\n  metadata?: string;\n  bytecode?: string;\n  deployedBytecode?: string;\n  libraries?: Libraries;\n  userdoc?: any;\n  devdoc?: any;\n  methodIdentifiers?: any;\n  diamondCut?: FacetCut[];\n  facets?: Facet[];\n  storageLayout?: any;\n  gasEstimates?: any;\n}\n```\n\nAs you can see, only abi and address are mandatory. But having the other fields allow more feature. For example, metadata and args allow you to benefit from contract code verification.\n\nFor Receipt, the following type is expected:\n\n```ts\nexport type Receipt = {\n  from: string;\n  transactionHash: string;\n  blockHash: string;\n  blockNumber: number;\n  transactionIndex: number;\n  cumulativeGasUsed: string;\n  gasUsed: string;\n  contractAddress?: string;\n  to?: string;\n  logs?: Log[];\n  events?: any[];\n  logsBloom?: string;\n  byzantium?: boolean;\n  status?: number;\n  confirmations?: number;\n};\n```\n\nHere is an example:\n\nLet's say you have:\n\n- 2 Contract named Greeter and Registry deployed on rinkeby\n- 1 contract named Greeter on mainnet\n- 2 Contract named Greeter and Registry deployed on a network named rinkeby2\n\nYou would get the following folder structure:\n\n```\ndeployments/\n  mainnet/\n    .chainId\n    Greeter.json\n  rinkeby/\n    .chainId\n    Greeter.json\n    Registry.json\n  rinkeby2/\n    .chainId\n    Greeter.json\n    Registry.json\n```\n\nThe reason why **hardhat-deploy** save chainId in the `.chainId` file is both for\n\n- safety: so that if you were to change the network name to point to a different chain, it would not attempt to read the wrong folder and assume that a contract has been deployed while it has not.\n- ability to know the chainId without requring to be connected to a node (and so not dependent on hardhat.config.js settings). Useful for `export` task.\n\n---\n\n## Hardhat Tasks Available/Updated\n\nhardhat deploy add several task to hardhat. It also modify existing one, adding new options and new behavior. All of these are described here:\n\n---\n\n### 1. hardhat deploy\n\n---\n\nThis plugin adds the _deploy_ task to Hardhat.\n\nThis task will execute the scripts in the `deploy` folder and save the contract deployments to disk. These deployments are supposed to be saved for example in a git repository. This way they can be accessed later. But you are free to save them elsewhere and get them back via your mechanism of choice.\n\nWith the deployment saved, it allows you to deploy a contract only if changes were made.\n\nDeploy scripts (also called Deploy functions) can also perform aribtrary logic.\n\nFor further details on how to use it and write deploy script, see [section](#deploy-scripts) below.\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployments, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice (in wei) to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--reset`: This flag resets the deployments from scratch. Previously deployed contract are not considered and deleted from disk.\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n---\n\n### 2. hardhat node\n\n---\n\nThis plugin modify the _node_ task so that it also execute the deployment script before exposing the server http RPC interface\n\nIt add similar options than the `deploy` task :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--no-reset`: This flag prevent the reseting of the existing deployments. This is usually not desired when running the `node` task as a network is created from scratch and previous deployemnt are irrelevant.\n\n`--show-accounts`: this flag will output the account private keys\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n`--no-deploy` that discard all other options to revert to normal `hardhat node` behavior without any deployment being performed.\n\n> :warning: Note that the deployments are saved as if the network name is `localhost`. This is because `hardhat node` is expected to be used as localhost: You can for example execute `hardhat --network localhost console` after `node` is running. Doing `hardhat --network hardhat console` would indeed not do anything useful. It still take the configuration from `hardhat` in the hardhat.config.js file though.\n\n---\n\n### 3. hardhat test\n\n---\n\nThis plugin adds a flag argument `--deploy-fixture` to the _test_ task which if enabled will run the global deployments fixture before the tests and snapshots it. This will generaly speed up the tests as further test will be able to revert back to the full deployment.\n\n> :warning: Note though that if your test behave differently whether that option is on or not, this most likely mean that your deploy scripts' tags and dependencies are not configured correctly. This is because the global fixture will ensure all contract are deployed while test will usually (for efficiency) ask for a particular tag.\n\n---\n\n### 4. hardhat etherscan-verify\n\n---\n\nThis plugin adds the _etherscan-verify_ task to Hardhat.\n\nThis task will submit the contract source and other info of all deployed contracts to allow etherscan to verify and record the sources.\n\nInstead of using the full solc input, this task will first attempt to send the minimal sources from the metadata.\nBut Etherscan sometime fails due to a bug in solidity compiler (<https://github.com/ethereum/solidity/issues/9573>). As such this task can fallback on full solc input (see option --solc-input). Note that if your contract was deployed with a previous version of **hardhat-deploy**, it might not contains the full information. The issue seems to be fully resolved since solc version 0.8.\n\nThis task will also attempt to automatically find the SPDX license in the source.\n\nTo execute that task, you need to specifiy the network to run against :\n\n```bash\nhardhat --network mainnet etherscan-verify [--api-key <apikey>] [--apiurl <url>]\n```\n\n#### **Options**\n\nNote that harhdat-deploy now use a different config format to not conflict with `hardhat-etherscan`\n\n`--api-key <api key>`: let you specify your etherscan api key. Alternatively, you can provide it via the env variable `ETHERSCAN_API_KEY` or through the hardhat.config.ts verify field:\n\n```js\n{\n  ...\n  verify: {\n    etherscan: {\n      apiKey: '<API key>'\n    }\n  }\n}\n```\n\n`--api-url <url>`: let you specify your etherscan url to submit the source to. Can also be configured per network in `hardhat.config.js`:\n\n```js\n{\n  ...\n  networks: {\n    mynetwork: {\n      ...\n      verify: {\n        etherscan: {\n          apiUrl: 'http://mynetwork.xyz'\n        }\n      }\n    }\n  }\n}\n```\n\n`--license <SPDX license id>`: SPDX license (useful if SPDX is not listed in the sources), need to be supported by etherscan: https://etherscan.io/contract-license-types\n\n`--force-license`: if set, will force the use of the license specified by --license option, ignoring the one in the source (useful for license not supported by etherscan)\n\n`--solc-input`: fallback on solc-input id needed (useful when etherscan fails on the minimum sources, see https://github.com/ethereum/solidity/issues/9573)\n\n`--sleep`: sleep 500ms between each verification, so API rate limit is not exceeded\n\n---\n\n### 5. hardhat sourcify\n\n---\n\nThis plugin adds the _sourcify_ task to Hardhat.\n\nSimilar to `hardhat etherscan-verify` this task will submit the contract source and other info of all deployed contracts to sourcify.\n\n```bash\nhardhat --network mainnet sourcify\n```\n\nLater this task might instead pin the metadata to ipfs, so sourcify can automatically verify them.\n\n#### **Options**\n\n`--endpoint <endpoint>`: specify the sourcify endpoint, default to https://sourcify.dev/server/\n\n`--write-failing-metadata`: if set and the sourcify task fails to verify, the metadata file will be written to disk, so you can more easily figure out what has gone wrong.\n\n---\n\n### 6. hardhat export\n\n---\n\nThis plugin adds the _export_ task to Hardhat.\n\nThis task will export the contract deployed (saved in `deployments` folder) to a file with a simple format containing only contract addresses and abi, useful for web apps.\n\nOne of the following options need to be set for this task to have any effects :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\nThis last option has some limitations, when combined with the use of external deployments (see [Configuration](#configuration)). If such external deployments were using older version of **hardhat-deploy** or truffle, the chainId might be missing. In order for these to be exported, the hardhat network config need to explicity state the chainId in the `networks` config of `hardhat.config.js`.\n\nWith both `--export` and `--export-all`, using the special `<filepath>` value of `-` will output to `STDOUT` rather than writing a normal file.\n\n---\n\n---\n\n## Hardhat Environment Extensions\n\nThis plugin extends the Hardhat Runtime Environment by adding 4 fields:\n\n- `getNamedAccounts: () => Promise<{ [name: string]: string }>`: a function returning an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [Configuration](#configuration)).\n\n- `getUnnamedAccounts: () => Promise<string[]}>`: accounts which has no names, useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`: contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId(): Promise<string>`: offer an easy way to fetch the current chainId.\n\n---\n\n---\n\n## Configuration\n\n---\n\n### **1. namedAccounts (ability to name addresses)**\n\n---\n\nThis plugin extends the `HardhatConfig`'s object with an optional `namedAccounts` field.\n\n`namedAccounts` allows you to associate names to addresses and have them configured per chain.\nThis allows you to have meaningful names in your tests while the addresses match to multi sig in real network for example.\n\n```js\n{\n    namedAccounts: {\n        deployer: {\n            default: 0, // here this will by default take the first account as deployer\n            1: 0, // similarly on mainnet it will take the first account as deployer. Note though that depending on how hardhat network are configured, the account 0 on one network can be different than on another\n            4: '0xA296a3d5F026953e17F472B497eC29a5631FB51B', // but for rinkeby it will be a specific address\n            \"goerli\": '0x84b9514E013710b9dD0811c9Fe46b837a4A0d8E0', //it can also specify a specific netwotk name (specified in hardhat.config.js)\n        },\n        feeCollector:{\n            default: 1, // here this will by default take the second account as feeCollector (so in the test this will be a different account than the deployer)\n            1: '0xa5610E1f289DbDe94F3428A9df22E8B518f65751', // on the mainnet the feeCollector could be a multi sig\n            4: '0xa250ac77360d4e837a13628bC828a2aDf7BabfB3', // on rinkeby it could be another account\n        }\n    }\n}\n```\n\n<!-- You can also specify addresses with the `ledger://` prefix. In which case the account fetched will still be the corresponding address, but behind the scene, the transaction will be created via the hardware waller. Currently the feature is not working very well though and better support is needed. -->\n\n---\n\n### **2. extra hardhat.config networks' options**\n\n---\n\n**hardhat-deploy** add 5 new fields to `networks` configuration\n\n#### `live`\n\nthis is not used internally but is useful to perform action on a network whether it is a live network (rinkeby, mainnet, etc) or a temporary one (localhost, hardhat). The default is true (except for localhost and hardhat where the default is false).\n\n#### `saveDeployments`\n\nthis tell whether **hardhat-deploy** should save the deployments to disk or not. Default to true, except for the hardhat network.\n\n#### `tags`\n\nnetwork can have tags to represent them. The config is an array and at runtime the hre.network.tags is an object whose fields (the tags) are set to true.\n\nThis is useful to conidtionaly operate on network based on their use case.\n\nExample:\n\n```js\n{\n  networks: {\n    localhost: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"local\"]\n    },\n    hardhat: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"test\", \"local\"]\n    },\n    rinkeby: {\n      live: true,\n      saveDeployments: true,\n      tags: [\"staging\"]\n    }\n  }\n}\n```\n\n#### `deploy`\n\nthe deploy field override the paths.deploy option and let you define a set of folder containing the deploy scripts to be executed for this network.\n\nYou can thus have one network that will be executing L1 deployment and other L2 deployments, etc...\n\nYou could also have a folder that deploy contracts that are live on mainnet but that you need to replicate for your test or local network.\n\n#### `companionNetworks`\n\nthe companionNetworks field is an object whose key is any name you desire and the value is the name of a network that will be accessible inside the deploy script. For example:\n\n```js\n{\n  ...\n  networks: {\n    optimism: {\n      url: 'http://127.0.0.1:8545',\n      ovm: true,\n      companionNetworks: {\n        l1: 'localhost',\n      },\n    }\n  }\n  ...\n}\n```\n\nBy using name you can have the same deploy script used in different set of network.\n\nFor your test you could have the companion networks pointing to the same hardhat network, for test deployment, you could have rinkeby acting like your l2 while goerli act as your l1.\n\nAn example repo that show case a multi-network setup with optimism can be found here : https://github.com/wighawag/template-ethereum-contracts/tree/examples/optimism\n\ndeploy script can then access the network and its deployment as follow :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  const OVM_L1ERC20Gateway = await hre.companionNetworks['l1'].deployments.get(\n    'OVM_L1ERC20Gateway'\n  ); // layer 1\n\n  await execute(\n    'SimpleERC20_OVM',\n    {from: deployer, log: true},\n    'init',\n    OVM_L1ERC20Gateway.address\n  );\n};\n```\n\n---\n\n### **3. extra hardhat.config paths' options**\n\n---\n\n`hardhat-deploy` also adds fields to `HardhatConfig`'s `ProjectPaths` object.\n\nHere is an example showing the default values :\n\n```js\n{\n    paths: {\n        deploy: 'deploy',\n        deployments: 'deployments',\n        imports: 'imports'\n    }\n}\n```\n\nThe `deploy` folder is expected to contains the deploy script that are executed upon invocation of `hardhat deploy` or `hardhat node`.\nIt can also be an array of folder path.\n\nThe `deployments` folder will contains the resulting deployments (contract addresses along their abi, bytecode, metadata...). One folder per network and one file per contract.\n\nThe `imports` folder is expected to contains artifacts that were pre-compiled. Useful if you want to upgrade to a new solidity version but want to keep using previously compiled contracts. The artifact is the same format as normal hardhat artifact, so you can easily copy them over, before switching to a new compiler version.\n\n> This is less useful now that hardhat support multiple solidity compiler at once.\n\n---\n\n---\n\n### **4. deterministicDeployment (ability to specify a deployment factory)**\n\n---\n\nThis plugin extends the `HardhatConfig`'s object with an optional `deterministicDeployment` field.\n\n`deterministicDeployment` allows you to associate information that are used on each network for deterministic deployment. The information for each deterministic deployment consist out of a `factory`, a `deployer`, the required `funding` and a `signedTx` to deploy the factory. The default deterministic deployment used is the [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy). The factory expects a 32 bytes `salt` concatenated with the deployment data (see [EIP-1014](https://eips.ethereum.org/EIPS/eip-1014) for more information on these parameters).\n\nUsing the `deterministicDeployment` it is possible to define a different setup for the deterministic deployment. One use case for this is the deterministic deployment on networks that required replay protection (such as Celo or Avalanche). The [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy) can only be deployed on networks that don't enforce replay protection, therefore on other networks an alternative library has to be used. An example for this would be the [Safe Singleton Factory](https://github.com/gnosis/safe-singleton-factory) that is an adjusted version of the [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy) that contains signed transactions that include replay protection.\n\nThe information can be defined either as an object\n\n```js\n{\n    deterministicDeployment: {\n      \"4\": {\n        factory: \"<factory_address>\",\n        deployer: \"<deployer_address>\",\n        funding: \"<required_funding_in_wei>\",\n        signedTx: \"<raw_signed_tx>\",\n      }\n    }\n}\n```\n\nor as an function that returns the information for the deterministic deployment\n\n```js\n{\n  deterministicDeployment: (network: string) => {\n    return {\n      factory: '<factory_address>',\n      deployer: '<deployer_address>',\n      funding: '<required_funding_in_wei>',\n      signedTx: '<raw_signed_tx>',\n    };\n  };\n}\n```\n\n### Importing deployment from other projects (with truffle support)\n\n`hardhat-deploy` also add the `external` field to `HardhatConfig`\n\nSuch field allows to specify paths for external artifacts or **deployments**.\n\nThe external object has 2 fields:\n\n```js\n{\n    external: {\n        contracts: [\n          {\n            artifacts: \"node_modules/@cartesi/arbitration/export/artifacts\",\n            deploy: \"node_modules/@cartesi/arbitration/export/deploy\"\n          },\n          {\n            artifacts: \"node_modules/someotherpackage/artifacts\",\n          }\n        ],\n        deployments: {\n          rinkeby: [\"node_modules/@cartesi/arbitration/build/contracts\"],\n        },\n    }\n}\n```\n\nThe `contracts` field specify an array of object which itself have 2 fields.\n\n- `artifacts`: (mandatory) it is a path to an artifact folder. This support both hardhat and truffle artifacts.\n- `deploy`: (optional) it specifies a path to a folder where reside deploy script. The deploy scripts have only access to the artifact specified in the artifacts field. This allow project to share their deployment procedure. A boon for developer aiming at integrating it as they can get the contracts to be deployed for testing locally.\n\nThe `deployments` fields specify an object whose field nasme are the hardhat network and the value is an array of path to look for deployments. It supports both **hardhat-deploy** and truffle formats.\n\n---\n\n### Access to Artifacts (non-deployed contract code and abi)\n\nArtifacts in hardhat terminology represent a compiled contract (not yet deployed) with at least its bytecode and abi.\n\n`hardhat-deploy` gives can access to these artifact via the `deployments.getArtifact` function :\n\n```js\nconst {deployments} = require('hardhat');\nconst artifact = await deployments.getArtifact(artifactName);\n```\n\nWith the `hardhat-deploy-ethers` plugin you can get an artifact as an ethers contract factory, ready to be deployed, via the following:\n\n```js\nconst {deployments, ethers} = require('hardhat');\nconst factory = await ethers.getContractFactory(artifactName);\n```\n\n> Note that the artifact's files need to be either in `artifacts` folder that hardhat generate on compilation or in the `imports` folder where you can store contracts compiled elsewhere. They can also be present in the folder specified in `external.artifacts` see [Importing deployment from other projects](#importing-deployment-from-other-projects-with-truffle-support)\n\n---\n\n---\n\n## How to Deploy Contracts\n\n---\n\n### The `deploy` Task\n\n`hardhat --network <networkName> deploy [options and flags]`\n\nThis is a new task that the `hardhat-deploy` adds. As the name suggests it deploys contracts.\nTo be exact it will look for files in the folder `deploy` or whatever was configured in `paths.deploy`, see [paths config](#extra-paths-config)\n\nIt will scan for files in alphabetical order and execute them in turn.\n\n- it will `require` each of these files and execute the exported function with the HRE as argument\n\nTo specify the network, you can use the builtin hardhat argument `--network <network name>` or set the env variable `HARDHAT_NETWORK`\n\n> :warning: Note that running `hardhat deploy` without specifying a network will use the default network. If the default network is hardhat (the default's default) then nothing will happen as a result as everything happens in memory, but this can be used to ensure the deployment is without issues.\n\n---\n\n### Deploy Scripts\n\nThe deploy scripts need to be of the following type :\n\n```ts\nexport interface DeployFunction {\n  (env: HardhatRuntimeEnvironment): Promise<void | boolean>;\n  skip?: (env: HardhatRuntimeEnvironment) => Promise<boolean>;\n  tags?: string[];\n  dependencies?: string[];\n  runAtTheEnd?: boolean;\n  id?: string;\n}\n```\n\nThe skip function can be used to skip executing the script under whatever condition. It simply need to resolve a promise to true.\n\nThe tags is a list of string that when the _deploy_ task is executed with, the script will be executed (unless it skips). In other word if the deploy task is executed with a tag that does not belong to that script, that script will not be executed unless it is a dependency of a script that does get executed.\n\nThe dependencies is a list of tag that will be executed if that script is executed. So if the script is executed, every script whose tag match any of the dependencies will be executed first.\n\nThe `runAtTheEnd` is a boolean that if set to true, will queue that script to be executed after all other scripts are executed.\n\nThese set of fields allow more flexibility to organize the scripts. You are not limited to alphabetical order and you can even organise deploy script in sub folders.\n\nFinally the function can return true if it wishes to never be executed again. This can be usfeul to emulate migration scripts that are meant to be executed only once. Once such script return true (async), the `id` field is used to track execution and if that field is not present when the script return true, it will fails.\n\nIn other words, if you want a particular deploy script to run only once, it needs to both return true (async) and have an `id` set.\n\nIn any case, as a general advice every deploy function should be idempotent. This is so they can always recover from failure or pending transaction. This is what underpin most of hardhat-deploy philosophy.\n\nThis is why the `hre.deployments.deploy` function will by default only deploy if the contract code has changed, making it easier to write idempotent script.\n\n#### An example of a deploy script :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  // the following will only deploy \"GenericMetaTxProcessor\" if the contract was never deployed or if the code changed since last deployment\n  await deploy('GenericMetaTxProcessor', {\n    from: deployer,\n    gasLimit: 4000000,\n    args: [],\n  });\n};\n```\n\nAs you can see the HRE passed in has 4 new fields :\n\n- `getNamedAccounts` is a function that returns a promise to an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [`namedAccounts`](#namedaccounts)).\n\n- `getUnnamedAccounts` is a function that return a promise to an array of accounts which were not named (see [`namedAccounts`](#namedaccounts)). It is useful for tests where you want to be sure that the account has no speicifc role in the system (no token given, no admin access, etc...).\n\n- `getChainId` is a function which return a promise for the chainId, as convenience\n\n- `deployments` is an object which contains functions to access past deployments or to save new ones, as well as helpers functions.\n\nThat latter field contains for example the `deploy` function that allows you to deploy contract and save them. It contains a lot more functions though :\n\n---\n\n### The `deployments` field\n\nThe deployments field contains several helpers function to deploy contract but also execute transaction.\n\n```ts\nexport interface DeploymentsExtension {\n  deploy(name: string, options: DeployOptions): Promise<DeployResult>; // deploy a contract\n  diamond: {\n    // deploy diamond based contract (see section below)\n    deploy(name: string, options: DiamondOptions): Promise<DeployResult>;\n  };\n  deterministic( // return the determinsitic address as well as a function to deploy the contract, can pass the `salt` field in the option to use different salt\n    name: string,\n    options: Create2DeployOptions\n  ): Promise<{\n    address: Address;\n    implementationAddress?: Address;\n    deploy(): Promise<DeployResult>;\n  }>;\n  fetchIfDifferent( // return true if new compiled code is different than deployed contract\n    name: string,\n    options: DeployOptions\n  ): Promise<{differences: boolean; address?: string}>;\n  save(name: string, deployment: DeploymentSubmission): Promise<void>; // low level save of deployment\n  get(name: string): Promise<Deployment>; // fetch a deployment by name, throw if not existing\n  getOrNull(name: string): Promise<Deployment | null>; // fetch deployment by name, return null if not existing\n  getDeploymentsFromAddress(address: string): Promise<Deployment[]>;\n  all(): Promise<{[name: string]: Deployment}>; // return all deployments\n  getArtifact(name: string): Promise<Artifact>; // return a hardhat artifact (compiled contract without deployment)\n  getExtendedArtifact(name: string): Promise<ExtendedArtifact>; // return a extended artifact (with more info) (compiled contract without deployment)\n  run( // execute deployment scripts\n    tags?: string | string[],\n    options?: {\n      resetMemory?: boolean;\n      deletePreviousDeployments?: boolean;\n      writeDeploymentsToFiles?: boolean;\n      export?: string;\n      exportAll?: string;\n    }\n  ): Promise<{[name: string]: Deployment}>;\n  fixture( // execute deployment as fixture for test // use evm_snapshot to revert back\n    tags?: string | string[],\n    options?: {fallbackToGlobal?: boolean; keepExistingDeployments?: boolean}\n  ): Promise<{[name: string]: Deployment}>;\n  createFixture<T, O>( // execute a function as fixture using evm_snaphost to revert back each time\n    func: FixtureFunc<T, O>,\n    id?: string\n  ): (options?: O) => Promise<T>;\n  log(...args: any[]): void; // log data only ig log enabled (disabled in test fixture)\n\n  execute( // execute function call on contract\n    name: string,\n    options: TxOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<Receipt>;\n  rawTx(tx: SimpleTx): Promise<Receipt>; // execute a simple transaction\n  catchUnknownSigner( // you can wrap other function with this function and it will catch failure due to missing signer with the details of the tx to be executed\n    action: Promise<any> | (() => Promise<any>),\n    options?: {log?: boolean}\n  ): Promise<null | {\n    from: string;\n    to?: string;\n    value?: string;\n    data?: string;\n  }>;\n  read( // make a read-only call to a contract\n    name: string,\n    options: CallOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<any>;\n  read(name: string, methodName: string, ...args: any[]): Promise<any>;\n  // rawCall(to: Address, data: string): Promise<any>; // TODO ?\n}\n```\n\n---\n\n#### `deployments.deploy(<name>, options)`\n\n---\n\nThe `deploy` function, as mentioned above, allows you to deploy a contract and save it under a specific name.\n\nThe deploy function expect 2 parameters: one for the name and one for the options\n\nSee below the full list of fields that the option parameter allows and requires:\n\n```ts\nexport interface DeployOptions = {\n  from: string; // address (or private key) that will perform the transaction. you can use `getNamedAccounts` to retrived the address you want by name.\n  contract?: // this is an optional field. If not specified it defaults to the contract with the same name as the first parameter\n    | string // this field can be either a string for the name of the contract\n    | { // or abi and bytecode\n        abi: ABI;\n        bytecode: string;\n        deployedBytecode?: string;\n      };\n  args?: any[]; // the list of argument for the constructor (or the upgrade function in case of proxy)\n  skipIfAlreadyDeployed?: boolean; // if set it to true, will not attempt to deploy even if the contract deployed under the same name is different\n  log?: boolean; // if true, it will log the result of the deployment (tx hash, address and gas used)\n  linkedData?: any; // This allow to associate any JSON data to the deployment. Useful for merkle tree data for example\n  libraries?: { [libraryName: string]: Address }; // This let you associate libraries to the deployed contract\n  proxy?: boolean | string | ProxyOptions; // This options allow to consider your contract as a proxy (see below for more details)\n\n  // here some common tx options :\n  gasLimit?: string | number | BigNumber;\n  gasPrice?: string | BigNumber;\n  value?: string | BigNumber;\n  nonce?: string | number | BigNumber;\n\n  estimatedGasLimit?: string | number | BigNumber; // to speed up the estimation, it is possible to provide an upper gasLimit\n  estimateGasExtra?: string | number | BigNumber; // this option allow you to add a gas buffer on top of the estimation\n\n  autoMine?: boolean; // this force a evm_mine to be executed. this is useful to speed deployment on test network that allow to specify a block delay (ganache for example). This option basically skip the delay by force mining.\n  deterministicDeployment? boolean | string; // if true, it will deploy the contract at a deterministic address based on bytecode and constructor arguments. The address will be the same across all network. It use create2 opcode for that, if it is a string, the string will be used as the salt.\n  waitConfirmations?: number; // number of the confirmations to wait after the transactions is included in the chain\n};\n```\n\n---\n\n---\n\n## Handling contract using libraries\n\nIn the deploy function, one of the `DeployOptions` field is the `libraries` field. It allows you to associate external contract as libraries at the time of deployment.\n\nFirst, you have deploy the library using the `deploy` function, then when we deploy a contract that needs the linked library, we can pass the deployed library name and address in as an argument to the `libraries` object.\n\nFirst step: deploy the library:\n\n```js\nconst exampleLibrary = await deploy(\"ExampleLibary\", {\n    from: <deployer>\n});\n\n```\n\nExampleLibrary is now deployed to whatever network was chosen (`hardhat deploy --network <networkName>`)\n\nFor example, if we are deploying on Rinkeby, this library will get deployed on rinkeby, and the `exampleLibrary` variable will be a deployment object that contains the abi as well as the deployed address for the contract.\n\nNow that the library is deployed, we can link it in our next deployed contract.\n\n```js\nconst example = await deploy(\"Example\", {\n    from: <deployer>\n    args: [\"example string argument for the 'Example' contract constructor\"],\n    libraries: {\n        ExampleLibrary: exampleLibrary.address\n    }\n});\n\n```\n\nThis `libraries` object takes the name of the library, and its deployed address on the network. Multiple libraries can be passed into the `libraries` object.\n\n---\n\n---\n\n## Exporting Deployments\n\nApart from deployments saved in the `deployments` folder which contains all information available about the contract (compile time data + deployment data), `hardhat-deploy` allows you to export lightweight files.\n\nThese can be used for example to power your frontend with contract's address and abi.\n\nThis come into 2 flavors.\n\nThe first one is exported via the `--export <file>` option and follow the following format :\n\n```ts\nexport interface Export {\n  chainId: string;\n  name: string;\n  contracts: {[name: string]: ContractExport};\n}\n```\n\nwhere name is the name of the network configuration chosen (see hardhat option `--network`)\n\nThe second one is exported via the `--export-all <file>` option and follow the following format :\n\n```ts\nexport type MultiExport = {\n  [chainId: string]: Export[];\n};\n```\n\nAs you see the second format include the previous. While in most case you'll need the single export where your application will support only one network, there are case where your app would want to support multiple networks at nonce. This second format allow for that.\n\nFurthermore as hardhat support multiple network configuration for the same network (rinkeby, mainnet...), the export-all format will contains each of them grouped by their chainId.\n\n\nNote: from v0.10.4 the old multi-export down is no more:\n\n```\nexport type MultiExport = {\n  [chainId: string]: {[name: string]: Export};\n};\n```\n\n---\n\n---\n\n## Deploying and Upgrading Proxies\n\nAs mentioned above, the deploy function can also deploy a contract through a proxy. It can be done without modification of the contract as long as its number of constructor arguments matches the proxy initialization/update function.\n\nThe default Proxy is both ERC-1967 and ERC-173 Compliant, but other proxy can be specified, like openzeppelin transparent proxies.\n\nCode for the default Proxy can be found [here](solc_0.7/proxy/EIP173Proxy.sol).\n\nTo perform such proxy deployment, you just need to invoke the deploy function with the following options : `{..., proxy: true}`\n\nSee example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: true,\n  });\n};\n```\n\nYou can also set it to `proxy: \"<upgradeMethodName>\"` in which case the function `<upgradeMethodName>` will be executed upon upgrade.\nthe `args` field will be then used for that function instead of the contructor. It is also possible to then have a constructor with the same arguments and have the proxy be disabled. It can be useful if you want to have your contract as upgradeable in a test network but be non-upgradeable on the mainnet.\n\nSee example :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  network,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: network.live ? false : 'postUpgrade',\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nThe proxy option can also be an object which can set the specific owner that the proxy is going to be managed by.\n\nSee example:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: {\n      owner: greeterOwner,\n      methodName: 'postUpgrade',\n    },\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nNote that for the second invokation, this deployment will not be executed from the specified `from: deployer` as otherwise these tx will always fails. It will instead be automatically executed from the proxy's current owner (in that case : `greeterOwner`)\n\nNow, it is likely you do not want to locally handle the private key / mnemonic of the account that manage the proxy or it could even be that the `greeterOwner` in question is a multi sig. As such that second invocation will throw an error as it cannot find a local signer for it.\n\nThe error will output the necessary information to upgrade the contract but `hardhat-deploy` comes also with a utility function for such case: `deployments.catchUnknwonSigner` which will catch the error and output to the console the necessary information while continuing to next step.\n\nHere is the full example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy, catchUnknownSigner} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await catchUnknownSigner(\n    deploy('Greeter', {\n      from: deployer,\n      proxy: {\n        owner: greeterOwner,\n        methodName: 'postUpgrade',\n      },\n      args: ['arg1', 2, 3],\n    })\n  );\n  // you could pause the deployment here and wait for input to continue\n};\n```\n\nThe full proxy options is as follow:\n\n```ts\ntype ProxyOptionsBase = {\n  owner?: Address; // this set the owner of the proxy. further upgrade will need to be executed from that owner\n  upgradeIndex?: number; // allow you to breakdown your upgrades into separate deploy scriot, each with their own index. A deploy call with a specific upgradeIndex will be executed only once, only if the current upgradeIndex is one less.\n  proxyContract?: // default to \"EIP173Proxy\". See below for more details\n  string | ArtifactData;\n  viaAdminContract?: // allow to specify a contract that act as a middle man to perform upgrades. Useful and Recommended for Transparent Proxies\n  | string\n    | {\n        name: string;\n        artifact?: string | ArtifactData;\n      };\n};\n\nexport type ProxyOptions =\n  | (ProxyOptionsBase & {\n      methodName?: string; // method to be executed when the proxy is deployed for the first time or when the implementation is modified. Use the deployOptions args field for arguments\n    })\n  | (ProxyOptionsBase & {\n      execute?:\n        | {\n            methodName: string; // method to be executed when the proxy is deployed for the first time or when the implementation is modified.\n            args: any[];\n          }\n        | {\n            init: {\n              methodName: string; // method to be executed when the proxy is deployed\n              args: any[];\n            };\n            onUpgrade?: {\n              methodName: string; // method to be executed when the proxy is upgraded (not first deployment)\n              args: any[];\n            };\n          };\n    });\n```\n\nThe `proxyContract` field allow you to specify your own Proxy contract. If it is a string, it will first attempt to get an artifact with that name. If not found it will fallback on the following if\n\nit matches:\n\n- `EIP173Proxy`: use the default Proxy that is EIP-173 compliant\n\n- `EIP173ProxyWithReceive`: Same as above except that the proxy contains a receive hook to accept empty ETH payment.\n\n- `OpenZeppelinTransparentProxy`: Use Openzeppelin Transparent Proxy (copied from openzeppelin repo, see code [here](solc_0.7/openzeppelin/proxy/TransparentUpgradeableProxy.sol))\n  When this option is chosen, the `DefaultProxyAdmin` is also used as admin since Transparent Proxy kind of need an intermediarry contract for administration. This can be configured via the `viaAdminContract` option. Note that the DefaultProxyAdmin is slightly different than the one used by openzeppelin as it allow you to set a different owner than msg.sender on first deploy, something openzeppelin version do not allow, see : https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2639\n\n- `OptimizedTransparentProxy`: This contract is similar to above, except that it is optimized to not require storage read for the admin on every call.\n\n## Builtin-In Support For Diamonds (EIP2535)\n\nThe deployments field also expose the diamond field: `hre.deployments.diamond` that let you deploy [Diamonds](https://eips.ethereum.org/EIPS/eip-2535) in an easy way.\n\nInstead of specifying the facets to cut out or cut in, which the diamond contract expects, you specify the facets you want to end up having on the deployed contract.\n\n`diamond.deploy` expect the facet as names. The names represent contract to be deployed as facet. In future version you ll be able to specify deployed contract or artifact object as facet.\n\nTo deploy a contract with 3 facet you can do as follow :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: deployer,\n    owner: diamondAdmin,\n    facets: ['Facet1', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nif you then later execute the following script:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: diamondAdmin, // this need to be the diamondAdmin for upgrade\n    owner: diamondAdmin,\n    facets: ['NewFacet', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nThen the NewFacet will be deployed automatically if needed and then the diamondCut will cut Facet1 out and add NewFacet.\n\nNote that if the code for Facet2 and Facet3 changes, they will also be redeployed automatically and the diamondCuts will replace the existing facets with these new ones.\n\nNote that The Diamond contract's code is part of `hardhat-deploy` and contains 3 built-in facet that can be removed manually if desired.\nThese facets are used for ownership, diamondCut and diamond loupe.\n\nThe implementation is the [reference implementation by Nick Mudge](https://github.com/mudgen/diamond-3)\n\nLike normal proxies you can also execute a function at the time of an upgrade.\n\nThis is done by specifying the execute field in the diamond deploy options :\n\n```js\ndiamond.deploy('ADiamondContract', {\n  from: deployer,\n  owner: diamondAdmin,\n  facets: ['NewFacet', 'Facet2', 'Facet3'],\n  execute: {\n    methodName: 'postUpgrade',\n    args: ['one', 2, '0x3'],\n  },\n});\n```\n\nSince the diamond standard has no builtin mechanism to make the deployment of Diamond with function execution, the Diamond when deployed is actually deployed through a special contract, the `Diamantaire` (see code [here](solc_0.7/diamond/Diamantaire.sol)) that act as factory to build Diamond. It uses deterministic deployment for that so, it is transparently managed by `hardhat-deploy`. It also embed the implementation of the builtin facet, removing the need to have different instances of each live.\n\n<!-- The Diamantaire also support the deterministic deployment of Diamonds.\nAn extra field can be passed to the Diamond deployment options : `deterministicSalt`. It has to be a non-zero 32bytes string (in hex format).\nNote that if you want to deploy 2 diamonds with same owner, you'll need 2 different deterministicSalt for them to be 2 separate contracts. -->\n\n## Testing Deployed Contracts\n\nYou can continue using the usual test task:\n\n`hardhat test`\n\nTests can use the `hre.deployments.fixture` function to run the deployment and snapshot it so that tests don't need to perform all the deployment transactions every time. They can simply reuse the snapshot for every test (this leverages `evm_snapshot` and `evm_revert` provided by both `hardhat` and `ganache`). You can for example set them in a `beforeEach`.\n\nHere is an example of a test :\n\n```js\nconst {deployments} = require('hardhat');\n\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    await deployments.fixture(['Token']);\n    const Token = await deployments.get('Token'); // Token is available because the fixture was executed\n    console.log(Token.address);\n    const ERC721BidSale = await deployments.get('ERC721BidSale');\n    console.log({ERC721BidSale});\n  });\n});\n```\n\nTests can also leverage named accounts for clearer test. Combined with `hardhat-deploy-ethers` plugin, you can write succint test :\n\n```js\nconst {ethers, getNamedAccounts} = require('hardhat');\n\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    await deployments.fixture(['Token']);\n    const {tokenOwner} = await getNamedAccounts();\n    const TokenContract = await ethers.getContract('Token', tokenOwner);\n    await TokenContract.mint(2).then((tx) => tx.wait());\n  });\n});\n```\n\n---\n\n### Creating Fixtures\n\nFurthermore, tests can easily create efficient fixture using `deployments.createFixture`\n\nSee example :\n\n```js\nconst setupTest = deployments.createFixture(\n  async ({deployments, getNamedAccounts, ethers}, options) => {\n    await deployments.fixture(); // ensure you start from a fresh deployments\n    const {tokenOwner} = await getNamedAccounts();\n    const TokenContract = await ethers.getContract('Token', tokenOwner);\n    await TokenContract.mint(10).then((tx) => tx.wait()); //this mint is executed once and then `createFixture` will ensure it is snapshotted\n    return {\n      tokenOwner: {\n        address: tokenOwner,\n        TokenContract,\n      },\n    };\n  }\n);\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    const {tokenOwner} = await setupTest();\n    await tokenOwner.TokenContract.mint(2);\n  });\n});\n```\n\nWhile this example is trivial, some fixture can requires several transaction and the ability to snapshot them automatically speed up the tests greatly.\n\n---\n\n---\n\n## More Information On Hardhat Tasks\n\n---\n\n### **1. node task**\n\nas mentioned above, the node task is slighly modified and augmented with various flags and options\n\n`hardhat node`\n\nIn particular it adds an argument `--export` that allows you to specify a destination file where the info about the contracts deployed is written.\nYour webapp can then access all contracts information.\n\n---\n\n### **2. test task**\n\n`hardhat test`\n\nthe test task is augmented with one flag argument `--deploy-fixture` that allows to run all deployments in a fixture snapshot before executing the tests. This can speed up the tests that use specific tags as the global fixture take precedence (unless specified).\n\nIn other word tests can use `deployments.fixture(<specific tag>)` where specific tag only deploys the minimal contracts for tests, while still benefiting from global deployment snapshot if used.\n\nIf a test needs the deployments to only include the specific deployment specified by the tag, it can use the following :\n\n```js\ndeployments.fixture('<specific tag>', {fallbackToGlobal: false});\n```\n\nDue to how snapshot/revert works in hardhat, this means that these tests will not benefit from the global fixture snapshot and will have to deploy their contracts as part of the fixture call. This is automatic but means that these tests will run slower.\n\n---\n\n### **3. run task**\n\n`hardhat --network <networkName> run <script>`\n\nThe run task act as before but thanks to the `hre.deployments` field it can access deployed contract :\n\n```js\nconst hre = require('hardhat');\nconst {deployments, getNamedAccounts} = hre;\n\n(async () => {\n  console.log(await deployments.all());\n  console.log({namedAccounts: await getNamedAccounts()});\n})();\n```\n\nYou can also run it directly from the command line as usual.\n\n`HARDHAT_NETWORK=rinkeby node <script>` is the equivalent except it does not load the hardhat environment twice (which the run task does)\n\n---\n\n### **4. console task**\n\n`hardhat console`\n\nThe same applies to the `console` task.\n\n---\n\n## Deploy Scripts: Tags And Dependencies\n\n---\n\nIt is possible to execute only specific parts of the deployments with `hardhat deploy --tags <tags>`\n\nTags represent what the deploy script acts on. In general it will be a single string value, the name of the contract it deploys or modifies.\n\nThen if another deploy script has such tag as a dependency, then when this latter deploy script has a specific tag and that tag is requested, the dependency will be executed first.\n\nHere is an example of two deploy scripts :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const deployResult = await deploy('Token', {\n    from: deployer,\n    args: ['hello', 100],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Token deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Token'];\n```\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const Token = await deployments.get('Token');\n  const deployResult = await deploy('Sale', {\n    from: deployer,\n    contract: 'ERC721BidSale',\n    args: [Token.address, 1, 3600],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Sale deployed at ${deployResult.contract.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.dependencies = ['Token']; // this ensure the Token script above is executed first, so `deployments.get('Token')` succeeds\n```\n\nAs you can see the second one depends on the first. This is because the second script depends on a tag that the first script registers as using.\n\nWith that when `hardhat deploy --tags Sale` is executed\n\nthen both scripts will be run, ensuring Sale is ready.\n\nYou can also define the script to run after another script is run by setting `runAtTheEnd` to be true. For example:\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, execute, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer, admin} = namedAccounts;\n  await execute('Sale', {from: deployer}, 'setAdmin', admin);\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.runAtTheEnd = true;\n```\n\nTags can also be used in test with `deployments.fixture`. This allow you to test a subset of the deploy script.\n","readmeFilename":"README.md","gitHead":"3820c44def2d904b827ad68275315bcfa6fc9945","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.10.5-zksync.0","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-eqeETxJRg1A4z2p4yz02B4x2iuqKeTVhZ4QB36FTlqmI7CrByBnLBcHTime3RnXbll4lSts14I7zOrTssiEJaA==","shasum":"c17612db60c31e73c2907f6c6e73a4973a28c032","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.10.5-zksync.0.tgz","fileCount":121,"unpackedSize":7476647,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCa3FWBTJhKZf4VQI//eeW7Sl0CGzn/YoZIZ0RrvZhH4AIgdrSHKiurLj9HnwDiR9HVCioFKWyZ5dCEU2VP9Kuk7Rw="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJicPv6ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqIRg/9FdlG+TC15LL2GfhG/up4K2Vpk1mALOmlZHoTzOu3eQJchYi9\r\nAVCX3s9gv0olY6oTnUL1HiP8zAQH5PVA5LU9Hg8c5k5qod/G0WpGqKSivZcp\r\nSrUQuWaiX+rpsicLw/38ZC1DjHmfx6iv9W4fxDeP2j0sSo0mCKoj34F6XEKw\r\nr41x3sgqr+YjPa1/UPL3ioL8YkRokI30NkBR3kUGSn1dnyYKK6Ls4NMcNJK7\r\nInBICntNMCN5l4RECvxL/yDRjLW4p7l3TOXYnHQJjRp1n4brHMWJxGObiO6U\r\nKgauO2w3+la3flPKP2Xd1eodyLded+9ZqALz5hxosxIPXIzrSP04OBug7tM6\r\nbAOUB280CjbfSJieR9bHxnEvxe2FBtfqZTo2Ga2nuUwE3k7lLc2ZZHbl7+uN\r\nnbP8OkbBguPlaJOxtoGqj23OZR+8gXGXU1f0OXuFfIly+st2LcHqJNQQ/4i8\r\nV1JOsI2klmEdPFCktVX37RZ7cHXVmo3sP6/uWLALOq2DTqWdxxAU/55Pysd2\r\n0/GBG2Ezz5tibtS5fm7CUFMHeBc34VPDAPBqMaqgfiswMiAKpif2rFY/z98/\r\n+QXBnsxjk6i9nC+VDkHhuB++EhDgvcpb/Osdv5G/wCHXjdYc1wwDRMMzC3YX\r\nojZoBzTY9Gud0E1LKsVJO2hDwL4zMG6WQIo=\r\n=Xv+z\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.10.5-zksync.0_1651571706377_0.6092979534271505"},"_hasShrinkwrap":false},"0.11.5-zksync.0":{"name":"hardhat-deploy","version":"0.11.5-zksync.0","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.9.0","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"dependencies":{"@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","ethers":"^5.5.3","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","zksync-web3":"^0.4.0"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"readme":"<h1> hardhat-deploy</h1>\n\n_A [Hardhat](https://hardhat.org) Plugin For Replicable Deployments And Easy Testing_\n\n> **A complete dev template using hardhat-deploy is available here** : https://github.com/wighawag/template-ethereum-contracts\n> It also contains various branches examplifying the capability of hardhat-deploy. Check it out.\n\n- [What is it for ?](#what-is-it-for-)\n- [hardhat-deploy in a nutshell](#hardhat-deploy-in-a-nutshell)\n- [Installation](#installation)\n  - [npm install hardhat-deploy](#npm-install-hardhat-deploy)\n  - [TypeScript support](#typescript-support)\n  - [Migrating existing deployment to hardhat-deploy](#migrating-existing-deployment-to-hardhat-deploy)\n- [Hardhat Tasks Available/Updated](#hardhat-tasks-availableupdated)\n  - [1. hardhat deploy](#1-hardhat-deploy)\n    - [**Options**](#options)\n    - [**Flags**](#flags)\n  - [2. hardhat node](#2-hardhat-node)\n    - [**Options**](#options-1)\n    - [**Flags**](#flags-1)\n  - [3. hardhat test](#3-hardhat-test)\n  - [4. hardhat etherscan-verify](#4-hardhat-etherscan-verify)\n    - [**Options**](#options-2)\n  - [5. hardhat sourcify](#5-hardhat-sourcify)\n    - [**Options**](#options-3)\n  - [6. hardhat export](#6-hardhat-export)\n    - [**Options**](#options-4)\n- [Hardhat Environment Extensions](#hardhat-environment-extensions)\n- [Configuration](#configuration)\n  - [**1. namedAccounts (ability to name addresses)**](#1-namedaccounts-ability-to-name-addresses)\n  - [**2. extra hardhat.config networks' options**](#2-extra-hardhatconfig-networks-options)\n    - [`live`](#live)\n    - [`saveDeployments`](#savedeployments)\n    - [`tags`](#tags)\n    - [`deploy`](#deploy)\n    - [`companionNetworks`](#companionnetworks)\n  - [**3. extra hardhat.config paths' options**](#3-extra-hardhatconfig-paths-options)\n  - [**4. deterministicDeployment (ability to specify a deployment factory)**](#4-deterministicdeployment-ability-to-specify-a-deployment-factory)\n  - [Importing deployment from other projects (with truffle support)](#importing-deployment-from-other-projects-with-truffle-support)\n  - [Access to Artifacts (non-deployed contract code and abi)](#access-to-artifacts-non-deployed-contract-code-and-abi)\n- [How to Deploy Contracts](#how-to-deploy-contracts)\n  - [The `deploy` Task](#the-deploy-task)\n  - [Deploy Scripts](#deploy-scripts)\n    - [An example of a deploy script :](#an-example-of-a-deploy-script-)\n  - [The `deployments` field](#the-deployments-field)\n    - [`deployments.deploy(<name>, options)`](#deploymentsdeployname-options)\n- [Handling contract using libraries](#handling-contract-using-libraries)\n- [Exporting Deployments](#exporting-deployments)\n- [Deploying and Upgrading Proxies](#deploying-and-upgrading-proxies)\n- [Builtin-In Support For Diamonds (EIP2535)](#builtin-in-support-for-diamonds-eip2535)\n  - [deployment / upgrade](#deployment--upgrade)\n  - [onUpgrade calls](#onupgrade-calls)\n  - [more...](#more)\n- [Testing Deployed Contracts](#testing-deployed-contracts)\n  - [Creating Fixtures](#creating-fixtures)\n- [More Information On Hardhat Tasks](#more-information-on-hardhat-tasks)\n  - [**1. node task**](#1-node-task)\n  - [**2. test task**](#2-test-task)\n  - [**3. run task**](#3-run-task)\n  - [**4. console task**](#4-console-task)\n- [Deploy Scripts: Tags And Dependencies](#deploy-scripts-tags-and-dependencies)\n\n## What is it for ?\n\nThis [hardhat](https://hardhat.org) plugin adds a mechanism to deploy contracts to any network, keeping track of them and replicating the same environment for testing.\n\nIt also adds a mechanism to associate names to addresses, so test and deployment scripts can be reconfigured by simply changing the address a name points to, allowing different configurations per network. This also results in much clearer tests and deployment scripts (no more `accounts[0]` in your code).\n\nThis plugin contains a lot more features too, all geared toward a better developer experience :\n\n- chain configuration export\n- listing deployed contracts' addresses and their abis (useful for webapps)\n- library linking at time of deployment.\n- deterministic deployment across networks.\n- support for specific deploy script per network (L1 vs L2 for example)\n- ability to access deployment from \"companion\" networks\n- deployment dependency system (allowing you to only deploy what is needed).\n- deployment retrying (by saving pending tx): so you can feel confident when making a deployment that you can always recover.\n- deployments as test fixture using `evm_snapshot` to speed up testing.\n- ability to create your own test fixture that automatically benefits from `evm_snapshot`'s tests speed-up boost\n- combined with [hardhat-deploy-ethers](https://github.com/wighawag/hardhat-deploy-ethers) it has the ability to get ethers contract instance by name (like `await ethers.getContract(\"ContractName\")`).\n- importing artifact from external sources (like npm packages), including [truffle](https://www.trufflesuite.com/truffle) support.\n- importing deployments from external sources (like npm packages)\n- ability to log information in `deploy` mode only (while in test the console remains clean).\n- contains helpers to read and execute transaction on deployed contract referring to them by name.\n- These helpers contains options to auto mine on dev network (to speed up test deployments).\n- save metadata of deployed contract so they can always be fully verified, via [sourcify](https://sourcify.dev) or [etherscan](https://etherscan.io).\n- ability to submit contract source to etherscan and sourcify for verification at any time. (Because **hardhat-deploy** will save all the necessary info, it can be executed at any time.)\n- support harhdat's fork feature so deployment can be accessed even when run through fork.\n- named accounts are automatically impersonnated too, so you can perform tx as if you had their private key.\n- proxy deployment with ability to upgrade them transparently, only if code changes.\n- this include support for [openzeppelin](https://openzeppelin.com) transparent proxies\n- diamond deployment with facets, allowing you to focus on what the new version will be. It will generate the diamondCut necessary to reach the new state.\n- watch and deploy: **hardhat-deploy** can watch both your deploy script and contract code and redeploy on changes.\n- HCR (Hot Contract Replacement): the watch feature combined with proxy or diamond, gives you an experience akin to frontend Hot Module Replacement: once your contract changes, the deployment is executed and your contract retains the same address and same state, allowing you to tweak your contracts while debugging your front-end.\n\n## hardhat-deploy in a nutshell\n\nBefore going into the details, here is a very simple summary of the basic feature of **hardhat-deploy**.\n\n**hardhat-deploy** allows you to write [`deploy scripts`](#deploy-scripts) in the `deploy` folder. Each of these files that look as follows will be executed in turn when you execute the following task: `hardhat --network <networkName> deploy`\n\n```js\n// deploy/00_deploy_my_contract.js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('MyContract', {\n    from: deployer,\n    args: ['Hello'],\n    log: true,\n  });\n};\nmodule.exports.tags = ['MyContract'];\n```\n\nFurthermore you can also ensure these scripts are executed in test too by calling `await deployments.fixture(['MyContract'])` in your test.\nThis is optimized, so if multiple tests use the same contract, the deployment will be executed once and each test will start with the exact same state.\n\nThis is a huge benefit for testing since you are not required to replicate the deployment procedure in your tests. The tag feature (as seen in the script above) and [dependencies](#deploy-scripts-tags-and-dependencies) will also make your life easier when writing complex deployment procedures.\n\nYou can even group deploy scripts in different sub folder and ensure they are executed in their logical order.\n\nFurthermore hardhat-deploy can also support a multi-chain settings like L1, L2 with multiple deploy folder specific to each network.\n\n**All of this can also be bundled in a npm package so user of hardhat-deploy can reuse your deployment procedure and get started integrating with your project locally.**\n\nThere is a tutorial covering the basics here : https://github.com/wighawag/tutorial-hardhat-deploy\n\n## Installation\n\n### npm install hardhat-deploy\n\n```bash\nnpm install -D hardhat-deploy\n```\n\nAnd add the following statement to your `hardhat.config.js`:\n\n```js\nrequire('hardhat-deploy');\n```\n\nif you use `ethers.js` we recommend you also install `hardhat-deploy-ethers` which add extra features to access deployments as ethers contract.\n\nSince `hardhat-deploy-ethers` is a fork of `@nomiclabs/hardhat-ethers` and that other plugin might have an hardcoded dependency on `@nomiclabs/hardhat-ethers` the best way to install `hardhat-deploy-ethers` and ensure compatibility is the following:\n\n```bash\nnpm install --save-dev  @nomiclabs/hardhat-ethers@npm:hardhat-deploy-ethers ethers\n```\n\nWhich means you then need to do `require(\"@nomiclabs/hardhat-ethers\")` instead of `require(\"hardhat-deploy-ethers\")` in your `hardhat.config.js` file.\n\nMore details on `hardhat-deploy-ethers` repo : https://github.com/wighawag/hardhat-deploy-ethers#readme\n\n### TypeScript support\n\nWith hardhat the tsconfig.json is optional.\n\nBut if you add folders to the `include` field in `tsconfig.json`, you ll also need to include `hardhat.config.ts` like :\n\n`include\": [\"./hardhat.config.ts\", \"./scripts\", \"./deploy\", \"./test\"]`\n\nfor deploy script (see below) you can write them this way to benefit from typing :\n\n```ts\nimport {HardhatRuntimeEnvironment} from 'hardhat/types';\nimport {DeployFunction} from 'hardhat-deploy/types';\n\nconst func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {\n  // code here\n};\nexport default func;\n```\n\nSee a template that uses **hardhat-deploy** here : https://github.com/wighawag/template-ethereum-contracts\n\nThis repo has also some examples branch that exemplify specific features, like the forking testing here : https://github.com/wighawag/template-ethereum-contracts/tree/examples/fork-test\n\n### Migrating existing deployment to hardhat-deploy\n\n> Only needed for existing project that already deployed contracts and has the deployment information available **(at minimum, address and abi)**\n\nYou might want to switch your current deployment process to use **hardhat-deploy**. In that case you probably have some deployments saved elsewhere.\n\nIn order to port them to **hardhat-deploy**, you'll need to create one `.json` file per contract in the `deployments/<network>` folder (configurable via [paths config](#extra-paths-config)).\n\nThe network folder is simply the hardhat network name (as configured in hardhat.config.js) (accessible at runtime via `hre.network.name`).\nSuch folder need to have a file named `.chainId` containing the chainId as decimal.\n\nFor example for network named \"rinkeby\" (for the corresponding network) the file `deployments/rinkeby/.chainId` would be\n\n```\n4\n```\n\nNote, prior to hardhat 0.6 the chainId was appended to the folder name (expect for some known network name). This has changed and upgrading to 0.6 will require you to change the folder name and add the '.chainId' file.\n\nEach contract file must follow this type (as defined in [types.ts](types.ts)) :\n\n```ts\nexport interface Deployment {\n  address: Address;\n  abi: ABI;\n  receipt?: Receipt;\n  transactionHash?: string;\n  history?: Deployment[];\n  numDeployments?: number;\n  implementation?: string;\n  args?: any[];\n  linkedData?: any;\n  solcInputHash?: string;\n  metadata?: string;\n  bytecode?: string;\n  deployedBytecode?: string;\n  libraries?: Libraries;\n  userdoc?: any;\n  devdoc?: any;\n  methodIdentifiers?: any;\n  diamondCut?: FacetCut[];\n  facets?: Facet[];\n  storageLayout?: any;\n  gasEstimates?: any;\n}\n```\n\nAs you can see, only abi and address are mandatory. But having the other fields allow more feature. For example, metadata and args allow you to benefit from contract code verification.\n\nFor Receipt, the following type is expected:\n\n```ts\nexport type Receipt = {\n  from: string;\n  transactionHash: string;\n  blockHash: string;\n  blockNumber: number;\n  transactionIndex: number;\n  cumulativeGasUsed: string;\n  gasUsed: string;\n  contractAddress?: string;\n  to?: string;\n  logs?: Log[];\n  events?: any[];\n  logsBloom?: string;\n  byzantium?: boolean;\n  status?: number;\n  confirmations?: number;\n};\n```\n\nHere is an example:\n\nLet's say you have:\n\n- 2 Contract named Greeter and Registry deployed on rinkeby\n- 1 contract named Greeter on mainnet\n- 2 Contract named Greeter and Registry deployed on a network named rinkeby2\n\nYou would get the following folder structure:\n\n```\ndeployments/\n  mainnet/\n    .chainId\n    Greeter.json\n  rinkeby/\n    .chainId\n    Greeter.json\n    Registry.json\n  rinkeby2/\n    .chainId\n    Greeter.json\n    Registry.json\n```\n\nThe reason why **hardhat-deploy** save chainId in the `.chainId` file is both for\n\n- safety: so that if you were to change the network name to point to a different chain, it would not attempt to read the wrong folder and assume that a contract has been deployed while it has not.\n- ability to know the chainId without requring to be connected to a node (and so not dependent on hardhat.config.js settings). Useful for `export` task.\n\n---\n\n## Hardhat Tasks Available/Updated\n\nhardhat deploy add several task to hardhat. It also modify existing one, adding new options and new behavior. All of these are described here:\n\n---\n\n### 1. hardhat deploy\n\n---\n\nThis plugin adds the _deploy_ task to Hardhat.\n\nThis task will execute the scripts in the `deploy` folder and save the contract deployments to disk. These deployments are supposed to be saved for example in a git repository. This way they can be accessed later. But you are free to save them elsewhere and get them back via your mechanism of choice.\n\nWith the deployment saved, it allows you to deploy a contract only if changes were made.\n\nDeploy scripts (also called Deploy functions) can also perform aribtrary logic.\n\nFor further details on how to use it and write deploy script, see [section](#deploy-scripts) below.\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployments, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice (in wei) to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--reset`: This flag resets the deployments from scratch. Previously deployed contract are not considered and deleted from disk.\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n---\n\n### 2. hardhat node\n\n---\n\nThis plugin modify the _node_ task so that it also execute the deployment script before exposing the server http RPC interface\n\nIt add similar options than the `deploy` task :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--no-reset`: This flag prevent the reseting of the existing deployments. This is usually not desired when running the `node` task as a network is created from scratch and previous deployemnt are irrelevant.\n\n`--show-accounts`: this flag will output the account private keys\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n`--no-deploy` that discard all other options to revert to normal `hardhat node` behavior without any deployment being performed.\n\n> :warning: Note that the deployments are saved as if the network name is `localhost`. This is because `hardhat node` is expected to be used as localhost: You can for example execute `hardhat --network localhost console` after `node` is running. Doing `hardhat --network hardhat console` would indeed not do anything useful. It still take the configuration from `hardhat` in the hardhat.config.js file though.\n\n---\n\n### 3. hardhat test\n\n---\n\nThis plugin adds a flag argument `--deploy-fixture` to the _test_ task which if enabled will run the global deployments fixture before the tests and snapshots it. This will generaly speed up the tests as further test will be able to revert back to the full deployment.\n\n> :warning: Note though that if your test behave differently whether that option is on or not, this most likely mean that your deploy scripts' tags and dependencies are not configured correctly. This is because the global fixture will ensure all contract are deployed while test will usually (for efficiency) ask for a particular tag.\n\n---\n\n### 4. hardhat etherscan-verify\n\n---\n\nThis plugin adds the _etherscan-verify_ task to Hardhat.\n\nThis task will submit the contract source and other info of all deployed contracts to allow etherscan to verify and record the sources.\n\nInstead of using the full solc input, this task will first attempt to send the minimal sources from the metadata.\nBut Etherscan sometime fails due to a bug in solidity compiler (<https://github.com/ethereum/solidity/issues/9573>). As such this task can fallback on full solc input (see option --solc-input). Note that if your contract was deployed with a previous version of **hardhat-deploy**, it might not contains the full information. The issue seems to be fully resolved since solc version 0.8.\n\nThis task will also attempt to automatically find the SPDX license in the source.\n\nTo execute that task, you need to specifiy the network to run against :\n\n```bash\nhardhat --network mainnet etherscan-verify [--api-key <apikey>] [--apiurl <url>]\n```\n\n#### **Options**\n\nNote that harhdat-deploy now use a different config format to not conflict with `hardhat-etherscan`\n\n`--api-key <api key>`: let you specify your etherscan api key. Alternatively, you can provide it via the env variable `ETHERSCAN_API_KEY` or through the hardhat.config.ts verify field:\n\n```js\n{\n  ...\n  verify: {\n    etherscan: {\n      apiKey: '<API key>'\n    }\n  }\n}\n```\n\n`--api-url <url>`: let you specify your etherscan url to submit the source to. Can also be configured per network in `hardhat.config.js`:\n\n```js\n{\n  ...\n  networks: {\n    mynetwork: {\n      ...\n      verify: {\n        etherscan: {\n          apiUrl: 'http://mynetwork.xyz'\n        }\n      }\n    }\n  }\n}\n```\n\n`--license <SPDX license id>`: SPDX license (useful if SPDX is not listed in the sources), need to be supported by etherscan: https://etherscan.io/contract-license-types\n\n`--force-license`: if set, will force the use of the license specified by --license option, ignoring the one in the source (useful for license not supported by etherscan)\n\n`--solc-input`: fallback on solc-input id needed (useful when etherscan fails on the minimum sources, see https://github.com/ethereum/solidity/issues/9573)\n\n`--sleep`: sleep 500ms between each verification, so API rate limit is not exceeded\n\n---\n\n### 5. hardhat sourcify\n\n---\n\nThis plugin adds the _sourcify_ task to Hardhat.\n\nSimilar to `hardhat etherscan-verify` this task will submit the contract source and other info of all deployed contracts to sourcify.\n\n```bash\nhardhat --network mainnet sourcify\n```\n\nLater this task might instead pin the metadata to ipfs, so sourcify can automatically verify them.\n\n#### **Options**\n\n`--contract-name <contract name>`: specify the contract's name you want to verify\n  \n`--endpoint <endpoint>`: specify the sourcify endpoint, default to https://sourcify.dev/server/\n\n`--write-failing-metadata`: if set and the sourcify task fails to verify, the metadata file will be written to disk, so you can more easily figure out what has gone wrong.\n\n---\n\n### 6. hardhat export\n\n---\n\nThis plugin adds the _export_ task to Hardhat.\n\nThis task will export the contract deployed (saved in `deployments` folder) to a file with a simple format containing only contract addresses and abi, useful for web apps.\n\nOne of the following options need to be set for this task to have any effects :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\nThis last option has some limitations, when combined with the use of external deployments (see [Configuration](#configuration)). If such external deployments were using older version of **hardhat-deploy** or truffle, the chainId might be missing. In order for these to be exported, the hardhat network config need to explicity state the chainId in the `networks` config of `hardhat.config.js`.\n\nWith both `--export` and `--export-all`, using the special `<filepath>` value of `-` will output to `STDOUT` rather than writing a normal file.\n\n---\n\n---\n\n## Hardhat Environment Extensions\n\nThis plugin extends the Hardhat Runtime Environment by adding 4 fields:\n\n- `getNamedAccounts: () => Promise<{ [name: string]: string }>`: a function returning an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [Configuration](#configuration)).\n\n- `getUnnamedAccounts: () => Promise<string[]}>`: accounts which has no names, useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`: contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId(): Promise<string>`: offer an easy way to fetch the current chainId.\n\n---\n\n---\n\n## Configuration\n\n---\n\n### **1. namedAccounts (ability to name addresses)**\n\n---\n\nThis plugin extends the `HardhatConfig`'s object with an optional `namedAccounts` field.\n\n`namedAccounts` allows you to associate names to addresses and have them configured per chain.\nThis allows you to have meaningful names in your tests while the addresses match to multi sig in real network for example.\n\n```js\n{\n    namedAccounts: {\n        deployer: {\n            default: 0, // here this will by default take the first account as deployer\n            1: 0, // similarly on mainnet it will take the first account as deployer. Note though that depending on how hardhat network are configured, the account 0 on one network can be different than on another\n            4: '0xA296a3d5F026953e17F472B497eC29a5631FB51B', // but for rinkeby it will be a specific address\n            \"goerli\": '0x84b9514E013710b9dD0811c9Fe46b837a4A0d8E0', //it can also specify a specific netwotk name (specified in hardhat.config.js)\n        },\n        feeCollector:{\n            default: 1, // here this will by default take the second account as feeCollector (so in the test this will be a different account than the deployer)\n            1: '0xa5610E1f289DbDe94F3428A9df22E8B518f65751', // on the mainnet the feeCollector could be a multi sig\n            4: '0xa250ac77360d4e837a13628bC828a2aDf7BabfB3', // on rinkeby it could be another account\n        }\n    }\n}\n```\n\n<!-- You can also specify addresses with the `ledger://` prefix. In which case the account fetched will still be the corresponding address, but behind the scene, the transaction will be created via the hardware waller. Currently the feature is not working very well though and better support is needed. -->\n\n---\n\n### **2. extra hardhat.config networks' options**\n\n---\n\n**hardhat-deploy** add 5 new fields to `networks` configuration\n\n#### `live`\n\nthis is not used internally but is useful to perform action on a network whether it is a live network (rinkeby, mainnet, etc) or a temporary one (localhost, hardhat). The default is true (except for localhost and hardhat where the default is false).\n\n#### `saveDeployments`\n\nthis tell whether **hardhat-deploy** should save the deployments to disk or not. Default to true, except for the hardhat network.\n\n#### `tags`\n\nnetwork can have tags to represent them. The config is an array and at runtime the hre.network.tags is an object whose fields (the tags) are set to true.\n\nThis is useful to conidtionaly operate on network based on their use case.\n\nExample:\n\n```js\n{\n  networks: {\n    localhost: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"local\"]\n    },\n    hardhat: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"test\", \"local\"]\n    },\n    rinkeby: {\n      live: true,\n      saveDeployments: true,\n      tags: [\"staging\"]\n    }\n  }\n}\n```\n\n#### `deploy`\n\nthe deploy field override the paths.deploy option and let you define a set of folder containing the deploy scripts to be executed for this network.\n\nYou can thus have one network that will be executing L1 deployment and other L2 deployments, etc...\n\nYou could also have a folder that deploy contracts that are live on mainnet but that you need to replicate for your test or local network.\n\n#### `companionNetworks`\n\nthe companionNetworks field is an object whose key is any name you desire and the value is the name of a network that will be accessible inside the deploy script. For example:\n\n```js\n{\n  ...\n  networks: {\n    optimism: {\n      url: 'http://127.0.0.1:8545',\n      ovm: true,\n      companionNetworks: {\n        l1: 'localhost',\n      },\n    }\n  }\n  ...\n}\n```\n\nBy using name you can have the same deploy script used in different set of network.\n\nFor your test you could have the companion networks pointing to the same hardhat network, for test deployment, you could have rinkeby acting like your l2 while goerli act as your l1.\n\nAn example repo that show case a multi-network setup with optimism can be found here : https://github.com/wighawag/template-ethereum-contracts/tree/examples/optimism\n\ndeploy script can then access the network and its deployment as follow :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  const OVM_L1ERC20Gateway = await hre.companionNetworks['l1'].deployments.get(\n    'OVM_L1ERC20Gateway'\n  ); // layer 1\n\n  await execute(\n    'SimpleERC20_OVM',\n    {from: deployer, log: true},\n    'init',\n    OVM_L1ERC20Gateway.address\n  );\n};\n```\n\n---\n\n### **3. extra hardhat.config paths' options**\n\n---\n\n`hardhat-deploy` also adds fields to `HardhatConfig`'s `ProjectPaths` object.\n\nHere is an example showing the default values :\n\n```js\n{\n    paths: {\n        deploy: 'deploy',\n        deployments: 'deployments',\n        imports: 'imports'\n    }\n}\n```\n\nThe `deploy` folder is expected to contains the deploy script that are executed upon invocation of `hardhat deploy` or `hardhat node`.\nIt can also be an array of folder path.\n\nThe `deployments` folder will contains the resulting deployments (contract addresses along their abi, bytecode, metadata...). One folder per network and one file per contract.\n\nThe `imports` folder is expected to contains artifacts that were pre-compiled. Useful if you want to upgrade to a new solidity version but want to keep using previously compiled contracts. The artifact is the same format as normal hardhat artifact, so you can easily copy them over, before switching to a new compiler version.\n\n> This is less useful now that hardhat support multiple solidity compiler at once.\n\n---\n\n---\n\n### **4. deterministicDeployment (ability to specify a deployment factory)**\n\n---\n\nThis plugin extends the `HardhatConfig`'s object with an optional `deterministicDeployment` field.\n\n`deterministicDeployment` allows you to associate information that are used on each network for deterministic deployment. The information for each deterministic deployment consist out of a `factory`, a `deployer`, the required `funding` and a `signedTx` to deploy the factory. The default deterministic deployment used is the [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy). The factory expects a 32 bytes `salt` concatenated with the deployment data (see [EIP-1014](https://eips.ethereum.org/EIPS/eip-1014) for more information on these parameters).\n\nUsing the `deterministicDeployment` it is possible to define a different setup for the deterministic deployment. One use case for this is the deterministic deployment on networks that required replay protection (such as Celo or Avalanche). The [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy) can only be deployed on networks that don't enforce replay protection, therefore on other networks an alternative library has to be used. An example for this would be the [Safe Singleton Factory](https://github.com/gnosis/safe-singleton-factory) that is an adjusted version of the [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy) that contains signed transactions that include replay protection.\n\nThe information can be defined either as an object\n\n```js\n{\n    deterministicDeployment: {\n      \"4\": {\n        factory: \"<factory_address>\",\n        deployer: \"<deployer_address>\",\n        funding: \"<required_funding_in_wei>\",\n        signedTx: \"<raw_signed_tx>\",\n      }\n    }\n}\n```\n\nor as an function that returns the information for the deterministic deployment\n\n```js\n{\n  deterministicDeployment: (network: string) => {\n    return {\n      factory: '<factory_address>',\n      deployer: '<deployer_address>',\n      funding: '<required_funding_in_wei>',\n      signedTx: '<raw_signed_tx>',\n    };\n  };\n}\n```\n\n### Importing deployment from other projects (with truffle support)\n\n`hardhat-deploy` also add the `external` field to `HardhatConfig`\n\nSuch field allows to specify paths for external artifacts or **deployments**.\n\nThe external object has 2 fields:\n\n```js\n{\n    external: {\n        contracts: [\n          {\n            artifacts: \"node_modules/@cartesi/arbitration/export/artifacts\",\n            deploy: \"node_modules/@cartesi/arbitration/export/deploy\"\n          },\n          {\n            artifacts: \"node_modules/someotherpackage/artifacts\",\n          }\n        ],\n        deployments: {\n          rinkeby: [\"node_modules/@cartesi/arbitration/build/contracts\"],\n        },\n    }\n}\n```\n\nThe `contracts` field specify an array of object which itself have 2 fields.\n\n- `artifacts`: (mandatory) it is a path to an artifact folder. This support both hardhat and truffle artifacts.\n- `deploy`: (optional) it specifies a path to a folder where reside deploy script. The deploy scripts have only access to the artifact specified in the artifacts field. This allow project to share their deployment procedure. A boon for developer aiming at integrating it as they can get the contracts to be deployed for testing locally.\n\nThe `deployments` fields specify an object whose field nasme are the hardhat network and the value is an array of path to look for deployments. It supports both **hardhat-deploy** and truffle formats.\n\n---\n\n### Access to Artifacts (non-deployed contract code and abi)\n\nArtifacts in hardhat terminology represent a compiled contract (not yet deployed) with at least its bytecode and abi.\n\n`hardhat-deploy` gives can access to these artifact via the `deployments.getArtifact` function :\n\n```js\nconst {deployments} = require('hardhat');\nconst artifact = await deployments.getArtifact(artifactName);\n```\n\nWith the `hardhat-deploy-ethers` plugin you can get an artifact as an ethers contract factory, ready to be deployed, via the following:\n\n```js\nconst {deployments, ethers} = require('hardhat');\nconst factory = await ethers.getContractFactory(artifactName);\n```\n\n> Note that the artifact's files need to be either in `artifacts` folder that hardhat generate on compilation or in the `imports` folder where you can store contracts compiled elsewhere. They can also be present in the folder specified in `external.artifacts` see [Importing deployment from other projects](#importing-deployment-from-other-projects-with-truffle-support)\n\n---\n\n---\n\n## How to Deploy Contracts\n\n---\n\n### The `deploy` Task\n\n`hardhat --network <networkName> deploy [options and flags]`\n\nThis is a new task that the `hardhat-deploy` adds. As the name suggests it deploys contracts.\nTo be exact it will look for files in the folder `deploy` or whatever was configured in `paths.deploy`, see [paths config](#extra-paths-config)\n\nIt will scan for files in alphabetical order and execute them in turn.\n\n- it will `require` each of these files and execute the exported function with the HRE as argument\n\nTo specify the network, you can use the builtin hardhat argument `--network <network name>` or set the env variable `HARDHAT_NETWORK`\n\n> :warning: Note that running `hardhat deploy` without specifying a network will use the default network. If the default network is hardhat (the default's default) then nothing will happen as a result as everything happens in memory, but this can be used to ensure the deployment is without issues.\n\n---\n\n### Deploy Scripts\n\nThe deploy scripts need to be of the following type :\n\n```ts\nexport interface DeployFunction {\n  (env: HardhatRuntimeEnvironment): Promise<void | boolean>;\n  skip?: (env: HardhatRuntimeEnvironment) => Promise<boolean>;\n  tags?: string[];\n  dependencies?: string[];\n  runAtTheEnd?: boolean;\n  id?: string;\n}\n```\n\nThe skip function can be used to skip executing the script under whatever condition. It simply need to resolve a promise to true.\n\nThe tags is a list of string that when the _deploy_ task is executed with, the script will be executed (unless it skips). In other word if the deploy task is executed with a tag that does not belong to that script, that script will not be executed unless it is a dependency of a script that does get executed.\n\nThe dependencies is a list of tag that will be executed if that script is executed. So if the script is executed, every script whose tag match any of the dependencies will be executed first.\n\nThe `runAtTheEnd` is a boolean that if set to true, will queue that script to be executed after all other scripts are executed.\n\nThese set of fields allow more flexibility to organize the scripts. You are not limited to alphabetical order and you can even organise deploy script in sub folders.\n\nFinally the function can return true if it wishes to never be executed again. This can be usfeul to emulate migration scripts that are meant to be executed only once. Once such script return true (async), the `id` field is used to track execution and if that field is not present when the script return true, it will fails.\n\nIn other words, if you want a particular deploy script to run only once, it needs to both return true (async) and have an `id` set.\n\nIn any case, as a general advice every deploy function should be idempotent. This is so they can always recover from failure or pending transaction. This is what underpin most of hardhat-deploy philosophy.\n\nThis is why the `hre.deployments.deploy` function will by default only deploy if the contract code has changed, making it easier to write idempotent script.\n\n#### An example of a deploy script :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  // the following will only deploy \"GenericMetaTxProcessor\" if the contract was never deployed or if the code changed since last deployment\n  await deploy('GenericMetaTxProcessor', {\n    from: deployer,\n    gasLimit: 4000000,\n    args: [],\n  });\n};\n```\n\nAs you can see the HRE passed in has 4 new fields :\n\n- `getNamedAccounts` is a function that returns a promise to an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [`namedAccounts`](#namedaccounts)).\n\n- `getUnnamedAccounts` is a function that return a promise to an array of accounts which were not named (see [`namedAccounts`](#namedaccounts)). It is useful for tests where you want to be sure that the account has no speicifc role in the system (no token given, no admin access, etc...).\n\n- `getChainId` is a function which return a promise for the chainId, as convenience\n\n- `deployments` is an object which contains functions to access past deployments or to save new ones, as well as helpers functions.\n\nThat latter field contains for example the `deploy` function that allows you to deploy contract and save them. It contains a lot more functions though :\n\n---\n\n### The `deployments` field\n\nThe deployments field contains several helpers function to deploy contract but also execute transaction.\n\n```ts\nexport interface DeploymentsExtension {\n  deploy(name: string, options: DeployOptions): Promise<DeployResult>; // deploy a contract\n  diamond: {\n    // deploy diamond based contract (see section below)\n    deploy(name: string, options: DiamondOptions): Promise<DeployResult>;\n  };\n  deterministic( // return the determinsitic address as well as a function to deploy the contract, can pass the `salt` field in the option to use different salt\n    name: string,\n    options: Create2DeployOptions\n  ): Promise<{\n    address: Address;\n    implementationAddress?: Address;\n    deploy(): Promise<DeployResult>;\n  }>;\n  fetchIfDifferent( // return true if new compiled code is different than deployed contract\n    name: string,\n    options: DeployOptions\n  ): Promise<{differences: boolean; address?: string}>;\n  save(name: string, deployment: DeploymentSubmission): Promise<void>; // low level save of deployment\n  get(name: string): Promise<Deployment>; // fetch a deployment by name, throw if not existing\n  getOrNull(name: string): Promise<Deployment | null>; // fetch deployment by name, return null if not existing\n  getDeploymentsFromAddress(address: string): Promise<Deployment[]>;\n  all(): Promise<{[name: string]: Deployment}>; // return all deployments\n  getArtifact(name: string): Promise<Artifact>; // return a hardhat artifact (compiled contract without deployment)\n  getExtendedArtifact(name: string): Promise<ExtendedArtifact>; // return a extended artifact (with more info) (compiled contract without deployment)\n  run( // execute deployment scripts\n    tags?: string | string[],\n    options?: {\n      resetMemory?: boolean;\n      deletePreviousDeployments?: boolean;\n      writeDeploymentsToFiles?: boolean;\n      export?: string;\n      exportAll?: string;\n    }\n  ): Promise<{[name: string]: Deployment}>;\n  fixture( // execute deployment as fixture for test // use evm_snapshot to revert back\n    tags?: string | string[],\n    options?: {fallbackToGlobal?: boolean; keepExistingDeployments?: boolean}\n  ): Promise<{[name: string]: Deployment}>;\n  createFixture<T, O>( // execute a function as fixture using evm_snaphost to revert back each time\n    func: FixtureFunc<T, O>,\n    id?: string\n  ): (options?: O) => Promise<T>;\n  log(...args: any[]): void; // log data only ig log enabled (disabled in test fixture)\n\n  execute( // execute function call on contract\n    name: string,\n    options: TxOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<Receipt>;\n  rawTx(tx: SimpleTx): Promise<Receipt>; // execute a simple transaction\n  catchUnknownSigner( // you can wrap other function with this function and it will catch failure due to missing signer with the details of the tx to be executed\n    action: Promise<any> | (() => Promise<any>),\n    options?: {log?: boolean}\n  ): Promise<null | {\n    from: string;\n    to?: string;\n    value?: string;\n    data?: string;\n  }>;\n  read( // make a read-only call to a contract\n    name: string,\n    options: CallOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<any>;\n  read(name: string, methodName: string, ...args: any[]): Promise<any>;\n  // rawCall(to: Address, data: string): Promise<any>; // TODO ?\n}\n```\n\n---\n\n#### `deployments.deploy(<name>, options)`\n\n---\n\nThe `deploy` function, as mentioned above, allows you to deploy a contract and save it under a specific name.\n\nThe deploy function expect 2 parameters: one for the name and one for the options\n\nSee below the full list of fields that the option parameter allows and requires:\n\n```ts\nexport interface DeployOptions = {\n  from: string; // address (or private key) that will perform the transaction. you can use `getNamedAccounts` to retrived the address you want by name.\n  contract?: // this is an optional field. If not specified it defaults to the contract with the same name as the first parameter\n    | string // this field can be either a string for the name of the contract\n    | { // or abi and bytecode\n        abi: ABI;\n        bytecode: string;\n        deployedBytecode?: string;\n      };\n  args?: any[]; // the list of argument for the constructor (or the upgrade function in case of proxy)\n  skipIfAlreadyDeployed?: boolean; // if set it to true, will not attempt to deploy even if the contract deployed under the same name is different\n  log?: boolean; // if true, it will log the result of the deployment (tx hash, address and gas used)\n  linkedData?: any; // This allow to associate any JSON data to the deployment. Useful for merkle tree data for example\n  libraries?: { [libraryName: string]: Address }; // This let you associate libraries to the deployed contract\n  proxy?: boolean | string | ProxyOptions; // This options allow to consider your contract as a proxy (see below for more details)\n\n  // here some common tx options :\n  gasLimit?: string | number | BigNumber;\n  gasPrice?: string | BigNumber;\n  value?: string | BigNumber;\n  nonce?: string | number | BigNumber;\n\n  estimatedGasLimit?: string | number | BigNumber; // to speed up the estimation, it is possible to provide an upper gasLimit\n  estimateGasExtra?: string | number | BigNumber; // this option allow you to add a gas buffer on top of the estimation\n\n  autoMine?: boolean; // this force a evm_mine to be executed. this is useful to speed deployment on test network that allow to specify a block delay (ganache for example). This option basically skip the delay by force mining.\n  deterministicDeployment? boolean | string; // if true, it will deploy the contract at a deterministic address based on bytecode and constructor arguments. The address will be the same across all network. It use create2 opcode for that, if it is a string, the string will be used as the salt.\n  waitConfirmations?: number; // number of the confirmations to wait after the transactions is included in the chain\n};\n```\n\n---\n\n---\n\n## Handling contract using libraries\n\nIn the deploy function, one of the `DeployOptions` field is the `libraries` field. It allows you to associate external contract as libraries at the time of deployment.\n\nFirst, you have deploy the library using the `deploy` function, then when we deploy a contract that needs the linked library, we can pass the deployed library name and address in as an argument to the `libraries` object.\n\nFirst step: deploy the library:\n\n```js\nconst exampleLibrary = await deploy(\"ExampleLibary\", {\n    from: <deployer>\n});\n\n```\n\nExampleLibrary is now deployed to whatever network was chosen (`hardhat deploy --network <networkName>`)\n\nFor example, if we are deploying on Rinkeby, this library will get deployed on rinkeby, and the `exampleLibrary` variable will be a deployment object that contains the abi as well as the deployed address for the contract.\n\nNow that the library is deployed, we can link it in our next deployed contract.\n\n```js\nconst example = await deploy(\"Example\", {\n    from: <deployer>\n    args: [\"example string argument for the 'Example' contract constructor\"],\n    libraries: {\n        ExampleLibrary: exampleLibrary.address\n    }\n});\n\n```\n\nThis `libraries` object takes the name of the library, and its deployed address on the network. Multiple libraries can be passed into the `libraries` object.\n\n---\n\n---\n\n## Exporting Deployments\n\nApart from deployments saved in the `deployments` folder which contains all information available about the contract (compile time data + deployment data), `hardhat-deploy` allows you to export lightweight files.\n\nThese can be used for example to power your frontend with contract's address and abi.\n\nThis come into 2 flavors.\n\nThe first one is exported via the `--export <file>` option and follow the following format :\n\n```ts\nexport interface Export {\n  chainId: string;\n  name: string;\n  contracts: {[name: string]: ContractExport};\n}\n```\n\nwhere name is the name of the network configuration chosen (see hardhat option `--network`)\n\nThe second one is exported via the `--export-all <file>` option and follow the following format :\n\n```ts\nexport type MultiExport = {\n  [chainId: string]: Export[];\n};\n```\n\nAs you see the second format include the previous. While in most case you'll need the single export where your application will support only one network, there are case where your app would want to support multiple networks at nonce. This second format allow for that.\n\nFurthermore as hardhat support multiple network configuration for the same network (rinkeby, mainnet...), the export-all format will contains each of them grouped by their chainId.\n\nNote: from v0.10.4 the old multi-export down is no more:\n\n```\nexport type MultiExport = {\n  [chainId: string]: {[name: string]: Export};\n};\n```\n\n---\n\n---\n\n## Deploying and Upgrading Proxies\n\nAs mentioned above, the deploy function can also deploy a contract through a proxy. It can be done without modification of the contract as long as its number of constructor arguments matches the proxy initialization/update function.\n\nThe default Proxy is both ERC-1967 and ERC-173 Compliant, but other proxy can be specified, like openzeppelin transparent proxies.\n\nCode for the default Proxy can be found [here](solc_0.7/proxy/EIP173Proxy.sol).\n\nTo perform such proxy deployment, you just need to invoke the deploy function with the following options : `{..., proxy: true}`\n\nSee example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: true,\n  });\n};\n```\n\nYou can also set it to `proxy: \"<upgradeMethodName>\"` in which case the function `<upgradeMethodName>` will be executed upon upgrade.\nthe `args` field will be then used for that function instead of the contructor. It is also possible to then have a constructor with the same arguments and have the proxy be disabled. It can be useful if you want to have your contract as upgradeable in a test network but be non-upgradeable on the mainnet.\n\nSee example :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  network,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: network.live ? false : 'postUpgrade',\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nThe proxy option can also be an object which can set the specific owner that the proxy is going to be managed by.\n\nSee example:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: {\n      owner: greeterOwner,\n      methodName: 'postUpgrade',\n    },\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nNote that for the second invokation, this deployment will not be executed from the specified `from: deployer` as otherwise these tx will always fails. It will instead be automatically executed from the proxy's current owner (in that case : `greeterOwner`)\n\nNow, it is likely you do not want to locally handle the private key / mnemonic of the account that manage the proxy or it could even be that the `greeterOwner` in question is a multi sig. As such that second invocation will throw an error as it cannot find a local signer for it.\n\nThe error will output the necessary information to upgrade the contract but `hardhat-deploy` comes also with a utility function for such case: `deployments.catchUnknwonSigner` which will catch the error and output to the console the necessary information while continuing to next step.\n\nHere is the full example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy, catchUnknownSigner} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await catchUnknownSigner(\n    deploy('Greeter', {\n      from: deployer,\n      proxy: {\n        owner: greeterOwner,\n        methodName: 'postUpgrade',\n      },\n      args: ['arg1', 2, 3],\n    })\n  );\n  // you could pause the deployment here and wait for input to continue\n};\n```\n\nThe full proxy options is as follow:\n\n```ts\ntype ProxyOptionsBase = {\n  owner?: Address; // this set the owner of the proxy. further upgrade will need to be executed from that owner\n  upgradeIndex?: number; // allow you to breakdown your upgrades into separate deploy scriot, each with their own index. A deploy call with a specific upgradeIndex will be executed only once, only if the current upgradeIndex is one less.\n  proxyContract?: // default to \"EIP173Proxy\". See below for more details\n  string | ArtifactData;\n  viaAdminContract?: // allow to specify a contract that act as a middle man to perform upgrades. Useful and Recommended for Transparent Proxies\n  | string\n    | {\n        name: string;\n        artifact?: string | ArtifactData;\n      };\n};\n\nexport type ProxyOptions =\n  | (ProxyOptionsBase & {\n      methodName?: string; // method to be executed when the proxy is deployed for the first time or when the implementation is modified. Use the deployOptions args field for arguments\n    })\n  | (ProxyOptionsBase & {\n      execute?:\n        | {\n            methodName: string; // method to be executed when the proxy is deployed for the first time or when the implementation is modified.\n            args: any[];\n          }\n        | {\n            init: {\n              methodName: string; // method to be executed when the proxy is deployed\n              args: any[];\n            };\n            onUpgrade?: {\n              methodName: string; // method to be executed when the proxy is upgraded (not first deployment)\n              args: any[];\n            };\n          };\n    });\n```\n\nThe `proxyContract` field allow you to specify your own Proxy contract. If it is a string, it will first attempt to get an artifact with that name. If not found it will fallback on the following if\n\nit matches:\n\n- `EIP173Proxy`: use the default Proxy that is EIP-173 compliant\n\n- `EIP173ProxyWithReceive`: Same as above except that the proxy contains a receive hook to accept empty ETH payment.\n\n- `OpenZeppelinTransparentProxy`: Use Openzeppelin Transparent Proxy (copied from openzeppelin repo, see code [here](solc_0.7/openzeppelin/proxy/TransparentUpgradeableProxy.sol))\n  When this option is chosen, the `DefaultProxyAdmin` is also used as admin since Transparent Proxy kind of need an intermediarry contract for administration. This can be configured via the `viaAdminContract` option. Note that the DefaultProxyAdmin is slightly different than the one used by openzeppelin as it allow you to set a different owner than msg.sender on first deploy, something openzeppelin version do not allow, see : https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2639\n\n- `OptimizedTransparentProxy`: This contract is similar to above, except that it is optimized to not require storage read for the admin on every call.\n\n## Builtin-In Support For Diamonds (EIP2535)\n\nThe deployments field also expose the diamond field: `hre.deployments.diamond` that let you deploy [Diamonds](https://eips.ethereum.org/EIPS/eip-2535) in an easy way.\n\n### deployment / upgrade\n\nInstead of specifying the facets to cut out or cut in, which the diamond contract expects, you specify the facets you want to end up having on the deployed contract.\n\nThis declarative approach allow you to focus on what you want instead of how to do it.\n\n`diamond.deploy` expect the facet as names. The names represent contract to be deployed as facet. In future version you ll be able to specify deployed contract or artifact object as facet.\n\nTo deploy a contract with 3 facet you can do as follow :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: deployer,\n    owner: diamondAdmin,\n    facets: ['Facet1', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nif you then later execute the following script:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: diamondAdmin, // this need to be the diamondAdmin for upgrade\n    owner: diamondAdmin,\n    facets: ['NewFacet', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nThen the NewFacet will be deployed automatically if needed and then the diamondCut will cut Facet1 out and add NewFacet.\n\nNote that if the code for Facet2 and Facet3 changes, they will also be redeployed automatically and the diamondCuts will replace the existing facets with these new ones.\n\nNote that the diamond has 3 facet added by default. These facets are used for ownership, diamondCut and diamond loupe.\n\nThe implementation is a sligthly modified version of the [reference implementation by Nick Mudge](https://github.com/mudgen/diamond-3).\nTHe only difference is the custom constructor that allow multiple initialization, used to allow the default ERC165 facet to be initialised along your custom initialization function.\n\n### onUpgrade calls\n\nLike normal proxies you can also execute a function at the time of an upgrade.\n\nThis is done by specifying the execute field in the diamond deploy options :\n\n```js\ndiamond.deploy('ADiamondContract', {\n  from: deployer,\n  owner: diamondAdmin,\n  facets: ['NewFacet', 'Facet2', 'Facet3'],\n  execute: {\n    methodName: 'postUpgrade',\n    args: ['one', 2, '0x3'],\n  },\n});\n```\n\n### more...\n\nThere are more options, to be described later...\n\n## Testing Deployed Contracts\n\nYou can continue using the usual test task:\n\n`hardhat test`\n\nTests can use the `hre.deployments.fixture` function to run the deployment and snapshot it so that tests don't need to perform all the deployment transactions every time. They can simply reuse the snapshot for every test (this leverages `evm_snapshot` and `evm_revert` provided by both `hardhat` and `ganache`). You can for example set them in a `beforeEach`.\n\nHere is an example of a test :\n\n```js\nconst {deployments} = require('hardhat');\n\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    await deployments.fixture(['Token']);\n    const Token = await deployments.get('Token'); // Token is available because the fixture was executed\n    console.log(Token.address);\n    const ERC721BidSale = await deployments.get('ERC721BidSale');\n    console.log({ERC721BidSale});\n  });\n});\n```\n\nTests can also leverage named accounts for clearer test. Combined with `hardhat-deploy-ethers` plugin, you can write succint test :\n\n```js\nconst {ethers, getNamedAccounts} = require('hardhat');\n\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    await deployments.fixture(['Token']);\n    const {tokenOwner} = await getNamedAccounts();\n    const TokenContract = await ethers.getContract('Token', tokenOwner);\n    await TokenContract.mint(2).then((tx) => tx.wait());\n  });\n});\n```\n\n---\n\n### Creating Fixtures\n\nFurthermore, tests can easily create efficient fixture using `deployments.createFixture`\n\nSee example :\n\n```js\nconst setupTest = deployments.createFixture(\n  async ({deployments, getNamedAccounts, ethers}, options) => {\n    await deployments.fixture(); // ensure you start from a fresh deployments\n    const {tokenOwner} = await getNamedAccounts();\n    const TokenContract = await ethers.getContract('Token', tokenOwner);\n    await TokenContract.mint(10).then((tx) => tx.wait()); //this mint is executed once and then `createFixture` will ensure it is snapshotted\n    return {\n      tokenOwner: {\n        address: tokenOwner,\n        TokenContract,\n      },\n    };\n  }\n);\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    const {tokenOwner} = await setupTest();\n    await tokenOwner.TokenContract.mint(2);\n  });\n});\n```\n\nWhile this example is trivial, some fixture can requires several transaction and the ability to snapshot them automatically speed up the tests greatly.\n\n---\n\n---\n\n## More Information On Hardhat Tasks\n\n---\n\n### **1. node task**\n\nas mentioned above, the node task is slighly modified and augmented with various flags and options\n\n`hardhat node`\n\nIn particular it adds an argument `--export` that allows you to specify a destination file where the info about the contracts deployed is written.\nYour webapp can then access all contracts information.\n\n---\n\n### **2. test task**\n\n`hardhat test`\n\nthe test task is augmented with one flag argument `--deploy-fixture` that allows to run all deployments in a fixture snapshot before executing the tests. This can speed up the tests that use specific tags as the global fixture take precedence (unless specified).\n\nIn other word tests can use `deployments.fixture(<specific tag>)` where specific tag only deploys the minimal contracts for tests, while still benefiting from global deployment snapshot if used.\n\nIf a test needs the deployments to only include the specific deployment specified by the tag, it can use the following :\n\n```js\ndeployments.fixture('<specific tag>', {fallbackToGlobal: false});\n```\n\nDue to how snapshot/revert works in hardhat, this means that these tests will not benefit from the global fixture snapshot and will have to deploy their contracts as part of the fixture call. This is automatic but means that these tests will run slower.\n\n---\n\n### **3. run task**\n\n`hardhat --network <networkName> run <script>`\n\nThe run task act as before but thanks to the `hre.deployments` field it can access deployed contract :\n\n```js\nconst hre = require('hardhat');\nconst {deployments, getNamedAccounts} = hre;\n\n(async () => {\n  console.log(await deployments.all());\n  console.log({namedAccounts: await getNamedAccounts()});\n})();\n```\n\nYou can also run it directly from the command line as usual.\n\n`HARDHAT_NETWORK=rinkeby node <script>` is the equivalent except it does not load the hardhat environment twice (which the run task does)\n\n---\n\n### **4. console task**\n\n`hardhat console`\n\nThe same applies to the `console` task.\n\n---\n\n## Deploy Scripts: Tags And Dependencies\n\n---\n\nIt is possible to execute only specific parts of the deployments with `hardhat deploy --tags <tags>`\n\nTags represent what the deploy script acts on. In general it will be a single string value, the name of the contract it deploys or modifies.\n\nThen if another deploy script has such tag as a dependency, then when this latter deploy script has a specific tag and that tag is requested, the dependency will be executed first.\n\nHere is an example of two deploy scripts :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const deployResult = await deploy('Token', {\n    from: deployer,\n    args: ['hello', 100],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Token deployed at ${deployResult.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Token'];\n```\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const Token = await deployments.get('Token');\n  const deployResult = await deploy('Sale', {\n    from: deployer,\n    contract: 'ERC721BidSale',\n    args: [Token.address, 1, 3600],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Sale deployed at ${deployResult.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.dependencies = ['Token']; // this ensure the Token script above is executed first, so `deployments.get('Token')` succeeds\n```\n\nAs you can see the second one depends on the first. This is because the second script depends on a tag that the first script registers as using.\n\nWith that when `hardhat deploy --tags Sale` is executed\n\nthen both scripts will be run, ensuring Sale is ready.\n\nYou can also define the script to run after another script is run by setting `runAtTheEnd` to be true. For example:\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, execute, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer, admin} = namedAccounts;\n  await execute('Sale', {from: deployer}, 'setAdmin', admin);\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.runAtTheEnd = true;\n```\n\nTags can also be used in test with `deployments.fixture`. This allow you to test a subset of the deploy script.\n","readmeFilename":"README.md","gitHead":"283ec68d4a2f420a8b23785f9efc58fd62451240","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.5-zksync.0","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-KOurAgS47waK3bupnt3ChS1jYYFRrJW0qcOEvHoWKwMCjliR01m2wfnOz/ob3B5vTOCIrYUGg34iuu31LYwM5Q==","shasum":"1f0673117b7bfaca67db7d5de5a114848ffe12a5","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.5-zksync.0.tgz","fileCount":149,"unpackedSize":12160665,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDYO09B5LvYMzGTBe028bQB42GEBGHVNQpqQc5IOPqNiQIhAI1K6O0mrJjONnjUICpnM/ZmYTaO5DC/ygpDekXBMfZS"}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJicP5zACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmpmOg//Z/YKdHd+DFKsYEEHjotPNzkThsS87nm3LdjDV3oI6NtTX0cc\r\naTF4vmRzXBVxCPFrHUFlIOHpEh13cA9FkXDexCrrTV3sErzZRO70gofXpUdI\r\no907oFjuclEmB/4wv0pJTPc7C/g+sE8FtjDyt2OflCRjhczZ5GYPBX5qHC1u\r\nkfHDhMWzIf1OcqB9FCDJcuDWsdVj5Ww1IjKnd8UARCg5Dosoqz0eIKEHygRV\r\nmXf24ccFlvcZwFKl1M8WaIqFCGl73mR+0gUs5dmXVa8q+tkVxRBUGEE3GmBZ\r\nQGglYCpC9U+1Xco8WWGXkue6yllPiEqylfTCB9gATzp8ttWrawv53HwdsOZD\r\nU/RMFhMYMYyEtqZgpBc8Q4HUOkNxrXFTqzdICFaN33d+sJ0egpc7OTQ21XYN\r\nkC2aCQVu8UcBIrEE/F3DBcnachxzUtkVI1jpzKi3uuv3IxuiV8ebvIvfW8FQ\r\nNxWIDIdCDjqcxMqV3OkZqPxsvxEvHs7BX5FfGvBcPO7L1O1wMuUMxBBHwCdf\r\nw9ls6Mtnx5UbUlQTFdDYZZsBkWmkWb7Z9jx1IofIA5ilAx/3S1t9lYDZA3gX\r\nmxUFIvxcZ6Q19fyLXieU0uXKFFtg2G8pECJNAFtFzp7mOLh8t8wHibaGSzwV\r\nBJC/qn+k4CR7yUsNPdk7O704qVu2z/y+Ke0=\r\n=srbh\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.5-zksync.0_1651572339373_0.9710386804768465"},"_hasShrinkwrap":false},"0.11.5-zksync.1":{"name":"hardhat-deploy","version":"0.11.5-zksync.1","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.9.0","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"dependencies":{"@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","ethers":"^5.5.3","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","zksync-web3":"^0.4.0"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"a103f2d4748cc4d66046cc3f45f6d6a1ec28f6a6","readme":"<h1> hardhat-deploy</h1>\n\n_A [Hardhat](https://hardhat.org) Plugin For Replicable Deployments And Easy Testing_\n\n> **A complete dev template using hardhat-deploy is available here** : https://github.com/wighawag/template-ethereum-contracts\n> It also contains various branches examplifying the capability of hardhat-deploy. Check it out.\n\n- [What is it for ?](#what-is-it-for-)\n- [hardhat-deploy in a nutshell](#hardhat-deploy-in-a-nutshell)\n- [Installation](#installation)\n  - [npm install hardhat-deploy](#npm-install-hardhat-deploy)\n  - [TypeScript support](#typescript-support)\n  - [Migrating existing deployment to hardhat-deploy](#migrating-existing-deployment-to-hardhat-deploy)\n- [Hardhat Tasks Available/Updated](#hardhat-tasks-availableupdated)\n  - [1. hardhat deploy](#1-hardhat-deploy)\n    - [**Options**](#options)\n    - [**Flags**](#flags)\n  - [2. hardhat node](#2-hardhat-node)\n    - [**Options**](#options-1)\n    - [**Flags**](#flags-1)\n  - [3. hardhat test](#3-hardhat-test)\n  - [4. hardhat etherscan-verify](#4-hardhat-etherscan-verify)\n    - [**Options**](#options-2)\n  - [5. hardhat sourcify](#5-hardhat-sourcify)\n    - [**Options**](#options-3)\n  - [6. hardhat export](#6-hardhat-export)\n    - [**Options**](#options-4)\n- [Hardhat Environment Extensions](#hardhat-environment-extensions)\n- [Configuration](#configuration)\n  - [**1. namedAccounts (ability to name addresses)**](#1-namedaccounts-ability-to-name-addresses)\n  - [**2. extra hardhat.config networks' options**](#2-extra-hardhatconfig-networks-options)\n    - [`live`](#live)\n    - [`saveDeployments`](#savedeployments)\n    - [`tags`](#tags)\n    - [`deploy`](#deploy)\n    - [`companionNetworks`](#companionnetworks)\n  - [**3. extra hardhat.config paths' options**](#3-extra-hardhatconfig-paths-options)\n  - [**4. deterministicDeployment (ability to specify a deployment factory)**](#4-deterministicdeployment-ability-to-specify-a-deployment-factory)\n  - [Importing deployment from other projects (with truffle support)](#importing-deployment-from-other-projects-with-truffle-support)\n  - [Access to Artifacts (non-deployed contract code and abi)](#access-to-artifacts-non-deployed-contract-code-and-abi)\n- [How to Deploy Contracts](#how-to-deploy-contracts)\n  - [The `deploy` Task](#the-deploy-task)\n  - [Deploy Scripts](#deploy-scripts)\n    - [An example of a deploy script :](#an-example-of-a-deploy-script-)\n  - [The `deployments` field](#the-deployments-field)\n    - [`deployments.deploy(<name>, options)`](#deploymentsdeployname-options)\n- [Handling contract using libraries](#handling-contract-using-libraries)\n- [Exporting Deployments](#exporting-deployments)\n- [Deploying and Upgrading Proxies](#deploying-and-upgrading-proxies)\n- [Builtin-In Support For Diamonds (EIP2535)](#builtin-in-support-for-diamonds-eip2535)\n  - [deployment / upgrade](#deployment--upgrade)\n  - [onUpgrade calls](#onupgrade-calls)\n  - [more...](#more)\n- [Testing Deployed Contracts](#testing-deployed-contracts)\n  - [Creating Fixtures](#creating-fixtures)\n- [More Information On Hardhat Tasks](#more-information-on-hardhat-tasks)\n  - [**1. node task**](#1-node-task)\n  - [**2. test task**](#2-test-task)\n  - [**3. run task**](#3-run-task)\n  - [**4. console task**](#4-console-task)\n- [Deploy Scripts: Tags And Dependencies](#deploy-scripts-tags-and-dependencies)\n\n## What is it for ?\n\nThis [hardhat](https://hardhat.org) plugin adds a mechanism to deploy contracts to any network, keeping track of them and replicating the same environment for testing.\n\nIt also adds a mechanism to associate names to addresses, so test and deployment scripts can be reconfigured by simply changing the address a name points to, allowing different configurations per network. This also results in much clearer tests and deployment scripts (no more `accounts[0]` in your code).\n\nThis plugin contains a lot more features too, all geared toward a better developer experience :\n\n- chain configuration export\n- listing deployed contracts' addresses and their abis (useful for webapps)\n- library linking at time of deployment.\n- deterministic deployment across networks.\n- support for specific deploy script per network (L1 vs L2 for example)\n- ability to access deployment from \"companion\" networks\n- deployment dependency system (allowing you to only deploy what is needed).\n- deployment retrying (by saving pending tx): so you can feel confident when making a deployment that you can always recover.\n- deployments as test fixture using `evm_snapshot` to speed up testing.\n- ability to create your own test fixture that automatically benefits from `evm_snapshot`'s tests speed-up boost\n- combined with [hardhat-deploy-ethers](https://github.com/wighawag/hardhat-deploy-ethers) it has the ability to get ethers contract instance by name (like `await ethers.getContract(\"ContractName\")`).\n- importing artifact from external sources (like npm packages), including [truffle](https://www.trufflesuite.com/truffle) support.\n- importing deployments from external sources (like npm packages)\n- ability to log information in `deploy` mode only (while in test the console remains clean).\n- contains helpers to read and execute transaction on deployed contract referring to them by name.\n- These helpers contains options to auto mine on dev network (to speed up test deployments).\n- save metadata of deployed contract so they can always be fully verified, via [sourcify](https://sourcify.dev) or [etherscan](https://etherscan.io).\n- ability to submit contract source to etherscan and sourcify for verification at any time. (Because **hardhat-deploy** will save all the necessary info, it can be executed at any time.)\n- support harhdat's fork feature so deployment can be accessed even when run through fork.\n- named accounts are automatically impersonnated too, so you can perform tx as if you had their private key.\n- proxy deployment with ability to upgrade them transparently, only if code changes.\n- this include support for [openzeppelin](https://openzeppelin.com) transparent proxies\n- diamond deployment with facets, allowing you to focus on what the new version will be. It will generate the diamondCut necessary to reach the new state.\n- watch and deploy: **hardhat-deploy** can watch both your deploy script and contract code and redeploy on changes.\n- HCR (Hot Contract Replacement): the watch feature combined with proxy or diamond, gives you an experience akin to frontend Hot Module Replacement: once your contract changes, the deployment is executed and your contract retains the same address and same state, allowing you to tweak your contracts while debugging your front-end.\n\n## hardhat-deploy in a nutshell\n\nBefore going into the details, here is a very simple summary of the basic feature of **hardhat-deploy**.\n\n**hardhat-deploy** allows you to write [`deploy scripts`](#deploy-scripts) in the `deploy` folder. Each of these files that look as follows will be executed in turn when you execute the following task: `hardhat --network <networkName> deploy`\n\n```js\n// deploy/00_deploy_my_contract.js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('MyContract', {\n    from: deployer,\n    args: ['Hello'],\n    log: true,\n  });\n};\nmodule.exports.tags = ['MyContract'];\n```\n\nFurthermore you can also ensure these scripts are executed in test too by calling `await deployments.fixture(['MyContract'])` in your test.\nThis is optimized, so if multiple tests use the same contract, the deployment will be executed once and each test will start with the exact same state.\n\nThis is a huge benefit for testing since you are not required to replicate the deployment procedure in your tests. The tag feature (as seen in the script above) and [dependencies](#deploy-scripts-tags-and-dependencies) will also make your life easier when writing complex deployment procedures.\n\nYou can even group deploy scripts in different sub folder and ensure they are executed in their logical order.\n\nFurthermore hardhat-deploy can also support a multi-chain settings like L1, L2 with multiple deploy folder specific to each network.\n\n**All of this can also be bundled in a npm package so user of hardhat-deploy can reuse your deployment procedure and get started integrating with your project locally.**\n\nThere is a tutorial covering the basics here : https://github.com/wighawag/tutorial-hardhat-deploy\n\n## Installation\n\n### npm install hardhat-deploy\n\n```bash\nnpm install -D hardhat-deploy\n```\n\nAnd add the following statement to your `hardhat.config.js`:\n\n```js\nrequire('hardhat-deploy');\n```\n\nif you use `ethers.js` we recommend you also install `hardhat-deploy-ethers` which add extra features to access deployments as ethers contract.\n\nSince `hardhat-deploy-ethers` is a fork of `@nomiclabs/hardhat-ethers` and that other plugin might have an hardcoded dependency on `@nomiclabs/hardhat-ethers` the best way to install `hardhat-deploy-ethers` and ensure compatibility is the following:\n\n```bash\nnpm install --save-dev  @nomiclabs/hardhat-ethers@npm:hardhat-deploy-ethers ethers\n```\n\nWhich means you then need to do `require(\"@nomiclabs/hardhat-ethers\")` instead of `require(\"hardhat-deploy-ethers\")` in your `hardhat.config.js` file.\n\nMore details on `hardhat-deploy-ethers` repo : https://github.com/wighawag/hardhat-deploy-ethers#readme\n\n### TypeScript support\n\nWith hardhat the tsconfig.json is optional.\n\nBut if you add folders to the `include` field in `tsconfig.json`, you ll also need to include `hardhat.config.ts` like :\n\n`include\": [\"./hardhat.config.ts\", \"./scripts\", \"./deploy\", \"./test\"]`\n\nfor deploy script (see below) you can write them this way to benefit from typing :\n\n```ts\nimport {HardhatRuntimeEnvironment} from 'hardhat/types';\nimport {DeployFunction} from 'hardhat-deploy/types';\n\nconst func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {\n  // code here\n};\nexport default func;\n```\n\nSee a template that uses **hardhat-deploy** here : https://github.com/wighawag/template-ethereum-contracts\n\nThis repo has also some examples branch that exemplify specific features, like the forking testing here : https://github.com/wighawag/template-ethereum-contracts/tree/examples/fork-test\n\n### Migrating existing deployment to hardhat-deploy\n\n> Only needed for existing project that already deployed contracts and has the deployment information available **(at minimum, address and abi)**\n\nYou might want to switch your current deployment process to use **hardhat-deploy**. In that case you probably have some deployments saved elsewhere.\n\nIn order to port them to **hardhat-deploy**, you'll need to create one `.json` file per contract in the `deployments/<network>` folder (configurable via [paths config](#extra-paths-config)).\n\nThe network folder is simply the hardhat network name (as configured in hardhat.config.js) (accessible at runtime via `hre.network.name`).\nSuch folder need to have a file named `.chainId` containing the chainId as decimal.\n\nFor example for network named \"rinkeby\" (for the corresponding network) the file `deployments/rinkeby/.chainId` would be\n\n```\n4\n```\n\nNote, prior to hardhat 0.6 the chainId was appended to the folder name (expect for some known network name). This has changed and upgrading to 0.6 will require you to change the folder name and add the '.chainId' file.\n\nEach contract file must follow this type (as defined in [types.ts](types.ts)) :\n\n```ts\nexport interface Deployment {\n  address: Address;\n  abi: ABI;\n  receipt?: Receipt;\n  transactionHash?: string;\n  history?: Deployment[];\n  numDeployments?: number;\n  implementation?: string;\n  args?: any[];\n  linkedData?: any;\n  solcInputHash?: string;\n  metadata?: string;\n  bytecode?: string;\n  deployedBytecode?: string;\n  libraries?: Libraries;\n  userdoc?: any;\n  devdoc?: any;\n  methodIdentifiers?: any;\n  diamondCut?: FacetCut[];\n  facets?: Facet[];\n  storageLayout?: any;\n  gasEstimates?: any;\n}\n```\n\nAs you can see, only abi and address are mandatory. But having the other fields allow more feature. For example, metadata and args allow you to benefit from contract code verification.\n\nFor Receipt, the following type is expected:\n\n```ts\nexport type Receipt = {\n  from: string;\n  transactionHash: string;\n  blockHash: string;\n  blockNumber: number;\n  transactionIndex: number;\n  cumulativeGasUsed: string;\n  gasUsed: string;\n  contractAddress?: string;\n  to?: string;\n  logs?: Log[];\n  events?: any[];\n  logsBloom?: string;\n  byzantium?: boolean;\n  status?: number;\n  confirmations?: number;\n};\n```\n\nHere is an example:\n\nLet's say you have:\n\n- 2 Contract named Greeter and Registry deployed on rinkeby\n- 1 contract named Greeter on mainnet\n- 2 Contract named Greeter and Registry deployed on a network named rinkeby2\n\nYou would get the following folder structure:\n\n```\ndeployments/\n  mainnet/\n    .chainId\n    Greeter.json\n  rinkeby/\n    .chainId\n    Greeter.json\n    Registry.json\n  rinkeby2/\n    .chainId\n    Greeter.json\n    Registry.json\n```\n\nThe reason why **hardhat-deploy** save chainId in the `.chainId` file is both for\n\n- safety: so that if you were to change the network name to point to a different chain, it would not attempt to read the wrong folder and assume that a contract has been deployed while it has not.\n- ability to know the chainId without requring to be connected to a node (and so not dependent on hardhat.config.js settings). Useful for `export` task.\n\n---\n\n## Hardhat Tasks Available/Updated\n\nhardhat deploy add several task to hardhat. It also modify existing one, adding new options and new behavior. All of these are described here:\n\n---\n\n### 1. hardhat deploy\n\n---\n\nThis plugin adds the _deploy_ task to Hardhat.\n\nThis task will execute the scripts in the `deploy` folder and save the contract deployments to disk. These deployments are supposed to be saved for example in a git repository. This way they can be accessed later. But you are free to save them elsewhere and get them back via your mechanism of choice.\n\nWith the deployment saved, it allows you to deploy a contract only if changes were made.\n\nDeploy scripts (also called Deploy functions) can also perform aribtrary logic.\n\nFor further details on how to use it and write deploy script, see [section](#deploy-scripts) below.\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployments, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice (in wei) to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--reset`: This flag resets the deployments from scratch. Previously deployed contract are not considered and deleted from disk.\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n---\n\n### 2. hardhat node\n\n---\n\nThis plugin modify the _node_ task so that it also execute the deployment script before exposing the server http RPC interface\n\nIt add similar options than the `deploy` task :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\n\n`--tags <tags>`: only excute deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--no-reset`: This flag prevent the reseting of the existing deployments. This is usually not desired when running the `node` task as a network is created from scratch and previous deployemnt are irrelevant.\n\n`--show-accounts`: this flag will output the account private keys\n\n`--silent`: This flag remove **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n`--no-deploy` that discard all other options to revert to normal `hardhat node` behavior without any deployment being performed.\n\n> :warning: Note that the deployments are saved as if the network name is `localhost`. This is because `hardhat node` is expected to be used as localhost: You can for example execute `hardhat --network localhost console` after `node` is running. Doing `hardhat --network hardhat console` would indeed not do anything useful. It still take the configuration from `hardhat` in the hardhat.config.js file though.\n\n---\n\n### 3. hardhat test\n\n---\n\nThis plugin adds a flag argument `--deploy-fixture` to the _test_ task which if enabled will run the global deployments fixture before the tests and snapshots it. This will generaly speed up the tests as further test will be able to revert back to the full deployment.\n\n> :warning: Note though that if your test behave differently whether that option is on or not, this most likely mean that your deploy scripts' tags and dependencies are not configured correctly. This is because the global fixture will ensure all contract are deployed while test will usually (for efficiency) ask for a particular tag.\n\n---\n\n### 4. hardhat etherscan-verify\n\n---\n\nThis plugin adds the _etherscan-verify_ task to Hardhat.\n\nThis task will submit the contract source and other info of all deployed contracts to allow etherscan to verify and record the sources.\n\nInstead of using the full solc input, this task will first attempt to send the minimal sources from the metadata.\nBut Etherscan sometime fails due to a bug in solidity compiler (<https://github.com/ethereum/solidity/issues/9573>). As such this task can fallback on full solc input (see option --solc-input). Note that if your contract was deployed with a previous version of **hardhat-deploy**, it might not contains the full information. The issue seems to be fully resolved since solc version 0.8.\n\nThis task will also attempt to automatically find the SPDX license in the source.\n\nTo execute that task, you need to specifiy the network to run against :\n\n```bash\nhardhat --network mainnet etherscan-verify [--api-key <apikey>] [--apiurl <url>]\n```\n\n#### **Options**\n\nNote that harhdat-deploy now use a different config format to not conflict with `hardhat-etherscan`\n\n`--api-key <api key>`: let you specify your etherscan api key. Alternatively, you can provide it via the env variable `ETHERSCAN_API_KEY` or through the hardhat.config.ts verify field:\n\n```js\n{\n  ...\n  verify: {\n    etherscan: {\n      apiKey: '<API key>'\n    }\n  }\n}\n```\n\n`--api-url <url>`: let you specify your etherscan url to submit the source to. Can also be configured per network in `hardhat.config.js`:\n\n```js\n{\n  ...\n  networks: {\n    mynetwork: {\n      ...\n      verify: {\n        etherscan: {\n          apiUrl: 'http://mynetwork.xyz'\n        }\n      }\n    }\n  }\n}\n```\n\n`--license <SPDX license id>`: SPDX license (useful if SPDX is not listed in the sources), need to be supported by etherscan: https://etherscan.io/contract-license-types\n\n`--force-license`: if set, will force the use of the license specified by --license option, ignoring the one in the source (useful for license not supported by etherscan)\n\n`--solc-input`: fallback on solc-input id needed (useful when etherscan fails on the minimum sources, see https://github.com/ethereum/solidity/issues/9573)\n\n`--sleep`: sleep 500ms between each verification, so API rate limit is not exceeded\n\n---\n\n### 5. hardhat sourcify\n\n---\n\nThis plugin adds the _sourcify_ task to Hardhat.\n\nSimilar to `hardhat etherscan-verify` this task will submit the contract source and other info of all deployed contracts to sourcify.\n\n```bash\nhardhat --network mainnet sourcify\n```\n\nLater this task might instead pin the metadata to ipfs, so sourcify can automatically verify them.\n\n#### **Options**\n\n`--contract-name <contract name>`: specify the contract's name you want to verify\n  \n`--endpoint <endpoint>`: specify the sourcify endpoint, default to https://sourcify.dev/server/\n\n`--write-failing-metadata`: if set and the sourcify task fails to verify, the metadata file will be written to disk, so you can more easily figure out what has gone wrong.\n\n---\n\n### 6. hardhat export\n\n---\n\nThis plugin adds the _export_ task to Hardhat.\n\nThis task will export the contract deployed (saved in `deployments` folder) to a file with a simple format containing only contract addresses and abi, useful for web apps.\n\nOne of the following options need to be set for this task to have any effects :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your frontend.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked.\nThis last option has some limitations, when combined with the use of external deployments (see [Configuration](#configuration)). If such external deployments were using older version of **hardhat-deploy** or truffle, the chainId might be missing. In order for these to be exported, the hardhat network config need to explicity state the chainId in the `networks` config of `hardhat.config.js`.\n\nWith both `--export` and `--export-all`, using the special `<filepath>` value of `-` will output to `STDOUT` rather than writing a normal file.\n\n---\n\n---\n\n## Hardhat Environment Extensions\n\nThis plugin extends the Hardhat Runtime Environment by adding 4 fields:\n\n- `getNamedAccounts: () => Promise<{ [name: string]: string }>`: a function returning an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [Configuration](#configuration)).\n\n- `getUnnamedAccounts: () => Promise<string[]}>`: accounts which has no names, useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`: contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId(): Promise<string>`: offer an easy way to fetch the current chainId.\n\n---\n\n---\n\n## Configuration\n\n---\n\n### **1. namedAccounts (ability to name addresses)**\n\n---\n\nThis plugin extends the `HardhatConfig`'s object with an optional `namedAccounts` field.\n\n`namedAccounts` allows you to associate names to addresses and have them configured per chain.\nThis allows you to have meaningful names in your tests while the addresses match to multi sig in real network for example.\n\n```js\n{\n    namedAccounts: {\n        deployer: {\n            default: 0, // here this will by default take the first account as deployer\n            1: 0, // similarly on mainnet it will take the first account as deployer. Note though that depending on how hardhat network are configured, the account 0 on one network can be different than on another\n            4: '0xA296a3d5F026953e17F472B497eC29a5631FB51B', // but for rinkeby it will be a specific address\n            \"goerli\": '0x84b9514E013710b9dD0811c9Fe46b837a4A0d8E0', //it can also specify a specific netwotk name (specified in hardhat.config.js)\n        },\n        feeCollector:{\n            default: 1, // here this will by default take the second account as feeCollector (so in the test this will be a different account than the deployer)\n            1: '0xa5610E1f289DbDe94F3428A9df22E8B518f65751', // on the mainnet the feeCollector could be a multi sig\n            4: '0xa250ac77360d4e837a13628bC828a2aDf7BabfB3', // on rinkeby it could be another account\n        }\n    }\n}\n```\n\n<!-- You can also specify addresses with the `ledger://` prefix. In which case the account fetched will still be the corresponding address, but behind the scene, the transaction will be created via the hardware waller. Currently the feature is not working very well though and better support is needed. -->\n\n---\n\n### **2. extra hardhat.config networks' options**\n\n---\n\n**hardhat-deploy** add 5 new fields to `networks` configuration\n\n#### `live`\n\nthis is not used internally but is useful to perform action on a network whether it is a live network (rinkeby, mainnet, etc) or a temporary one (localhost, hardhat). The default is true (except for localhost and hardhat where the default is false).\n\n#### `saveDeployments`\n\nthis tell whether **hardhat-deploy** should save the deployments to disk or not. Default to true, except for the hardhat network.\n\n#### `tags`\n\nnetwork can have tags to represent them. The config is an array and at runtime the hre.network.tags is an object whose fields (the tags) are set to true.\n\nThis is useful to conidtionaly operate on network based on their use case.\n\nExample:\n\n```js\n{\n  networks: {\n    localhost: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"local\"]\n    },\n    hardhat: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"test\", \"local\"]\n    },\n    rinkeby: {\n      live: true,\n      saveDeployments: true,\n      tags: [\"staging\"]\n    }\n  }\n}\n```\n\n#### `deploy`\n\nthe deploy field override the paths.deploy option and let you define a set of folder containing the deploy scripts to be executed for this network.\n\nYou can thus have one network that will be executing L1 deployment and other L2 deployments, etc...\n\nYou could also have a folder that deploy contracts that are live on mainnet but that you need to replicate for your test or local network.\n\n#### `companionNetworks`\n\nthe companionNetworks field is an object whose key is any name you desire and the value is the name of a network that will be accessible inside the deploy script. For example:\n\n```js\n{\n  ...\n  networks: {\n    optimism: {\n      url: 'http://127.0.0.1:8545',\n      ovm: true,\n      companionNetworks: {\n        l1: 'localhost',\n      },\n    }\n  }\n  ...\n}\n```\n\nBy using name you can have the same deploy script used in different set of network.\n\nFor your test you could have the companion networks pointing to the same hardhat network, for test deployment, you could have rinkeby acting like your l2 while goerli act as your l1.\n\nAn example repo that show case a multi-network setup with optimism can be found here : https://github.com/wighawag/template-ethereum-contracts/tree/examples/optimism\n\ndeploy script can then access the network and its deployment as follow :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  const OVM_L1ERC20Gateway = await hre.companionNetworks['l1'].deployments.get(\n    'OVM_L1ERC20Gateway'\n  ); // layer 1\n\n  await execute(\n    'SimpleERC20_OVM',\n    {from: deployer, log: true},\n    'init',\n    OVM_L1ERC20Gateway.address\n  );\n};\n```\n\n---\n\n### **3. extra hardhat.config paths' options**\n\n---\n\n`hardhat-deploy` also adds fields to `HardhatConfig`'s `ProjectPaths` object.\n\nHere is an example showing the default values :\n\n```js\n{\n    paths: {\n        deploy: 'deploy',\n        deployments: 'deployments',\n        imports: 'imports'\n    }\n}\n```\n\nThe `deploy` folder is expected to contains the deploy script that are executed upon invocation of `hardhat deploy` or `hardhat node`.\nIt can also be an array of folder path.\n\nThe `deployments` folder will contains the resulting deployments (contract addresses along their abi, bytecode, metadata...). One folder per network and one file per contract.\n\nThe `imports` folder is expected to contains artifacts that were pre-compiled. Useful if you want to upgrade to a new solidity version but want to keep using previously compiled contracts. The artifact is the same format as normal hardhat artifact, so you can easily copy them over, before switching to a new compiler version.\n\n> This is less useful now that hardhat support multiple solidity compiler at once.\n\n---\n\n---\n\n### **4. deterministicDeployment (ability to specify a deployment factory)**\n\n---\n\nThis plugin extends the `HardhatConfig`'s object with an optional `deterministicDeployment` field.\n\n`deterministicDeployment` allows you to associate information that are used on each network for deterministic deployment. The information for each deterministic deployment consist out of a `factory`, a `deployer`, the required `funding` and a `signedTx` to deploy the factory. The default deterministic deployment used is the [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy). The factory expects a 32 bytes `salt` concatenated with the deployment data (see [EIP-1014](https://eips.ethereum.org/EIPS/eip-1014) for more information on these parameters).\n\nUsing the `deterministicDeployment` it is possible to define a different setup for the deterministic deployment. One use case for this is the deterministic deployment on networks that required replay protection (such as Celo or Avalanche). The [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy) can only be deployed on networks that don't enforce replay protection, therefore on other networks an alternative library has to be used. An example for this would be the [Safe Singleton Factory](https://github.com/gnosis/safe-singleton-factory) that is an adjusted version of the [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy) that contains signed transactions that include replay protection.\n\nThe information can be defined either as an object\n\n```js\n{\n    deterministicDeployment: {\n      \"4\": {\n        factory: \"<factory_address>\",\n        deployer: \"<deployer_address>\",\n        funding: \"<required_funding_in_wei>\",\n        signedTx: \"<raw_signed_tx>\",\n      }\n    }\n}\n```\n\nor as an function that returns the information for the deterministic deployment\n\n```js\n{\n  deterministicDeployment: (network: string) => {\n    return {\n      factory: '<factory_address>',\n      deployer: '<deployer_address>',\n      funding: '<required_funding_in_wei>',\n      signedTx: '<raw_signed_tx>',\n    };\n  };\n}\n```\n\n### Importing deployment from other projects (with truffle support)\n\n`hardhat-deploy` also add the `external` field to `HardhatConfig`\n\nSuch field allows to specify paths for external artifacts or **deployments**.\n\nThe external object has 2 fields:\n\n```js\n{\n    external: {\n        contracts: [\n          {\n            artifacts: \"node_modules/@cartesi/arbitration/export/artifacts\",\n            deploy: \"node_modules/@cartesi/arbitration/export/deploy\"\n          },\n          {\n            artifacts: \"node_modules/someotherpackage/artifacts\",\n          }\n        ],\n        deployments: {\n          rinkeby: [\"node_modules/@cartesi/arbitration/build/contracts\"],\n        },\n    }\n}\n```\n\nThe `contracts` field specify an array of object which itself have 2 fields.\n\n- `artifacts`: (mandatory) it is a path to an artifact folder. This support both hardhat and truffle artifacts.\n- `deploy`: (optional) it specifies a path to a folder where reside deploy script. The deploy scripts have only access to the artifact specified in the artifacts field. This allow project to share their deployment procedure. A boon for developer aiming at integrating it as they can get the contracts to be deployed for testing locally.\n\nThe `deployments` fields specify an object whose field nasme are the hardhat network and the value is an array of path to look for deployments. It supports both **hardhat-deploy** and truffle formats.\n\n---\n\n### Access to Artifacts (non-deployed contract code and abi)\n\nArtifacts in hardhat terminology represent a compiled contract (not yet deployed) with at least its bytecode and abi.\n\n`hardhat-deploy` gives can access to these artifact via the `deployments.getArtifact` function :\n\n```js\nconst {deployments} = require('hardhat');\nconst artifact = await deployments.getArtifact(artifactName);\n```\n\nWith the `hardhat-deploy-ethers` plugin you can get an artifact as an ethers contract factory, ready to be deployed, via the following:\n\n```js\nconst {deployments, ethers} = require('hardhat');\nconst factory = await ethers.getContractFactory(artifactName);\n```\n\n> Note that the artifact's files need to be either in `artifacts` folder that hardhat generate on compilation or in the `imports` folder where you can store contracts compiled elsewhere. They can also be present in the folder specified in `external.artifacts` see [Importing deployment from other projects](#importing-deployment-from-other-projects-with-truffle-support)\n\n---\n\n---\n\n## How to Deploy Contracts\n\n---\n\n### The `deploy` Task\n\n`hardhat --network <networkName> deploy [options and flags]`\n\nThis is a new task that the `hardhat-deploy` adds. As the name suggests it deploys contracts.\nTo be exact it will look for files in the folder `deploy` or whatever was configured in `paths.deploy`, see [paths config](#extra-paths-config)\n\nIt will scan for files in alphabetical order and execute them in turn.\n\n- it will `require` each of these files and execute the exported function with the HRE as argument\n\nTo specify the network, you can use the builtin hardhat argument `--network <network name>` or set the env variable `HARDHAT_NETWORK`\n\n> :warning: Note that running `hardhat deploy` without specifying a network will use the default network. If the default network is hardhat (the default's default) then nothing will happen as a result as everything happens in memory, but this can be used to ensure the deployment is without issues.\n\n---\n\n### Deploy Scripts\n\nThe deploy scripts need to be of the following type :\n\n```ts\nexport interface DeployFunction {\n  (env: HardhatRuntimeEnvironment): Promise<void | boolean>;\n  skip?: (env: HardhatRuntimeEnvironment) => Promise<boolean>;\n  tags?: string[];\n  dependencies?: string[];\n  runAtTheEnd?: boolean;\n  id?: string;\n}\n```\n\nThe skip function can be used to skip executing the script under whatever condition. It simply need to resolve a promise to true.\n\nThe tags is a list of string that when the _deploy_ task is executed with, the script will be executed (unless it skips). In other word if the deploy task is executed with a tag that does not belong to that script, that script will not be executed unless it is a dependency of a script that does get executed.\n\nThe dependencies is a list of tag that will be executed if that script is executed. So if the script is executed, every script whose tag match any of the dependencies will be executed first.\n\nThe `runAtTheEnd` is a boolean that if set to true, will queue that script to be executed after all other scripts are executed.\n\nThese set of fields allow more flexibility to organize the scripts. You are not limited to alphabetical order and you can even organise deploy script in sub folders.\n\nFinally the function can return true if it wishes to never be executed again. This can be usfeul to emulate migration scripts that are meant to be executed only once. Once such script return true (async), the `id` field is used to track execution and if that field is not present when the script return true, it will fails.\n\nIn other words, if you want a particular deploy script to run only once, it needs to both return true (async) and have an `id` set.\n\nIn any case, as a general advice every deploy function should be idempotent. This is so they can always recover from failure or pending transaction. This is what underpin most of hardhat-deploy philosophy.\n\nThis is why the `hre.deployments.deploy` function will by default only deploy if the contract code has changed, making it easier to write idempotent script.\n\n#### An example of a deploy script :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  // the following will only deploy \"GenericMetaTxProcessor\" if the contract was never deployed or if the code changed since last deployment\n  await deploy('GenericMetaTxProcessor', {\n    from: deployer,\n    gasLimit: 4000000,\n    args: [],\n  });\n};\n```\n\nAs you can see the HRE passed in has 4 new fields :\n\n- `getNamedAccounts` is a function that returns a promise to an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [`namedAccounts`](#namedaccounts)).\n\n- `getUnnamedAccounts` is a function that return a promise to an array of accounts which were not named (see [`namedAccounts`](#namedaccounts)). It is useful for tests where you want to be sure that the account has no speicifc role in the system (no token given, no admin access, etc...).\n\n- `getChainId` is a function which return a promise for the chainId, as convenience\n\n- `deployments` is an object which contains functions to access past deployments or to save new ones, as well as helpers functions.\n\nThat latter field contains for example the `deploy` function that allows you to deploy contract and save them. It contains a lot more functions though :\n\n---\n\n### The `deployments` field\n\nThe deployments field contains several helpers function to deploy contract but also execute transaction.\n\n```ts\nexport interface DeploymentsExtension {\n  deploy(name: string, options: DeployOptions): Promise<DeployResult>; // deploy a contract\n  diamond: {\n    // deploy diamond based contract (see section below)\n    deploy(name: string, options: DiamondOptions): Promise<DeployResult>;\n  };\n  deterministic( // return the determinsitic address as well as a function to deploy the contract, can pass the `salt` field in the option to use different salt\n    name: string,\n    options: Create2DeployOptions\n  ): Promise<{\n    address: Address;\n    implementationAddress?: Address;\n    deploy(): Promise<DeployResult>;\n  }>;\n  fetchIfDifferent( // return true if new compiled code is different than deployed contract\n    name: string,\n    options: DeployOptions\n  ): Promise<{differences: boolean; address?: string}>;\n  save(name: string, deployment: DeploymentSubmission): Promise<void>; // low level save of deployment\n  get(name: string): Promise<Deployment>; // fetch a deployment by name, throw if not existing\n  getOrNull(name: string): Promise<Deployment | null>; // fetch deployment by name, return null if not existing\n  getDeploymentsFromAddress(address: string): Promise<Deployment[]>;\n  all(): Promise<{[name: string]: Deployment}>; // return all deployments\n  getArtifact(name: string): Promise<Artifact>; // return a hardhat artifact (compiled contract without deployment)\n  getExtendedArtifact(name: string): Promise<ExtendedArtifact>; // return a extended artifact (with more info) (compiled contract without deployment)\n  run( // execute deployment scripts\n    tags?: string | string[],\n    options?: {\n      resetMemory?: boolean;\n      deletePreviousDeployments?: boolean;\n      writeDeploymentsToFiles?: boolean;\n      export?: string;\n      exportAll?: string;\n    }\n  ): Promise<{[name: string]: Deployment}>;\n  fixture( // execute deployment as fixture for test // use evm_snapshot to revert back\n    tags?: string | string[],\n    options?: {fallbackToGlobal?: boolean; keepExistingDeployments?: boolean}\n  ): Promise<{[name: string]: Deployment}>;\n  createFixture<T, O>( // execute a function as fixture using evm_snaphost to revert back each time\n    func: FixtureFunc<T, O>,\n    id?: string\n  ): (options?: O) => Promise<T>;\n  log(...args: any[]): void; // log data only ig log enabled (disabled in test fixture)\n\n  execute( // execute function call on contract\n    name: string,\n    options: TxOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<Receipt>;\n  rawTx(tx: SimpleTx): Promise<Receipt>; // execute a simple transaction\n  catchUnknownSigner( // you can wrap other function with this function and it will catch failure due to missing signer with the details of the tx to be executed\n    action: Promise<any> | (() => Promise<any>),\n    options?: {log?: boolean}\n  ): Promise<null | {\n    from: string;\n    to?: string;\n    value?: string;\n    data?: string;\n  }>;\n  read( // make a read-only call to a contract\n    name: string,\n    options: CallOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<any>;\n  read(name: string, methodName: string, ...args: any[]): Promise<any>;\n  // rawCall(to: Address, data: string): Promise<any>; // TODO ?\n}\n```\n\n---\n\n#### `deployments.deploy(<name>, options)`\n\n---\n\nThe `deploy` function, as mentioned above, allows you to deploy a contract and save it under a specific name.\n\nThe deploy function expect 2 parameters: one for the name and one for the options\n\nSee below the full list of fields that the option parameter allows and requires:\n\n```ts\nexport interface DeployOptions = {\n  from: string; // address (or private key) that will perform the transaction. you can use `getNamedAccounts` to retrived the address you want by name.\n  contract?: // this is an optional field. If not specified it defaults to the contract with the same name as the first parameter\n    | string // this field can be either a string for the name of the contract\n    | { // or abi and bytecode\n        abi: ABI;\n        bytecode: string;\n        deployedBytecode?: string;\n      };\n  args?: any[]; // the list of argument for the constructor (or the upgrade function in case of proxy)\n  skipIfAlreadyDeployed?: boolean; // if set it to true, will not attempt to deploy even if the contract deployed under the same name is different\n  log?: boolean; // if true, it will log the result of the deployment (tx hash, address and gas used)\n  linkedData?: any; // This allow to associate any JSON data to the deployment. Useful for merkle tree data for example\n  libraries?: { [libraryName: string]: Address }; // This let you associate libraries to the deployed contract\n  proxy?: boolean | string | ProxyOptions; // This options allow to consider your contract as a proxy (see below for more details)\n\n  // here some common tx options :\n  gasLimit?: string | number | BigNumber;\n  gasPrice?: string | BigNumber;\n  value?: string | BigNumber;\n  nonce?: string | number | BigNumber;\n\n  estimatedGasLimit?: string | number | BigNumber; // to speed up the estimation, it is possible to provide an upper gasLimit\n  estimateGasExtra?: string | number | BigNumber; // this option allow you to add a gas buffer on top of the estimation\n\n  autoMine?: boolean; // this force a evm_mine to be executed. this is useful to speed deployment on test network that allow to specify a block delay (ganache for example). This option basically skip the delay by force mining.\n  deterministicDeployment? boolean | string; // if true, it will deploy the contract at a deterministic address based on bytecode and constructor arguments. The address will be the same across all network. It use create2 opcode for that, if it is a string, the string will be used as the salt.\n  waitConfirmations?: number; // number of the confirmations to wait after the transactions is included in the chain\n};\n```\n\n---\n\n---\n\n## Handling contract using libraries\n\nIn the deploy function, one of the `DeployOptions` field is the `libraries` field. It allows you to associate external contract as libraries at the time of deployment.\n\nFirst, you have deploy the library using the `deploy` function, then when we deploy a contract that needs the linked library, we can pass the deployed library name and address in as an argument to the `libraries` object.\n\nFirst step: deploy the library:\n\n```js\nconst exampleLibrary = await deploy(\"ExampleLibary\", {\n    from: <deployer>\n});\n\n```\n\nExampleLibrary is now deployed to whatever network was chosen (`hardhat deploy --network <networkName>`)\n\nFor example, if we are deploying on Rinkeby, this library will get deployed on rinkeby, and the `exampleLibrary` variable will be a deployment object that contains the abi as well as the deployed address for the contract.\n\nNow that the library is deployed, we can link it in our next deployed contract.\n\n```js\nconst example = await deploy(\"Example\", {\n    from: <deployer>\n    args: [\"example string argument for the 'Example' contract constructor\"],\n    libraries: {\n        ExampleLibrary: exampleLibrary.address\n    }\n});\n\n```\n\nThis `libraries` object takes the name of the library, and its deployed address on the network. Multiple libraries can be passed into the `libraries` object.\n\n---\n\n---\n\n## Exporting Deployments\n\nApart from deployments saved in the `deployments` folder which contains all information available about the contract (compile time data + deployment data), `hardhat-deploy` allows you to export lightweight files.\n\nThese can be used for example to power your frontend with contract's address and abi.\n\nThis come into 2 flavors.\n\nThe first one is exported via the `--export <file>` option and follow the following format :\n\n```ts\nexport interface Export {\n  chainId: string;\n  name: string;\n  contracts: {[name: string]: ContractExport};\n}\n```\n\nwhere name is the name of the network configuration chosen (see hardhat option `--network`)\n\nThe second one is exported via the `--export-all <file>` option and follow the following format :\n\n```ts\nexport type MultiExport = {\n  [chainId: string]: Export[];\n};\n```\n\nAs you see the second format include the previous. While in most case you'll need the single export where your application will support only one network, there are case where your app would want to support multiple networks at nonce. This second format allow for that.\n\nFurthermore as hardhat support multiple network configuration for the same network (rinkeby, mainnet...), the export-all format will contains each of them grouped by their chainId.\n\nNote: from v0.10.4 the old multi-export down is no more:\n\n```\nexport type MultiExport = {\n  [chainId: string]: {[name: string]: Export};\n};\n```\n\n---\n\n---\n\n## Deploying and Upgrading Proxies\n\nAs mentioned above, the deploy function can also deploy a contract through a proxy. It can be done without modification of the contract as long as its number of constructor arguments matches the proxy initialization/update function.\n\nThe default Proxy is both ERC-1967 and ERC-173 Compliant, but other proxy can be specified, like openzeppelin transparent proxies.\n\nCode for the default Proxy can be found [here](solc_0.7/proxy/EIP173Proxy.sol).\n\nTo perform such proxy deployment, you just need to invoke the deploy function with the following options : `{..., proxy: true}`\n\nSee example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: true,\n  });\n};\n```\n\nYou can also set it to `proxy: \"<upgradeMethodName>\"` in which case the function `<upgradeMethodName>` will be executed upon upgrade.\nthe `args` field will be then used for that function instead of the contructor. It is also possible to then have a constructor with the same arguments and have the proxy be disabled. It can be useful if you want to have your contract as upgradeable in a test network but be non-upgradeable on the mainnet.\n\nSee example :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  network,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: network.live ? false : 'postUpgrade',\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nThe proxy option can also be an object which can set the specific owner that the proxy is going to be managed by.\n\nSee example:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: {\n      owner: greeterOwner,\n      methodName: 'postUpgrade',\n    },\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nNote that for the second invokation, this deployment will not be executed from the specified `from: deployer` as otherwise these tx will always fails. It will instead be automatically executed from the proxy's current owner (in that case : `greeterOwner`)\n\nNow, it is likely you do not want to locally handle the private key / mnemonic of the account that manage the proxy or it could even be that the `greeterOwner` in question is a multi sig. As such that second invocation will throw an error as it cannot find a local signer for it.\n\nThe error will output the necessary information to upgrade the contract but `hardhat-deploy` comes also with a utility function for such case: `deployments.catchUnknwonSigner` which will catch the error and output to the console the necessary information while continuing to next step.\n\nHere is the full example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy, catchUnknownSigner} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await catchUnknownSigner(\n    deploy('Greeter', {\n      from: deployer,\n      proxy: {\n        owner: greeterOwner,\n        methodName: 'postUpgrade',\n      },\n      args: ['arg1', 2, 3],\n    })\n  );\n  // you could pause the deployment here and wait for input to continue\n};\n```\n\nThe full proxy options is as follow:\n\n```ts\ntype ProxyOptionsBase = {\n  owner?: Address; // this set the owner of the proxy. further upgrade will need to be executed from that owner\n  upgradeIndex?: number; // allow you to breakdown your upgrades into separate deploy scriot, each with their own index. A deploy call with a specific upgradeIndex will be executed only once, only if the current upgradeIndex is one less.\n  proxyContract?: // default to \"EIP173Proxy\". See below for more details\n  string | ArtifactData;\n  viaAdminContract?: // allow to specify a contract that act as a middle man to perform upgrades. Useful and Recommended for Transparent Proxies\n  | string\n    | {\n        name: string;\n        artifact?: string | ArtifactData;\n      };\n};\n\nexport type ProxyOptions =\n  | (ProxyOptionsBase & {\n      methodName?: string; // method to be executed when the proxy is deployed for the first time or when the implementation is modified. Use the deployOptions args field for arguments\n    })\n  | (ProxyOptionsBase & {\n      execute?:\n        | {\n            methodName: string; // method to be executed when the proxy is deployed for the first time or when the implementation is modified.\n            args: any[];\n          }\n        | {\n            init: {\n              methodName: string; // method to be executed when the proxy is deployed\n              args: any[];\n            };\n            onUpgrade?: {\n              methodName: string; // method to be executed when the proxy is upgraded (not first deployment)\n              args: any[];\n            };\n          };\n    });\n```\n\nThe `proxyContract` field allow you to specify your own Proxy contract. If it is a string, it will first attempt to get an artifact with that name. If not found it will fallback on the following if\n\nit matches:\n\n- `EIP173Proxy`: use the default Proxy that is EIP-173 compliant\n\n- `EIP173ProxyWithReceive`: Same as above except that the proxy contains a receive hook to accept empty ETH payment.\n\n- `OpenZeppelinTransparentProxy`: Use Openzeppelin Transparent Proxy (copied from openzeppelin repo, see code [here](solc_0.7/openzeppelin/proxy/TransparentUpgradeableProxy.sol))\n  When this option is chosen, the `DefaultProxyAdmin` is also used as admin since Transparent Proxy kind of need an intermediarry contract for administration. This can be configured via the `viaAdminContract` option. Note that the DefaultProxyAdmin is slightly different than the one used by openzeppelin as it allow you to set a different owner than msg.sender on first deploy, something openzeppelin version do not allow, see : https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2639\n\n- `OptimizedTransparentProxy`: This contract is similar to above, except that it is optimized to not require storage read for the admin on every call.\n\n## Builtin-In Support For Diamonds (EIP2535)\n\nThe deployments field also expose the diamond field: `hre.deployments.diamond` that let you deploy [Diamonds](https://eips.ethereum.org/EIPS/eip-2535) in an easy way.\n\n### deployment / upgrade\n\nInstead of specifying the facets to cut out or cut in, which the diamond contract expects, you specify the facets you want to end up having on the deployed contract.\n\nThis declarative approach allow you to focus on what you want instead of how to do it.\n\n`diamond.deploy` expect the facet as names. The names represent contract to be deployed as facet. In future version you ll be able to specify deployed contract or artifact object as facet.\n\nTo deploy a contract with 3 facet you can do as follow :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: deployer,\n    owner: diamondAdmin,\n    facets: ['Facet1', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nif you then later execute the following script:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: diamondAdmin, // this need to be the diamondAdmin for upgrade\n    owner: diamondAdmin,\n    facets: ['NewFacet', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nThen the NewFacet will be deployed automatically if needed and then the diamondCut will cut Facet1 out and add NewFacet.\n\nNote that if the code for Facet2 and Facet3 changes, they will also be redeployed automatically and the diamondCuts will replace the existing facets with these new ones.\n\nNote that the diamond has 3 facet added by default. These facets are used for ownership, diamondCut and diamond loupe.\n\nThe implementation is a sligthly modified version of the [reference implementation by Nick Mudge](https://github.com/mudgen/diamond-3).\nTHe only difference is the custom constructor that allow multiple initialization, used to allow the default ERC165 facet to be initialised along your custom initialization function.\n\n### onUpgrade calls\n\nLike normal proxies you can also execute a function at the time of an upgrade.\n\nThis is done by specifying the execute field in the diamond deploy options :\n\n```js\ndiamond.deploy('ADiamondContract', {\n  from: deployer,\n  owner: diamondAdmin,\n  facets: ['NewFacet', 'Facet2', 'Facet3'],\n  execute: {\n    methodName: 'postUpgrade',\n    args: ['one', 2, '0x3'],\n  },\n});\n```\n\n### more...\n\nThere are more options, to be described later...\n\n## Testing Deployed Contracts\n\nYou can continue using the usual test task:\n\n`hardhat test`\n\nTests can use the `hre.deployments.fixture` function to run the deployment and snapshot it so that tests don't need to perform all the deployment transactions every time. They can simply reuse the snapshot for every test (this leverages `evm_snapshot` and `evm_revert` provided by both `hardhat` and `ganache`). You can for example set them in a `beforeEach`.\n\nHere is an example of a test :\n\n```js\nconst {deployments} = require('hardhat');\n\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    await deployments.fixture(['Token']);\n    const Token = await deployments.get('Token'); // Token is available because the fixture was executed\n    console.log(Token.address);\n    const ERC721BidSale = await deployments.get('ERC721BidSale');\n    console.log({ERC721BidSale});\n  });\n});\n```\n\nTests can also leverage named accounts for clearer test. Combined with `hardhat-deploy-ethers` plugin, you can write succint test :\n\n```js\nconst {ethers, getNamedAccounts} = require('hardhat');\n\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    await deployments.fixture(['Token']);\n    const {tokenOwner} = await getNamedAccounts();\n    const TokenContract = await ethers.getContract('Token', tokenOwner);\n    await TokenContract.mint(2).then((tx) => tx.wait());\n  });\n});\n```\n\n---\n\n### Creating Fixtures\n\nFurthermore, tests can easily create efficient fixture using `deployments.createFixture`\n\nSee example :\n\n```js\nconst setupTest = deployments.createFixture(\n  async ({deployments, getNamedAccounts, ethers}, options) => {\n    await deployments.fixture(); // ensure you start from a fresh deployments\n    const {tokenOwner} = await getNamedAccounts();\n    const TokenContract = await ethers.getContract('Token', tokenOwner);\n    await TokenContract.mint(10).then((tx) => tx.wait()); //this mint is executed once and then `createFixture` will ensure it is snapshotted\n    return {\n      tokenOwner: {\n        address: tokenOwner,\n        TokenContract,\n      },\n    };\n  }\n);\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    const {tokenOwner} = await setupTest();\n    await tokenOwner.TokenContract.mint(2);\n  });\n});\n```\n\nWhile this example is trivial, some fixture can requires several transaction and the ability to snapshot them automatically speed up the tests greatly.\n\n---\n\n---\n\n## More Information On Hardhat Tasks\n\n---\n\n### **1. node task**\n\nas mentioned above, the node task is slighly modified and augmented with various flags and options\n\n`hardhat node`\n\nIn particular it adds an argument `--export` that allows you to specify a destination file where the info about the contracts deployed is written.\nYour webapp can then access all contracts information.\n\n---\n\n### **2. test task**\n\n`hardhat test`\n\nthe test task is augmented with one flag argument `--deploy-fixture` that allows to run all deployments in a fixture snapshot before executing the tests. This can speed up the tests that use specific tags as the global fixture take precedence (unless specified).\n\nIn other word tests can use `deployments.fixture(<specific tag>)` where specific tag only deploys the minimal contracts for tests, while still benefiting from global deployment snapshot if used.\n\nIf a test needs the deployments to only include the specific deployment specified by the tag, it can use the following :\n\n```js\ndeployments.fixture('<specific tag>', {fallbackToGlobal: false});\n```\n\nDue to how snapshot/revert works in hardhat, this means that these tests will not benefit from the global fixture snapshot and will have to deploy their contracts as part of the fixture call. This is automatic but means that these tests will run slower.\n\n---\n\n### **3. run task**\n\n`hardhat --network <networkName> run <script>`\n\nThe run task act as before but thanks to the `hre.deployments` field it can access deployed contract :\n\n```js\nconst hre = require('hardhat');\nconst {deployments, getNamedAccounts} = hre;\n\n(async () => {\n  console.log(await deployments.all());\n  console.log({namedAccounts: await getNamedAccounts()});\n})();\n```\n\nYou can also run it directly from the command line as usual.\n\n`HARDHAT_NETWORK=rinkeby node <script>` is the equivalent except it does not load the hardhat environment twice (which the run task does)\n\n---\n\n### **4. console task**\n\n`hardhat console`\n\nThe same applies to the `console` task.\n\n---\n\n## Deploy Scripts: Tags And Dependencies\n\n---\n\nIt is possible to execute only specific parts of the deployments with `hardhat deploy --tags <tags>`\n\nTags represent what the deploy script acts on. In general it will be a single string value, the name of the contract it deploys or modifies.\n\nThen if another deploy script has such tag as a dependency, then when this latter deploy script has a specific tag and that tag is requested, the dependency will be executed first.\n\nHere is an example of two deploy scripts :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const deployResult = await deploy('Token', {\n    from: deployer,\n    args: ['hello', 100],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Token deployed at ${deployResult.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Token'];\n```\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const Token = await deployments.get('Token');\n  const deployResult = await deploy('Sale', {\n    from: deployer,\n    contract: 'ERC721BidSale',\n    args: [Token.address, 1, 3600],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Sale deployed at ${deployResult.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.dependencies = ['Token']; // this ensure the Token script above is executed first, so `deployments.get('Token')` succeeds\n```\n\nAs you can see the second one depends on the first. This is because the second script depends on a tag that the first script registers as using.\n\nWith that when `hardhat deploy --tags Sale` is executed\n\nthen both scripts will be run, ensuring Sale is ready.\n\nYou can also define the script to run after another script is run by setting `runAtTheEnd` to be true. For example:\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, execute, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer, admin} = namedAccounts;\n  await execute('Sale', {from: deployer}, 'setAdmin', admin);\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.runAtTheEnd = true;\n```\n\nTags can also be used in test with `deployments.fixture`. This allow you to test a subset of the deploy script.\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.5-zksync.1","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-QypMm9eP6okoBSVeHMIwACiqqRbwf5BDFYbRyAIggdLxRwYugnIEPimIfcHRX1IiYRhY75lsuReElxuOWtpCBg==","shasum":"fa11e78df43a29d3af03f1c1fc81d438014eab23","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.5-zksync.1.tgz","fileCount":149,"unpackedSize":12161310,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCICzxyeWzyFzYhCTY+rdxFJabNHCdmX1i7SSWmxoXzdo5AiEAqF6EHeU+f2mpR680G41ebJh6Uisn/4IC9Uu2gRmPmGE="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJig1yjACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmpnrA/+N6S23vGTv5JI9NVVzN0fXhTlG3lShXkx118ECMfSSCLETd2V\r\nTNKTgJ8oZ39k71J3QDPVVWLCAh7plvhP/Vvrp8jMVJTCjl+1w+z3VUn0DJFe\r\nlveBIFi10gyc+1BxtO1lOitVyo3cfZamoelUPQKgwGJY2ghJaUvLoMH5IVzq\r\nHs+WN0lDhhg+mAOGTfbEPffxKqBDC+BqwVNC3HpTIXW38olQY6RpZEjOliFc\r\ndHkG6X/6hFxP1HOGo1uTbsRYM/VYPb2X1t49XUvjqNQjwUur9dBoZNKekhEU\r\ngb8g1d7Hqi5zAtbli+r/M1cwCgIhxRYzhHTc/RDPO9AaOyTBE/yCli5SaQth\r\nbdiFUYwbRwzv3k+QcRWynRxDe9Psa2qDrYAAnKJy9nGM7TVgGcYkqZMgPaIO\r\nGppBPIMowXtF7uAFXX52OnZ5K5ViDOsRURR9Jyx+yDRJ32uFPIYRLdH5691Z\r\nQVa4OAklXScvkdCyhz/6/Wqs4oSCdLTFMu6ZdO6a/L/iosDTETwIYhzMZqcg\r\nnGxzwzCHdPHI//iSRkGrwJfNEMtjYNHuyLY83sok6VqDrEBNEkjnDGFUf1Zf\r\nLmBjpHmE/lapB4/1axR/WMDA6ckOhBiNaK96edSgh6Vw1fQV9lFpoxJ6knF9\r\nyxQoePHjLkRpbjoNFJnZIgxIfFtG93PdyVM=\r\n=F20M\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.5-zksync.1_1652776099611_0.2301571804395086"},"_hasShrinkwrap":false},"0.11.5":{"name":"hardhat-deploy","version":"0.11.5","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.9.0","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"dependencies":{"@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","ethers":"^5.5.3","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","zksync-web3":"^0.4.0"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"9c8cd433a37188e793181b727222e2d22aef34b0","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.5","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-3AZqbwNzM/CKqdMI5FNWkCm8bFO2BdKrTAdYiu19bg6DL0TIUbjfqS8xRY691tu595wd0s+k3ZRHgCB4eopWTg==","shasum":"c73324ec16a6f330356de86297290f7a2eb69bf5","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.5.tgz","fileCount":149,"unpackedSize":12161391,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIF+mwgD7BG3hckLK/By/Y7/SF9QD7fQPiSatIuw56e8IAiEAtJOQxW9aa9rUJUYL7qoiqyg8EfkfWzsejfap8TYUyJg="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJig1zgACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmouPA//YbMmEZd0SvoS35bvCDNdU0Az9KlgaBErZJg9Hyn4Fa6NuwKe\r\nvxcgEC6Aj7jOlpmZw21GXGdeCbS8F99nhly58uMz6mJod6j4KKHU8zjFKJo5\r\ncOdRKwsvHXPcVJKhDabfcpp44e7xxxtGSc97Dusil0Dt1Flqrqw1EIQ8uq9D\r\nrfNTDGsUT7TjPhliuwpD1NeKGDo9mQzGeT84Y+LIaQdnrfP9p0RHbAz3FwEJ\r\njJGMrUSpQG+0KUoVq8am+3La8gW8mSsZl4ZEt/2BvKqE7GJGM/jZadDe8drl\r\nH411pPgNblyRWkB3+tMUMWQ6jAvM5gwBu1cjbgE5wS59ZJfNaxR1BfZoN3nv\r\n0yBqv5a+ejwr34BANiLBYJCODddoR1pdJ9CgDhxyi0GspL2kYdmTZ9OVKUYi\r\nZZf89UcSgffFAZLz5j+s7iyav7aRuT0zAT6DKhRCMkrgz77uc88m+ELj9hnd\r\nhcgYixoRVB2nIqHW6xnlQ0njXRAsHTpDraSJ/mdpFvB1S4NRhtB4AGc8HDI9\r\nZB/4vvkTkHCTWi2ai1OulnggpPW6hnliDaMCVnq2ecVHrVXDZAunG+Nx8xtG\r\nue9RMcZ7sSuKVhxed3EecK/rWP51FA4M8bYM20cZN3F3naS0stZ6hvITH3O9\r\nMZROaLcASyeTYQR/Rq5Xis6bNxGtaLf6jSs=\r\n=Ocwg\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.5_1652776159983_0.9540448270654422"},"_hasShrinkwrap":false},"0.11.6":{"name":"hardhat-deploy","version":"0.11.6","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.9.0","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"dependencies":{"@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","ethers":"^5.5.3","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","zksync-web3":"^0.4.0"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"9de0e46cfdfd13279733d03abb54961cf8c365d3","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.6","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-i5Ih3OeJ9c2r191wD+S6Z1ymMR++FS2FH5XXD4HNCUETkPLaNpAF+M0NaNLu/Zkyayh3E4cpayGb+rO2mE+MSA==","shasum":"01b7ab925a715588397cdaead240ad3616371019","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.6.tgz","fileCount":149,"unpackedSize":12165999,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIGXkBRjMmbUH+FFnTAvQOqIefjR9n+W8pa8Jj+qz8n3RAiEAuoXTpD8sBEf1vhs0+p8A3IbUTUfVrioHycWJdPXoA44="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJih+3BACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmo1fg//bNZpmMfTHjv/gkRg1Rt7GIUBemBlCLNjW7U4g1aRJyBuRN1I\r\nxIDpfQ+HqsflTIlR1pKD5BxTQTsP3IU/8JRanb+TeOwrTg+WlOaVEXnuZSRF\r\nLYrZpeK5hXA/ETP/V3ncnCxqmpawjOvlBWeUA5iDYV/0PzLzLyCogsYpDPhn\r\nFVO5xM9oUfFPpEX+M60HJDMjEe53c+H90Q7eBRQnbgFX7q3tItkJxYjc+Igo\r\nUNCD+GTbSx0ai71cPCOg66Gv+y8l9byO08FeqRalFrgIEkbETPAa85cfKXvV\r\nuZwa5BUn5cts61Awro2176Q4STyxKtHMtoNfrytuongV7q/7SXIktZjZeZQA\r\nlIAPqD1pLQX7S0C2drlV33cZJit4SEjOSJ/ZU7Q5HTRi2oBhh+NlmGdTZjox\r\n1novZe5G6TtR0/XAPDMjwhXJcDmpa47Q9J/HejEvHqlAhm5ZaNsQkvLJVTF8\r\ndh7M98b1/F4ViPvCBCvW24LAa9tMxwSvCXmT8ZtVy27rCLFy2HG7g+6W/exZ\r\n6zvq8OYxU/f2fX1nsME+qrT/Q2Rc8ignayfQ5T1bgvxPSjL70oXaFL8TBr4Y\r\nw2dTFU8VBOA/9Qx1KqcQ+xFeKzX3AQKEn/Mh0+1doTk4Q34nbVHl954irk8R\r\nhAghks8FqXpEbxGVmNIommgzp6HMkpQ04b8=\r\n=jJ8N\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.6_1653075393515_0.4619288876696106"},"_hasShrinkwrap":false},"0.11.7":{"name":"hardhat-deploy","version":"0.11.7","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.9.0","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"dependencies":{"@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","ethers":"^5.5.3","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","zksync-web3":"^0.4.0"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"05141c48ca04dd51e8536e4da4a1f989ea92242a","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.7","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-SzmRdILhljlHC+MvK+xt45Lj/5/BU9fIyNjkaB242Sv7BLyo8tsMwZz4AxIBx7ETKDijND+OIsbNzUQPlhoD9g==","shasum":"2a20186fbec1366811a1715013cbd94c1f7638bd","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.7.tgz","fileCount":149,"unpackedSize":12166179,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDX+haS6DQL/teKQz1q10E0pFSMaWqI26nyW+cWliJHoAIgLcVZ0Nb6HsaiMil9seTd5bY51/gRwpAUxbDqQij3FRY="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJih++5ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmoYrA//bM+Dd7UiG2lDmjFEKIwQF0wDWTgrrmO+C6oZfsM11tF2Ncyi\r\nFBLrQfjYv9IceVF/VAL+o+SbuWM64ItKp/e8V5JR3t+l3pjSIV3LL7jicxBd\r\n2kLvw06VUr29Ct5mEms+7M8MXYyknrpYlOQyTTBxrzkmq21j870YSZk24NFz\r\n/zCl5Dd3AbhKmNbrwDsTevrcD21x0cuw0QkW25aVW/WBVbIcKu+Gyah8TtTW\r\nw7yHykmWubH6CHcwkQwixt+Ax45KWuGLzNZsSgabNjLqKgcJU1AgeBYxSaYO\r\nS9noKLuYGtbmoK3I7AMBZvMfbn3F05YZlXFv54PslFSHWyoGdr90scLxRUcR\r\nDBi9E0bNjO68n523zrKnX6zGod/SO4EBorRWbbRlGmQHf4LX8aGTGK5t6xXd\r\nyxMfscvK9mbpQx93gs0HPyiQSGRJjgKY0dvo2wQCFrioK+8vdcXgCLAC8JL+\r\ngWHn+8+hH8H/1sgaj8TYIfLkJMY6UjGmkFAgebpYSAylE9+eQe2f7IctvkKH\r\ne1IX62np6uvOmM5cjAXJjEpIkhrgJAHgYt9uAMzTdsY04x7fkNikeIcXsN+D\r\n5aBjZ69j5sGOLJV6+fcCU92HfM+QNMucpokdWw7Zhb/eJETkcgstWDz4wuUL\r\nk2D4J0HCoKyEH2LkjpTE+gD8+jIyXG9nubg=\r\n=KV/T\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.7_1653075896866_0.7184643770619392"},"_hasShrinkwrap":false},"0.11.8":{"name":"hardhat-deploy","version":"0.11.8","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.9.0","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"dependencies":{"@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","ethers":"^5.5.3","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","zksync-web3":"^0.4.0"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"1f8d547ed4642e127f74f6a3aaa1cbbe424c4ee4","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.8","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-Z9mRetxaMimv0pLipxN1JzrqWhEV1fOhmcc0ie+WO7zH8RnCyScpFp1xaGkP4ZliMcmb9UXJXJ9yfqSrwP5I+Q==","shasum":"0a1914e0864d3b449104dc362f6be92b5c0617a1","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.8.tgz","fileCount":149,"unpackedSize":12166221,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCWFFwVpy6UZePmtAu0TOotnSEEiioYs5Gh/P1wqT18ygIhAJ1iFisOnFlFVdh63bOb/MnAqTbH7HBaY5dGzs3Krqaf"}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJih/WxACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmrItw/9E55NtrTN1XgJvC5Reqk1g5iIuiKxwXcwgFXr7A6RzvffoIfm\r\nNtr8Z/zW3mFul2D6akP2Lv/MFYz48IzcbvOhis9GHQRuloQpR/KUbhi4miy5\r\noIUZGObNGRIjBb9R5lP4sICX68NzIGXDmqHsS0YgFGu2OfHjPioiqLz+d9J/\r\nH5wgJ67FcSw1Z4CH00W5t8DcQVxYQgIdCn4F4qcNgNaD7i1mofrU2DrKXXAP\r\nzTcbNLTGfapO8LnBf/nzKFvDh9JaKUFwpxwF0FivNMVnbFfS86y2/5Cwf61o\r\nlKWQv5TM159X4Pb4L7hMrlXW4tpud0yFy0BF1Ppy+F5sgnbqWhJADpNt0+k9\r\nvTCW6t6JjoPgPx2L/fYbGvAe3pAfKNOoAAZCAUMK1QNg2HMNzjSucUY1o9cA\r\n5qpsgCRZnuAjVtuWclnq5E4kNcFRjj7ACmQ5RcB76etXBRC2DHCkA06WT/SM\r\nhRjWXennaIYWM8SZ4D1q+llMM9v0L+HrP33tMEc94+mvO22xWoajPU8/sfCe\r\nl5ayCNdyGJQ/b4vFzli1r6iuB/p/2Bg58Ghg3uteoHIXJ/gUU5EXyl5XAI4z\r\nUxHyn+KsNYhrSVZ73bzqrDfATAnaSdr5BSxU0I4v0MmORZLhXf0//9fke8Kk\r\n4DKlzK4ddimzFAFBC2tfiPMi7fjqgxXPoaw=\r\n=JPzU\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.8_1653077425588_0.5988575659536353"},"_hasShrinkwrap":false},"0.11.9":{"name":"hardhat-deploy","version":"0.11.9","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.9.0","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"dependencies":{"@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","ethers":"^5.5.3","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","zksync-web3":"^0.4.0"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"06e80d86d31c4a2cd7fd2175e428a798fad9f4b8","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.9","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-B3TLFPIfC3ATrKczan7ny3/gzbPmdbUjKBdAUeqER2bZR7UF51x3ix2XnSxcC18YNjNds1qrOEVluki9ZFANyw==","shasum":"f40268489931e92fc31019cfa26e7fd33533b575","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.9.tgz","fileCount":149,"unpackedSize":12167623,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIEaLfVf024BnQbvkbdAbkXDtjdaRlzdQ0v0VKte/wTu8AiAbmnNWqyIq8Gc/B6FHrul3e4SWCXbPBCDoPijnbJkObw=="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJih/pPACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqM3g/+L53rjeAJJsA2kix88/cg7FooqaegXinrafLbwkpWhFFl1pHz\r\nUPzTyUC2UH2e5XTyAINp5NQCgc+rPHSnAlhW3O+YiO9Voz7U828GiEm/6q3Y\r\noW5gHon5+v1S8w/sR0Tzid8pIghdrk7Sz7PHqqQjHG8Byq/zrMfbbRnhPnhf\r\n2gDe1uEjNhtOUTXVqoDrlsANEoeEgjFFZjuBRmRN+J2KpANX4k4V5DUu9joj\r\nJO/yHkBieznOedSweZrTHjQtGBDDiujiMANwxCgEECKwFz61kAQEO7dDQQee\r\nfiahUeWgspWJfvDhmmjjtpvhLrOCD7pqU4GAGyycbgy/u8/4QM5MhFwHJP6A\r\nLvUKEWZTQ4hjOuyIVePQeXbRr6LH8sF9l5hZ+T1clBuQXYX8yQI/KoCU6axP\r\nzRwMV8ikxJ4hrlAiRlOkUj2AauFtJCumQ0ozDkrQKrY0rhkKYpd354tcvIl1\r\nS/rHML1TtvQtQs5seJOriJOcl6ySx/E+L/WQTWHx7u+hTarFVyGp77QENR1t\r\n8/UeoWpyCf4mso7IvaAHYz3g7b+XbrYoyeHKlnWrob9sR84fXP3unI/gc1M8\r\nUGiz5+jEjXlR9jcy5lJojOpc7vQsM+x416g6Y4nTU1R3LpMf/ZqFR4cH6puR\r\nsJARtjop0hi61PuBqN+YX9ldd6xHR2H9V6I=\r\n=ruOH\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.9_1653078607120_0.39425957622278296"},"_hasShrinkwrap":false},"0.11.10":{"name":"hardhat-deploy","version":"0.11.10","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.9.0","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"dependencies":{"@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","ethers":"^5.5.3","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","zksync-web3":"^0.4.0"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"819df0fad56d75a5de5218c3307bec2093f8794c","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.10","_nodeVersion":"14.17.6","_npmVersion":"6.14.15","dist":{"integrity":"sha512-Iby2WhDuAdaKXFkcrMbaA9YWOgDMBnuwixCk4TfBBu8+mBGI9muYsbU/pCMkKfXA4MwSHENweJlfDMyyz7zcNA==","shasum":"5d34020ae2d475a9278d5dd5f493d86290a35b4d","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.10.tgz","fileCount":149,"unpackedSize":12169387,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCxuX92QcfCY4y8FLwwhv1sYzgxK5bdugCR4bc2PrmeeAIhAL9zvrZ6IyEI5ZENJmIJepQauMOkGsymjP/iEiepIRud"}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJii0bTACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmrVYA/+NibWGoqe2UDAt17urvK13iG8v1NOJbvjrOeQEOxtQ6B+DO7P\r\nLut0c2BGr/Y425kDygIJhGcZvKh45cub6rhMULxhozMa2RrOol1hML/Mw5fq\r\nqIQgIEMhPR8WP8ScuFp9+Xpau4nYABiXTnq++rKty84aZoHvbTfPJNoZyz7q\r\nkJSrS3OEKd1zid/jwf28sTsi9JEKhHRFRoN+cLyRwtcjYEf7gq2/xN5GDIvv\r\nBaVeMPS13bF+HwX025G5al/YEkEWN/pK1KuWOhbRuDdJ2/zvjtnco0ZDNAHI\r\nABQ6V+PyJAXKQIZKKONgb6fekV+qB1ABpel6cI0r/xOaW5k/PMSC86eTzOP1\r\ntpLiFkvyHxRP75jvUCigTWu27r0881wHc69amcTzLYrfK2iKOB1GX46t08MR\r\nPZMGcDdREEdco5gH2fc0/x/ciLvWrnW7OI+zBEcd4+0PrCNzMBXHYNoYpw9a\r\nBzz8CEqOT0ZQfGdqzn4rLpU4WHPSqyO/OlpgwBmbFhI109YQRSiwmTn7AbxL\r\nJRe5qH78Uomhvu4JXLEcKm5dodEwEPVUlNx2tQamMdN5MjFhP1wMaBOn+QOE\r\ncnAfOXENDmqa3eafnVYTExnWCdWRKqonRpFtnTnmdWkY10FWRYRFApHX7xG1\r\nBkKwcbbeoOhol/5OCIITCmbwasuZul/EKZ4=\r\n=1eqP\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.10_1653294803410_0.29002860928390817"},"_hasShrinkwrap":false},"0.11.11":{"name":"hardhat-deploy","version":"0.11.11","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.9.0","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"dependencies":{"@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","ethers":"^5.5.3","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","zksync-web3":"^0.7.8"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"91a749a5d10536540f9d5caa5bf5c80a783c2520","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.11","_nodeVersion":"16.15.1","_npmVersion":"8.11.0","dist":{"integrity":"sha512-/37No1l6aFMMc4+t+a0/8gk6OwwD4tyW8bSQqV/0IZEiaHiNa7hOV4rTbC9B7277SDHVoFUrV/fwmk7IDiB8sQ==","shasum":"479040ba84d5b6d582d8fc719a3e77656ba8dc66","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.11.tgz","fileCount":148,"unpackedSize":12154002,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQC6FX4dQRpE3lWhcV/Ht/oglnfmdzxNf+EBgbd1X0XoMQIhAOcfRAdOATGz/V2NT0BWNcUfFfX5WLnNUnKmBHqvbySE"}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJivF+UACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmrDUg//Rl4mw5NH4g8tUQKXLP0CFfMZGQYJh6gcAqw8yIKlD0+PH8rQ\r\nAzmwPv5NYqG8xcojRpkaOaTu1kK51UOMKy3rnax3YVAt+1lrI8Ehlzc4Waz2\r\nIk44uLbrUgEG7dqIG+/eJCQsd6Toh3uUyPulrMWYu6mX2Jo8HQU1xh9eU7lq\r\nTXVYCZZ+8lGhD4fOdFvokSWMobmdGngLdb4Pr2RlQC9WrU9vBoXwPsz8WxXg\r\nPVQpks5kh6tum2yn08qI2c8ktbuBgzjh8DEfuS3DwAqvtRU7J5MRqhed6OII\r\np1xIWsmxVYONn8AnTjOzkgIf4igdXpUjq+ce8H3tJ5EB90qYAB494hPfrioK\r\niiGumY60RJ2bAzT5Rqtm08LLIuEOw8N6HVTOUURj7MCFWSZhfAvkw2Jb5xji\r\nw4rjOTfQ7AECDY2yr6OvdaIFEDIz+rT8+t6ofxCZ/V0p2fD3B0fQbjY1UNu9\r\nrr98hcUx+AkVqJGIo8sTX92dkPeahSRIKtR5TM16fL3LPDPyw+zaeiDpM+qO\r\nkXJEf9Yjmdp+uTDCFZahk71LxzEyMM3QQ2MVsN2lSJZs9520R+aPArVeT6HQ\r\nUQLK0F1TRLMShEcyawuMuBvzcN/z+C1qeULNvecaRaJcaQMaZpZbqW2Yvml+\r\nQoI9H2CbRhMnHkpzjk6HSUxWIR58qF5rEOA=\r\n=F/7V\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.11_1656512404064_0.31104226928318734"},"_hasShrinkwrap":false},"0.11.12":{"name":"hardhat-deploy","version":"0.11.12","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.9.0","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"dependencies":{"@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","ethers":"^5.5.3","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","zksync-web3":"^0.7.8"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"3d08a33a6ae9404bf56187c4f49ec359427672eb","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.12","_nodeVersion":"16.15.1","_npmVersion":"8.11.0","dist":{"integrity":"sha512-Wv0BqzwW4mz78raxkfQtBbkhZwZTRWXwRbEwgkTUimD3MX/0Z9+D4O+s1zHJlG0zwZvJMbwxPOrOHQm4NZ3JAQ==","shasum":"323e05ecd8e6c80a9193b9c6f6c8ecbb6abfbe47","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.12.tgz","fileCount":149,"unpackedSize":12377124,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIGP6pE9C8oP7DkgPLDXvwvStzI6Bcej6Q/xkf1gwDKCBAiAZtU5WRu+lhPKO04bolJJEdlM+wAwYiB6Y+SrUdRmSmA=="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJi3ZGyACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmr41A//R4mFINjDzWRwLmykZraLqvCabKqOq4zI+t80Zsi119YoBjQp\r\n/V7afWYHggCWffX1yQyeIABaAoMFdrUQYohSpyJ9bGf67ur7i9NEDQxP2JDb\r\nngaO/Wdws0oCLg+QoKwjS8d772YS7Vaf30s2V8+FEYEFZH85VxU+pvG7zx5m\r\nfHX19XaMd+eY/aON9PrxWQTM6oBIMy5hO4ljItMa7hJ/rQqjFJOQcTibABvs\r\nFw76pdhKcqT9UJOFsJq9SVoKQyoOtY72/G6l6bqqiauFRCBvHmniNss9J+Ft\r\nzXGDHGkZbftd64Qh+kkrphdSViJ42gskhaQFfTnRq3V32eXedvbkY+oT1Dr2\r\ns9Qgcf2S9OVtr1JTY0fpFhYNmzFZaoakKY9j9amY3WbrVmClqe7fVyaLYX9m\r\nZ83J7DgXkdBsuCfKcqzGIjSCBf2bMAR1f0LPNQXK6mPgwSk1R0AZbfeRro7z\r\nWLZkCJEgZPBnz9iBrfOmQh4fLa9IpwhE/UzCETUnm8NF+n9kQRJp2AkEOzdH\r\n330WQ5odU/WFFFhbn2IDW+dshVrjaVyPGq7SVHgjYu+sHKM9NBSPrwNcJJVD\r\nUTxnJQ3DBggIzDMgf24fNlrTXSqYYzJuXwY8F4qFINgl1Uq5SerQ2OX5kEWi\r\nnWWdT5umXrjXfQztNw5ZEwYhWN2LpL7Gsww=\r\n=lOOJ\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.12_1658687922532_0.8656513239696064"},"_hasShrinkwrap":false},"0.11.13":{"name":"hardhat-deploy","version":"0.11.13","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.9.0","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"dependencies":{"@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","ethers":"^5.5.3","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","zksync-web3":"^0.8.1"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"dfcf2fc63d208698cf14842d998c40fb7d5be2ca","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.13","_nodeVersion":"16.15.1","_npmVersion":"8.11.0","dist":{"integrity":"sha512-2kcNce74b4cNALx6I76IZCGSqhxvg2wOLSa3N988o4jYGEMFnQuwSTwJQ/RkZAqIZ5IvWo2jpBS/KUzEt+Igdw==","shasum":"598cabcc4574403189ee2f09c3d65baaed90e1f9","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.13.tgz","fileCount":149,"unpackedSize":12377123,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCC9IJPsfVeF+UPcohhBLtLBwEA5DpRr6LbC+i8nUd50gIhAPF9mX0LFIK9R0oN/Xzh10HVkgy4c41krRhHb9nQDjDC"}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjFEooACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqfmQ/9HAEqzgUKYncVhyXdgcelmOwLhbfuEYNsy0uMhzzVTsIWZC3m\r\n3ceCoLyar3YIcPh2hkzd2/5GNnU7qgjKnYQYSiwRhSJNKLkFRPLKsQg25ihM\r\niU0csge+ujGVBOaDHE0wCSq6xoWa2mpw0AM67kSxceRgaBaXnH2BVJitQZXY\r\nHB7useV73s9DSECjql6s2V8j4FVoUWuR/b9VQ4Ie77Svioba1z+mVjkXS7Le\r\nzfFlhZxxuoAU4HReIDnzmt8IYshtnpH5oi122QIe10bHyexn4aC8GkSRDeKf\r\nK+P/LW9FO/AULGl+DdRZHAjyR1eiqQjxdjOQBCyCxUeCr2U17BhvlZgRtlr3\r\nONMp5HcZs6CBirpsZc6jaUfDbxsx/sVXxlLzr8Kp2KA8Mvqoqa89cZq4K5pA\r\nMV6/RfC6I0pcakmbj2rB3OI5z7fp/KrKH6DaW11LfR2tHgvyl7vsOKRoKyOk\r\n7D2NvCNGQ9A91TnoWfc4YalH/H/kgVdplutDz8H1ZOOKVMjmqeM3YfInoc18\r\nFY+R3vggM4bgj3OPhsE/46m9ezVH8XOwFngapSI+7a78AL7Grz6DWL6DoG7Y\r\n0FyRv6Y0KwvxKcDtV0FWmZIsSBKH+fsetZk16auBJprJc0u8aY/f18y7LUqX\r\nNC3YDIUcVGPSwwXX4OrMUnfMQEXWjjwTgcE=\r\n=JP6x\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.13_1662274088019_0.9799302047809719"},"_hasShrinkwrap":false},"0.11.14":{"name":"hardhat-deploy","version":"0.11.14","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.9.0","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"dependencies":{"@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","ethers":"^5.5.3","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","zksync-web3":"^0.8.1"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"02416ec1fc18e6dd3e786e9d27a1576255059567","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.14","_nodeVersion":"16.15.1","_npmVersion":"8.11.0","dist":{"integrity":"sha512-QL/ETKUj8a5QNZujXJCYFf7vwSvtKFmQhrSFe2S6x2TCHqhYt7heiR0H3YCxFGO8d1iF2QNL2wYtwvL+i5VvLQ==","shasum":"8be2dcb0fa3560e59abba2ca33212d98f201b904","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.14.tgz","fileCount":149,"unpackedSize":12377806,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIEAiPIG8HvTBzT+m7EKSOMcewsk0hEH34lLiGPyZB8j+AiEAxVIzqouOwcReoeElHnUzz3qMhZutfqoE8vwYOFUA+tY="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjGFbcACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmrNDg/+Me/nODBgQklF30KcOfn6eSf6fh8+aDz5L6rYX0BoRGnq3y6o\r\nn36wf+e42z+aDharSXZ5QM4YcKwBfxOVLyBXauuPmLcSl3xoGo8mWI06vPUF\r\nj/EW+GAUzx/bbiWLkXZvgjcXiLjnsnjO0dgrvsCBscadrKeF283CWZ9LmZji\r\n9R6/YpHhVJ51hhzKb5zOgCwS+yAmzjC+nelwRAMH1gS9F4gDRmj966Sohq44\r\nrmP8OTRA+5cbg8Jgbo7kJaZhyVVN1ACy79FOCrKcnGNyzDjjvW6OZjtZkET0\r\nFSpHKkU1mfav2mQTWuqCCWdTdRt41ZSeqL/IUWtDXIJq5zS6/2vWMzHsGLRy\r\n4A1d+BQCnDa7bSopzHBjEzlj5jQW3yJSPAPMz7EnsLgH5JTNcyX4+GXQ8T9I\r\n9LNZ+CuR5lzd0TNylSs2FIzfQh4x2OYmiaDg89SXwfgyTNijrvsYOpcyMSZH\r\nvM+Jo9bSMZDn6sGQlBjD0Nd26C4nX2YkR7kJr1goIaQUQsb6m0U+8NnT2WYt\r\njluqijTdq2rXv0wQtPbBpxD/8p+BCQFzaKRG6+KlR1HHrwv7IeicjNaPlTYi\r\nM3VLkWSPyJ4zhszkpmINO9nguJiduxAoU7kVTq9/h+xn0dLmQukVahw1Qau+\r\niU0TgMw7gaBlf7X98nDxKYj1pnR5J23qT84=\r\n=+zrP\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.14_1662539484453_0.6160869375658122"},"_hasShrinkwrap":false},"0.11.15":{"name":"hardhat-deploy","version":"0.11.15","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.9.0","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"dependencies":{"@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","ethers":"^5.5.3","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","zksync-web3":"^0.8.1"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"c05b477a5c91b80dbd6bb8517f36de966f94bb94","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.15","_nodeVersion":"16.15.1","_npmVersion":"8.11.0","dist":{"integrity":"sha512-7e/GfVLmSXlcVePVFbC/xZ8mD97ChR6gHeUbejWMvzXpZ6I5bjSPZuaH5AebRRlb/6LjeIrN1+bKnayY0Sw9aA==","shasum":"5b5f6f762caa3c4d30e6e2800379ea7817a861b5","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.15.tgz","fileCount":149,"unpackedSize":12378066,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDPqDm1bAc21sRHWUGzFR/mHz9cN1ZMCpsGttsbyRHA5QIgMEb6RvQSnkJyj8aRDjpGgHTWdsKuW6q36T1FOV1C6Ps="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjIVUPACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmosmw//WM8iD5ngArLrgZO/9Cyd5E2uvUdmxAFr6u5f/pULC6HAHesn\r\nqGTE1eC1TikqbTcr6YrnBv/8JfXqTlx7MQNFJV9q38h45SQbeUpXytMPTqAL\r\nXGXomw7GHGvKTtDefFWPjFDzRqGVsEk4+rYeXOFrfLpV2akPYS1RAy0ETJ5M\r\n85cXiPMrCOqewOB8T/gTEy1x899d3YilA0sx31+jtQqLqm22RWplOZuoVZsG\r\nb97LPcQsmDFeuG3eY+D5RVUuVNM0FSCUjvRdtsg4ScmUfLaFSqhzWRNPkQ1q\r\nJ+yp8GJHrqfBsPojBDHlTPaNDcPjNay8kg+SOLunJbXDY/pUv4Xo10AWf5g5\r\n15jQTFpWs33lecYLRBIbj2E5xT9YtLeeh13hCTwGMbjyx6UkIT1YPuENm8KK\r\nOyJ6HYLkZdvY8+UznFIg+Ku2M6BrensT5sOyQLmI+ZZfONokyouLb9dWmX2E\r\nBSvqeE0akNPAAtocjY+yQ05f/JSrZdF+p//tHlOJiuujg1TFmmzDW5qOChxG\r\nfsnbzlYzpPm7SY3Ie2TLbtf7QegXqbFqXq0UvBqCYZz3gi5xrb9/4VLQUdET\r\nCZ/huO1tbN932LGKxeM+QcARh1hH7yl7ZemaNhssOlRfYijIK0Hp6AKQrIZS\r\nZGe0RYHQNgj8rIi7FXv426TVNyvAeU2PtMM=\r\n=KQ+p\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.15_1663128847700_0.4440369312092487"},"_hasShrinkwrap":false},"0.11.16":{"name":"hardhat-deploy","version":"0.11.16","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.9.0","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"dependencies":{"@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","ethers":"^5.5.3","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","zksync-web3":"^0.8.1"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"728e8edf2d952d38b6315b5b8c24157db43240fb","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.16","_nodeVersion":"16.17.1","_npmVersion":"8.15.0","dist":{"integrity":"sha512-dEpbrp3wewfEkDVroOiOteDvKc2BOMQzbjljHJkk65mb8gQZ0c0GsZBoLXROWSRoNhPCFjEDAhKPqBds5pclqQ==","shasum":"856f3ac6d749460aba40ae39a314058f33f16352","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.16.tgz","fileCount":148,"unpackedSize":11480414,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQC8V4AHV204nt3odIYd75fCM1sDwg2PDSsJJrB1SmBxvQIhAI2iVA9quZ1N+6vygbDGKrYJPTmEA21m6q0tAZAvl3fT"}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjPK2ZACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmp9cw/+MKdzHUtYPXVA7pvEVq9vvaKdopVfi043x9/IT0L5UejGNCEK\r\n6R4/bO9X7gD66QOcNdrcDE+q5CPRGkbFHLg0+oNsRa4Z/FZRtEprLZgbNv+L\r\nZ/Kq8yHuD1J7nvxv6Uim/Zgfl61sXQD78OiSsCegvSoG7uMBwziD24MIzQwn\r\n8XAtFbYVwiGE2kfent9Mbm/ProJ3HXvml1U+tolAhU0mHQPLXnCdG+2g4riK\r\nt9Mar8iQbtVpTYYqPYuuhGTAmz+eYAkeWcT21x0/JC8kdQm4G96Hpf7eSnZC\r\nkigAOUx+yxaFhztGYDcSTqUFnMVVXA7YVXLUwGbH4RJNof181oz5XRlGDN9G\r\nHJzH/h3q5sWGj8CjRtdivJ51cNaqiOnOGuNZrBrI92uEyQG8ld30rIiXAd8U\r\nKAOgJFdaMednMCKGUOtytp4IdJZU16l7m0Y7OvfEsZfdKjnlymAnodI2TxyB\r\n1JC4BKoaJdWglj4aNQyWS/irWdBdGKjiHA6Nw7NbeBKbqFob800Zi3hWb5RO\r\n6l9fwvYXAvD+NpY3e9FbG8O2DKyITtWNR+/5mYkZjIsmQG+d0uxOYIScpNP9\r\nZ4VKWMrGf3YLNBhKCDD9t3CcWtAmDLU28TKfSQiX9eRQurdneq+/TPrDjlvx\r\nNUfd7venFu0P1YPDjF9l+3E8v66oNWHSreA=\r\n=/6NT\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.16_1664920985682_0.18293969772969176"},"_hasShrinkwrap":false},"0.11.17":{"name":"hardhat-deploy","version":"0.11.17","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.9.0","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"dependencies":{"@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","ethers":"^5.5.3","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","zksync-web3":"^0.8.1"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"3f141cf77726f0bc11d7f3b4208c4eef2f13fc70","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.17","_nodeVersion":"16.17.1","_npmVersion":"8.15.0","dist":{"integrity":"sha512-HPlGi5SviRuI6ILagbNnEQbBXJ4GdXZdIAMJW4Mru/2ySmwmJgTRtOvvIousrcmaRoGKYKQD5KxGHovi4zVHjA==","shasum":"e4830e4d341409d971492570e0c5a329bf3d7efb","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.17.tgz","fileCount":148,"unpackedSize":11480682,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQD/FbGUsJomZ1BvkQB4x6FWskf4TZPLstjWA9K14owcFAIgARDTaz0/1SqFtCZdVPnTwiqE+LsFpRyTNRuTkSXPN5s="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjQGCQACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmrpkg//W0IEH2Gwnd2fhFaHnUGOLXkFuDwBSEXjK6U7lO2TRisXUeBq\r\n/+gsRsoE7hUm8HidJPjyUEINo2KU1D8fRb3wTkpWUnASfR6NPC9Rk0XSaT7r\r\nV1ZR1a5rmy3yxhQhRu5Z0XR6gr1/DeVP/F3GlfoOu/ZepnhKDJYjA+zBlqEZ\r\n+NfuxZKb//0sjzGYnf64ejPMAKFe/ZC+AJhchbuw7LI+bzrafNl6h3BnGT5y\r\nkndl53+DFfmnCzmiHWDlnrJMBkY/Kuc9tHvewUBkHNCvjBFBn8+RUj4pBzyX\r\nlj/k7bkotTx316gZy3oi5fHX2IQyj40a7J6TUkZGWuAODcqAmKbEXy7g3vIP\r\nPmfQUxQZHBdZxnJeRflxtC9R6Au/ZMx4vZkmcIucBkqACPWXww7BrOaB0HUe\r\nwo6eAPKL9O++pb7zukk1Z6nBjH95CeMBnHjC76WDFT7OCDbnQV7UIn3LAdTg\r\nJwmCdBSr7xDnyKV9gbhAu2muvGqFCpj6KIRNXWddKC99FQ94eAXtk5R6Nsam\r\nD2ZpxvWGwmtSrUS/k94uXB4O/kcNrtX0FPkDcHtmFk8NW4XGt0X7uS1is1IQ\r\nBEgMN6xiJVW3sbpuNDLHlz4duz+OcvHPgmJFWT//S+ijgQH6c8dNboTtZeDS\r\n8Qipb+t5oOyFZzv6N1TLwRtRpmyvSKcGWUc=\r\n=9iXw\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.17_1665163408640_0.5571236782290097"},"_hasShrinkwrap":false},"0.11.18":{"name":"hardhat-deploy","version":"0.11.18","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.9.0","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"dependencies":{"@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","ethers":"^5.5.3","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","zksync-web3":"^0.8.1"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"cfb57948bcf0a852b3d03070ed899540f18cee7b","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.18","_nodeVersion":"16.17.1","_npmVersion":"8.15.0","dist":{"integrity":"sha512-Zs5Gr23/HEcYPjQgcSJLlXkR2/WOp24O9Af+7qA540sCDvHjuQ7WhHG/fB2cjPel0Ajf0TzXx1uVViWtbKLqTg==","shasum":"076b4f5e7dc78bc144c2807112fb4bc764a7a7d1","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.18.tgz","fileCount":148,"unpackedSize":11480634,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIBspWDUB5owUOEBUg3XeHxc4/wfzG7iChL6lan2Fh9OMAiEAloU+CIZeBiSpCv705Uvyi2fjBebJM69i4c62ZpDTaWo="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjQJpVACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmpUMg/+Ikkm4gKWC4qbE+kw+mMnHK+EkLMkXTIGDsPtwGCU/7Q7PGRn\r\nLNQmDxrFbVJP304gjoYtUVwWaoxgPawka0WBPD/QZrRRor3iQsw2ZFi7aeJR\r\nWF9pdpd+FVA9N8WW66kdkoXy1IsbZSZJPGIvwa1G4ACxAz7m2hdNxAKBEGY6\r\nYyrUFNQKPeoU7zYTV7/yrdmTTAAKp46cWQMWhnM5aXqBZpaid85Hykg6eLld\r\nmukkt6n0ALCdqcMJWBjXGUSqjNhYOc+k85hUFBXS4q2l5ubm6lVFO4RpewLS\r\nr24+3SklI86ME/n+kqnyrwmBPhGj1bwJ1A+DeWTkysOTQ178k1TD24e+xSfQ\r\n8cUFwWf79XJW0Ryw9GxeYa+x8pDRza/dHxLpT1wxuhq0xGA8RBf5qoIqzmZ3\r\nVy2h6mQRB2W18ni+PEa/JgWVd7IzYBjMKZUqJQY9H8SENl1GpL9h11d7LHqQ\r\nVUb3X3wxZjQksIz84RdrsrHF3yNlvbUKZ5uv+iQqOZsKCyjWX1ex/FJpRcR2\r\nI1C33G7UvXBUK+aaKdMcPlZhAqNFMV9uP+VQXQxXRK1mIPQQU/oiLhbKGzZ7\r\n0Bd3xVPpYDLTOIJ4OHUw6V4vZ9vV82ieNnZg0x0g9fotrKpC3YkaVqHgz6Xh\r\naP8jDSF5R+kqUp2wVcFTwpJDZtgyvpegSBA=\r\n=b8zy\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.18_1665178196694_0.9174690456001495"},"_hasShrinkwrap":false},"0.11.19":{"name":"hardhat-deploy","version":"0.11.19","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.9.0","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"dependencies":{"@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","ethers":"^5.5.3","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","zksync-web3":"^0.8.1"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"febb62c7984d0a6053da432d86eebbbcd500ca71","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.19","_nodeVersion":"16.17.1","_npmVersion":"8.15.0","dist":{"integrity":"sha512-5hJNgOtG0Uo+hlhjBd0kBb1/VWMrlmdZdYPPNfryZjacIqePpriY82sZP8PxHEEV38AXxdQ809WT2LE4M+a2FQ==","shasum":"19b9cd8c513fdd03ffc296fd5a2b76a559b33009","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.19.tgz","fileCount":148,"unpackedSize":11480881,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIDdqlgCXlMbBVHuYTt4kW5v21j+D5eQNZQ/7UsOpKlMVAiEAkAaRBvTIcZyP/1NtNqwwSrcMu9hP7gywnS4OyQB4QZ4="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjW+IIACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmpw7w//boH0/n7gXOwu7BzFYIRsUrwtF+7M0Vy2857tWxPt3efJ8HYu\r\nhKqDOhVVeE0MPwXWsEYE19zb1A/GXTkIMR8w9Q0WU5gSePDqkGXjZgh/eLEO\r\nm5+Ghxaf/1r9Pmu8CzuDGybyK87d8Z4/mytYBbv24FCrWf23pi0xAI+QIwWi\r\n9crHz97Qe4MJTtRoAxVGEXfVGNyzVXFhmIGMD86mhEHdr6INI4qm3sFubC7J\r\nSM98G0FwRvBN+pNXmpcnkDp0+YUvortAW4DbyI9Jm/WQu+Esidn6cCkzPghG\r\nEuz7I+POzN12zWHNz75lg6Ih7erCX9m7bzi9vCg5sEY0tcYjpQrL5gWXRVG7\r\npbgD0sm/z2hrMixJXNmDzqeC9fVjY6CExxxth19nnCDhDweCLOLTCBueBWpQ\r\nK5Vh/AUKGJtPeM03MXO2GMiJXMe2TfUC0e83uI1zvZCEGc8oz6ZrlEsAylHX\r\naxH+TnXTnnaxXj8pCXN24YJnpfrFYJEBVfND8E+Wclt/SuDSWJ1Y88C00ypw\r\nHSo7O2KMIKphtyKeX5VVQR9JKv1zIqjI6NJatOB67MQhR8vcSsVewJIeKmuJ\r\n0LrP8ziZinL2JBhgdoLFThE9oDI4jGoH2Bx3i1Upt0Rxqqw2cOaQHhFieJcu\r\nqRVFM33UzX7aIrFEWVyIBpE5czz4jtVLqX8=\r\n=zXQu\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.19_1666966024179_0.44407400274941433"},"_hasShrinkwrap":false},"0.11.20":{"name":"hardhat-deploy","version":"0.11.20","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.9.0","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"dependencies":{"@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","ethers":"^5.5.3","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","zksync-web3":"^0.8.1"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"14d93c0681dffdaad2909480b5aa864ba6b23ca7","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.20","_nodeVersion":"16.17.1","_npmVersion":"8.15.0","dist":{"integrity":"sha512-6G2aFLW0mfZxY0ljDf8rxzEJkVh57gr3Eia5H2DeBIQNJh0dhBV2Y5LDq4E4J9K4Crq0DjpxGNTshEtAB9eWxA==","shasum":"d95499a0d29b75f1f1d3838c9a3eb6d2d0d20f57","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.20.tgz","fileCount":152,"unpackedSize":11486165,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIEmMJPAgeKFooHIfBD6KSZ20hN5Umds0xXouFCuFEJV+AiBwzwUKA+eqfWjtFmcntPLJFwXLPU8pYF7am0ugJovrbA=="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjY7keACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmoGTA//bFWvihlVWn0VHV6pMa+Qay4Qgt6TvrifuknzeowZjvNek9zr\r\neoMS1V/8dpPTpDov7c22lNq8qLyJ6TCOtt1X/t8kB4x2/XlYuX/MUnV7o3ae\r\ncKv8yuKjMTQvrNvj5J7F26l8m1TI4q5d808qF1xpOumGSoj/dhnaEBq1kvQw\r\nnU9PsKFGqQCQONZSgK5ldwFMJi4dZVSlFRc5vWBx+Iaq7dvXzMBwSzItmNTR\r\ne52wbPWVHel1Ok6/RC6OmfaUpub/PMk8xVdUF4G9S+QHBiHycYyR24wwZk3W\r\nWL/AzNtpynu3OQ440xs9k+rMXHafoGmlnHojyHUwhuPscZIEMSjqx5tiLWKe\r\nqcy1XOngfM/NScMzUnqrMtMrmYj2WrD+Z80p+p5/u9y8RFGHbbiWV3cW+28n\r\nS4NMJxyJKImWTyOmVxObfUTgj1uhh18WotQ2tJqrt6LqAm69vwNmiDDj0X5Z\r\nL2VZI3NOC0jvBVgxfSXKcmlXtX5jL0CSV0cgcrlguuDrQORSmW5kNCepJulZ\r\n5y0/U58badsdLhMKquUNtKDy5OJWxBhlryDgBY4HsrJEif6tXfw8EMWz0fUJ\r\nce4s445BFmHHofgHtHQmcx9Keu1i2+yKY0SYLG1FOezy5dDAcpa+C4eb9sr9\r\nd+VWPtDN2r0OLYw/05KVvah1lA4dVdkGK+k=\r\n=CIbX\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.20_1667479838169_0.25803908370298534"},"_hasShrinkwrap":false},"0.11.21":{"name":"hardhat-deploy","version":"0.11.21","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.9.0","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"dependencies":{"@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","ethers":"^5.5.3","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","zksync-web3":"^0.8.1"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"9b4ec925743d71f8c356bbb6448abacb6f00e871","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.21","_nodeVersion":"16.17.1","_npmVersion":"8.15.0","dist":{"integrity":"sha512-cSFZ+CgFdN012+ysckSiEfiD6u5fFpYmdadj2kG5BnkU0adJZtzGNtbVp/GrOt6sj73pIScWpWwMtkCLaxk+gg==","shasum":"d40b7755e52b3c39419dc877bfacc0695eea1897","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.21.tgz","fileCount":153,"unpackedSize":11861813,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCrEqEkKdeIMtz49NDDBD/54FyPlJuKDa+LvY4trKNKswIhAIsWfdcsvEbgWqEBkZsZMXzDOtbsHMYQIrZIiyRhDZh9"}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjhvLuACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmpNHBAAg/XzukFdLAS3FPz6nJxG10l+v4+dz0rVJcW2z+wOYZI4/bk4\r\nXzn4peBs/wcTFoqUKzYPcp2TZYtbLwFeb66wfpDCeL/ypSpJpRaQ36lCPKa+\r\nCoVx6Zck7u6NFB3JuVBNLccppZWlTDBCD74CwjZJIBzr1JZqefNCko4Mdm5b\r\nNMmj0SWxY++i+wW64uKfVCsESxbcWZBo+usYygpbwfyp8Pek9agmhI5CYpy4\r\nZotynF7E6gXQdjVY972/LwSxMvszPrIajj3QCfPlIO59ZSbK5qkbEzMC49pG\r\n4dpyUHyvaGxB8rnjUqsvGTRKKKlqC+KXuE2+sLbBT0uthxYtotacWlj13Ns8\r\nkWzkf65n8iHrh6CxEL5OpIiW3ZEoD6au2ccA2+SjfXEqaBNW4xYZCfBMKRiS\r\n5Ut0SxoeZRvqqtwtNz1v0iTT8U39XESH97dmFzqSpX5Qqp5tOfo0rmVygRJI\r\nky+0TVLSH8UDTuhPZ5cn7ocpVj7U5gkvBoyoKH5cF+OpmdZzFATXafZLOQSN\r\nQPJJEYEHWqFzvbVCH9Cvjoz2vrCanCybueSBoYH3Vhc8iI5mbQ/zjyoryNgI\r\n2DQPw0voVP3LNfRvWYev2XiDuSNzARVh+T/RJdoY1WQWo68iq5p++3eCsQif\r\nryBHlegdtrog+2Ng5LkSKFoLZhVBC9hAr2I=\r\n=3QiC\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.21_1669788398080_0.1391571582111013"},"_hasShrinkwrap":false},"0.11.22":{"name":"hardhat-deploy","version":"0.11.22","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.9.0","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"dependencies":{"@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","ethers":"^5.5.3","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","zksync-web3":"^0.8.1"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"0c969e9a27b4eeff9f5ccac7e19721ef2329eed2","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.22","_nodeVersion":"16.17.1","_npmVersion":"8.15.0","dist":{"integrity":"sha512-ZhHVNB7Jo2l8Is+KIAk9F8Q3d7pptyiX+nsNbIFXztCz81kaP+6kxNODRBqRCy7SOD3It4+iKCL6tWsPAA/jVQ==","shasum":"9799c0266a0fc40c84690de54760f1b4dae5e487","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.22.tgz","fileCount":153,"unpackedSize":11862534,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIE155F2bjIhn90uYzsrhUpdQCrDWZ0WHgFaJm4e9ywNHAiEAgL5ckOy+LX+6sXoix17AbwRwUjjbmnez/zXBZpi58yE="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjiV7RACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmpaPg//WIpLra1cB85yF9QIPSWWW3xiEa6lKhDanR/m1h8niulYafE4\r\ngXnF+eeGyNWTrZlPIAcvd+XBVv6vOvLukW0rh9J/bMzesJOHoUqRzQTCROdm\r\n8ZOKxkFXSIewhnmTKj+1THUiCc/0ZbicNqABxYtr+FeAa/A6z0WqRH2D0zKm\r\njfshnnMh6Wrm2NLD4Ac0jg3GSIcqbu4TkjAvAVsyAaL6vOjTRmQTlQyVF+uo\r\nH0rKtgmOH2nGd1rUSDM5D3GaYWZGWu9BJ+95mlzcQCUrzxZWmIAX8whAUNQg\r\n72p0eMqLnPSOQirA0XEPsRHJ1zdSnQl3CVGrkwAz7iDThXq6KZXXVrBPUjDT\r\nBW5oq6nTy65LplTYAkJTB9hwLxXi5Xq735bQfZG7ECrhC1088v1+vXDr2kbY\r\nGWmvv3N9zQgeV3gulqbM73L19oVsCPPHvRF2cOaHSnSah081cdj8jb32HBMv\r\npvLqyuL8CYwbNT+c+Q8rOvkD6XRkiu8JonMLYWpjOi5/0ZrGwoFLz/uxESWQ\r\nqmMq1G2zBerJiIThEJHhtBgTIuph1xZT9d3tkdR/OC/2YCDEJBbT5XAgSxaw\r\nI4ckydzMjY2YxaT2ZDKjG9wBtF3fwZ2WUXxr/9OJ+wfPsa4hZtwxj1PBGdKM\r\nndn/cG/M4YKoz0XAuFinsvdCc4mRkd4Bl5Y=\r\n=hxms\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.22_1669947089560_0.08211200679898689"},"_hasShrinkwrap":false},"0.11.23":{"name":"hardhat-deploy","version":"0.11.23","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.9.0","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"dependencies":{"@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","ethers":"^5.5.3","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","zksync-web3":"^0.8.1"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"ad9ad6590efc29a9a60c326a47f4e0e9a2bf0cff","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.23","_nodeVersion":"16.17.1","_npmVersion":"8.15.0","dist":{"integrity":"sha512-9F+sDRX79D/oV1cUEE0k2h5LiccrnzXEtrMofL5PTVDCJfUnRvhQqCRi4NhcYmxf2+MBkOIJv5KyzP0lz6ojTw==","shasum":"7c5d11ba32acfd7c5730490bf6af8815b435c996","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.23.tgz","fileCount":153,"unpackedSize":11862789,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIBbWNp5X9hlj0VK20ViA9yp/Ecvvz535qfCCL1AXG8OBAiBK4KDketviffstHJPG5fChhhaYlJX+whBTOvIpF4wlgw=="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJj3S9qACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmoIfg//e1MFi2uoiKvBmt6enRalEJsdr3ycQ1ZnbDA4ojsgXIlzV83t\r\n8pMVSFPvkG5DtyonQagW1U5mH6+99MCIxYf300zufA45sAGeg35+Eioh94zP\r\nnSTbXESIk4rtHUTpfNeyr3B+/+xofY6wXL8U2L+oxEK+7HKr/h5C7i1iRBJG\r\nTHADPEzZFiceKEOI9ui2nDq9D5ABW3dQCBrhhPXDeUgmS0pPBh2KegckW2kj\r\nHnAVi+QfupTAO+Ca/VJXu/JBcw8K/LzjoGkINrCqgbxByzXR6/FpEadlyE2Z\r\nSQMO0K6Jib6idgeUcdrdv8eWlmiTxjprMF7EPZNSn3sL/uHOACDU+m5d5KoW\r\nUAGhThIo7eJKGr3kJ/CjJbZ8yi4WVbKZVMnRhroPBgyMUZK1+rRLQaai16vw\r\nuZ4VPSyMUXYPVxarwPzgNp29z8CYkXN3FUJV0g9QFDvFQssw/RFov/5nHgwa\r\njgMdwthOL/KqwdLNth1N7O+cHk5TgMzKbiZCHjEpNjoc4uJMBIbFTbdjHXjF\r\nrf8fSTcGSkBY2FZxvlHqYD0c3fQTZNL8j4XCDakrEaBTRGzC6Nttv1Oms+fD\r\nIPb4gniJEgfe0oSQbA+X5cpDUYdxiooMne/rxZtVBQ4kvmS0HuiRAZDb/6Ak\r\nfbMklKr0GNr60l/H4lYc5Rg3tK4QWMWmCaQ=\r\n=uEeT\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.23_1675439978316_0.7465622869616135"},"_hasShrinkwrap":false},"0.11.24":{"name":"hardhat-deploy","version":"0.11.24","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.9.0","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"dependencies":{"@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","ethers":"^5.5.3","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","zksync-web3":"^0.8.1"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"bcc0295cad25b45279233c556512708f23b2ad97","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.24","_nodeVersion":"16.17.1","_npmVersion":"8.15.0","dist":{"integrity":"sha512-26TXDlvW9ADIhb3OjAhjFgURcdU7jVeXpvm+4pJZ8dS0A7K+JFBskTdn9uA8h/vg8R3NUbPxRNPIbvyL1QRwtw==","shasum":"6865ede4544d2c53333695cb279aebec5322a262","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.24.tgz","fileCount":153,"unpackedSize":11863201,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDIGxTvdJ9IW4FEE6/sYHQf3dX0Gii0JxzQ9G8ffJx+CQIhAIjH/QKR0cKB61RMpremjSxK2cInTeHGBTwdOw8axsB+"}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJj/KeQACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmoS0w//XPl1CUn6O7dgWFX6xxYwi83KdTG13/UQPMh7fXudQ2/5FwN8\r\nBT1LN+JUBjzW6ZCX843ay7ByEUHsPeu5OfPpuPLdtrKftEGLE/WEi8aYsz0d\r\nJHBwMWIZ3ZYZn4BWeo884km731VEljS9ABEF9DeZCU8iAT/Ab9ExKsEfypt4\r\nHEZWZCASne7XskTbbVdUnb+Iyc88j2LjwS5cbcfxVe7rLOojAQbAvXLdPgZr\r\nGKzLqHPYZtOWQ7LQtYzIQ30YU3kWfjInr0aXHAhrMpAnJrH8fBH2xNsMDC78\r\n4NvOzxoZANJeqsOobHIzbcq2OcrcKlfBEKm5cvSvGEAA+7FN9cxAVCjFnG4g\r\niWWL3/ZgQ30O4/z1G6piQC5upYu/2FBTAKQUNrcDDg53q9eJeybCovX7gdes\r\n8/9bLKg55uLiQ9tOz+WK/m/Mjsep9P9stG5XWkU+8vlZ9MNLmWVSchLmwl7y\r\nv8Qwj9rrPKWY7WIgmb/MFLi6rv3RocW03E/b6dUszqsJPYBWnQujoCM7USLh\r\n3OEa3ll5QnTEtcwjGAaZQ7nCIETkOpjWq3OJCK2Z1x+MaqgUUUWl9waVK9NV\r\nNJ8FfeXWeWP8q72fQ4rJmgyUw50P9RXHyaJO2b9Y3TrhFsXzDUkjPZDFVPkU\r\nHoUdAxm/12D7crl/et4+B6Sx2NnXIE0/nLM=\r\n=ZVOq\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.24_1677502352173_0.09283308747926222"},"_hasShrinkwrap":false},"0.11.25":{"name":"hardhat-deploy","version":"0.11.25","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.9.0","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"dependencies":{"@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","ethers":"^5.5.3","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","zksync-web3":"^0.8.1"},"scripts":{"prepare":"node ./.setup.js","compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish","prepublishOnly":"npm run build"},"gitHead":"70894adbf8e9fface98ca6cbbce82c7428443c85","bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.25","_nodeVersion":"16.17.1","_npmVersion":"8.15.0","dist":{"integrity":"sha512-ppSgrVE9A13YgTmf2PQGoyIs9o/jgJOMORrUP/rblU5K8mQ2YHWlPvkzZmP4h+SBW+tNmlnvSrf5K5DmMmExhw==","shasum":"bd6f2310ad9232a5d73f6e5dfff4112220a392e8","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.25.tgz","fileCount":153,"unpackedSize":11865164,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQC9CtDFiEaitU9F0IocAV88B/bmxeon2dG1+kjAovcEEQIhAPAr3zv3Cw3V+0zDaiyjawBTdt5arZlWPI1vI22Qr8Uy"}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJkBwZ9ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmoMBA//Q8hgvzCcTh84lsOGMS4IjLGoCnrrkE4o5vGyzmKPVMBe1Bvr\r\nC4FhyLWLpUnTyWIXlmeDdXLfYBumT7oHSWeSsXQcpdkYHm9py8qy2vgx34lF\r\ndgjjEY5cLaz27C5k+YHbQ2x02o/GKX7615TDYIBaeIcxkVkXVdMidb2PyOTx\r\nMC81ZgmdwaXlWpY+t95BRMYQwU63YdKbuV5KrR6si00flyGloNLK3v+yK0Hc\r\nlXIuZoxOqydpoOoLqlS+KGPbJiJrUvHZ3FY3zi2AEkQyMwdRi8o1b10bFHqD\r\n74BZoyM/NoDbdV4Gn5n6Cku7EOr1CMz5ck+7ZR8J4qyiwEBakUQOZlmMovEI\r\nYphV0/BYZYktmmjFVoOmOOy95JfYTUzHU60JvVYqUxKSaEC39kfjgXxEzEO3\r\nve8fH2FnHJCSnJZAsQwEHUYgkozbIdbMT0RcqCViJPCrtJLEx0HsQ35IfWKE\r\nSbdF1LF2ueMwoOC9Te+0SXTfPvnM7ckIT2XOwQe1tzYqwCn82hLI/CGiiYRx\r\ndu60zRN2TS3jjRBJWShAOAvdFeCSVc5NAB+ahfMvS0eTNllAvDNfzwlJSIB7\r\nT7+YnorH4SOIbF+vUCyCLegb1Y4lo7UqnMHaA5qv1qu8hIEmqcG3PbzZJOIS\r\nWL0jUX2xfOoMCNViFpS2ZByaWStQvuvKaQE=\r\n=Ilnc\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.25_1678182013211_0.3007315687627439"},"_hasShrinkwrap":false},"0.11.26":{"name":"hardhat-deploy","version":"0.11.26","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.9.0","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"dependencies":{"@ethersproject/abi":"^5.7.0","@ethersproject/abstract-signer":"^5.7.0","@ethersproject/address":"^5.7.0","@ethersproject/bignumber":"^5.7.0","@ethersproject/bytes":"^5.7.0","@ethersproject/constants":"^5.7.0","@ethersproject/contracts":"^5.7.0","@ethersproject/providers":"^5.7.2","@ethersproject/solidity":"^5.7.0","@ethersproject/transactions":"^5.7.0","@ethersproject/wallet":"^5.7.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","ethers":"^5.5.3","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","zksync-web3":"^0.14.3"},"scripts":{"compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish"},"bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.26","_integrity":"sha512-GvnkD8v6q0coCQbwZNeUcO3ab1zz36FKsqzNdm6EcnVoAfXVkFpdA0pgJ7/Rk3+Lv5709xOtbneFOyoukUOhWQ==","_resolved":"/tmp/0a8506c095fb1970cfbc81d982215e45/hardhat-deploy-0.11.26.tgz","_from":"file:hardhat-deploy-0.11.26.tgz","_nodeVersion":"18.15.0","_npmVersion":"9.5.0","dist":{"integrity":"sha512-GvnkD8v6q0coCQbwZNeUcO3ab1zz36FKsqzNdm6EcnVoAfXVkFpdA0pgJ7/Rk3+Lv5709xOtbneFOyoukUOhWQ==","shasum":"df2698cbafb575a014be6226e559ef467168cbdd","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.26.tgz","fileCount":149,"unpackedSize":11862568,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIFWbI/tTYv1ZDPfJMaL0Sl/rgKpbIsqZc6J3t1g5tahQAiEA3HIk3Qu6Q/zqDkZhUUW4rWpPUDrABltGt56cX3CGbRQ="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJkMdrDACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmqinw/+PGxE2DrXXtrlbrqTyse9PbbnvaoTdlOmpS10ovYXlqJc7LJQ\r\nthuhKvOoJZP8VXuoO9ZkIXviFGXMaphfiPpzIfizbFjL/KmaM1aQiagPuadS\r\nxHwtwFdtzc0r89SxaqpAxsWGp5oDojjYD0qHPzdOnPOGEzF9ZkuZPLwzZnLY\r\nsYAnh3ZYTIgckClonw3oji2eSQeUh1vSkfheS83hXtP8HHU/kJT5H/UjrcnP\r\n5bhijk1Js9jCJZaTCCBLJS0shzZrh+0OYNcI/zz0hM64bU/iwzQS+U8lQ5Ft\r\n6UFvZUbchlJnhdUZBVGIvSxEA2dIwO09QBQnPylvYMBp/PdywsLeOKZJJ5kx\r\nlGKR/8Fi+aBEg/g2Czwawp6hGLcAa4dOCEz/Tp4EG6Sbz/MLKHvPU5+H0wvx\r\n0b058v8XbwGDepFPYwv8xqoQpL4W1426RSikAz4JLyFiloBPFvvMdrTSFseP\r\n8mOX4PDDXRphJQkIDYhjb2LjoS2d880C5hvHaiK20E05kjEkGg4WttVjx4Xu\r\nUmFzC4fVBaUxEa5bt98FcbLHy+TC8yCx8hVLTlQw9O+QNtEDEGGSt1T5i1nY\r\n9+nOT6f1gSaj4R7jrf7xuJKZPbXa0Gxdeg1F4BSNwJBRzEpwMr6pfD0DYfJn\r\ncFFPIE+o8ccBQ5ajeiwPOTTCu/Ta9wd5y3Q=\r\n=xmC8\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.26_1680988867358_0.9021613609139725"},"_hasShrinkwrap":false},"0.11.27":{"name":"hardhat-deploy","version":"0.11.27","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.9.0","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"dependencies":{"@ethersproject/abi":"^5.7.0","@ethersproject/abstract-signer":"^5.7.0","@ethersproject/address":"^5.7.0","@ethersproject/bignumber":"^5.7.0","@ethersproject/bytes":"^5.7.0","@ethersproject/constants":"^5.7.0","@ethersproject/contracts":"^5.7.0","@ethersproject/providers":"^5.7.2","@ethersproject/solidity":"^5.7.0","@ethersproject/transactions":"^5.7.0","@ethersproject/wallet":"^5.7.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","ethers":"^5.5.3","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","zksync-web3":"^0.14.3"},"scripts":{"compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish"},"bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.27","_integrity":"sha512-dtvJTmjFAo5uu4ftitWnqo1eIh5JHUEsUWNq70qUGS2fx7j/AljBUHDQy6PL4RwzYY2jNY15xbVhuI8g+im9fQ==","_resolved":"/tmp/a5466ad80aa22e44c3d21901a8e6e4b1/hardhat-deploy-0.11.27.tgz","_from":"file:hardhat-deploy-0.11.27.tgz","_nodeVersion":"16.20.0","_npmVersion":"8.19.4","dist":{"integrity":"sha512-dtvJTmjFAo5uu4ftitWnqo1eIh5JHUEsUWNq70qUGS2fx7j/AljBUHDQy6PL4RwzYY2jNY15xbVhuI8g+im9fQ==","shasum":"4499624327b1854cb02a3a9919fd3128a962feb4","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.27.tgz","fileCount":149,"unpackedSize":11862978,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQD8//7vdQwF8UboZsgnl2okVaaMOAMxz9TyJVWzf9M/8AIhAKY9dOMwPd33ojqHnBmaB5DmdPUqutSflJXYHMnDK+JO"}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJkU28cACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmr/1Q//eAvrFnfZy8D0IUBr7OIfvMRsu4F706Gs3z2OHS/ICpSDQYAH\r\n3xcpaGU0LGcmMrA64SF+o2b1ag1OYU09uBjZe+gK/D4saraQLuSOgZ06O3S2\r\nmqLJ0KTgHAiGQh0EAlB7v1QiR5CesgatY3oJlKde+8Ypa3qJD3aom1D91u3l\r\nULTFTAcRm1V4yolKsBn7HYmGin9MPG91d39/9NK+cpu+Z0Hcwq5PWLwSBQ68\r\ndDXWxeoPg8COBHnfldEldchzKAnWcv4BG262j+HJwfI3q17fndBL1OIbm7Up\r\nPFmS/xwMlOuKzZOzvmFbn+T1WtRXJGU1oSVWb/mPyhyKtVzfd0HIi3wuxAvH\r\nhSoMze30nqaGcAwmzRC1N+YAf/Dv91XysKmAxL/59wvys0dwPrQ/cz1sIgpM\r\nfWkwhTbax0CIJMhVKVBXbsfEJjdfp0u0a8R5d63f81TPbsGkD0Woq4VE6773\r\nytYBVYx+AiBA8izf9ZZ9ygWFedxDY4W/foYHl/0dgx6zxzI27neLyko/PAG9\r\nmZtvo1tAUBLkwcBeF6Guvj0d762eXZNGp3SEJDfvvHxxImPqZ7mfOs0CRsuO\r\nyBZH+2GhwjN6sTqDIQumZf+l1sFvN7nk+N/yr8FovqCte1I94ZExtcMde43U\r\n7lulz4WlW0a/bw27imuJHwRx7nII3380dGU=\r\n=CGs9\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.27_1683189532184_0.008262084339578868"},"_hasShrinkwrap":false},"0.11.28":{"name":"hardhat-deploy","version":"0.11.28","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.9.0","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"dependencies":{"@ethersproject/abi":"^5.7.0","@ethersproject/abstract-signer":"^5.7.0","@ethersproject/address":"^5.7.0","@ethersproject/bignumber":"^5.7.0","@ethersproject/bytes":"^5.7.0","@ethersproject/constants":"^5.7.0","@ethersproject/contracts":"^5.7.0","@ethersproject/providers":"^5.7.2","@ethersproject/solidity":"^5.7.0","@ethersproject/transactions":"^5.7.0","@ethersproject/wallet":"^5.7.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","ethers":"^5.5.3","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","zksync-web3":"^0.14.3"},"scripts":{"compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish"},"bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.28","_integrity":"sha512-Bzg+QFtp7bKYfoF7KJwFQTWcUm28MGmgDT/+VH5r3USKfzWhezQXlxpLvcBJPdV7UFHa3mGGnr8tVbNqxsllLw==","_resolved":"/tmp/28fe958ee926d31b0c3b46b57f4798e9/hardhat-deploy-0.11.28.tgz","_from":"file:hardhat-deploy-0.11.28.tgz","_nodeVersion":"16.20.0","_npmVersion":"8.19.4","dist":{"integrity":"sha512-Bzg+QFtp7bKYfoF7KJwFQTWcUm28MGmgDT/+VH5r3USKfzWhezQXlxpLvcBJPdV7UFHa3mGGnr8tVbNqxsllLw==","shasum":"01278bf62343d3a2345ee4f415d8807e0f784378","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.28.tgz","fileCount":149,"unpackedSize":11865063,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDQlN/b2xm19YANChD07wxyk5lDfYcyAIxh02NMPeUewwIhALRh6FJggi/3Uxbc/TZeYB2CnG+e1d83g4D2e2ONuX9o"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.28_1683301755809_0.24102219091549082"},"_hasShrinkwrap":false},"0.11.29":{"name":"hardhat-deploy","version":"0.11.29","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.9.0","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"dependencies":{"@ethersproject/abi":"^5.7.0","@ethersproject/abstract-signer":"^5.7.0","@ethersproject/address":"^5.7.0","@ethersproject/bignumber":"^5.7.0","@ethersproject/bytes":"^5.7.0","@ethersproject/constants":"^5.7.0","@ethersproject/contracts":"^5.7.0","@ethersproject/providers":"^5.7.2","@ethersproject/solidity":"^5.7.0","@ethersproject/transactions":"^5.7.0","@ethersproject/wallet":"^5.7.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","ethers":"^5.5.3","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","zksync-web3":"^0.14.3"},"scripts":{"compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish"},"bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.29","_integrity":"sha512-9F+MRFkEocelzB8d+SDDCcTL7edBYAj2S63ldknvfIIBSajeB6q1/jm+dlK1GjcWzAzw7EVoxtjJXzxAxZfZcg==","_resolved":"/tmp/aad2b331de0a4b408b5c01373342cd7d/hardhat-deploy-0.11.29.tgz","_from":"file:hardhat-deploy-0.11.29.tgz","_nodeVersion":"18.16.0","_npmVersion":"9.5.1","dist":{"integrity":"sha512-9F+MRFkEocelzB8d+SDDCcTL7edBYAj2S63ldknvfIIBSajeB6q1/jm+dlK1GjcWzAzw7EVoxtjJXzxAxZfZcg==","shasum":"e6d76e37fa2ed74d76d15b01f3849da3bda49a81","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.29.tgz","fileCount":154,"unpackedSize":11872830,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIBqY97snRI0oU2YigwX0Qiok+ln0JHbK8idTD1l/A90AAiBDDEyWeUGSOeFI8Cb5apsTRtuUNTj9GWWYZ226cG4EoQ=="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.29_1684009468902_0.7117737815516894"},"_hasShrinkwrap":false},"0.11.30":{"name":"hardhat-deploy","version":"0.11.30","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.9.0","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"dependencies":{"@ethersproject/abi":"^5.7.0","@ethersproject/abstract-signer":"^5.7.0","@ethersproject/address":"^5.7.0","@ethersproject/bignumber":"^5.7.0","@ethersproject/bytes":"^5.7.0","@ethersproject/constants":"^5.7.0","@ethersproject/contracts":"^5.7.0","@ethersproject/providers":"^5.7.2","@ethersproject/solidity":"^5.7.0","@ethersproject/transactions":"^5.7.0","@ethersproject/wallet":"^5.7.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","ethers":"^5.5.3","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","zksync-web3":"^0.14.3"},"scripts":{"compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish"},"bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.30","_integrity":"sha512-FpMP1zSa24NEARVh/vwFCJJa9Gws3SBRZbVIDYMIvleoH3yOwFcdWY68zfGoxrm4kRHNcaiVNAXVFTm0enKR0A==","_resolved":"/tmp/8c0095e9be3b0bd018994376fae87593/hardhat-deploy-0.11.30.tgz","_from":"file:hardhat-deploy-0.11.30.tgz","_nodeVersion":"18.16.0","_npmVersion":"9.5.1","dist":{"integrity":"sha512-FpMP1zSa24NEARVh/vwFCJJa9Gws3SBRZbVIDYMIvleoH3yOwFcdWY68zfGoxrm4kRHNcaiVNAXVFTm0enKR0A==","shasum":"d47203b584446dce8136ac6d0a96fce2827fb532","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.30.tgz","fileCount":154,"unpackedSize":11872892,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDHz9TR6ouyRBDr6r4RmW/ePKP5Qyx8MXQKqtjibS4/5QIhAJ3sp93DjmHBHbfmsWRnJ8ZcXuVBYO75UArxpXp0coG2"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.30_1685287411254_0.48974271091430843"},"_hasShrinkwrap":false},"0.11.31":{"name":"hardhat-deploy","version":"0.11.31","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.9.0","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"dependencies":{"@ethersproject/abi":"^5.7.0","@ethersproject/abstract-signer":"^5.7.0","@ethersproject/address":"^5.7.0","@ethersproject/bignumber":"^5.7.0","@ethersproject/bytes":"^5.7.0","@ethersproject/constants":"^5.7.0","@ethersproject/contracts":"^5.7.0","@ethersproject/providers":"^5.7.2","@ethersproject/solidity":"^5.7.0","@ethersproject/transactions":"^5.7.0","@ethersproject/wallet":"^5.7.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","ethers":"^5.5.3","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","zksync-web3":"^0.14.3"},"scripts":{"compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish"},"bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.31","_integrity":"sha512-86LObxQri29nxDzP7cjUyfHJ8jBF5aW60ahn883dqlw4rzc5I6ylLFQc6T2aMC2gEZI1oBc2gI2idmUulXP35g==","_resolved":"/tmp/b0e2acd32b69a20036e5b1789c0a8004/hardhat-deploy-0.11.31.tgz","_from":"file:hardhat-deploy-0.11.31.tgz","_nodeVersion":"18.16.0","_npmVersion":"9.5.1","dist":{"integrity":"sha512-86LObxQri29nxDzP7cjUyfHJ8jBF5aW60ahn883dqlw4rzc5I6ylLFQc6T2aMC2gEZI1oBc2gI2idmUulXP35g==","shasum":"1f05adc280bf7c3de502693271aa6700a043db20","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.31.tgz","fileCount":159,"unpackedSize":11874691,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIBLQqblCxJno73Kcu28Xdj7u013JKaTogbCvZOqKvfuCAiEA5Id9WKaQn679rpUhKMs8kCrIQDWmD7fAX2B89e80rXw="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.31_1686921737166_0.008627429614182391"},"_hasShrinkwrap":false},"0.11.32":{"name":"hardhat-deploy","version":"0.11.32","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.9.0","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"dependencies":{"@ethersproject/abi":"^5.7.0","@ethersproject/abstract-signer":"^5.7.0","@ethersproject/address":"^5.7.0","@ethersproject/bignumber":"^5.7.0","@ethersproject/bytes":"^5.7.0","@ethersproject/constants":"^5.7.0","@ethersproject/contracts":"^5.7.0","@ethersproject/providers":"^5.7.2","@ethersproject/solidity":"^5.7.0","@ethersproject/transactions":"^5.7.0","@ethersproject/wallet":"^5.7.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","ethers":"^5.5.3","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","zksync-web3":"^0.14.3"},"scripts":{"compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish"},"bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.32","_integrity":"sha512-DpHeI6KyC9tnGRmsNDN4KtPXmhDd9giSQaNk502hfwb7wc6Jo0RneZY9qwWKj9V3fPvTkh7JXyyc3liWl+0QVw==","_resolved":"/tmp/c810c53d02c7ac5d9c1d00dfca50ad3f/hardhat-deploy-0.11.32.tgz","_from":"file:hardhat-deploy-0.11.32.tgz","_nodeVersion":"18.16.0","_npmVersion":"9.5.1","dist":{"integrity":"sha512-DpHeI6KyC9tnGRmsNDN4KtPXmhDd9giSQaNk502hfwb7wc6Jo0RneZY9qwWKj9V3fPvTkh7JXyyc3liWl+0QVw==","shasum":"14f7167211c9b151c382201d4c2d1a4e3ba8bc01","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.32.tgz","fileCount":159,"unpackedSize":11877165,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIHLzppvlm45S1uHnf0LBsh6pzlUOFtvmOzq77EbaIygPAiBZ3KgpTiAHSXSDPbZ7hwpeJV1Klx2E6X1haPtYjOVYNA=="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.32_1687593265961_0.5564613930677034"},"_hasShrinkwrap":false},"0.11.33":{"name":"hardhat-deploy","version":"0.11.33","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.9.0","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"dependencies":{"@ethersproject/abi":"^5.7.0","@ethersproject/abstract-signer":"^5.7.0","@ethersproject/address":"^5.7.0","@ethersproject/bignumber":"^5.7.0","@ethersproject/bytes":"^5.7.0","@ethersproject/constants":"^5.7.0","@ethersproject/contracts":"^5.7.0","@ethersproject/providers":"^5.7.2","@ethersproject/solidity":"^5.7.0","@ethersproject/transactions":"^5.7.0","@ethersproject/wallet":"^5.7.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","ethers":"^5.5.3","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","zksync-web3":"^0.14.3"},"scripts":{"compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish"},"bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.33","_integrity":"sha512-hymrhhzLdw9nHQ9gBV8Xduy2xh7L1X/uAw0TYiLj3swceJ+2eMQ/I2auOCrif6V5K75fKs7HrBNrGF9jmXnmIA==","_resolved":"/tmp/23271a6a208e67b5144d735101a5944c/hardhat-deploy-0.11.33.tgz","_from":"file:hardhat-deploy-0.11.33.tgz","_nodeVersion":"18.16.0","_npmVersion":"9.5.1","dist":{"integrity":"sha512-hymrhhzLdw9nHQ9gBV8Xduy2xh7L1X/uAw0TYiLj3swceJ+2eMQ/I2auOCrif6V5K75fKs7HrBNrGF9jmXnmIA==","shasum":"89b75436a81afc95f1a3841c47617e9183b9e4f9","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.33.tgz","fileCount":159,"unpackedSize":11877843,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDVIgw6l1auqVH70RZj+XIOII37Rq4ZovLKOOGAq2Dx1AIgPZMVXTDnDv077+szbHoesjNCCEYEnerL3MxuaCSFVXg="}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.33_1687593834501_0.5244632665748339"},"_hasShrinkwrap":false},"0.11.34":{"name":"hardhat-deploy","version":"0.11.34","description":"Hardhat Plugin For Replicable Deployments And Tests","repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"license":"MIT","publishConfig":{"access":"public"},"main":"dist/src/index.js","types":"dist/src/index.d.ts","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"devDependencies":{"@changesets/cli":"^2.11.1","@types/chai":"^4.2.21","@types/debug":"^4.1.7","@types/fs-extra":"^9.0.12","@types/mocha":"^9.0.0","@types/node":"^16.6.2","@typescript-eslint/eslint-plugin":"^4.29.2","@typescript-eslint/parser":"^4.29.2","chai":"^4.2.0","dotenv":"^10.0.0","eslint":"^7.32.0","eslint-config-prettier":"^8.3.0","hardhat":"^2.9.0","mocha":"^9.1.0","prettier":"^2.3.2","prettier-plugin-solidity":"^1.0.0-beta.17","solhint":"^3.3.6","solhint-plugin-prettier":"^0.0.5","source-map-support":"^0.5.12","ts-node":"^10.2.1","typescript":"^4.3.5"},"dependencies":{"@ethersproject/abi":"^5.7.0","@ethersproject/abstract-signer":"^5.7.0","@ethersproject/address":"^5.7.0","@ethersproject/bignumber":"^5.7.0","@ethersproject/bytes":"^5.7.0","@ethersproject/constants":"^5.7.0","@ethersproject/contracts":"^5.7.0","@ethersproject/providers":"^5.7.2","@ethersproject/solidity":"^5.7.0","@ethersproject/transactions":"^5.7.0","@ethersproject/wallet":"^5.7.0","@types/qs":"^6.9.7","axios":"^0.21.1","chalk":"^4.1.2","chokidar":"^3.5.2","debug":"^4.3.2","enquirer":"^2.3.6","ethers":"^5.5.3","form-data":"^4.0.0","fs-extra":"^10.0.0","match-all":"^1.2.6","murmur-128":"^0.2.1","qs":"^6.9.4","zksync-web3":"^0.14.3"},"scripts":{"compile":"hardhat compile","lint":"eslint \"**/*.{js,ts}\" && solhint src/**/*.sol","lint:fix":"eslint --fix \"**/*.{js,ts}\" && solhint --fix src/**/*.sol","format":"prettier --write \"**/*.{ts,js,sol}\"","test":"mocha --timeout 20000 --exit","build":"tsc","watch":"tsc -w","publish:next":"npm publish --tag next","publish:release":"npm publish"},"bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"homepage":"https://github.com/wighawag/hardhat-deploy#readme","_id":"hardhat-deploy@0.11.34","_integrity":"sha512-N6xcwD8LSMV/IyfEr8TfR2YRbOh9Q4QvitR9MKZRTXQmgQiiMGjX+2efMjKgNMxwCVlmpfnE1tyDxOJOOUseLQ==","_resolved":"/tmp/ce38e2cb062ee055ed899d1b4508ee2f/hardhat-deploy-0.11.34.tgz","_from":"file:hardhat-deploy-0.11.34.tgz","_nodeVersion":"18.16.0","_npmVersion":"9.5.1","dist":{"integrity":"sha512-N6xcwD8LSMV/IyfEr8TfR2YRbOh9Q4QvitR9MKZRTXQmgQiiMGjX+2efMjKgNMxwCVlmpfnE1tyDxOJOOUseLQ==","shasum":"61252ebf5dfdda7b0b31298dd5580b0735c05910","tarball":"https://registry.npmjs.org/hardhat-deploy/-/hardhat-deploy-0.11.34.tgz","fileCount":159,"unpackedSize":11877801,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQC3x8NCew1L1f+q2No/MAq9ZLM93hkLdMpzxrtIBq9dvAIhAIBHd0fq0KTmlLc6MZ7J/OQakIde1JeGnk8KW3KnAgis"}]},"_npmUser":{"name":"wighawag","email":"npmdev1234567890@gmail.com"},"directories":{},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hardhat-deploy_0.11.34_1687614152494_0.2215794081074156"},"_hasShrinkwrap":false}},"time":{"created":"2020-10-20T23:14:19.863Z","0.7.0-beta.0":"2020-10-20T23:14:20.086Z","modified":"2023-06-24T13:42:32.965Z","0.7.0-beta.1":"2020-10-21T09:43:50.590Z","0.7.0-beta.2":"2020-10-21T20:05:09.421Z","0.7.0-beta.3":"2020-10-22T16:25:10.685Z","0.7.0-beta.4":"2020-10-22T18:04:07.736Z","0.7.0-beta.5":"2020-10-22T19:10:03.397Z","0.7.0-beta.6":"2020-10-22T19:41:43.497Z","0.7.0-beta.7":"2020-10-23T18:56:54.042Z","0.7.0-beta.8":"2020-10-23T19:10:44.272Z","0.7.0-beta.9":"2020-10-24T17:46:26.055Z","0.7.0-beta.10":"2020-10-25T09:12:18.315Z","0.7.0-beta.11":"2020-10-25T09:18:37.147Z","0.7.0-beta.12":"2020-10-25T09:38:01.486Z","0.7.0-beta.13":"2020-10-25T10:56:16.946Z","0.7.0-beta.14":"2020-10-25T17:54:51.030Z","0.7.0-beta.15":"2020-10-26T08:25:11.864Z","0.7.0-beta.16":"2020-10-26T09:29:35.719Z","0.7.0-beta.17":"2020-10-26T18:42:12.282Z","0.7.0-beta.18":"2020-10-26T19:44:32.011Z","0.7.0-beta.19":"2020-10-28T08:04:44.794Z","0.7.0-beta.20":"2020-10-28T13:23:30.439Z","0.7.0-beta.21":"2020-10-29T18:08:03.777Z","0.7.0-beta.22":"2020-10-29T21:28:50.279Z","0.7.0-beta.23":"2020-10-30T00:17:33.522Z","0.7.0-beta.24":"2020-10-30T13:07:53.108Z","0.7.0-beta.25":"2020-10-30T13:12:48.494Z","0.7.0-beta.27":"2020-11-03T07:58:20.716Z","0.7.0-beta.28":"2020-11-03T20:12:39.124Z","0.7.0-beta.29":"2020-11-19T19:26:04.538Z","0.7.0-beta.30":"2020-11-20T08:08:12.728Z","0.7.0-beta.31":"2020-11-27T20:12:10.640Z","0.7.0-beta.32":"2020-11-28T09:44:02.824Z","0.7.0-beta.33":"2020-11-30T18:01:30.895Z","0.7.0-beta.34":"2020-12-01T10:22:03.759Z","0.7.0-beta.35":"2020-12-01T10:39:03.649Z","0.7.0-beta.36":"2020-12-05T09:50:14.855Z","0.7.0-beta.37":"2020-12-05T17:05:42.972Z","0.7.0-beta.38":"2020-12-09T10:58:03.206Z","0.7.0-beta.39":"2020-12-23T09:33:11.999Z","0.7.0-beta.40":"2021-01-06T21:17:42.901Z","0.7.0-beta.41":"2021-01-06T23:44:45.749Z","0.7.0-beta.42":"2021-01-07T12:19:18.446Z","0.7.0-beta.43":"2021-01-07T18:24:06.672Z","0.7.0-beta.44":"2021-01-11T11:50:12.758Z","0.7.0-beta.45":"2021-02-18T18:26:00.004Z","0.7.0-beta.46":"2021-02-23T10:58:24.010Z","0.7.0-beta.47":"2021-03-09T17:08:35.539Z","0.7.0-beta.48":"2021-03-12T10:20:38.599Z","0.7.0-beta.49":"2021-03-22T17:59:30.401Z","0.7.0-beta.50":"2021-03-23T07:52:12.646Z","0.7.0-beta.51":"2021-03-27T19:12:28.453Z","0.7.0-beta.52":"2021-03-27T21:53:43.019Z","0.7.0-beta.53":"2021-03-29T00:11:40.956Z","0.7.0-beta.54":"2021-03-29T19:18:01.586Z","0.7.0-beta.55":"2021-03-30T10:48:54.801Z","0.7.0-beta.56":"2021-03-31T09:30:28.687Z","0.7.0-beta.57":"2021-04-01T07:14:54.704Z","0.7.0-beta.58":"2021-04-03T17:57:45.394Z","0.7.0":"2021-04-04T11:09:11.626Z","0.8.0-next.0":"2021-04-04T11:19:33.954Z","0.7.1":"2021-04-04T11:37:46.933Z","0.8.0-next.1":"2021-04-05T09:10:29.985Z","0.8.0-next.2":"2021-04-05T17:57:20.660Z","0.7.2":"2021-04-06T10:58:35.071Z","0.8.0-next.3":"2021-04-06T11:14:54.117Z","0.7.3":"2021-04-09T10:40:22.131Z","0.7.4":"2021-04-09T11:09:16.349Z","0.8.0-next.4":"2021-04-11T21:47:56.547Z","0.7.5":"2021-04-18T12:00:33.833Z","0.7.6":"2021-05-17T17:22:26.695Z","0.7.7":"2021-05-19T23:24:24.764Z","0.7.8":"2021-05-21T10:30:47.864Z","0.7.9":"2021-05-21T10:31:51.072Z","0.7.10":"2021-05-27T22:48:49.719Z","0.7.11":"2021-06-10T13:38:09.920Z","0.8.0-next.5":"2021-06-12T08:06:31.017Z","0.8.0":"2021-06-12T08:09:53.205Z","0.8.1":"2021-06-12T17:36:13.772Z","0.8.2":"2021-06-12T20:27:08.884Z","0.8.3":"2021-06-13T06:14:09.141Z","0.8.4":"2021-06-13T06:56:05.172Z","0.8.5":"2021-06-13T11:52:21.489Z","0.8.6":"2021-06-13T17:35:36.191Z","0.8.7":"2021-06-18T11:36:52.219Z","0.8.8":"2021-06-18T15:20:51.986Z","0.8.9":"2021-06-25T15:18:11.208Z","0.8.10":"2021-07-10T06:55:14.148Z","0.8.11":"2021-07-10T07:09:35.333Z","0.9.0-next.0":"2021-08-21T09:42:20.052Z","0.9.0":"2021-08-24T07:49:54.686Z","0.9.1":"2021-09-04T14:00:53.997Z","0.9.2":"2021-09-27T19:31:01.342Z","0.9.3":"2021-10-03T14:03:26.245Z","0.9.4":"2021-10-16T08:58:23.967Z","0.9.5":"2021-11-08T12:21:44.803Z","0.9.6":"2021-11-10T15:41:51.312Z","0.9.7":"2021-11-13T09:53:33.550Z","0.9.8":"2021-11-13T10:02:53.934Z","0.9.9":"2021-11-21T16:03:06.621Z","0.9.10":"2021-11-21T16:06:00.599Z","0.9.11":"2021-11-25T07:20:14.515Z","0.9.12":"2021-11-25T07:26:28.249Z","0.9.13":"2021-11-28T17:08:52.029Z","0.9.14":"2021-11-28T22:36:33.545Z","0.9.15":"2021-12-24T11:00:04.191Z","0.9.16":"2021-12-24T11:12:22.731Z","0.9.17":"2021-12-24T11:19:06.383Z","0.9.18":"2021-12-24T14:34:34.429Z","0.9.19":"2021-12-25T00:10:58.939Z","0.9.20":"2021-12-26T10:57:34.682Z","0.9.21":"2021-12-26T11:05:44.114Z","0.9.22":"2021-12-26T11:13:22.370Z","0.9.23":"2021-12-30T14:05:40.235Z","0.9.24":"2022-01-03T15:51:34.731Z","0.9.25":"2022-01-20T10:17:02.106Z","0.9.26":"2022-01-20T11:25:12.789Z","0.9.27":"2022-01-21T18:27:53.241Z","0.9.28":"2022-01-24T12:22:57.686Z","0.9.29":"2022-01-27T19:26:25.295Z","0.10.0":"2022-01-28T12:34:53.787Z","0.10.1":"2022-01-28T17:29:29.895Z","0.10.2":"2022-01-28T21:49:11.900Z","0.10.3":"2022-01-29T09:59:21.458Z","0.10.4":"2022-01-29T15:36:07.338Z","0.11.0-next.0":"2022-02-01T16:31:53.140Z","0.11.0-next.1":"2022-02-01T16:53:49.501Z","0.11.0-next.2":"2022-02-01T17:33:08.487Z","0.10.5":"2022-02-07T12:56:31.731Z","0.11.0-next.3":"2022-02-28T08:24:23.871Z","0.11.0-next.4":"2022-02-28T09:18:47.393Z","0.11.0-next.5":"2022-03-01T07:07:36.904Z","0.10.6":"2022-03-11T07:50:39.301Z","0.11.0":"2022-03-15T21:42:47.763Z","0.11.1":"2022-03-21T16:21:21.607Z","0.11.2":"2022-03-21T23:15:41.429Z","0.11.3-experimental.0":"2022-03-24T06:36:05.381Z","0.11.3-experimental.1":"2022-03-24T06:40:20.627Z","0.11.3-experimental.2":"2022-03-24T06:43:14.538Z","0.11.3":"2022-03-29T07:29:08.626Z","0.11.4":"2022-03-29T07:30:28.633Z","0.10.5-zksync.0":"2022-05-03T09:55:06.576Z","0.11.5-zksync.0":"2022-05-03T10:05:39.624Z","0.11.5-zksync.1":"2022-05-17T08:28:19.889Z","0.11.5":"2022-05-17T08:29:20.291Z","0.11.6":"2022-05-20T19:36:33.777Z","0.11.7":"2022-05-20T19:44:57.144Z","0.11.8":"2022-05-20T20:10:25.840Z","0.11.9":"2022-05-20T20:30:07.415Z","0.11.10":"2022-05-23T08:33:23.643Z","0.11.11":"2022-06-29T14:20:04.285Z","0.11.12":"2022-07-24T18:38:42.770Z","0.11.13":"2022-09-04T06:48:08.324Z","0.11.14":"2022-09-07T08:31:24.692Z","0.11.15":"2022-09-14T04:14:07.904Z","0.11.16":"2022-10-04T22:03:05.930Z","0.11.17":"2022-10-07T17:23:28.937Z","0.11.18":"2022-10-07T21:29:56.997Z","0.11.19":"2022-10-28T14:07:04.404Z","0.11.20":"2022-11-03T12:50:38.394Z","0.11.21":"2022-11-30T06:06:38.431Z","0.11.22":"2022-12-02T02:11:29.811Z","0.11.23":"2023-02-03T15:59:38.646Z","0.11.24":"2023-02-27T12:52:32.383Z","0.11.25":"2023-03-07T09:40:13.435Z","0.11.26":"2023-04-08T21:21:07.592Z","0.11.27":"2023-05-04T08:38:52.464Z","0.11.28":"2023-05-05T15:49:16.150Z","0.11.29":"2023-05-13T20:24:29.204Z","0.11.30":"2023-05-28T15:23:31.547Z","0.11.31":"2023-06-16T13:22:17.434Z","0.11.32":"2023-06-24T07:54:26.358Z","0.11.33":"2023-06-24T08:03:54.908Z","0.11.34":"2023-06-24T13:42:32.799Z"},"maintainers":[{"name":"wighawag","email":"npmdev1234567890@gmail.com"}],"description":"Hardhat Plugin For Replicable Deployments And Tests","homepage":"https://github.com/wighawag/hardhat-deploy#readme","keywords":["ethereum","smart-contracts","deployment","test","testing","tool","hardhat","hardhat-deploy","hardhat-plugin"],"repository":{"type":"git","url":"git+https://github.com/wighawag/hardhat-deploy.git"},"author":{"name":"wighawag"},"bugs":{"url":"https://github.com/wighawag/hardhat-deploy/issues"},"license":"MIT","readme":"<h1> hardhat-deploy</h1>\n\n_A [Hardhat](https://hardhat.org) Plugin For Replicable Deployments And Easy Testing_\n\n> **A complete dev template using hardhat-deploy is available here**: https://github.com/wighawag/template-ethereum-contracts\n> It also contains various branches examplifying the capability of hardhat-deploy. Check it out.\n\n- [What is it for?](#what-is-it-for-)\n- [hardhat-deploy in a nutshell](#hardhat-deploy-in-a-nutshell)\n- [Installation](#installation)\n  - [npm install hardhat-deploy](#npm-install-hardhat-deploy)\n  - [TypeScript support](#typescript-support)\n  - [Migrating existing deployment to hardhat-deploy](#migrating-existing-deployment-to-hardhat-deploy)\n- [Hardhat Tasks Available/Updated](#hardhat-tasks-availableupdated)\n  - [1. hardhat deploy](#1-hardhat-deploy)\n    - [**Options**](#options)\n    - [**Flags**](#flags)\n  - [2. hardhat node](#2-hardhat-node)\n    - [**Options**](#options-1)\n    - [**Flags**](#flags-1)\n  - [3. hardhat test](#3-hardhat-test)\n  - [4. hardhat etherscan-verify](#4-hardhat-etherscan-verify)\n    - [**Options**](#options-2)\n  - [5. hardhat sourcify](#5-hardhat-sourcify)\n    - [**Options**](#options-3)\n  - [6. hardhat export](#6-hardhat-export)\n    - [**Options**](#options-4)\n- [Hardhat Environment Extensions](#hardhat-environment-extensions)\n- [Configuration](#configuration)\n  - [**1. namedAccounts (ability to name addresses)**](#1-namedaccounts-ability-to-name-addresses)\n  - [**2. extra hardhat.config networks' options**](#2-extra-hardhatconfig-networks-options)\n    - [`live`](#live)\n    - [`saveDeployments`](#savedeployments)\n    - [`tags`](#tags)\n    - [`deploy`](#deploy)\n    - [`companionNetworks`](#companionnetworks)\n  - [**3. extra hardhat.config paths' options**](#3-extra-hardhatconfig-paths-options)\n  - [**4. deterministicDeployment (ability to specify a deployment factory)**](#4-deterministicdeployment-ability-to-specify-a-deployment-factory)\n  - [Importing deployment from other projects (with truffle support)](#importing-deployment-from-other-projects-with-truffle-support)\n  - [Access to Artifacts (non-deployed contract code and abi)](#access-to-artifacts-non-deployed-contract-code-and-abi)\n- [How to Deploy Contracts](#how-to-deploy-contracts)\n  - [The `deploy` Task](#the-deploy-task)\n  - [Deploy Scripts](#deploy-scripts)\n    - [An example of a deploy script :](#an-example-of-a-deploy-script-)\n  - [The `deployments` field](#the-deployments-field)\n    - [`deployments.deploy(<name>, options)`](#deploymentsdeployname-options)\n- [Handling contract using libraries](#handling-contract-using-libraries)\n- [Exporting Deployments](#exporting-deployments)\n- [Deploying and Upgrading Proxies](#deploying-and-upgrading-proxies)\n- [Builtin-In Support For Diamonds (EIP2535)](#builtin-in-support-for-diamonds-eip2535)\n  - [deployment / upgrade](#deployment--upgrade)\n  - [onUpgrade calls](#onupgrade-calls)\n  - [more...](#more)\n- [Testing Deployed Contracts](#testing-deployed-contracts)\n  - [Creating Fixtures](#creating-fixtures)\n- [More Information On Hardhat Tasks](#more-information-on-hardhat-tasks)\n  - [**1. node task**](#1-node-task)\n  - [**2. test task**](#2-test-task)\n  - [**3. run task**](#3-run-task)\n  - [**4. console task**](#4-console-task)\n- [Deploy Scripts: Tags And Dependencies](#deploy-scripts-tags-and-dependencies)\n\n## What is it for?\n\nThis [hardhat](https://hardhat.org) plugin adds a mechanism to deploy contracts to any network, keeping track of them and replicating the same environment for testing.\n\nIt also adds a mechanism to associate names to addresses, so test and deployment scripts can be reconfigured by simply changing the address a name points to, allowing different configurations per network. This also results in much clearer tests and deployment scripts (no more `accounts[0]` in your code).\n\nThis plugin contains a lot more features too, all geared toward a better developer experience :\n\n- chain configuration export\n- listing deployed contracts' addresses and their abis (useful for web apps)\n- library linking at the time of deployment.\n- deterministic deployment across networks.\n- support for specific deploy script per network (L1 vs L2 for example)\n- ability to access deployment from \"companion\" networks\n- deployment dependency system (allowing you to only deploy what is needed).\n- deployment retrying (by saving pending tx): so you can feel confident when making a deployment that you can always recover.\n- deployments as test fixture using `evm_snapshot` to speed up testing.\n- ability to create your own test fixture that automatically benefits from `evm_snapshot`'s tests speed-up boost\n- combined with [hardhat-deploy-ethers](https://github.com/wighawag/hardhat-deploy-ethers) it has the ability to get ethers contract instance by name (like `await ethers.getContract(\"ContractName\")`).\n- importing artifacts from external sources (like npm packages), including [truffle](https://www.trufflesuite.com/truffle) support.\n- importing deployments from external sources (like npm packages)\n- ability to log information in `deploy` mode only (while in test the console remains clean).\n- contains helpers to read and execute transaction on deployed contract referring to them by name.\n- These helpers contains options to auto-mine on dev network (to speed up test deployments).\n- save metadata of deployed contract so they can always be fully verified, via [sourcify](https://sourcify.dev) or [etherscan](https://etherscan.io).\n- ability to submit contract source to etherscan and sourcify for verification at any time. (Because **hardhat-deploy** will save all the necessary info, it can be executed at any time.)\n- support hardhat's fork feature so deployment can be accessed even when run through fork.\n- named accounts are automatically impersonated too, so you can perform tx as if you had their private key.\n- proxy deployment with ability to upgrade them transparently, only if code changes.\n- this include support for [openzeppelin](https://openzeppelin.com) transparent proxies\n- diamond deployment with facets, allowing you to focus on what the new version will be. It will generate the diamondCut necessary to reach the new state.\n- watch and deploy: **hardhat-deploy** can watch both your deploy script and contract code and redeploy on changes.\n- HCR (Hot Contract Replacement): the watch feature combined with proxy or diamond, gives you an experience akin to frontend Hot Module Replacement: once your contract changes, the deployment is executed and your contract retains the same address and same state, allowing you to tweak your contracts while debugging your front-end.\n\n## hardhat-deploy in a nutshell\n\nBefore going into the details, here is a very simple summary of the basic feature of **hardhat-deploy**.\n\n**hardhat-deploy** allows you to write [`deploy scripts`](#deploy-scripts) in the `deploy` folder. Each of these files that look as follows will be executed in turn when you execute the following task: `hardhat --network <networkName> deploy`\n\n```js\n// deploy/00_deploy_my_contract.js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('MyContract', {\n    from: deployer,\n    args: ['Hello'],\n    log: true,\n  });\n};\nmodule.exports.tags = ['MyContract'];\n```\n\nFurthermore you can also ensure these scripts are executed in test too by calling `await deployments.fixture(['MyContract'])` in your test.\nThis is optimized, so if multiple tests use the same contract, the deployment will be executed once and each test will start with the exact same state.\n\nThis is a huge benefit for testing since you are not required to replicate the deployment procedure in your tests. The tag feature (as seen in the script above) and [dependencies](#deploy-scripts-tags-and-dependencies) will also make your life easier when writing complex deployment procedures.\n\nYou can even group deploy scripts in different sub-folders and ensure they are executed in their logical order.\n\nFurthermore hardhat-deploy can also support a multi-chain settings like L1, L2 with multiple deploy folder specific to each network.\n\n**All of this can also be bundled in a npm package so users of hardhat-deploy can reuse your deployment procedure and get started integrating with your project locally.**\n\nThere is a tutorial covering the basics here: https://github.com/wighawag/tutorial-hardhat-deploy\n\n## Installation\n\n### npm install hardhat-deploy\n\n```bash\nnpm install -D hardhat-deploy\n```\n\nAnd add the following statement to your `hardhat.config.js`:\n\n```js\nrequire('hardhat-deploy');\n```\n\nif you use `ethers.js` we recommend you also install `hardhat-deploy-ethers` which add extra features to access deployments as ethers contract.\n\nSince `hardhat-deploy-ethers` is a fork of `@nomiclabs/hardhat-ethers` and that other plugin might have a hardcoded  dependency on `@nomiclabs/hardhat-ethers` the best way to install `hardhat-deploy-ethers` and ensure compatibility is the following:\n\n```bash\nnpm install --save-dev  @nomiclabs/hardhat-ethers@npm:hardhat-deploy-ethers ethers\n```\n\nWhich means you then need to do `require(\"@nomiclabs/hardhat-ethers\")` instead of `require(\"hardhat-deploy-ethers\")` in your `hardhat.config.js` file.\n\nMore details on `hardhat-deploy-ethers` repo: https://github.com/wighawag/hardhat-deploy-ethers#readme\n\n### TypeScript support\n\nWith hardhat the tsconfig.json is optional.\n\nBut if you add folders to the `include` field in `tsconfig.json`, you ll also need to include `hardhat.config.ts` like :\n\n`\"include\": [\"./hardhat.config.ts\", \"./scripts\", \"./deploy\", \"./test\"]`\n\nfor deploy script (see below) you can write them this way to benefit from typing :\n\n```ts\nimport {HardhatRuntimeEnvironment} from 'hardhat/types';\nimport {DeployFunction} from 'hardhat-deploy/types';\n\nconst func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {\n  // code here\n};\nexport default func;\n```\n\nSee a template that uses **hardhat-deploy** here: https://github.com/wighawag/template-ethereum-contracts\n\nThis repo has also some examples branch that exemplify specific features, like the forking testing here: https://github.com/wighawag/template-ethereum-contracts/tree/examples/fork-test\n\n### Migrating existing deployment to hardhat-deploy\n\n> Only needed for an existing project that already deployed contracts and has the deployment information available **(at minimum, address and abi)**\n\nYou might want to switch your current deployment process to use **hardhat-deploy**. In that case you probably have some deployments saved elsewhere.\n\nIn order to port them to **hardhat-deploy**, you'll need to create one `.json` file per contract in the `deployments/<network>` folder (configurable via [paths config](#extra-paths-config)).\n\nThe network folder is simply the hardhat network name (as configured in hardhat.config.js) (accessible at runtime via `hre.network.name`).\nSuch folder need to have a file named `.chainId` containing the chainId as decimal.\n\nFor example for a network named \"rinkeby\" (for the corresponding network) the file `deployments/rinkeby/.chainId` would be\n\n```\n4\n```\n\nNote, prior to hardhat 0.6 the chainId was appended to the folder name (expect for some known network name). This has changed and upgrading to 0.6 will require you to change the folder name and add the '.chainId' file.\n\nEach contract file must follow this type (as defined in [types.ts](types.ts)) :\n\n```ts\nexport interface Deployment {\n  address: Address;\n  abi: ABI;\n  receipt?: Receipt;\n  transactionHash?: string;\n  history?: Deployment[];\n  numDeployments?: number;\n  implementation?: string;\n  args?: any[];\n  linkedData?: any;\n  solcInputHash?: string;\n  metadata?: string;\n  bytecode?: string;\n  deployedBytecode?: string;\n  libraries?: Libraries;\n  userdoc?: any;\n  devdoc?: any;\n  methodIdentifiers?: any;\n  diamondCut?: FacetCut[];\n  facets?: Facet[];\n  storageLayout?: any;\n  gasEstimates?: any;\n}\n```\n\nAs you can see, only abi and address are mandatory. But having the other fields allow more feature. For example, metadata and args allow you to benefit from contract code verification.\n\nFor Receipt, the following type is expected:\n\n```ts\nexport type Receipt = {\n  from: string;\n  transactionHash: string;\n  blockHash: string;\n  blockNumber: number;\n  transactionIndex: number;\n  cumulativeGasUsed: string;\n  gasUsed: string;\n  contractAddress?: string;\n  to?: string;\n  logs?: Log[];\n  events?: any[];\n  logsBloom?: string;\n  byzantium?: boolean;\n  status?: number;\n  confirmations?: number;\n};\n```\n\nHere is an example:\n\nLet's say you have:\n\n- 2 Contract named Greeter and Registry deployed on rinkeby\n- 1 contract named Greeter on mainnet\n- 2 Contract named Greeter and Registry deployed on a network named rinkeby2\n\nYou would get the following folder structure:\n\n```\ndeployments/\n  mainnet/\n    .chainId\n    Greeter.json\n  rinkeby/\n    .chainId\n    Greeter.json\n    Registry.json\n  rinkeby2/\n    .chainId\n    Greeter.json\n    Registry.json\n```\n\nThe reason why **hardhat-deploy** save chainId in the `.chainId` file is both for\n\n- safety: so that if you were to change the network name to point to a different chain, it would not attempt to read the wrong folder and assume that a contract has been deployed while it has not.\n- ability to know the chainId without requiring to be connected to a node (and so not dependent on hardhat.config.js settings). Useful for `export` task.\n\n---\n\n## Hardhat Tasks Available/Updated\n\nhardhat deploy add several task to hardhat. It also modify existing one, adding new options and new behavior. All of these are described here:\n\n---\n\n### 1. hardhat deploy\n\n---\n\nThis plugin adds the _deploy_ task to Hardhat.\n\nThis task will execute the scripts in the `deploy` folder and save the contract deployments to disk. These deployments are supposed to be saved for example in a git repository. This way they can be accessed later. But you are free to save them elsewhere and get them back via your mechanism of choice.\n\nWith the deployment saved, it allows you to deploy a contract only if changes were made.\n\nDeploy scripts (also called Deploy functions) can also perform aribtrary logic.\n\nFor further details on how to use it and write deploy script, see [section](#deploy-scripts) below.\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your front end.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployments, regardless of the network being invoked.\n\n`--tags <tags>`: only excutes deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice (in wei) to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--reset`: This flag resets the deployments from scratch. Previously deployed contract are not considered and deleted from disk.\n\n`--silent`: This flag removes **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag make the task never-ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n---\n\n### 2. hardhat node\n\n---\n\nThis plugin modify the _node_ task so that it also execute the deployment script before exposing the server http RPC interface\n\nIt add similar options than the `deploy` task :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your front end. If the extension ends in .ts it will generate a typescript file containing the contracts info.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked. If the extension ends in .ts it will generate a typescript file containing the contracts info.\n\n`--tags <tags>`: only excutes deploy scripts with the given tags (separated by commas) and their dependencies (see more info [here](#deploy-scripts-tags-and-dependencies) about tags and dependencies)\n\n`--gasprice <gasprice>`: specify the gasprice to use by default for transactions executed via **hardhat-deploy** helpers in deploy scripts\n\n`--write <boolean>`: default to true (except for hardhat network). If true, write deployments to disk (in deployments path, see [path config](#extra-paths-config)).\n\n#### **Flags**\n\n`--no-reset`: This flag prevent the reseting of the existing deployments. This is usually not desired when running the `node` task as a network is created from scratch and previous deployemnt are irrelevant.\n\n`--show-accounts`: this flag will output the account private keys\n\n`--silent`: This flag removes **hardhat-deploy** log output (see log function and log options for [`hre.deployments`](#the-deployments-field))\n\n`--watch`: This flag makes the task never-ending, watching for file changes in the deploy scripts folder and the contract source folder. If any changes happen the contracts are recompiled and the deploy script are re-run. Combined with a proxy deployment ([Proxies](#deploying-and-upgrading-proxies) or [Diamond](#builtin-in-support-for-diamonds-eip2535)) this allow to have HCR (Hot Contract Replacement).\n\n`--no-deploy` that discard all other options to revert to normal `hardhat node` behavior without any deployment being performed.\n\n> :warning: Note that the deployments are saved as if the network name is `localhost`. This is because `hardhat node` is expected to be used as localhost: You can for example execute `hardhat --network localhost console` after `node` is running. Doing `hardhat --network hardhat console` would indeed not do anything useful. It still take the configuration from `hardhat` in the hardhat.config.js file though.\n\n---\n\n### 3. hardhat test\n\n---\n\nThis plugin adds a flag argument `--deploy-fixture` to the _test_ task which if enabled will run the global deployments fixture before the tests and snapshots it. This will generally speed up the tests as further test will be able to revert back to the full deployment.\n\n> :warning: Note though that if your test behave differently whether that option is on or not, this most likely mean that your deploy scripts' tags and dependencies are not configured correctly. This is because the global fixture will ensure all contract are deployed while test will usually (for efficiency) ask for a particular tag.\n\n---\n\n### 4. hardhat etherscan-verify\n\n---\n\nThis plugin adds the _etherscan-verify_ task to Hardhat.\n\nThis task will submit the contract source and other info of all deployed contracts to allow etherscan to verify and record the sources.\n\nInstead of using the full solc input, this task will first attempt to send the minimal sources from the metadata.\nBut Etherscan sometime fails due to a bug in solidity compiler (<https://github.com/ethereum/solidity/issues/9573>). As such this task can fallback on full solc input (see option --solc-input). Note that if your contract was deployed with a previous version of **hardhat-deploy**, it might not contains the full information. The issue seems to be fully resolved since solc version 0.8.\n\nThis task will also attempt to automatically find the SPDX license in the source.\n\nTo execute that task, you need to specifiy the network to run against :\n\n```bash\nhardhat --network mainnet etherscan-verify [--api-key <apikey>] [--apiurl <url>]\n```\n\n#### **Options**\n\nNote that harhdat-deploy now use a different config format to not conflict with `hardhat-etherscan`\n\n`--api-key <api key>`: let you specify your etherscan api key. Alternatively, you can provide it via the env variable `ETHERSCAN_API_KEY` or through the hardhat.config.ts verify field:\n\n```js\n{\n  ...\n  verify: {\n    etherscan: {\n      apiKey: '<API key>'\n    }\n  }\n}\n```\n\n`--api-url <url>`: let you specify your etherscan url to submit the source to. Can also be configured per network in `hardhat.config.js`:\n\n```js\n{\n  ...\n  networks: {\n    mynetwork: {\n      ...\n      verify: {\n        etherscan: {\n          apiUrl: 'http://mynetwork.xyz'\n        }\n      }\n    }\n  }\n}\n```\n\n`--license <SPDX license id>`: SPDX license (useful if SPDX is not listed in the sources), need to be supported by etherscan: https://etherscan.io/contract-license-types\n\n`--force-license`: if set, will force the use of the license specified by --license option, ignoring the one in the source (useful for license not supported by etherscan)\n\n`--solc-input`: fallback on solc-input id needed (useful when etherscan fails on the minimum sources, see https://github.com/ethereum/solidity/issues/9573)\n\n`--sleep`: sleep 500ms between each verification, so API rate limit is not exceeded\n\n---\n\n### 5. hardhat sourcify\n\n---\n\nThis plugin adds the _sourcify_ task to Hardhat.\n\nSimilar to `hardhat etherscan-verify` this task will submit the contract source and other info of all deployed contracts to sourcify.\n\n```bash\nhardhat --network mainnet sourcify\n```\n\nLater this task might instead pin the metadata to ipfs, so sourcify can automatically verify them.\n\n#### **Options**\n\n`--contract-name <contract name>`: specify the contract's name you want to verify\n\n`--endpoint <endpoint>`: specify the sourcify endpoint, default to https://sourcify.dev/server/\n\n`--write-failing-metadata`: if set and the sourcify task fails to verify, the metadata file will be written to disk, so you can more easily figure out what has gone wrong.\n\n---\n\n### 6. hardhat export\n\n---\n\nThis plugin adds the _export_ task to Hardhat.\n\nThis task will export the contract deployed (saved in `deployments` folder) to a file with a simple format containing only contract addresses and abi, useful for web apps.\n\nOne of the following options need to be set for this task to have any effects :\n\n#### **Options**\n\n`--export <filepath>`: export one file that contains all contracts (address, abi + extra data) for the network being invoked. The file contains the minimal information so to not bloat your front end. If the extension ends in .ts it will generate a typescript file containing the contracts info.\n\n`--export-all <filepath>`: export one file that contains all contracts across all saved deployment, regardless of the network being invoked. If the extension ends in .ts it will generate a typescript file containing the contracts info.\n\nThis last option has some limitations, when combined with the use of external deployments (see [Configuration](#configuration)). If such external deployments were using older version of **hardhat-deploy** or truffle, the chainId might be missing. In order for these to be exported, the hardhat network config need to explicity state the chainId in the `networks` config of `hardhat.config.js`.\n\nWith both `--export` and `--export-all`, using the special `<filepath>` value of `-` will output to `STDOUT` rather than writing a normal file.\n\n---\n\n---\n\n## Hardhat Environment Extensions\n\nThis plugin extends the Hardhat Runtime Environment by adding 4 fields:\n\n- `getNamedAccounts: () => Promise<{ [name: string]: string }>`: a function returning an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [Configuration](#configuration)).\n\n- `getUnnamedAccounts: () => Promise<string[]}>`: accounts which has no names, useful for test where you want to be sure that the account is not one of the predefined one\n\n- `deployments`: contains functions to access past deployments or to save new ones, as well as helpers functions.\n\n- `getChainId(): Promise<string>`: offer an easy way to fetch the current chainId.\n\n---\n\n---\n\n## Configuration\n\n---\n\n### **1. namedAccounts (ability to name addresses)**\n\n---\n\nThis plugin extends the `HardhatConfig`'s object with an optional `namedAccounts` field.\n\n`namedAccounts` allows you to associate names to addresses and have them configured per chain.\nThis allows you to have meaningful names in your tests while the addresses match to multi sig in real network for example.\n\n```js\n{\n    namedAccounts: {\n        deployer: {\n            default: 0, // here this will by default take the first account as deployer\n            1: 0, // similarly on mainnet it will take the first account as deployer. Note though that depending on how hardhat network are configured, the account 0 on one network can be different than on another\n            4: '0xA296a3d5F026953e17F472B497eC29a5631FB51B', // but for rinkeby it will be a specific address\n            \"goerli\": '0x84b9514E013710b9dD0811c9Fe46b837a4A0d8E0', //it can also specify a specific netwotk name (specified in hardhat.config.js)\n        },\n        feeCollector:{\n            default: 1, // here this will by default take the second account as feeCollector (so in the test this will be a different account than the deployer)\n            1: '0xa5610E1f289DbDe94F3428A9df22E8B518f65751', // on the mainnet the feeCollector could be a multi sig\n            4: '0xa250ac77360d4e837a13628bC828a2aDf7BabfB3', // on rinkeby it could be another account\n        }\n    }\n}\n```\n\n<!-- You can also specify addresses with the `ledger://` prefix. In which case the account fetched will still be the corresponding address, but behind the scene, the transaction will be created via the hardware waller. Currently the feature is not working very well though and better support is needed. -->\n\n---\n\n### **2. extra hardhat.config networks' options**\n\n---\n\n**hardhat-deploy** add 5 new fields to `networks` configuration\n\n#### `live`\n\nthis is not used internally but is useful to perform action on a network whether it is a live network (rinkeby, mainnet, etc) or a temporary one (localhost, hardhat). The default is true (except for localhost and hardhat where the default is false).\n\n#### `saveDeployments`\n\nthis tell whether **hardhat-deploy** should save the deployments to disk or not. Default to true, except for the hardhat network.\n\n#### `tags`\n\nnetwork can have tags to represent them. The config is an array and at runtime the hre.network.tags is an object whose fields (the tags) are set to true.\n\nThis is useful to conditionally operate on network based on their use case.\n\nExample:\n\n```js\n{\n  networks: {\n    localhost: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"local\"]\n    },\n    hardhat: {\n      live: false,\n      saveDeployments: true,\n      tags: [\"test\", \"local\"]\n    },\n    rinkeby: {\n      live: true,\n      saveDeployments: true,\n      tags: [\"staging\"]\n    }\n  }\n}\n```\n\n#### `deploy`\n\nthe deploy field override the paths.deploy option and let you define a set of folder containing the deploy scripts to be executed for this network.\n\nYou can thus have one network that will be executing L1 deployment and other L2 deployments, etc...\n\nYou could also have a folder that deploy contracts that are live on mainnet but that you need to replicate for your test or local network.\n\nExample:\n\n```js\n{\n  networks: {\n    mainnet: {\n      deploy: [ 'deploy/' ]\n    },\n    rinkeby: {\n      deploy: [ 'testnet-deploy/' ]\n    }\n  }\n}\n```\n\n#### `companionNetworks`\n\nthe companionNetworks field is an object whose key is any name you desire and the value is the name of a network that will be accessible inside the deploy script. For example:\n\n```js\n{\n  ...\n  networks: {\n    optimism: {\n      url: 'http://127.0.0.1:8545',\n      ovm: true,\n      companionNetworks: {\n        l1: 'localhost',\n      },\n    }\n  }\n  ...\n}\n```\n\nBy using name you can have the same deploy script used in different set of network.\n\nFor your test you could have the companion networks pointing to the same hardhat network, for test deployment, you could have rinkeby acting like your l2 while goerli act as your l1.\n\nAn example repo that show case a multi-network setup with optimism can be found here: https://github.com/wighawag/template-ethereum-contracts/tree/examples/optimism\n\ndeploy script can then access the network and its deployment as follow :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  const OVM_L1ERC20Gateway = await hre.companionNetworks['l1'].deployments.get(\n    'OVM_L1ERC20Gateway'\n  ); // layer 1\n\n  await execute(\n    'SimpleERC20_OVM',\n    {from: deployer, log: true},\n    'init',\n    OVM_L1ERC20Gateway.address\n  );\n};\n```\n\n---\n\n### **3. extra hardhat.config paths' options**\n\n---\n\n`hardhat-deploy` also adds fields to `HardhatConfig`'s `ProjectPaths` object.\n\nHere is an example showing the default values :\n\n```js\n{\n    paths: {\n        deploy: 'deploy',\n        deployments: 'deployments',\n        imports: 'imports'\n    }\n}\n```\n\nThe `deploy` folder is expected to contains the deploy script that are executed upon invocation of `hardhat deploy` or `hardhat node`.\nIt can also be an array of folder path.\n\nThe `deployments` folder will contains the resulting deployments (contract addresses along their abi, bytecode, metadata...). One folder per network and one file per contract.\n\nThe `imports` folder is expected to contains artifacts that were pre-compiled. Useful if you want to upgrade to a new solidity version but want to keep using previously compiled contracts. The artifact is the same format as normal hardhat artifact, so you can easily copy them over, before switching to a new compiler version.\n\n> This is less useful now that hardhat support multiple solidity compiler at once.\n\n---\n\n---\n\n### **4. deterministicDeployment (ability to specify a deployment factory)**\n\n---\n\nThis plugin extends the `HardhatConfig`'s object with an optional `deterministicDeployment` field.\n\n`deterministicDeployment` allows you to associate information that are used on each network for deterministic deployment. The information for each deterministic deployment consist out of a `factory`, a `deployer`, the required `funding` and a `signedTx` to deploy the factory. The default deterministic deployment used is the [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy). The factory expects a 32 bytes `salt` concatenated with the deployment data (see [EIP-1014](https://eips.ethereum.org/EIPS/eip-1014) for more information on these parameters).\n\nUsing the `deterministicDeployment` it is possible to define a different setup for the deterministic deployment. One use case for this is the deterministic deployment on networks that required replay protection (such as Celo or Avalanche). The [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy) can only be deployed on networks that don't enforce replay protection, therefore on other networks an alternative library has to be used. An example for this would be the [Safe Singleton Factory](https://github.com/gnosis/safe-singleton-factory) that is an adjusted version of the [Deterministic Deployment Proxy](https://github.com/Arachnid/deterministic-deployment-proxy) that contains signed transactions that include replay protection.\n\nThe information can be defined either as an object\n\n```js\n{\n    deterministicDeployment: {\n      \"4\": {\n        factory: \"<factory_address>\",\n        deployer: \"<deployer_address>\",\n        funding: \"<required_funding_in_wei>\",\n        signedTx: \"<raw_signed_tx>\",\n      }\n    }\n}\n```\n\nor as an function that returns the information for the deterministic deployment\n\n```js\n{\n  deterministicDeployment: (network: string) => {\n    return {\n      factory: '<factory_address>',\n      deployer: '<deployer_address>',\n      funding: '<required_funding_in_wei>',\n      signedTx: '<raw_signed_tx>',\n    };\n  };\n}\n```\n\n### Importing deployment from other projects (with truffle support)\n\n`hardhat-deploy` also add the `external` field to `HardhatConfig`\n\nSuch field allows to specify paths for external artifacts or **deployments**.\n\nThe external object has 2 fields:\n\n```js\n{\n    external: {\n        contracts: [\n          {\n            artifacts: \"node_modules/@cartesi/arbitration/export/artifacts\",\n            deploy: \"node_modules/@cartesi/arbitration/export/deploy\"\n          },\n          {\n            artifacts: \"node_modules/someotherpackage/artifacts\",\n          }\n        ],\n        deployments: {\n          rinkeby: [\"node_modules/@cartesi/arbitration/build/contracts\"],\n        },\n    }\n}\n```\n\nThe `contracts` field specify an array of object which itself have 2 fields.\n\n- `artifacts`: (mandatory) it is a path to an artifact folder. This support both hardhat and truffle artifacts.\n- `deploy`: (optional) it specifies a path to a folder where reside deploy script. The deploy scripts have only access to the artifact specified in the artifacts field. This allow project to share their deployment procedure. A boon for developer aiming at integrating it as they can get the contracts to be deployed for testing locally.\n\nThe `deployments` fields specify an object whose field names are the hardhat network and the value is an array of path to look for deployments. It supports both **hardhat-deploy** and truffle formats.\n\n---\n\n### Access to Artifacts (non-deployed contract code and abi)\n\nArtifacts in hardhat terminology represent a compiled contract (not yet deployed) with at least its bytecode and abi.\n\n`hardhat-deploy` gives can access to these artifact via the `deployments.getArtifact` function :\n\n```js\nconst {deployments} = require('hardhat');\nconst artifact = await deployments.getArtifact(artifactName);\n```\n\nWith the `hardhat-deploy-ethers` plugin you can get an artifact as an ethers contract factory, ready to be deployed, via the following:\n\n```js\nconst {deployments, ethers} = require('hardhat');\nconst factory = await ethers.getContractFactory(artifactName);\n```\n\n> Note that the artifact's files need to be either in `artifacts` folder that hardhat generate on compilation or in the `imports` folder where you can store contracts compiled elsewhere. They can also be present in the folder specified in `external.artifacts` see [Importing deployment from other projects](#importing-deployment-from-other-projects-with-truffle-support)\n\n---\n\n---\n\n## How to Deploy Contracts\n\n---\n\n### The `deploy` Task\n\n`hardhat --network <networkName> deploy [options and flags]`\n\nThis is a new task that the `hardhat-deploy` adds. As the name suggests it deploys contracts.\nTo be exact it will look for files in the folder `deploy` or whatever was configured in `paths.deploy`, see [paths config](#extra-paths-config)\n\nIt will scan for files in alphabetical order and execute them in turn.\n\n- it will `require` each of these files and execute the exported function with the HRE as argument\n\nTo specify the network, you can use the builtin hardhat argument `--network <network name>` or set the env variable `HARDHAT_NETWORK`\n\n> :warning: Note that running `hardhat deploy` without specifying a network will use the default network. If the default network is hardhat (the default's default) then nothing will happen as a result as everything happens in memory, but this can be used to ensure the deployment is without issues.\n\n---\n\n### Deploy Scripts\n\nThe deploy scripts need to be of the following type :\n\n```ts\nexport interface DeployFunction {\n  (env: HardhatRuntimeEnvironment): Promise<void | boolean>;\n  skip?: (env: HardhatRuntimeEnvironment) => Promise<boolean>;\n  tags?: string[];\n  dependencies?: string[];\n  runAtTheEnd?: boolean;\n  id?: string;\n}\n```\n\nThe skip function can be used to skip executing the script under whatever condition. It simply need to resolve a promise to true.\n\nThe tags is a list of string that when the _deploy_ task is executed with, the script will be executed (unless it skips). In other word if the deploy task is executed with a tag that does not belong to that script, that script will not be executed unless it is a dependency of a script that does get executed.\n\nThe dependencies is a list of tag that will be executed if that script is executed. So if the script is executed, every script whose tag match any of the dependencies will be executed first.\n\nThe `runAtTheEnd` is a boolean that if set to true, will queue that script to be executed after all other scripts are executed.\n\nThese set of fields allow more flexibility to organize the scripts. You are not limited to alphabetical order and you can even organise deploy script in sub folders.\n\nFinally the function can return true if it wishes to never be executed again. This can be usfeul to emulate migration scripts that are meant to be executed only once. Once such script return true (async), the `id` field is used to track execution and if that field is not present when the script return true, it will fails.\n\nIn other words, if you want a particular deploy script to run only once, it needs to both return true (async) and have an `id` set.\n\nIn any case, as a general advice every deploy function should be idempotent. This is so they can always recover from failure or pending transaction. This is what underpin most of hardhat-deploy philosophy.\n\nThis is why the `hre.deployments.deploy` function will by default only deploy if the contract code has changed, making it easier to write idempotent script.\n\n#### An example of a deploy script :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  getUnnamedAccounts,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n\n  // the following will only deploy \"GenericMetaTxProcessor\" if the contract was never deployed or if the code changed since last deployment\n  await deploy('GenericMetaTxProcessor', {\n    from: deployer,\n    gasLimit: 4000000,\n    args: [],\n  });\n};\n```\n\nAs you can see the HRE passed in has 4 new fields :\n\n- `getNamedAccounts` is a function that returns a promise to an object whose keys are names and values are addresses. It is parsed from the `namedAccounts` configuration (see [`namedAccounts`](#namedaccounts)).\n\n- `getUnnamedAccounts` is a function that return a promise to an array of accounts which were not named (see [`namedAccounts`](#namedaccounts)). It is useful for tests where you want to be sure that the account has no speicifc role in the system (no token given, no admin access, etc...).\n\n- `getChainId` is a function which return a promise for the chainId, as convenience\n\n- `deployments` is an object which contains functions to access past deployments or to save new ones, as well as helpers functions.\n\nThat latter field contains for example the `deploy` function that allows you to deploy contract and save them. It contains a lot more functions though :\n\n---\n\n### The `deployments` field\n\nThe deployments field contains several helpers function to deploy contract but also execute transaction.\n\n```ts\nexport interface DeploymentsExtension {\n  deploy(name: string, options: DeployOptions): Promise<DeployResult>; // deploy a contract\n  diamond: {\n    // deploy diamond based contract (see section below)\n    deploy(name: string, options: DiamondOptions): Promise<DeployResult>;\n  };\n  deterministic( // return the determinsitic address as well as a function to deploy the contract, can pass the `salt` field in the option to use different salt\n    name: string,\n    options: Create2DeployOptions\n  ): Promise<{\n    address: Address;\n    implementationAddress?: Address;\n    deploy(): Promise<DeployResult>;\n  }>;\n  fetchIfDifferent( // return true if new compiled code is different than deployed contract\n    name: string,\n    options: DeployOptions\n  ): Promise<{differences: boolean; address?: string}>;\n  save(name: string, deployment: DeploymentSubmission): Promise<void>; // low level save of deployment\n  get(name: string): Promise<Deployment>; // fetch a deployment by name, throw if not existing\n  getOrNull(name: string): Promise<Deployment | null>; // fetch deployment by name, return null if not existing\n  getDeploymentsFromAddress(address: string): Promise<Deployment[]>;\n  all(): Promise<{[name: string]: Deployment}>; // return all deployments\n  getArtifact(name: string): Promise<Artifact>; // return a hardhat artifact (compiled contract without deployment)\n  getExtendedArtifact(name: string): Promise<ExtendedArtifact>; // return a extended artifact (with more info) (compiled contract without deployment)\n  run( // execute deployment scripts\n    tags?: string | string[],\n    options?: {\n      resetMemory?: boolean;\n      deletePreviousDeployments?: boolean;\n      writeDeploymentsToFiles?: boolean;\n      export?: string;\n      exportAll?: string;\n    }\n  ): Promise<{[name: string]: Deployment}>;\n  fixture( // execute deployment as fixture for test // use evm_snapshot to revert back\n    tags?: string | string[],\n    options?: {fallbackToGlobal?: boolean; keepExistingDeployments?: boolean}\n  ): Promise<{[name: string]: Deployment}>;\n  createFixture<T, O>( // execute a function as fixture using evm_snaphost to revert back each time\n    func: FixtureFunc<T, O>,\n    id?: string\n  ): (options?: O) => Promise<T>;\n  log(...args: any[]): void; // log data only ig log enabled (disabled in test fixture)\n\n  execute( // execute function call on contract\n    name: string,\n    options: TxOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<Receipt>;\n  rawTx(tx: SimpleTx): Promise<Receipt>; // execute a simple transaction\n  catchUnknownSigner( // you can wrap other function with this function and it will catch failure due to missing signer with the details of the tx to be executed\n    action: Promise<any> | (() => Promise<any>),\n    options?: {log?: boolean}\n  ): Promise<null | {\n    from: string;\n    to?: string;\n    value?: string;\n    data?: string;\n  }>;\n  read( // make a read-only call to a contract\n    name: string,\n    options: CallOptions,\n    methodName: string,\n    ...args: any[]\n  ): Promise<any>;\n  read(name: string, methodName: string, ...args: any[]): Promise<any>;\n  // rawCall(to: Address, data: string): Promise<any>; // TODO ?\n}\n```\n\n---\n\n#### `deployments.deploy(<name>, options)`\n\n---\n\nThe `deploy` function, as mentioned above, allows you to deploy a contract and save it under a specific name.\n\nThe deploy function expect 2 parameters: one for the name and one for the options\n\nSee below the full list of fields that the option parameter allows and requires:\n\n```ts\nexport interface DeployOptions = {\n  from: string; // address (or private key) that will perform the transaction. you can use `getNamedAccounts` to retrived the address you want by name.\n  contract?: // this is an optional field. If not specified it defaults to the contract with the same name as the first parameter\n    | string // this field can be either a string for the name of the contract\n    | { // or abi and bytecode\n        abi: ABI;\n        bytecode: string;\n        deployedBytecode?: string;\n      };\n  args?: any[]; // the list of argument for the constructor (or the upgrade function in case of proxy)\n  skipIfAlreadyDeployed?: boolean; // if set it to true, will not attempt to deploy even if the contract deployed under the same name is different\n  log?: boolean; // if true, it will log the result of the deployment (tx hash, address and gas used)\n  linkedData?: any; // This allow to associate any JSON data to the deployment. Useful for merkle tree data for example\n  libraries?: { [libraryName: string]: Address }; // This let you associate libraries to the deployed contract\n  proxy?: boolean | string | ProxyOptions; // This options allow to consider your contract as a proxy (see below for more details)\n\n  // here some common tx options :\n  gasLimit?: string | number | BigNumber;\n  gasPrice?: string | BigNumber;\n  value?: string | BigNumber;\n  nonce?: string | number | BigNumber;\n\n  estimatedGasLimit?: string | number | BigNumber; // to speed up the estimation, it is possible to provide an upper gasLimit\n  estimateGasExtra?: string | number | BigNumber; // this option allow you to add a gas buffer on top of the estimation\n\n  autoMine?: boolean; // this force a evm_mine to be executed. this is useful to speed deployment on test network that allow to specify a block delay (ganache for example). This option basically skip the delay by force mining.\n  deterministicDeployment? boolean | string; // if true, it will deploy the contract at a deterministic address based on bytecode and constructor arguments. The address will be the same across all network. It use create2 opcode for that, if it is a string, the string will be used as the salt.\n  waitConfirmations?: number; // number of the confirmations to wait after the transactions is included in the chain\n};\n```\n\n---\n\n---\n\n## Handling contract using libraries\n\nIn the deploy function, one of the `DeployOptions` field is the `libraries` field. It allows you to associate external contract as libraries at the time of deployment.\n\nFirst, you have deploy the library using the `deploy` function, then when we deploy a contract that needs the linked library, we can pass the deployed library name and address in as an argument to the `libraries` object.\n\nFirst step: deploy the library:\n\n```js\nconst exampleLibrary = await deploy(\"ExampleLibary\", {\n    from: <deployer>\n});\n\n```\n\nExampleLibrary is now deployed to whatever network was chosen (`hardhat deploy --network <networkName>`)\n\nFor example, if we are deploying on Rinkeby, this library will get deployed on rinkeby, and the `exampleLibrary` variable will be a deployment object that contains the abi as well as the deployed address for the contract.\n\nNow that the library is deployed, we can link it in our next deployed contract.\n\n```js\nconst example = await deploy(\"Example\", {\n    from: <deployer>\n    args: [\"example string argument for the 'Example' contract constructor\"],\n    libraries: {\n        ExampleLibrary: exampleLibrary.address\n    }\n});\n\n```\n\nThis `libraries` object takes the name of the library, and its deployed address on the network. Multiple libraries can be passed into the `libraries` object.\n\n---\n\n---\n\n## Exporting Deployments\n\nApart from deployments saved in the `deployments` folder which contains all information available about the contract (compile time data + deployment data), `hardhat-deploy` allows you to export lightweight files.\n\nThese can be used for example to power your frontend with contract's address and abi.\n\nThis come into 2 flavors.\n\nThe first one is exported via the `--export <file>` option and follow the following format :\n\n```ts\nexport interface Export {\n  chainId: string;\n  name: string;\n  contracts: {[name: string]: ContractExport};\n}\n```\n\nwhere name is the name of the network configuration chosen (see hardhat option `--network`)\n\nThe second one is exported via the `--export-all <file>` option and follow the following format :\n\n```ts\nexport type MultiExport = {\n  [chainId: string]: Export[];\n};\n```\n\nAs you see the second format include the previous. While in most case you'll need the single export where your application will support only one network, there are case where your app would want to support multiple networks at once. This second format allow for that.\n\nFurthermore as hardhat support multiple network configuration for the same network (rinkeby, mainnet...), the export-all format will contains each of them grouped by their chainId.\n\nNote: from v0.10.4 the old multi-export down is no more:\n\n```\nexport type MultiExport = {\n  [chainId: string]: {[name: string]: Export};\n};\n```\n\nFor both --export and --export-all, if the extension ends in .ts it will generate a typescript file containing the contracts info.\n\n---\n\n---\n\n## Deploying and Upgrading Proxies\n\nAs mentioned above, the deploy function can also deploy a contract through a proxy. It can be done without modification of the contract as long as its number of constructor arguments matches the proxy initialization/update function.\n\nThe default Proxy is both ERC-1967 and ERC-173 Compliant, but other proxy can be specified, like openzeppelin transparent proxies.\n\nCode for the default Proxy can be found [here](solc_0.8/proxy/EIP173Proxy.sol).\n\nTo perform such proxy deployment, you just need to invoke the deploy function with the following options : `{..., proxy: true}`\n\nSee example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: true,\n  });\n};\n```\n\nYou can also set it to `proxy: \"<upgradeMethodName>\"` in which case the function `<upgradeMethodName>` will be executed upon upgrade.\nthe `args` field will be then used for that function instead of the contructor. It is also possible to then have a constructor with the same arguments and have the proxy be disabled. It can be useful if you want to have your contract as upgradeable in a test network but be non-upgradeable on the mainnet.\n\nSee example :\n\n```js\nmodule.exports = async ({\n  getNamedAccounts,\n  deployments,\n  getChainId,\n  network,\n}) => {\n  const {deploy} = deployments;\n  const {deployer} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: network.live ? false : 'postUpgrade',\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nThe proxy option can also be an object which can set the specific owner that the proxy is going to be managed by.\n\nSee example:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await deploy('Greeter', {\n    from: deployer,\n    proxy: {\n      owner: greeterOwner,\n      methodName: 'postUpgrade',\n    },\n    args: ['arg1', 2, 3],\n  });\n};\n```\n\nNote that for the second invocation, this deployment will not be executed from the specified `from: deployer` as otherwise these tx will always fails. It will instead be automatically executed from the proxy's current owner (in that case : `greeterOwner`)\n\nNow, it is likely you do not want to locally handle the private key / mnemonic of the account that manage the proxy or it could even be that the `greeterOwner` in question is a multi sig. As such that second invocation will throw an error as it cannot find a local signer for it.\n\nThe error will output the necessary information to upgrade the contract but `hardhat-deploy` comes also with a utility function for such case: `deployments.catchUnknownSigner` which will catch the error and output to the console the necessary information while continuing to next step.\n\nHere is the full example :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {deploy, catchUnknownSigner} = deployments;\n  const {deployer, greeterOwner} = await getNamedAccounts();\n  await catchUnknownSigner(\n    deploy('Greeter', {\n      from: deployer,\n      proxy: {\n        owner: greeterOwner,\n        methodName: 'postUpgrade',\n      },\n      args: ['arg1', 2, 3],\n    })\n  );\n  // you could pause the deployment here and wait for input to continue\n};\n```\n\nThe full proxy options is as follow:\n\n```ts\ntype ProxyOptionsBase = {\n  owner?: Address; // this set the owner of the proxy. further upgrade will need to be executed from that owner\n  upgradeIndex?: number; // allow you to breakdown your upgrades into separate deploy script, each with their own index. A deploy call with a specific upgradeIndex will be executed only once, only if the current upgradeIndex is one less.\n  proxyContract?: // default to \"EIP173Proxy\". See below for more details\n  string | ArtifactData;\n  viaAdminContract?: // allow to specify a contract that act as a middle man to perform upgrades. Useful and Recommended for Transparent Proxies\n  | string\n    | {\n        name: string;\n        artifact?: string | ArtifactData;\n      };\n};\n\nexport type ProxyOptions =\n  | (ProxyOptionsBase & {\n      methodName?: string; // method to be executed when the proxy is deployed for the first time or when the implementation is modified. Use the deployOptions args field for arguments\n    })\n  | (ProxyOptionsBase & {\n      execute?:\n        | {\n            methodName: string; // method to be executed when the proxy is deployed for the first time or when the implementation is modified.\n            args: any[];\n          }\n        | {\n            init: {\n              methodName: string; // method to be executed when the proxy is deployed\n              args: any[];\n            };\n            onUpgrade?: {\n              methodName: string; // method to be executed when the proxy is upgraded (not first deployment)\n              args: any[];\n            };\n          };\n    });\n```\n\nThe `proxyContract` field allow you to specify your own Proxy contract. If it is a string, it will first attempt to get an artifact with that name. If not found it will fallback on the following if\n\nit matches:\n\n- `EIP173Proxy`: use the default Proxy that is EIP-173 compliant\n\n- `EIP173ProxyWithReceive`: Same as above except that the proxy contains a receive hook to accept empty ETH payment.\n\n- `OpenZeppelinTransparentProxy`: Use Openzeppelin Transparent Proxy (copied from openzeppelin repo, see code [here](solc_0.7/openzeppelin/proxy/TransparentUpgradeableProxy.sol))\n  When this option is chosen, the `DefaultProxyAdmin` is also used as admin since Transparent Proxy kind of need an intermediary contract for administration. This can be configured via the `viaAdminContract` option. Note that the DefaultProxyAdmin is slightly different than the one used by openzeppelin as it allow you to set a different owner than msg.sender on first deploy, something openzeppelin version do not allow, see : https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2639\n\n- `OptimizedTransparentProxy`: This contract is similar to above, except that it is optimized to not require storage read for the admin on every call.\n\n## Builtin-In Support For Diamonds (EIP2535)\n\nThe deployments field also expose the diamond field: `hre.deployments.diamond` that let you deploy [Diamonds](https://eips.ethereum.org/EIPS/eip-2535) in an easy way.\n\n### deployment / upgrade\n\nInstead of specifying the facets to cut out or cut in, which the diamond contract expects, you specify the facets you want to end up having on the deployed contract.\n\nThis declarative approach allow you to focus on what you want instead of how to do it.\n\n`diamond.deploy` expect the facet as names. The names represent contract to be deployed as facet. In future version you ll be able to specify deployed contract or artifact object as facet.\n\nTo deploy a contract with 3 facet you can do as follow :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: deployer,\n    owner: diamondAdmin,\n    facets: ['Facet1', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nif you then later execute the following script:\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments, getChainId}) => {\n  const {diamond} = deployments;\n  const {deployer, diamondAdmin} = await getNamedAccounts();\n  await diamond.deploy('ADiamondContract', {\n    from: diamondAdmin, // this need to be the diamondAdmin for upgrade\n    owner: diamondAdmin,\n    facets: ['NewFacet', 'Facet2', 'Facet3'],\n  });\n};\n```\n\nThen the NewFacet will be deployed automatically if needed and then the diamondCut will cut Facet1 out and add NewFacet.\n\nNote that if the code for Facet2 and Facet3 changes, they will also be redeployed automatically and the diamondCuts will replace the existing facets with these new ones.\n\nNote that the diamond has 3 facet added by default. These facets are used for ownership, diamondCut and diamond loupe.\n\nThe implementation is a sligthly modified version of the [reference implementation by Nick Mudge](https://github.com/mudgen/diamond-3).\nTHe only difference is the custom constructor that allow multiple initialization, used to allow the default ERC165 facet to be initialised along your custom initialization function.\n\n### onUpgrade calls\n\nLike normal proxies you can also execute a function at the time of an upgrade.\n\nThis is done by specifying the execute field in the diamond deploy options :\n\n```js\ndiamond.deploy('ADiamondContract', {\n  from: deployer,\n  owner: diamondAdmin,\n  facets: ['NewFacet', 'Facet2', 'Facet3'],\n  execute: {\n    methodName: 'postUpgrade',\n    args: ['one', 2, '0x3'],\n  },\n});\n```\n\n### more...\n\nThere are more options, to be described later...\n\n## Testing Deployed Contracts\n\nYou can continue using the usual test task:\n\n`hardhat test`\n\nTests can use the `hre.deployments.fixture` function to run the deployment and snapshot it so that tests don't need to perform all the deployment transactions every time. They can simply reuse the snapshot for every test (this leverages `evm_snapshot` and `evm_revert` provided by both `hardhat` and `ganache`). You can for example set them in a `beforeEach`.\n\nHere is an example of a test :\n\n```js\nconst {deployments} = require('hardhat');\n\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    await deployments.fixture(['Token']);\n    const Token = await deployments.get('Token'); // Token is available because the fixture was executed\n    console.log(Token.address);\n    const ERC721BidSale = await deployments.get('ERC721BidSale');\n    console.log({ERC721BidSale});\n  });\n});\n```\n\nTests can also leverage named accounts for clearer test. Combined with `hardhat-deploy-ethers` plugin, you can write succint test :\n\n```js\nconst {ethers, getNamedAccounts} = require('hardhat');\n\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    await deployments.fixture(['Token']);\n    const {tokenOwner} = await getNamedAccounts();\n    const TokenContract = await ethers.getContract('Token', tokenOwner);\n    await TokenContract.mint(2).then((tx) => tx.wait());\n  });\n});\n```\n\n---\n\n### Creating Fixtures\n\nFurthermore, tests can easily create efficient fixture using `deployments.createFixture`\n\nSee example :\n\n```js\nconst setupTest = deployments.createFixture(\n  async ({deployments, getNamedAccounts, ethers}, options) => {\n    await deployments.fixture(); // ensure you start from a fresh deployments\n    const {tokenOwner} = await getNamedAccounts();\n    const TokenContract = await ethers.getContract('Token', tokenOwner);\n    await TokenContract.mint(10).then((tx) => tx.wait()); //this mint is executed once and then `createFixture` will ensure it is snapshotted\n    return {\n      tokenOwner: {\n        address: tokenOwner,\n        TokenContract,\n      },\n    };\n  }\n);\ndescribe('Token', () => {\n  it('testing 1 2 3', async function () {\n    const {tokenOwner} = await setupTest();\n    await tokenOwner.TokenContract.mint(2);\n  });\n});\n```\n\nWhile this example is trivial, some fixture can requires several transaction and the ability to snapshot them automatically speed up the tests greatly.\n\n---\n\n---\n\n## More Information On Hardhat Tasks\n\n---\n\n### **1. node task**\n\nas mentioned above, the node task is slighly modified and augmented with various flags and options\n\n`hardhat node`\n\nIn particular it adds an argument `--export` that allows you to specify a destination file where the info about the contracts deployed is written.\nYour webapp can then access all contracts information.\n\n---\n\n### **2. test task**\n\n`hardhat test`\n\nthe test task is augmented with one flag argument `--deploy-fixture` that allows to run all deployments in a fixture snapshot before executing the tests. This can speed up the tests that use specific tags as the global fixture take precedence (unless specified).\n\nIn other word tests can use `deployments.fixture(<specific tag>)` where specific tag only deploys the minimal contracts for tests, while still benefiting from global deployment snapshot if used.\n\nIf a test needs the deployments to only include the specific deployment specified by the tag, it can use the following :\n\n```js\ndeployments.fixture('<specific tag>', {fallbackToGlobal: false});\n```\n\nDue to how snapshot/revert works in hardhat, this means that these tests will not benefit from the global fixture snapshot and will have to deploy their contracts as part of the fixture call. This is automatic but means that these tests will run slower.\n\n---\n\n### **3. run task**\n\n`hardhat --network <networkName> run <script>`\n\nThe run task act as before but thanks to the `hre.deployments` field it can access deployed contract :\n\n```js\nconst hre = require('hardhat');\nconst {deployments, getNamedAccounts} = hre;\n\n(async () => {\n  console.log(await deployments.all());\n  console.log({namedAccounts: await getNamedAccounts()});\n})();\n```\n\nYou can also run it directly from the command line as usual.\n\n`HARDHAT_NETWORK=rinkeby node <script>` is the equivalent except it does not load the hardhat environment twice (which the run task does)\n\n---\n\n### **4. console task**\n\n`hardhat console`\n\nThe same applies to the `console` task.\n\n---\n\n## Deploy Scripts: Tags And Dependencies\n\n---\n\nIt is possible to execute only specific parts of the deployments with `hardhat deploy --tags <tags>`\n\nTags represent what the deploy script acts on. In general it will be a single string value, the name of the contract it deploys or modifies.\n\nThen if another deploy script has such tag as a dependency, then when this latter deploy script has a specific tag and that tag is requested, the dependency will be executed first.\n\nHere is an example of two deploy scripts :\n\n```js\nmodule.exports = async ({getNamedAccounts, deployments}) => {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const deployResult = await deploy('Token', {\n    from: deployer,\n    args: ['hello', 100],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Token deployed at ${deployResult.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Token'];\n```\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer} = namedAccounts;\n  const Token = await deployments.get('Token');\n  const deployResult = await deploy('Sale', {\n    from: deployer,\n    contract: 'ERC721BidSale',\n    args: [Token.address, 1, 3600],\n  });\n  if (deployResult.newlyDeployed) {\n    log(\n      `contract Sale deployed at ${deployResult.address} using ${deployResult.receipt.gasUsed} gas`\n    );\n  }\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.dependencies = ['Token']; // this ensure the Token script above is executed first, so `deployments.get('Token')` succeeds\n```\n\nAs you can see the second one depends on the first. This is because the second script depends on a tag that the first script registers as using.\n\nWith that when `hardhat deploy --tags Sale` is executed\n\nthen both scripts will be run, ensuring Sale is ready.\n\nYou can also define the script to run after another script is run by setting `runAtTheEnd` to be true. For example:\n\n```js\nmodule.exports = async function ({getNamedAccounts, deployments}) {\n  const {deployIfDifferent, execute, log} = deployments;\n  const namedAccounts = await getNamedAccounts();\n  const {deployer, admin} = namedAccounts;\n  await execute('Sale', {from: deployer}, 'setAdmin', admin);\n};\nmodule.exports.tags = ['Sale'];\nmodule.exports.runAtTheEnd = true;\n```\n\nTags can also be used in test with `deployments.fixture`. This allow you to test a subset of the deploy script.\n","readmeFilename":"README.md"}